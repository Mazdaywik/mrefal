[29.09.2007 - 20:25:52,85]

	Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
	Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
	Список приоритетных изменений:

	[TODO] Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

	[TODO] Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

	[TODO] ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
	Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

	Mu {
		F e.Arg = <F e.Arg>;
		G e.Arg = <G e.Arg>;
		H e.Arg = <H e.Arg>;
		Mod1 A e.Arg = <Mod1::A e.Arg>;
		Mod1 B e.Arg = <Mod1::B e.Arg>;
		Mod1 C e.Arg = <Mod1::C e.Arg>;
		Mod2 A e.Arg = <Mod2::A e.Arg>;
		Mod2 C e.Arg = <Mod2::C e.Arg>;
		Mod2 D e.Arg = <Mod2::D e.Arg>;
	}

	Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
	Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

	[TODO] Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
	Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

	ModuleName::SomeHolder::Swap {
		e.NewValue =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.NewValue>;
	}

	Синтаксически можно использовать конструкцию, похожую на список импорта:

	$SWAP SomeHolder, OtherSomeHolder;

	Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

	[TODO] Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собст-
венный интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

	[TODO] Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

	Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

	[DONE] Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

	Ещё вспомнил.

	[TODO] Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

	[TODO] Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

	[DONE] Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
	
	Было:

	t.Module ::=
		(t.SymTable t.ModuleContent)

	t.ModuleContent ::=
		( (ModuleName e.ModuleName)
			t.Element*
		)

	Стало:

	t.Module ::= (t.SymTable e.ModuleContent)

	e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

	[DONE] Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится
только в таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе
генерации кода. Но по-другому реализация могла бы быть ещё кривее.
	Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
	Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

	[TODO] Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал
статический ящик вместо копилки.

	[TODO] Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

	[DONE] С копилкой распрощались. При необходимости можно копилку реализовать поверх статических
ящиков. В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализа-
ции текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

	[TODO] Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

	[TODO] На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

	[TODO] Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть дос-
тупно только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.


[06.10.2007 - 18:35:07,82]

	[CHANGED] Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.

	[TODO] Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".


[07.10.2007 -  0:23:54,89]

	[DONE] Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождест-
вены идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова
указателей таков (см. Syntax.txt).
	
	FunctionCall = '<' Callable ResultExpr '>' .
	Callable = FunctionName | Qualifier '::' FunctionName
		| SwapName | S-VARIABLE .

	Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
	Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

	Context::FnPtr::Local {
		Create =
			$Context::Create::Entry$ ;
		UpdateModuleInfo =
			$Context::UpdateModuleInfo::Entry$ ;

		// Часть пропущена

		AppendError =
			$Context::AppendError::Entry$ ;
		FnPtr =
			$Context::FnPtr::Local$ ;
		MModulesList UpdateModuleInfo =
			$MModulesList::UpdateModuleInfo::Entry$ ;
		MModulesList LastModule =
			$MModulesList::LastModule::Entry$ ;
		MModulesList ExtractOption =
			$MModulesList::ExtractOption::Entry$ ;
		MModulesList GetProgName =
			$MModulesList::GetProgName::Entry$ ;
		MModulesList ExtractModulesList =
			$MModulesList::ExtractModulesList::Entry$ ;
	}

	В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
	Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

	Test::IndirectCall::Local {
		s.Function =
			<Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
	}

	Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
	$MODULE Indirect;

	/*
		<ForAll s.FnPtr t.Term*>
			== e.Result*
		где e.Result = <s.FnPtr t.Term>
	*/
	$ENTRY ForAll {
		s.FnPtr t.Next e.Tail =
			<s.FnPtr t.Next>
			<ForAll s.FnPtr e.Tail>;

		s.FnPtr = ;
	}

	$END Indirect.

	Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

	$MODULE Convert;

	$IMPORT MStrings, Indirect;

	$ENTRY NumsToStrings
		e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

	ToStr s.Num = <MStrings::Symb s.Num> ' ';

	$END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
	Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.