[29.09.2007 - 20:25:52,85]

	Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
	Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
	Список приоритетных изменений:

	[TODO: Механизм поиска модулей]
	Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

	[TODO: Использование нескольких front-end и back-end]
	Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

	[TODO: Указатели на функции или функция Mu]
	... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
	Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

	Mu {
		F e.Arg = <F e.Arg>;
		G e.Arg = <G e.Arg>;
		H e.Arg = <H e.Arg>;
		Mod1 A e.Arg = <Mod1::A e.Arg>;
		Mod1 B e.Arg = <Mod1::B e.Arg>;
		Mod1 C e.Arg = <Mod1::C e.Arg>;
		Mod2 A e.Arg = <Mod2::A e.Arg>;
		Mod2 C e.Arg = <Mod2::C e.Arg>;
		Mod2 D e.Arg = <Mod2::D e.Arg>;
	}

	Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
	Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

	[TODO: Статические ящики]
	Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
	Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

	ModuleName::SomeHolder::Swap {
		e.NewValue =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.NewValue>;
	}

	Синтаксически можно использовать конструкцию, похожую на список импорта:

	$SWAP SomeHolder, OtherSomeHolder;

	Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

	[TODO: RASL и интерпретатор]
	Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

	[TODO: Резервное копирование]
	Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

	Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

	[DONE: Резервное копирование]
	Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

	Ещё вспомнил.

	[TODO: Элемент (Module e.ModuleName)]
	Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

	[TODO: Доделать механизм переименования модулей]
	Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

	[DONE: Элемент (Module e.ModuleName)]
	Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
	
	Было:

	t.Module ::=
		(t.SymTable t.ModuleContent)

	t.ModuleContent ::=
		( (ModuleName e.ModuleName)
			t.Element*
		)

	Стало:

	t.Module ::= (t.SymTable e.ModuleContent)

	e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

	[DONE: Статические ящики]
	Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
	Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
	Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

	[TODO: FileIO-дескрипторы в статическом ящике]
	Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.

	[TODO: Переименовать модуль Refal5]
	Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

	[DONE: FileIO-дескрипторы в статическом ящике]
	С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

	[TODO: Расширения .rout2 -> .rout]
	Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

	[TODO: Единица компоновки -- функция вместо модуля]
	На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

	[TODO: Новая семантика идентификатора]
	Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.


[06.10.2007 - 18:35:07,82]

	[CHANGED: Компиляция структурных скобок по-новому]
	Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.

	[TODO: Абстрактные типы данных]
	Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".


[07.10.2007 -  0:23:54,89]

	[DONE: Указатели на функции или функция Mu]
	Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождест-
вены идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова
указателей таков (см. Syntax.txt).
	
	FunctionCall = '<' Callable ResultExpr '>' .
	Callable = FunctionName | Qualifier '::' FunctionName
		| SwapName | S-VARIABLE .

	Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
	Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

	Context::FnPtr::Local {
		Create =
			$Context::Create::Entry$ ;
		UpdateModuleInfo =
			$Context::UpdateModuleInfo::Entry$ ;

		// Часть пропущена

		AppendError =
			$Context::AppendError::Entry$ ;
		FnPtr =
			$Context::FnPtr::Local$ ;
		MModulesList UpdateModuleInfo =
			$MModulesList::UpdateModuleInfo::Entry$ ;
		MModulesList LastModule =
			$MModulesList::LastModule::Entry$ ;
		MModulesList ExtractOption =
			$MModulesList::ExtractOption::Entry$ ;
		MModulesList GetProgName =
			$MModulesList::GetProgName::Entry$ ;
		MModulesList ExtractModulesList =
			$MModulesList::ExtractModulesList::Entry$ ;
	}

	В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
	Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

	Test::IndirectCall::Local {
		s.Function =
			<Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
	}

	Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
	$MODULE Indirect;

	/*
		<ForAll s.FnPtr t.Term*>
			== e.Result*
		где e.Result = <s.FnPtr t.Term>
	*/
	$ENTRY ForAll {
		s.FnPtr t.Next e.Tail =
			<s.FnPtr t.Next>
			<ForAll s.FnPtr e.Tail>;

		s.FnPtr = ;
	}

	$END Indirect.

	Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

	$MODULE Convert;

	$IMPORT MStrings, Indirect;

	$ENTRY NumsToStrings
		e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

	ToStr s.Num = <MStrings::Symb s.Num> ' ';

	$END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
	Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


[12.10.2007 - 22:09:54,55]

	[CHANGED: Папка ROut2]
	По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.

	[DONE: Переименовать модуль Refal5]
	Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


[16.10.2007 - 21:50:54,61]

	[FIXED: MOS::Env корректно работает с кириллицей]
	Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.

	[TODO: Исправить зависимую от MOS::Env MOS::EnvList]
	Изменить соответствующим образом MOS::EnvList.


[16.10.2007 - 22:06:30,03]

	[DONE: Исправить зависимую от MOS::Env MOS::EnvList]
	Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.

	[CHANGED: Удалена ROut]
	Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


[19.10.2007 -  1:04:32,32]

	[TODO: eXpression eXchange in/out]
	В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).

	[ERROR: Ошибка в MFileSystem при работе с кириллицей]
	Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
	Возможные пути решения:
	(1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
	Преимущества. Подход обобщается на использования других команд консоли Windows.
	Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
	(2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
	Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
	Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

	Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

	Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
	Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.

	[CHANGED: MFileSystem стал библиотечным]
	Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


[20.10.2007 - 16:06:51,06]

	[TODO: Автоматизация списка TODO]
	Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
	\[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).

	[TODO: Функция MOS::ArgList]
	Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
	<MOS::ArgList> == e.Args
	e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
	t.ArgK ::= (e.ArgK)


[20.10.2007 - 17:59:43,10]

	[DONE: Функция MOS::ArgList]
	В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).

	[DONE: Автоматизация списка TODO]
	Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


[20.10.2007 - 19:08:06,05]

	[CHANGED: TODOs.txt -- сводка только TODO и ERROR]
	Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.

	[TODO: Стандартные модули контейнеров и распространённых функций]
	Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
	А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.


[27.10.2007 - 18:34:49,78]

	[TODO: Новая модель модулей]
	Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
	Подробности задачи см. в файле "Module conception for Module Refal.txt".


[27.10.2007 - 22:34:49,97]

	Законспектирую основные идеи из "Module conception for Module Refal.txt".
	[TODO: Модуль-программа]
	[TODO: Иерархия в стиле Java]
	[TODO: Продумать квалификацию точкой]
	[TODO: SymInfo как АТД]
	[TODO: Переписать драйвер]
	[TODO: Промежуточное представление как АТД]
	[TODO: Добавление категории "квалифицированное имя"]


[27.01.2008 - 21:21:01,49]

	[DONE: Новая семантика идентификатора]
	Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
	Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

	Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.

	[TODO: Генерация Info/Log.txt по требованию]
	Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.

	[TODO: Номер версии независимо от компиляции]
	Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.

	[TODO: Вывод номера версии компилятора]
	Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

	Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

	Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.

	[TODO: Создание папок Defs и ROut по требованию]
	Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.


[27.01.2008 - 23:01:49,86]

	[DONE: Генерация Info/Log.txt по требованию]
	[DONE: Создание папок Defs и ROut по требованию]
	Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


[02.02.2008 - 17:15:41,26]

	[TODO: Удалить MRefalRTS::Lenw]
	Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.


[02.02.2008 - 17:27:23,22]

	[TODO: Удалить прозрачные функции вывода из RTS]
	Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.


[02.02.2008 - 17:49:08,69]

	Оказалось всё не так просто. Функцией MRefalRTS::Putout пользуется весьма полезная функция
MSelfDiag::Log-T. Так что пускай пока остаётся MRefalRTS::Putout.


[02.02.2008 - 17:55:52,95]

	[DONE: Удалить MRefalRTS::Lenw]
	[DONE: Удалить прозрачные функции вывода из RTS]
	Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.

	[TODO: Удалить MRefalRTS::Put]
	См. выше, почему это не особо критично.


[04.02.2008 - 16:08:22,32]

	[TODO: Исключение промежуточного представления модуля]
	Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.


[04.02.2008 - 23:26:22,87]

	[TODO: Таблица перекрёстных ссылок]
	Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
	Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
	В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.

	[TODO: Составить список приоритетных TODO]
	Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.


[05.02.2008 -  1:09:32,10]

	[TODO: TODO_list изменяет порядок TODO]
	Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.


[05.02.2008 -  1:22:49,77]

	[DONE: TODO_list изменяет порядок TODO]
	Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).

	[DONE: Составить список приоритетных TODO]
	Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.

	[TODO: //== Список приоритетных TODO ==\\]
	Выполнив все эти TODO, я увеличу номер версии до 0.2.

	[TODO] Механизм поиска модулей
	Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.
	[TODO: Механизм поиска модулей]

	[TODO] Использование нескольких front-end и back-end
	Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".
	[TODO: Использование нескольких front-end и back-end]

	[TODO] RASL и интерпретатор
	Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
	Не выделяем.

	[TODO] Доделать механизм переименования модулей
	Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.
	[TODO: Доделать механизм переименования модулей]

	[TODO] Расширения .rout2 -> .rout
	Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
	Не выделяем.

	[TODO] Единица компоновки -- функция вместо модуля
	Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.
	[TODO: Единица компоновки -- функция вместо модуля]

	[TODO] Абстрактные типы данных
	Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.
	[TODO: Абстрактные типы данных]

	[TODO] eXpression eXchange in/out
	Совсем не торопит. Не выделяем.

	[ERROR] Ошибка в MFileSystem при работе с кириллицей
	Ошибку необходимо исправить. Даже не обсуждается.
	[ERROR: Ошибка в MFileSystem при работе с кириллицей]

	[TODO] Стандартные модули контейнеров и распространённых функций
	Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

	[TODO] Новая модель модулей
	Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.
	[TODO: Новая модель модулей]

	[TODO] Модуль-программа
	[TODO] Иерархия в стиле Java
	Обсуждалось. Добавляем.
	[TODO: Модуль-программа]
	[TODO: Иерархия в стиле Java]
	
	[TODO] Продумать квалификацию точкой
    Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
    Не выделяем.

	[TODO] SymInfo как АТД
	Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.
	[TODO: SymInfo как ATД]

	[TODO] Переписать драйвер
	Обсуждалось. Добавляем.
	[TODO: Переписать драйвер]

	[TODO] Промежуточное представление как АТД
	См. комментарий к "SymInfo как АТД". Вопрос решать надо.
	[TODO: Промежуточное представление как АТД]

	[TODO] Добавление категории "квалифицированное имя"
	Добавление этого является прямым следствием иерархии языка Java.
	[TODO: Добавление категории "квалифицированное имя"]

	[TODO] Номер версии независимо от компиляции
	[TODO] Вывод номера версии компилятора
	Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
	Не выделяем.

	[TODO] Удалить MRefalRTS::Put
	Идеологически не принципиально. Всё равно это деталь реализации.
	Не выделяем.

	[TODO] Исключение промежуточного представления модуля
	Продумать и исключить.
	[TODO: Исключение промежуточного представления модуля]

	[TODO] Таблица перекрёстных ссылок
	Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.
	[TODO: Таблица перекрёстных ссылок]

	[TODO: \\== Вот список приоритетных TODO ==//]


[05.02.2008 -  2:46:46,28]

	[CHANGED: Директива $CLEARMODULE]
	Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.



[08.02.2008 -  2:54:59,96]

	[CHANGED: Квадратные скобки]
	Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


[09.02.2008 -  3:00:29,53]

	Исправил пару ошибок, продолжил работу над человеческой линковкой, изменил вывод сообщений.

	[FIXED: Ошибка в MOrder::Sort]
	Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.

	[FIXED: Ошибка в MParser::NImportBlock-AfterName]
	Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $MODULE. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.

	[CHANGED: Изменился вывод сообщений о процессе компиляции]
	Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

	[TODO: Пересмотреть/переписать mOutModuleStatus.mref]
	См. выше.