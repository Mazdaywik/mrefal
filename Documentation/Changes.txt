[29.09.2007 - 20:25:52,85]

	Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.

	Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
	Список приоритетных изменений:

	[TODO] Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

	[TODO] Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

	[TODO] ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.

	Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

	Mu {
		F e.Arg = <F e.Arg>;
		G e.Arg = <G e.Arg>;
		H e.Arg = <H e.Arg>;
		Mod1 A e.Arg = <Mod1::A e.Arg>;
		Mod1 B e.Arg = <Mod1::B e.Arg>;
		Mod1 C e.Arg = <Mod1::C e.Arg>;
		Mod2 A e.Arg = <Mod2::A e.Arg>;
		Mod2 C e.Arg = <Mod2::C e.Arg>;
		Mod2 D e.Arg = <Mod2::D e.Arg>;
	}

	Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.

	Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

	[TODO] Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.

	Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

	ModuleName::SomeHolder::Swap {
		e.NewValue =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.NewValue>;
	}

	Синтаксически можно использовать конструкцию, похожую на список импорта:

	$SWAP SomeHolder, OtherSomeHolder;

	Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

	[TODO] Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собст-
венный интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

	[TODO] Сделать возможность резервного копирования такое же, как и было сделано для FindCopies.

	Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.