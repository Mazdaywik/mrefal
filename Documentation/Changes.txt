[29.09.2007 - 20:25:52,85]

	Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
	Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
	Список приоритетных изменений:

	[TODO] Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

	[TODO] Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

	[TODO] ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
	Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

	Mu {
		F e.Arg = <F e.Arg>;
		G e.Arg = <G e.Arg>;
		H e.Arg = <H e.Arg>;
		Mod1 A e.Arg = <Mod1::A e.Arg>;
		Mod1 B e.Arg = <Mod1::B e.Arg>;
		Mod1 C e.Arg = <Mod1::C e.Arg>;
		Mod2 A e.Arg = <Mod2::A e.Arg>;
		Mod2 C e.Arg = <Mod2::C e.Arg>;
		Mod2 D e.Arg = <Mod2::D e.Arg>;
	}

	Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
	Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

	[TODO] Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
	Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

	ModuleName::SomeHolder::Swap {
		e.NewValue =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.NewValue>;
	}

	Синтаксически можно использовать конструкцию, похожую на список импорта:

	$SWAP SomeHolder, OtherSomeHolder;

	Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

	[TODO] Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собст-
венный интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

	[TODO] Сделать возможность резервного копирования такое же, как и было сделано для FindCopies.

	Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

	[DONE] Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

	Ещё вспомнил.

	[TODO] Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

	[TODO] Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

	[DONE] Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
	
	Было:

	t.Module ::=
		(t.SymTable t.ModuleContent)

	t.ModuleContent ::=
		( (ModuleName e.ModuleName)
			t.Element*
		)

	Стало:

	t.Module ::= (t.SymTable e.ModuleContent)

	e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

	[DONE] Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится
только в таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе
генерации кода. Но по-другому реализация могла бы быть ещё кривее.
	Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
	Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

	[TODO] Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал
статический ящик вместо копилки.

	[TODO] Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

	[DONE] С копилкой распрощались. При необходимости можно копилку реализовать поверх статических
ящиков. В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализа-
ции текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

	[TODO] Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

	[TODO] На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

	[TODO] Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть дос-
тупно только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.