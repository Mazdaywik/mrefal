		Описание новой модульной концепции для Модульного Рефала

	Мотивация.
	Модульный Рефал претендует на то, чтобы быть языком, имеющим ясную и непротиворечивую модульную
концепцию типа той, которая есть в классических "модульных" языках, типа Borland Delphi, Модула-2 и
Оберон-2. Свой первоначальный вариант (имеющийся в текущей версии 0.1.367) отчасти позаимствован из
языков Оберон-2 и C++ (хотя на момент создания я думал, что только из Оберона-2).
	Модульная концепция, во-первых, упрощает разработку крупных приложений, т.к. способствует логи-
ческому разбиению системы независимые части, во-вторых, даёт возможность предоставить пользователю
более богатый набор стандартных библиотечных функций, чем использование встроенных функций, как это
сделано во многих других диалектах Рефала. Набор встроенных функций по возможности должен быть орто-
гональным и компактным, функции, входящие в набор, должны быть примитивными. Набор функций библиотеч-
ных модулей не обязан быть примитивным и ортогональными -- функции могут быть даже свободно реализо-
вываться с обычными средствами Рефала (например, OneOf). Также набор библиотечных функций может быть
довольно объёмным, т.к. (1) пользователь имеет возможность выбирать библиотечные модули для импорта,
и (2) при использовании квалифицированного доступа конфликтов между именами функций не возникает.
	Кратко опишем первоначальный вариант механизма модулей. Исходный текст программы состоит из одно-
го или нескольких модулей, причём один модуль должен находиться в одном файле исходного текста. Каж-
дый модуль имеет имя, которое должно совпадать с именем файла (без расширения).
	Модуль может содержать только следующие сущности -- функции (Рефал всё таки функциональный язык)
и статические ящики. При этом функции можно сделать доступными для других модулей. Для того, чтобы
функцию сделать доступной, необходимо её экспортировать, т.е. объявить как entry-функцию (entry --
точка входа -- терминология, позаимствованная из других диалектов Рефала).
	Для того, чтобы иметь возможность вызвать экспортированную функцию из другого модуля, необходимо
этот модуль импортировать. Импорт модуля делает доступными все entry-функции импортируемого модуля.
	Модуль может хранить в статических ящиках информацию в промежутках между вызовами экспортируемых
функций, и, возможно, не любое состояние модуля (состояние модуля определяется содержимым его стати-
ческих ящиков) может быть приемлемым, т.е. необходимо иметь возможность поддерживать инвариант модуля.
Для создания и уничтожения инварианта модуля предоставляется возможность создать entry-функции Init и
Final соответственно. Эти функции может вызывать только исполняющая система -- результат вызова функ-
ции из пользовательского кода не определён. При этом гарантируется, что перед вызовом любой entry-
функции из другого модуля будет вызвана функция Init (т.е. любая entry-функция имеет возможность по-
лучить модуль в инвариантном состоянии), причём функция Init будет вызвана ровно один раз. Также в
процессе выполнения программы будет выполнена функция Final для обеспечения корректности уничтожения
инварианта модуля (закрытие всех дескрипторов файлов и др.), причём гарантируется, что функция Final
будет вызвана не ранее любого вызова entry-функции из любого другого модуля. Т.е. можно быть уверен-
ным, что перед вызовом любой entry-функции из импортируемого модуля, этот модуль будет корректно про-
инициализированным и не будет при этом финализированным.
	Из этих двух требований следует то, что циклический импорт модулей запрещён. Допустим, у нас име-
ются два модуля ModA и ModB, которые импортируют друг друга и имеют функцию инициализации. Тогда,
функция ModA::Init может вызывать entry-функцию из модуля ModB, а значит, функция ModB::Init должна
быть вызвана раньше функции ModA::Init. Аналогичными рассуждениями можно прийти к тому, что функция
ModA::Init должна быть вызвана раньше функции ModB::Init. Т.е. циклический импорт приводит к проти-
воречию с этими требованиями. Те же противоречия мы обнаружили бы, если бы эти оба модуля имели бы
функцию финализации Final. В принципе, можно было бы разрешить циклический импорт модулей без функции
инициализации, однако (1) это усложнило бы компилятор, (2) усложнило бы сам язык, (3) при изменении
языка (например, если каждый модуль должен будет инициализировать структуры данных времени выполне-
ния) это приведёт к тому, что программы, написанные для более ранних версий (хотя таких программ до
смешного мало) перестанут работать.
	Все модули программы находятся в едином пространстве имён модулей (и библиотечные, и пользова-
тельские). Понятия модуля-программы нет, выполнение основной программы начинается с entry-функции Go,
содержащейся в одном из модулей. Если же несколько модулей проекта содержат entry-функцию Go, то
выдаётся сообщение об ошибке. В проект включаются модули, перечисленные в командной строке и те, ко-
торые прямо или косвенно импортируются модулями перечисленными в командной строке. При этом все функ-
ции Init выполняются перед, а функции Final -- после выполнения функции Go. Т.е. в проекте может су-
ществовать несколько стартовых модулей, а также, возможна реализация гамака (см. терминологию в лабе
Module Conception). В принципе, можно охарактеризовать язык по списку вопросов уже упоминавшейся лабы
Module Conception:

	1. Разрешён ли циклический импорт модулей?
	Запрещён (см. выше).

	2. Как определён порядок инициализации модулей?
	Об этом подробно написано выше.

	3. Должно ли имя файла совпадать с именем модуля?
	Должно, т.к. компилятор должен иметь возможность найти импортируемые модули и провести их компи-
ляцию при необходимости (см. вопрос 8).

	4. Как компилятор осуществляет поиск модулей, перечисленных в списке импорта?
	Сначала производится поиск модулей в текущей папке, а затем в папке библиотечных модулей, указан-
ной в переменной среды MR_Home. Это позволяет упростить разработку компилятора и библиотек, т.к.
и то и другое эволюционирует параллельно.

	5. Возможно ли в рамках отдельного проекта приложения создать модуль, имеющий то же имя, что и
библиотечный модуль? Перекроет ли этот модуль одноимённый библиотечный?
	Можно. Перекроет. Однако, если библиотечный модуль зависит от другого библиотечного модуля, кото-
рый перекрыт пользовательским, то выдаётся сообщение об ошибке.

	6. Могут ли в проекте существовать два модуля с одним именем?
	Нет, не могут, т.к. все модули находятся в плоском пространстве имён.

	7. Возможен ли "гамак"?
	Совершенно спокойно. Т.к. можно указать в командной строке несколько стартовых модулей и все они
будут проинициализированы до выполнения функции Go, то возможна, к примеру, регистрация функций об-
ратного вызова. Т.к. набор стартовых модулей определяется в командной строке, то до выполнения функ-
ции Go может быть выполнен код инициализации любого, даже совершенно постороннего модуля, указанного
в командной строке.
	Именно эта особенность роднит текущую концепцию модулей с языком C++: выбор в C++ единиц трансля-
ции, входящих в программу определяется на этапе компоновки, поэтому перед вызовом функции main() мо-
жет быть выполнен любой код как код инициализации некоторого объектника.

	8. Встроена ли в компилятор утилита make?
	Встроена. Причём проверяет необходимость компиляции по времени последнего изменения файла с точ-
ностью до минуты. Это объясняется несовершенной реализацией средств работы с файловой системой (под-
робности в ошибке модуля MFileSystem).


	TODO. Возможные пути изменения концепции модулей.
	Планируется изменить следующие аспекты:
	Внешние изменения.
	[*] Введение синтаксически выделенного модуля-программы. Отсутствие модуля-программы приводит к
возможности реализации проекта с несколькими стартовыми модулями -- "гамака". При наличии модуля-
программы набор модулей, входящих в проект, определяется самим исходным текстом, а не внешними фак-
торами. Добавление в язык модуля-программы (1) упростит структуру исходных текстов -- сделает её де-
ревом, а не потенциальным гамаком, (2) упростит способ выбора имени для .exe-шника (сейчас имя для
исполняемого файла выбирается из имён стартовых модулей по весьма шаманскому правилу -- даже не помню
по какому -- то ли имя самого первого, то ли самого последнего стартового модуля, перечисленного в
командной строке) -- имя определяется именем модуля-программы.
	При использовании модуля-программы можно изменить способ интерпретации специальных функций --
функция Go выбирается из модуля-программы, в остальных модулях она не будет считаться специальной.
Аналогично, функции Init и Final будут считаться специальными только в обычных (regular) модулях.
	Синтаксически модуль-программа может быть таким же, как и обычный, только вместо $MODULE будет
использована директива $PROGRAM.
	[*] Использование иерархической структуры модулей в стиле языка Java. При этом можно осуществлять
поиск модулей в папках, перечисленных в списке, аналогичном CLASSPATH языка Java. Альтернативой мог-
ло бы быть введение возможности указания пути поиска модуля аналогичного языку Delphi. Для этого
можно расширить имеющийся синтасис переименования модулей (к которому семантика до сих пор не реали-
зована).
	Пакеты модулей также могут соответствовать каталогам файловой системы. Для указания того факта,
что модуль принадлежит пакету, можно использовать квалифицированное имя в качестве имени модуля:
	$MODULE PackName::SubPackName::ModuleName;
	$END PackName::SubPackName::ModuleName.
	[*] Подумать над квалификацией с использованием точки '.' вместо (или вместе) используемого в
настоящее время двойного двоеточия '::'.

	Внутренние изменения.
	[*] Реализация наконец переименования модулей.
	[*] Представление символьной информации не как структуры данных, а как АТД.
	[*] Переработка управляющей программы (драйвера). Текущий драйвер (0.0.376) объединяет в себе
операции проверки необходимости перекомпиляции и самой перекомпиляции, а также не проверяет, изменил-
ся ли импортируемый модуль после импортирующего. Также имеется ошибка при попытке отправить на пере-
компиляцию библиотечный модуль -- в этом случае компилятор умирает с внутренней ошибкой.
	[*] В перспективе -- разработка унифицированного промежуточного представления модуля (ведь в пер-
спективе компилятор должен поддерживать несколько back- и front-end'ов) и организация этого представ-
ления в виде АТД.
	[*] Изменение синтаксиса -- введение такой категории, как квалифицированное имя. Имя модуля, имя
импортируемого модуля и имя вызываемой функции должны быть квалифицированными именами. На первое вре-
мя (когда ещё пакеты не будут реализованы) можно выдавать сообщения об ошибке при обнаружении квали-
фицированного имени не там, где надо (в директиве $MODULE или $IMPORT или при квалификации более чем
двумя именами вызова функции) на этапе семантической проверки.