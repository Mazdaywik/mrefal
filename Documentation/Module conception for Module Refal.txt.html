<HTML> <BODY>
&nbsp&nbsp&nbsp&nbsp	Описание новой модульной концепции для Модульного Рефала<br>
<br>
&nbsp&nbsp&nbsp&nbspМотивация.<br>
&nbsp&nbsp&nbsp&nbspМодульный Рефал претендует на то, чтобы быть языком, имеющим ясную и непротиворечивую модульную<br>
концепцию типа той, которая есть в классических "модульных" языках, таких как Borland Delphi,<br>
Модула-2 и Оберон-2. Первоначальный вариант (имеющийся в текущей версии 0.1.367) отчасти позаимст-<br>
вован из языков Оберон-2 и C++ (хотя на момент создания я думал, что только из Оберона-2).<br>
&nbsp&nbsp&nbsp&nbspМодульная концепция, во-первых, упрощает разработку крупных приложений, т.к. способствует деком-<br>
позиции системы на независимые части, во-вторых, даёт возможность предоставить пользователю<br>
более богатый набор стандартных библиотечных функций, чем использование встроенных функций, как это<br>
сделано во многих других диалектах Рефала. Набор встроенных функций по возможности должен быть орто-<br>
гональным и компактным; функции, входящие в набор, должны быть примитивными. Набор функций библиотеч-<br>
ных модулей не обязан быть примитивным и ортогональным -- функции могут быть даже реализо-<br>
вываться обычными средствами Рефала (например, OneOf). Также набор библиотечных функций может быть<br>
довольно объёмным, т.к. (1) пользователь имеет возможность выбирать библиотечные модули для импорта,<br>
и, (2) при использовании квалифицированного доступа, конфликтов между именами функций не возникает.<br>
&nbsp&nbsp&nbsp&nbspКратко опишем первоначальный вариант механизма модулей. Исходный текст программы состоит из одно-<br>
го или нескольких модулей, причём один модуль должен находиться в одном файле исходного текста. Каж-<br>
дый модуль имеет имя, которое должно совпадать с именем файла (без расширения).<br>
&nbsp&nbsp&nbsp&nbspМодуль может содержать только следующие сущности -- функции (Рефал всё таки функциональный язык)<br>
и статические ящики. При этом функции можно сделать доступными для других модулей. Для того, чтобы<br>
функцию сделать доступной, необходимо её экспортировать, т.е. объявить как entry-функцию (entry --<br>
точка входа -- терминология, позаимствованная из других диалектов Рефала).<br>
&nbsp&nbsp&nbsp&nbspДля того чтобы иметь возможность вызвать экспортированную функцию из другого модуля, необходимо<br>
этот модуль импортировать. Импорт модуля делает доступными все entry-функции импортируемого модуля.<br>
&nbsp&nbsp&nbsp&nbspМодуль может хранить в статических ящиках информацию в промежутках между вызовами экспортируемых<br>
функций, и, возможно, не любое состояние модуля (состояние модуля определяется содержимым его стати-<br>
ческих ящиков) может быть приемлемым, т.е. необходимо иметь возможность поддерживать инвариант модуля.<br>
Для создания и уничтожения инварианта модуля предоставляется возможность создать entry-функции Init и<br>
Final соответственно. Эти функции может вызывать только исполняющая система -- результат вызова функ-<br>
ции из пользовательского кода не определён. При этом гарантируется, что перед вызовом любой entry-<br>
функции из другого модуля будет вызвана функция Init (т.е. любая entry-функция имеет возможность по-<br>
лучить модуль в инвариантном состоянии), причём функция Init будет вызвана ровно один раз. Также в<br>
процессе выполнения программы будет выполнена функция Final: для обеспечения корректности уничтоже-<br>
ния инварианта модуля (закрытие всех дескрипторов файлов и др.), причём гарантируется, что функция<br>
Final будет вызвана не ранее любого вызова entry-функции из любого другого модуля. Т.е. можно быть<br>
уверенным, что перед вызовом любой entry-функции из импортируемого модуля, этот модуль будет кор-<br>
ректно проинициализированным и не будет при этом финализированным.<br>
&nbsp&nbsp&nbsp&nbspИз этих двух требований следует то, что циклический импорт модулей запрещён. Допустим, у нас име-<br>
ются два модуля ModA и ModB, которые импортируют друг друга и имеют функцию инициализации. Тогда,<br>
функция ModA::Init может вызывать entry-функцию из модуля ModB, а значит, функция ModB::Init должна<br>
быть вызвана раньше функции ModA::Init. Аналогичными рассуждениями можно прийти к тому, что функция<br>
ModA::Init должна быть вызвана раньше функции ModB::Init. Т.е. циклический импорт приводит к проти-<br>
воречию с этими требованиями. Те же противоречия мы обнаружили бы, если бы эти оба модуля имели бы<br>
функцию финализации Final. В принципе, можно было бы разрешить циклический импорт модулей без функции<br>
инициализации, однако: (1) это усложнило бы компилятор, (2) усложнило бы сам язык, (3) при изменении<br>
языка (например, если каждый модуль должен будет инициализировать структуры данных времени выполне-<br>
ния) это приведёт к тому, что программы, написанные для более ранних версий (хотя таких программ до<br>
смешного мало) перестанут работать.<br>
&nbsp&nbsp&nbsp&nbspВсе модули программы находятся в едином пространстве имён модулей (и библиотечные, и пользова-<br>
тельские). Понятия модуля-программы нет, выполнение основной программы начинается с entry-функции Go,<br>
содержащейся в одном из модулей. Если же несколько модулей проекта содержат entry-функцию Go, то<br>
выдаётся сообщение об ошибке. В проект включаются модули: те, которые перечисленны в командной строке,<br>
и те, которые прямо или косвенно импортируются первыми. При этом все функции Init выполняются перед,<br>
а функции Final -- после выполнения функции Go. Т.е. в проекте может существовать несколько стартовых<br>
модулей, а также, возможна реализация гамака (см. терминологию в лабе Module Conception). В принципе,<br>
можно охарактеризовать язык по списку вопросов уже упоминавшейся лабы Module Conception:<br>
<br>
&nbsp&nbsp&nbsp&nbsp1. Разрешён ли циклический импорт модулей?<br>
&nbsp&nbsp&nbsp&nbspЗапрещён (см. выше).<br>
<br>
&nbsp&nbsp&nbsp&nbsp2. Как определён порядок инициализации модулей?<br>
&nbsp&nbsp&nbsp&nbspОб этом подробно написано выше.<br>
<br>
&nbsp&nbsp&nbsp&nbsp3. Должно ли имя файла совпадать с именем модуля?<br>
&nbsp&nbsp&nbsp&nbspДолжно, т.к. компилятор должен иметь возможность найти импортируемые модули и провести их компи-<br>
ляцию при необходимости (см. вопрос 8).<br>
<br>
&nbsp&nbsp&nbsp&nbsp4. Как компилятор осуществляет поиск модулей, перечисленных в списке импорта?<br>
&nbsp&nbsp&nbsp&nbspСначала производится поиск модулей в текущей папке, а затем в папке библиотечных модулей, указан-<br>
ной в переменной среды MR_Home. Это позволяет упростить разработку компилятора и библиотек, т.к.<br>
и то и другое эволюционирует параллельно.<br>
<br>
&nbsp&nbsp&nbsp&nbsp5. Возможно ли в рамках отдельного проекта приложения создать модуль, имеющий то же имя, что и<br>
библиотечный модуль? Перекроет ли этот модуль одноимённый библиотечный?<br>
&nbsp&nbsp&nbsp&nbspМожно. Перекроет. Однако, если библиотечный модуль зависит от другого библиотечного модуля, кото-<br>
рый перекрыт пользовательским, то выдаётся сообщение об ошибке.<br>
<br>
&nbsp&nbsp&nbsp&nbsp6. Могут ли в проекте существовать два модуля с одним именем?<br>
&nbsp&nbsp&nbsp&nbspНет, не могут, т.к. все модули находятся в плоском пространстве имён.<br>
<br>
&nbsp&nbsp&nbsp&nbsp7. Возможен ли "гамак"?<br>
&nbsp&nbsp&nbsp&nbspСовершенно спокойно. Т.к. можно указать в командной строке несколько стартовых модулей и все они<br>
будут проинициализированы до выполнения функции Go, то возможна, к примеру, регистрация функций об-<br>
ратного вызова. Т.к. набор стартовых модулей определяется в командной строке, то до выполнения функ-<br>
ции Go может быть выполнен код инициализации любого, даже совершенно постороннего модуля, указанного<br>
в командной строке.<br>
&nbsp&nbsp&nbsp&nbspИменно эта особенность роднит текущую концепцию модулей с языком C++: выбор в C++ единиц трансля-<br>
ции, входящих в программу, определяется на этапе компоновки, поэтому перед вызовом функции main() мо-<br>
жет быть выполнен любой код -- как код инициализации некоторого объектника.<br>
<br>
&nbsp&nbsp&nbsp&nbsp8. Встроена ли в компилятор утилита make?<br>
&nbsp&nbsp&nbsp&nbspВстроена. Причём проверяет необходимость компиляции по времени последнего изменения файла с точ-<br>
ностью до минуты. Это объясняется несовершенной реализацией средств работы с файловой системой (под-<br>
робности в ошибке модуля MFileSystem).<br>
<br>
<br>
&nbsp&nbsp&nbsp&nbspTODO. Возможные пути изменения концепции модулей.<br>
&nbsp&nbsp&nbsp&nbspПланируется изменить следующие аспекты:<br>
&nbsp&nbsp&nbsp&nbspВнешние изменения.<br>
&nbsp&nbsp&nbsp&nbsp[*] Введение синтаксически выделенного модуля-программы. Отсутствие модуля-программы приводит к<br>
возможности реализации проекта с несколькими стартовыми модулями -- "гамака". При наличии модуля-<br>
программы набор модулей, входящих в проект, определяется самим исходным текстом, а не внешними фак-<br>
торами. Добавление в язык модуля-программы: (1) упростит структуру исходных текстов -- сделает её де-<br>
ревом, а не потенциальным гамаком, (2) упростит способ выбора имени для .exe-шника (сейчас имя для<br>
исполняемого файла выбирается из имён стартовых модулей по весьма шаманскому правилу -- даже не помню<br>
по какому -- то ли имя самого первого, то ли самого последнего стартового модуля, перечисленного в<br>
командной строке) -- имя .exe-шника будет определяться именем модуля-программы.<br>
&nbsp&nbsp&nbsp&nbspПри использовании модуля-программы можно изменить способ интерпретации специальных функций --<br>
функция Go выбирается из модуля-программы, в остальных модулях она не будет считаться специальной.<br>
Аналогично, функции Init и Final будут считаться специальными только в обычных (regular) модулях.<br>
&nbsp&nbsp&nbsp&nbspСинтаксически модуль-программа может быть таким же, как и обычный модуль, только вместо $MODULE<br>
будет использована директива $PROGRAM.<br>
&nbsp&nbsp&nbsp&nbsp[*] Использование иерархической структуры модулей в стиле языка Java. При этом можно осуществлять<br>
поиск модулей в папках, перечисленных в списке, аналогичном CLASSPATH языка Java. Альтернативой мог-<br>
ло бы быть введение возможности указания пути к модулю так, как это сделано в Delphi. Для этого<br>
можно расширить имеющийся синтасис переименования модулей (к которому семантика до сих пор не реали-<br>
зована).<br>
&nbsp&nbsp&nbsp&nbspПакеты модулей также могут соответствовать каталогам файловой системы. Для указания того факта,<br>
что модуль принадлежит пакету, можно использовать квалифицированное имя в качестве имени модуля:<br>
&nbsp&nbsp&nbsp&nbsp$MODULE PackName::SubPackName::ModuleName;<br>
&nbsp&nbsp&nbsp&nbsp$END PackName::SubPackName::ModuleName.<br>
&nbsp&nbsp&nbsp&nbsp[*] Подумать над квалификацией с использованием точки '.' вместо (или вместе) используемого в<br>
настоящее время двойного двоеточия '::'.<br>
<br>
&nbsp&nbsp&nbsp&nbspВнутренние изменения.<br>
&nbsp&nbsp&nbsp&nbsp[*] Реализация наконец переименования модулей.<br>
&nbsp&nbsp&nbsp&nbsp[*] Представление символьной информации не как структуры данных, а как АТД.<br>
&nbsp&nbsp&nbsp&nbsp[*] Переработка управляющей программы (драйвера). Текущий драйвер (0.0.376) объединяет в себе<br>
операции по проверке необходимости перекомпиляции и самой перекомпиляции. Однако, при проверке необ-<br>
ходимости перекомпиляции не проверяется, изменился ли импортируемый модуль после импортирующего.<br>
Также имеется ошибка при попытке отправить на перекомпиляцию библиотечный модуль -- в этом случае<br>
компилятор умирает с внутренней ошибкой.<br>
&nbsp&nbsp&nbsp&nbsp[*] В перспективе -- разработка унифицированного промежуточного представления модуля (ведь в пер-<br>
спективе компилятор должен поддерживать несколько back- и front-end'ов) и организация этого представ-<br>
ления в виде АТД.<br>
&nbsp&nbsp&nbsp&nbsp[*] Изменение синтаксиса -- введение такой категории, как квалифицированное имя. Имя модуля, имя<br>
импортируемого модуля и имя вызываемой функции должны быть квалифицированными именами. На первое вре-<br>
мя (когда ещё пакеты не будут реализованы) можно выдавать сообщения об ошибке при обнаружении квали-<br>
фицированного имени не там, где надо (в директиве $MODULE или $IMPORT или при квалификации более чем<br>
двумя именами вызова функции) на этапе семантической проверки.<br>
</BODY></HTML>
