	Цель лаб. В этом каталоге будет располагаться серия лаб, цель которых состо-
ит в изучении механизма модулей в языках, которые этот механизм поддерживают:
Borland Delphi, XDS Modula/Oberon, JOB. Также будет рассмотрен язык Java (под-
робности в файле Java\note000.txt).
	Образец гамака на C++ (см. ниже) рассмотрен в папке Gamak-Sample-C++.

	Основные термины и понятия:
	Библиотечный модуль -- модуль, поставляемый вместе с реализацией языка раз-
работчиками языка и содержащий средства поддержки языка и средства общего наз-
начения (операции ввода/вывода, математические функции, средства для работы с
сетью, файловой системой и др.).
	Гамак (употребляется только здесь, не общепринятый термин) -- проект, со-
держащий несколько стартовых модулей. Как правило, если проект не является га-
маком, т.е. имеется только один стартовый модуль, и утилита make встроена в ком-
пилятор, то достаточно указать только один модуль. Если же гамак поддерживается
языком, то для компиляции необходимо указать компилятору как минимум все старто-
вые модули. Если же начертить граф зависимостей между модулями (при отсутствии
циклического импорта) так, чтобы стартовые и листовые модули располагались с
разных сторон, то граф будет напоминать гамак или рекламу-растяжку над дорогой.
	Импорт -- языковое средство, позволяющее получить доступ к средствам друго-
	Имя модуля -- как правило, синтаксис многих языков требует указания имени
модуля.
го модуля.
	Инвариант модуля -- некоторое множество состояний данных данного модуля и
окружающей среды, в котором определено поведение всех средств модуля (например,
при неинициализированном указателе поведение функции, использующей значение
данного указателя не определено -- состояние неинициализированного указателя
не входит в инвариант).
	Инициализация модуля -- средство, позволяющее установить инвариант модуля,
а также открыть ресурсы, необходимые модулю (файлы, сетевые соединения, память
и др.). Как правило, код инициализации вызывается перед первым использованием
ресурсов модуля.
	Листовой модуль -- модуль, который не импортирует ресурсы ни одного модуля
данного проекта (хотя он может импортировать библиотечные модули).
	Модуль. (а) Общее понятие -- набор взаимосвязанных функций, объявлений,
определений, связанных между собой семантически и выполняющих строго определён-
ную задачу. Под это определение попадают также единицы компиляции языков C, С++
и исходные файлы многих реализаций Рефала. (б) Языковое средство, обеспечиваю-
щее группировку различных средств языка (функции, процедуры, классы, структуры
данных, данные в виде, к примеру, глобальных переменных) в единое целое, а так-
же обеспечивающее сокрытие деталей реализации (инкапсуляцию). Для доступа к
средствам, содержащимся в модуле, его необходимо импортировать. Под это опре-
деление попадают понятия модуля в языках Паскаль-семейства, классы в объектно-
ориентированных языках -- потомках Симулы (C++, Java, C#, Object Pascal и др.).
Однако, в ряде ОО-языков используется другое понятие класса -- множество объек-
тов, реализующее определённый интерфейс, например, в Haskell.
	Термин "модуль" в значении (а) здесь будет использоваться только при описа-
нии реализации образца гамака на языке C++, в остальных случаях будет использо-
ваться термин "модуль" только в значении (б).
	Проект -- набор исходных файлов, из которого в результате компиляции обра-
зуется отдельное самостоятельное приложение (исполнимый модуль или библиотека).
	Сборка -- процесс получения из набора исходных файлов проекта готового при-
ложения. Может осуществляться вручную (компиляция отдельных модулей, затем ком-
поновка), самим компилятором, утилитой make, интегрированной средой разработки.
	Стартовый модуль -- модуль, ресурсы которого не импортируются другими моду-
	Утилита make (здесь) -- средство компилятора, позволяющее при указании
имени модуля также откомпилировать все модули, прямо или косвенно, импортиру-
емые данным модулем. Названо по названию утилиты make, осуществляющее анализ
зависимостей между исходными файлами, а также, устанавливающее необходимость
перекомпиляции модулей.
лями данного проекта.
	Финализация модуля -- средство, позволяющее разрушающее инвариант модуля,
а также закрыть ресурсы, необходимые модулю. Как правило, код финализации выпол-
няется после последнего использования ресурсов модуля.
	Циклический импорт -- такое состояние проекта, что существуют в проекте хотя
бы два модуля, прямо или косвенно импортирующие средства друг друга.
	Экспорт некоторого ресурса модуля (функция, объявление структуры данных,
данные и т.д.) -- языковое средство, предоставляющее возможность импорта этого
ресурса другими модулями.

	Вопросы, на которые необходимо найти ответ:

	1. Разрешён ли циклический импорт модулей?
	2. Как определён порядок инициализации модулей?
	3. Должно ли имя файла совпадать с именем модуля?
	4. Как компилятор осуществляет поиск модулей, перечисленных в списке импор-
та?
	5. Возможно ли в рамках отдельного проекта приложения создать модуль, имею-
щий то же имя, что и библиотечный модуль? Перекроет ли этот модуль одноимённый
библиотечный?
	6. Могут ли в проекте существовать два модуля с одним именем?
	7. Возможен ли "гамак"?
	8. Встроена ли в компилятор утилита make?

	Выводы.
	Рассмотрены языки Oberon-2, Modula-2, Java (с учётом определённых допущений),
Pascal и их реализации XDS Oberon-2, XDS Modula-2, Borland Delphi 7, Sun Micro-
systems Java, Microsoft Visual J#, Java-Oberon Compiler (JOB).
	Подавляющее большинство рассмотренных реализаций (все, кроме JOB и MS J#)
имеют встроенную в компилятор утилиту make, т.е. компилируют не только модуль,
указанный в командной строке, но и все зависимые импротируемые модули.
	При этом можно разделить все реализации на те, которые используют статичес-
кое определение зависимостей между модулями и динамическое определение.
	Статическое определение зависимостей использует язык Модула-2, т.к. файлы
определений (.def-файлы) модулей доступны ещё до компиляции соответствующих фай-
лов реализации (.mod-файлы). Поэтому язык может допустить (без нарушения логи-
ческой целостности проекта) циклические зависимости между модулями (при этом по-
рядок инициализации не определён). Однако, в руководстве к языку написано, что
циклические зависимости между модулями запрещены.
	Остальные языки используют динамическое определение зависимостей -- файл ин-
терфейсов формируется при компиляции соответствующего файла -- это .sym-файл для
XDS Oberon-2, .dcu-файлы для Delphi (в одном файле объединены как информация о
межмодульных связях, так и сам откомпилированный код для компоновки), .class-
файлы для Java (также объединены два вида информации), .dfn-файлы для JOB.
	Такая динамическая (времени компиляции) проверка межмодульных связей затруд-
няет возможность создания проекта с циклическими зависимостями. Java представля-
ет собой исключение, т.к. использует динамическую загрузку классов и проверку
межклассовых зависимостей.
	Все рассмотренные языки и реализации содержат понятие главной программы --
модуля, выделенного синтаксически и используемого как стартовый.
	
	Теперь ответим последовательно на поставленные вопросы.
	1. Разрешён ли циклический импорт модулей?
	Циклический импорт модулей (классов) разрешён только в языке Java. В осталь-
ных языках циклический импорт модулей запрещён, хотя некоторые компиляторы (JOB,
XDS Modula-2) по ошибке его допускают.

	2. Как определён порядок инициализации модулей?
	В рассмотренных языках, кроме JOB и Java, при отсутствии циклических зави-
симостей между модулями, импортируемые модули инициализируются раньше, а фина-
лизируются позже (для языка Модула-2 финализация не проверялась, Оберон-2 фи-
нализацию не поддерживает), чем импортирующие их. Таким образом гарантируется
инвариантное состояние импортируемых модулей. Язык Java использует динамическую
инициализацию (при загрузке класса во время выполнения), но при этом инициали-
зация выполняется до первого использования класса, т.е. также гарантируется
инвариантное состояние класса в момент вызова его модуля. Однако, если имеет-
ся циклическая зависимость между классами в момент выполнения блока статичес-
кой инициализации, то инвариантное состояние не гарантируется (класс может
использоваться в момент его статической инициализации). Компилятор JOB не под-
держивает инициализацию модулей -- файлы исходного текста компилируются без
ошибок, но при попытке выполнить, выпадает сообщение об ошибке.
	После инициализации всех модулей выполняется главная программа -- код в
модуле-программе (program в Delphi, <* +MAIN *> в XDS Модуле-2 и Обероне-2,
при чём, в Модуле-2 модуль должен быть MODULE, а не DEFINITION MODULE или
IMPLEMENTATION MODULE).
	В реализации JOB просто выполняется код процедуры main(), как и в языке
Java.

	3. Должно ли имя файла совпадать с именем модуля?
	В большинстве языков -- должно совпадать только в случае, если модуль не
является модулем-программой. Модуль-программа может иметь любое внутреннее имя
-- это никак не влияет (Borland Delphi) или почти не влияет (XDS -- это имя по-
лучает соответствующий объектный или исполнимый файл) на конечный результат.
	В языке Java имя класса должно сопвпадать с именем файла, только если этот
файл должен быть доступен за пределами данного проекта, т.е. быть public.

	4. Как компилятор осуществляет поиск модулей, перечисленных в списке импор-
та?
	Все языки, кроме Java, рассмотренные здесь сначала осуществляют поиск в те-
кущей директории, а затем среди библиотечных модулей. Язык Java сначала ищет
класс среди библиотечных модулей.
	Однако, большинство компиляторов позволяют изменить эти правила:
	Borland Delphi внутри модуля-программы (и только его) позволяет создать пе-
ренаправление для некоторого имени модуля.
	Компилятор XDS позволяет указать папки для поиска исходных текстов, файлов
описания межмодульных связей, объектников и др. в файле перенаправления (redi-
rection) xc.red в папке проекта.
	Виртуальная машина Java позволяет указать пути поиска классов как параметр
-classpath (это относится одновременно к языкам Java и JOB), компилятор MS
Visual J# предоставляет ключи командной строки для той же цели.

	5. Возможно ли в рамках отдельного проекта приложения создать модуль, имею-
щий то же имя, что и библиотечный модуль? Перекроет ли этот модуль одноимённый
библиотечный?
	Создать то везде можно. И почти везде (везде, кроме Sun Microsystems Java)
перекроет. Однако, спецификации языков такой трюк могут и запрещать, как напри-
мер, это делает язык Modula-2 (см. руководство к языку).

	6. Могут ли в проекте существовать два модуля с одним именем?
	Во всех языках, кроме Java, имена модулей находятся в общем пространстве
имён, т.е. невозможно использование в проекте двух модулей с одним именем.
Если же компилятор может найти модуль с заданным именем двумя разными спосо-
бами, то выбирается один и тот же во всех случаях (откуда бы он не импортировал-
ся).
	В языке Java механизм более совершенный -- классы образуют иерархическую
структуру -- при этом классы могут иметь одно имя, если они располагаются на
разных уровнях. Эта структура описывается при помощи пакетов. Пакеты соответст-
вуют каталогам файловой системы (или каталогам внутри архива jar), при этом
модуль, находящийся внутри пакета, должен иметь директиву package, указывающую,
в каком пакете он находится.
	При этом на одном уровне иерархической структуры не могут одновременно нахо-
диться одноимённые пакет и модуль.

	7. Возможен ли "гамак"?
	Ни в одном языке не возможен.
	В языках, использующих модуль-программу стартовый модуль может быть только
один -- модуль-программа. Однако, в качестве "главного модуля программы" может
использоваться и обычный модуль программы со специально выделенной функцией типа
main, а сам модуль-программа может генерироваться в скриптом процессе сборки.
Такая возможность продемонстрирована в папке Borland Delphi\Gamak (см. файл
make-gamak.bat)
	В реализации Sun Microsystems Java выполнение всегда начинается с метода
main класса, указанного в командной строке, хотя до него может выполняться и
блок статической инициализации этого же класса. Никакой другой код выполняться
раньше не может.
	В реализации MS Visual J# при наличии в проекте нескольких классов с методом
main выполненяется только одна точка входа (как именно определяется выбор, я не
исследовал). При необходимости можно указать в ключе /main:<entry-point> исполь-
зуемую точку входа.
	Однако, почему же в C++ возможен гамак? В C++ перед вызовом функции main()
должны быть проинициализированы все глобальные объекты всех единиц трансляции,
входящих в проект. Однако набор единиц трансляции определяется не средствами
языка (рекурсивная компиляция зависимых модулей в исследованных реализаций по-
томков Паскаля, загрузка классов по требованию в языке Java), а внешними средст-
вами (программист явно указывает входящие в проект файлы или использует утилиту
make для определения зависимостей между файлами). Поэтому перед выполнением
функции main() может быть выполнен любой код, прикомпонованный в процессе сборки.

	8. Встроена ли в компилятор утилита make?
	Встроена во все, кроме MS Visual J# и JOB. Компилятору MS Visual J# необхо-
димо в командной строке перечислить все файлы проекта, компилятор JOB может
за раз откомпилировать только один файл. Механизм проверки необходимости компи-
ляции (например, сравнение времени изменения исходного/объектного файла) не ис-
следовался, проверялось только наличие механизма перекомпиляции зависимых фай-
лов.