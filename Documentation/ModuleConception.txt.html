<HTML> <BODY>
&nbsp&nbsp&nbsp&nbspЦель лаб. В этом каталоге будет располагаться серия лаб, цель которых состо-<br>
ит в изучении механизма модулей в языках, которые этот механизм поддерживают:<br>
Borland Delphi, XDS Modula/Oberon, JOB. Также будет рассмотрен язык Java (под-<br>
робности в файле Java\note000.txt).<br>
&nbsp&nbsp&nbsp&nbspОбразец гамака на C++ (см. ниже) рассмотрен в папке Gamak-Sample-C++.<br>
<br>
&nbsp&nbsp&nbsp&nbspОсновные термины и понятия:<br>
&nbsp&nbsp&nbsp&nbspБиблиотечный модуль -- модуль, поставляемый вместе с реализацией языка раз-<br>
работчиками языка и содержащий средства поддержки языка и средства общего наз-<br>
начения (операции ввода/вывода, математические функции, средства для работы с<br>
сетью, файловой системой и др.).<br>
&nbsp&nbsp&nbsp&nbspГамак (употребляется только здесь, не общепринятый термин) -- проект, со-<br>
держащий несколько стартовых модулей. Как правило, если проект не является га-<br>
маком, т.е. имеется только один стартовый модуль, и утилита make встроена в ком-<br>
пилятор, то достаточно указать только один модуль. Если же гамак поддерживается<br>
языком, то для компиляции необходимо указать компилятору как минимум все старто-<br>
вые модули. Если же начертить граф зависимостей между модулями (при отсутствии<br>
циклического импорта) так, чтобы стартовые и листовые модули располагались с<br>
разных сторон, то граф будет напоминать гамак или рекламу-растяжку над дорогой.<br>
&nbsp&nbsp&nbsp&nbspИмпорт -- языковое средство, позволяющее получить доступ к средствам друго-<br>
&nbsp&nbsp&nbsp&nbspИмя модуля -- как правило, синтаксис многих языков требует указания имени<br>
модуля.<br>
го модуля.<br>
&nbsp&nbsp&nbsp&nbspИнвариант модуля -- некоторое множество состояний данных данного модуля и<br>
окружающей среды, в котором определено поведение всех средств модуля (например,<br>
при неинициализированном указателе поведение функции, использующей значение<br>
данного указателя не определено -- состояние неинициализированного указателя<br>
не входит в инвариант).<br>
&nbsp&nbsp&nbsp&nbspИнициализация модуля -- средство, позволяющее установить инвариант модуля,<br>
а также открыть ресурсы, необходимые модулю (файлы, сетевые соединения, память<br>
и др.). Как правило, код инициализации вызывается перед первым использованием<br>
ресурсов модуля.<br>
&nbsp&nbsp&nbsp&nbspЛистовой модуль -- модуль, который не импортирует ресурсы ни одного модуля<br>
данного проекта (хотя он может импортировать библиотечные модули).<br>
&nbsp&nbsp&nbsp&nbspМодуль. (а) Общее понятие -- набор взаимосвязанных функций, объявлений,<br>
определений, связанных между собой семантически и выполняющих строго определён-<br>
ную задачу. Под это определение попадают также единицы компиляции языков C, С++<br>
и исходные файлы многих реализаций Рефала. (б) Языковое средство, обеспечиваю-<br>
щее группировку различных средств языка (функции, процедуры, классы, структуры<br>
данных, данные в виде, к примеру, глобальных переменных) в единое целое, а так-<br>
же обеспечивающее сокрытие деталей реализации (инкапсуляцию). Для доступа к<br>
средствам, содержащимся в модуле, его необходимо импортировать. Под это опре-<br>
деление попадают понятия модуля в языках Паскаль-семейства, классы в объектно-<br>
ориентированных языках -- потомках Симулы (C++, Java, C#, Object Pascal и др.).<br>
Однако, в ряде ОО-языков используется другое понятие класса -- множество объек-<br>
тов, реализующее определённый интерфейс, например, в Haskell.<br>
&nbsp&nbsp&nbsp&nbspТермин "модуль" в значении (а) здесь будет использоваться только при описа-<br>
нии реализации образца гамака на языке C++, в остальных случаях будет использо-<br>
ваться термин "модуль" только в значении (б).<br>
&nbsp&nbsp&nbsp&nbspПроект -- набор исходных файлов, из которого в результате компиляции обра-<br>
зуется отдельное самостоятельное приложение (исполнимый модуль или библиотека).<br>
&nbsp&nbsp&nbsp&nbspСборка -- процесс получения из набора исходных файлов проекта готового при-<br>
ложения. Может осуществляться вручную (компиляция отдельных модулей, затем ком-<br>
поновка), самим компилятором, утилитой make, интегрированной средой разработки.<br>
&nbsp&nbsp&nbsp&nbspСтартовый модуль -- модуль, ресурсы которого не импортируются другими моду-<br>
&nbsp&nbsp&nbsp&nbspУтилита make (здесь) -- средство компилятора, позволяющее при указании<br>
имени модуля также откомпилировать все модули, прямо или косвенно, импортиру-<br>
емые данным модулем. Названо по названию утилиты make, осуществляющее анализ<br>
зависимостей между исходными файлами, а также, устанавливающее необходимость<br>
перекомпиляции модулей.<br>
лями данного проекта.<br>
&nbsp&nbsp&nbsp&nbspФинализация модуля -- средство, позволяющее разрушающее инвариант модуля,<br>
а также закрыть ресурсы, необходимые модулю. Как правило, код финализации выпол-<br>
няется после последнего использования ресурсов модуля.<br>
&nbsp&nbsp&nbsp&nbspЦиклический импорт -- такое состояние проекта, что существуют в проекте хотя<br>
бы два модуля, прямо или косвенно импортирующие средства друг друга.<br>
&nbsp&nbsp&nbsp&nbspЭкспорт некоторого ресурса модуля (функция, объявление структуры данных,<br>
данные и т.д.) -- языковое средство, предоставляющее возможность импорта этого<br>
ресурса другими модулями.<br>
<br>
&nbsp&nbsp&nbsp&nbspВопросы, на которые необходимо найти ответ:<br>
<br>
&nbsp&nbsp&nbsp&nbsp1. Разрешён ли циклический импорт модулей?<br>
&nbsp&nbsp&nbsp&nbsp2. Как определён порядок инициализации модулей?<br>
&nbsp&nbsp&nbsp&nbsp3. Должно ли имя файла совпадать с именем модуля?<br>
&nbsp&nbsp&nbsp&nbsp4. Как компилятор осуществляет поиск модулей, перечисленных в списке импор-<br>
та?<br>
&nbsp&nbsp&nbsp&nbsp5. Возможно ли в рамках отдельного проекта приложения создать модуль, имею-<br>
щий то же имя, что и библиотечный модуль? Перекроет ли этот модуль одноимённый<br>
библиотечный?<br>
&nbsp&nbsp&nbsp&nbsp6. Могут ли в проекте существовать два модуля с одним именем?<br>
&nbsp&nbsp&nbsp&nbsp7. Возможен ли "гамак"?<br>
&nbsp&nbsp&nbsp&nbsp8. Встроена ли в компилятор утилита make?<br>
<br>
&nbsp&nbsp&nbsp&nbspВыводы.<br>
&nbsp&nbsp&nbsp&nbspРассмотрены языки Oberon-2, Modula-2, Java (с учётом определённых допущений),<br>
Pascal и их реализации XDS Oberon-2, XDS Modula-2, Borland Delphi 7, Sun Micro-<br>
systems Java, Microsoft Visual J#, Java-Oberon Compiler (JOB).<br>
&nbsp&nbsp&nbsp&nbspПодавляющее большинство рассмотренных реализаций (все, кроме JOB и MS J#)<br>
имеют встроенную в компилятор утилиту make, т.е. компилируют не только модуль,<br>
указанный в командной строке, но и все зависимые импротируемые модули.<br>
&nbsp&nbsp&nbsp&nbspПри этом можно разделить все реализации на те, которые используют статичес-<br>
кое определение зависимостей между модулями и динамическое определение.<br>
&nbsp&nbsp&nbsp&nbspСтатическое определение зависимостей использует язык Модула-2, т.к. файлы<br>
определений (.def-файлы) модулей доступны ещё до компиляции соответствующих фай-<br>
лов реализации (.mod-файлы). Поэтому язык может допустить (без нарушения логи-<br>
ческой целостности проекта) циклические зависимости между модулями (при этом по-<br>
рядок инициализации не определён). Однако, в руководстве к языку написано, что<br>
циклические зависимости между модулями запрещены.<br>
&nbsp&nbsp&nbsp&nbspОстальные языки используют динамическое определение зависимостей -- файл ин-<br>
терфейсов формируется при компиляции соответствующего файла -- это .sym-файл для<br>
XDS Oberon-2, .dcu-файлы для Delphi (в одном файле объединены как информация о<br>
межмодульных связях, так и сам откомпилированный код для компоновки), .class-<br>
файлы для Java (также объединены два вида информации), .dfn-файлы для JOB.<br>
&nbsp&nbsp&nbsp&nbspТакая динамическая (времени компиляции) проверка межмодульных связей затруд-<br>
няет возможность создания проекта с циклическими зависимостями. Java представля-<br>
ет собой исключение, т.к. использует динамическую загрузку классов и проверку<br>
межклассовых зависимостей.<br>
&nbsp&nbsp&nbsp&nbspВсе рассмотренные языки и реализации содержат понятие главной программы --<br>
модуля, выделенного синтаксически и используемого как стартовый.<br>
&nbsp&nbsp&nbsp&nbsp<br>
&nbsp&nbsp&nbsp&nbspТеперь ответим последовательно на поставленные вопросы.<br>
&nbsp&nbsp&nbsp&nbsp1. Разрешён ли циклический импорт модулей?<br>
&nbsp&nbsp&nbsp&nbspЦиклический импорт модулей (классов) разрешён только в языке Java. В осталь-<br>
ных языках циклический импорт модулей запрещён, хотя некоторые компиляторы (JOB,<br>
XDS Modula-2) по ошибке его допускают.<br>
<br>
&nbsp&nbsp&nbsp&nbsp2. Как определён порядок инициализации модулей?<br>
&nbsp&nbsp&nbsp&nbspВ рассмотренных языках, кроме JOB и Java, при отсутствии циклических зави-<br>
симостей между модулями, импортируемые модули инициализируются раньше, а фина-<br>
лизируются позже (для языка Модула-2 финализация не проверялась, Оберон-2 фи-<br>
нализацию не поддерживает), чем импортирующие их. Таким образом гарантируется<br>
инвариантное состояние импортируемых модулей. Язык Java использует динамическую<br>
инициализацию (при загрузке класса во время выполнения), но при этом инициали-<br>
зация выполняется до первого использования класса, т.е. также гарантируется<br>
инвариантное состояние класса в момент вызова его модуля. Однако, если имеет-<br>
ся циклическая зависимость между классами в момент выполнения блока статичес-<br>
кой инициализации, то инвариантное состояние не гарантируется (класс может<br>
использоваться в момент его статической инициализации). Компилятор JOB не под-<br>
держивает инициализацию модулей -- файлы исходного текста компилируются без<br>
ошибок, но при попытке выполнить, выпадает сообщение об ошибке.<br>
&nbsp&nbsp&nbsp&nbspПосле инициализации всех модулей выполняется главная программа -- код в<br>
модуле-программе (program в Delphi, &lt* +MAIN *&gt в XDS Модуле-2 и Обероне-2,<br>
при чём, в Модуле-2 модуль должен быть MODULE, а не DEFINITION MODULE или<br>
IMPLEMENTATION MODULE).<br>
&nbsp&nbsp&nbsp&nbspВ реализации JOB просто выполняется код процедуры main(), как и в языке<br>
Java.<br>
<br>
&nbsp&nbsp&nbsp&nbsp3. Должно ли имя файла совпадать с именем модуля?<br>
&nbsp&nbsp&nbsp&nbspВ большинстве языков -- должно совпадать только в случае, если модуль не<br>
является модулем-программой. Модуль-программа может иметь любое внутреннее имя<br>
-- это никак не влияет (Borland Delphi) или почти не влияет (XDS -- это имя по-<br>
лучает соответствующий объектный или исполнимый файл) на конечный результат.<br>
&nbsp&nbsp&nbsp&nbspВ языке Java имя класса должно сопвпадать с именем файла, только если этот<br>
файл должен быть доступен за пределами данного проекта, т.е. быть public.<br>
<br>
&nbsp&nbsp&nbsp&nbsp4. Как компилятор осуществляет поиск модулей, перечисленных в списке импор-<br>
та?<br>
&nbsp&nbsp&nbsp&nbspВсе языки, кроме Java, рассмотренные здесь сначала осуществляют поиск в те-<br>
кущей директории, а затем среди библиотечных модулей. Язык Java сначала ищет<br>
класс среди библиотечных модулей.<br>
&nbsp&nbsp&nbsp&nbspОднако, большинство компиляторов позволяют изменить эти правила:<br>
&nbsp&nbsp&nbsp&nbspBorland Delphi внутри модуля-программы (и только его) позволяет создать пе-<br>
ренаправление для некоторого имени модуля.<br>
&nbsp&nbsp&nbsp&nbspКомпилятор XDS позволяет указать папки для поиска исходных текстов, файлов<br>
описания межмодульных связей, объектников и др. в файле перенаправления (redi-<br>
rection) xc.red в папке проекта.<br>
&nbsp&nbsp&nbsp&nbspВиртуальная машина Java позволяет указать пути поиска классов как параметр<br>
-classpath (это относится одновременно к языкам Java и JOB), компилятор MS<br>
Visual J# предоставляет ключи командной строки для той же цели.<br>
<br>
&nbsp&nbsp&nbsp&nbsp5. Возможно ли в рамках отдельного проекта приложения создать модуль, имею-<br>
щий то же имя, что и библиотечный модуль? Перекроет ли этот модуль одноимённый<br>
библиотечный?<br>
&nbsp&nbsp&nbsp&nbspСоздать то везде можно. И почти везде (везде, кроме Sun Microsystems Java)<br>
перекроет. Однако, спецификации языков такой трюк могут и запрещать, как напри-<br>
мер, это делает язык Modula-2 (см. руководство к языку).<br>
<br>
&nbsp&nbsp&nbsp&nbsp6. Могут ли в проекте существовать два модуля с одним именем?<br>
&nbsp&nbsp&nbsp&nbspВо всех языках, кроме Java, имена модулей находятся в общем пространстве<br>
имён, т.е. невозможно использование в проекте двух модулей с одним именем.<br>
Если же компилятор может найти модуль с заданным именем двумя разными спосо-<br>
бами, то выбирается один и тот же во всех случаях (откуда бы он не импортировал-<br>
ся).<br>
&nbsp&nbsp&nbsp&nbspВ языке Java механизм более совершенный -- классы образуют иерархическую<br>
структуру -- при этом классы могут иметь одно имя, если они располагаются на<br>
разных уровнях. Эта структура описывается при помощи пакетов. Пакеты соответст-<br>
вуют каталогам файловой системы (или каталогам внутри архива jar), при этом<br>
модуль, находящийся внутри пакета, должен иметь директиву package, указывающую,<br>
в каком пакете он находится.<br>
&nbsp&nbsp&nbsp&nbspПри этом на одном уровне иерархической структуры не могут одновременно нахо-<br>
диться одноимённые пакет и модуль.<br>
<br>
&nbsp&nbsp&nbsp&nbsp7. Возможен ли "гамак"?<br>
&nbsp&nbsp&nbsp&nbspНи в одном языке не возможен.<br>
&nbsp&nbsp&nbsp&nbspВ языках, использующих модуль-программу стартовый модуль может быть только<br>
один -- модуль-программа. Однако, в качестве "главного модуля программы" может<br>
использоваться и обычный модуль программы со специально выделенной функцией типа<br>
main, а сам модуль-программа может генерироваться в скриптом процессе сборки.<br>
Такая возможность продемонстрирована в папке Borland Delphi\Gamak (см. файл<br>
make-gamak.bat)<br>
&nbsp&nbsp&nbsp&nbspВ реализации Sun Microsystems Java выполнение всегда начинается с метода<br>
main класса, указанного в командной строке, хотя до него может выполняться и<br>
блок статической инициализации этого же класса. Никакой другой код выполняться<br>
раньше не может.<br>
&nbsp&nbsp&nbsp&nbspВ реализации MS Visual J# при наличии в проекте нескольких классов с методом<br>
main выполненяется только одна точка входа (как именно определяется выбор, я не<br>
исследовал). При необходимости можно указать в ключе /main:&ltentry-point&gt исполь-<br>
зуемую точку входа.<br>
&nbsp&nbsp&nbsp&nbspОднако, почему же в C++ возможен гамак? В C++ перед вызовом функции main()<br>
должны быть проинициализированы все глобальные объекты всех единиц трансляции,<br>
входящих в проект. Однако набор единиц трансляции определяется не средствами<br>
языка (рекурсивная компиляция зависимых модулей в исследованных реализаций по-<br>
томков Паскаля, загрузка классов по требованию в языке Java), а внешними средст-<br>
вами (программист явно указывает входящие в проект файлы или использует утилиту<br>
make для определения зависимостей между файлами). Поэтому перед выполнением<br>
функции main() может быть выполнен любой код, прикомпонованный в процессе сборки.<br>
<br>
&nbsp&nbsp&nbsp&nbsp8. Встроена ли в компилятор утилита make?<br>
&nbsp&nbsp&nbsp&nbspВстроена во все, кроме MS Visual J# и JOB. Компилятору MS Visual J# необхо-<br>
димо в командной строке перечислить все файлы проекта, компилятор JOB может<br>
за раз откомпилировать только один файл. Механизм проверки необходимости компи-<br>
ляции (например, сравнение времени изменения исходного/объектного файла) не ис-<br>
следовался, проверялось только наличие механизма перекомпиляции зависимых фай-<br>
лов.<br>
</BODY></HTML>
