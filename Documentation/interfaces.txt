===============================
Module Brackets;

===============================
Module Compiler;
*****************************************************************************
Модуль реализует трансляцию отдельных модулей исходного текста Модульного
Рефала. Точки входа в модуль -- функции CompileByModuleName и CompileByFileName
выполняют компиляцию указанного модуля по заданному имени файла (имя в файло-
вой системе) или модуля (указанного после директивы $MODULE). Сигнатуры этих
функций следующие:
<CompileBy***Name t.Context e.***Name> == t.UpdatedContext
В процессе компиляции функции возвращают контекст с обновлённой информацией
о скомпилированных модулях или завершают выполнение программы аварийно вызовом
функции из модуля Error. Функции также при необходимости рекурсивно перекомпи-
лируют модули указанные в директивах $IMPORT указанных модулей.
Для простоты потребуем в данной версии, чтобы имя модуля совпадало с именем
файла. Поиск исходных файлов осуществляется в текущей директории, поиск библио-
течных файлов осуществляется сначала в текущей директории, затем по алгоритму,
находящемуся в модуле Modules вызовом Modules::LookupLibrary.
******************************************************************************

<CompileModule
	t.Context
	(e.Directory)
	e.ModuleName
> == t.UpdatedContext

===============================
Module Context;

===============================
Module FileIO;

===============================
Module InOut;

===============================
Module Linker;

<UpdateStartInfo t.StartInfo t.Context>
	== t.StartInfo t.Context

===============================
Module Math;

===============================
Module MBackEnd;

<Generate t.Module t.ErrorList e.OutName>
	== s.Result t.UpdatedErrorList
s.Result ::= Success | Waringns | Errors

===============================
Module MBuildNumber;

===============================
Module MError;

===============================
Module MFileSystem;

<ParseFileName e.FileName>
	== (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
	== ('c;\\Directory') 'Document' ('doc')

===============================
Module MFrontEnd;

<LoadModule e.SourceName>
	== t.Module s.Status t.ErrorList
s.Status ::= Success | Warnings | Errors | Fatal

<SymInfo t.Module>
	== t.Module t.SymInfo

<SymInfo-Old t.Module>
	== t.Module
	( Module (e.Directory) e.ModuleName )
	( Functions (e.FnName)* )
	( Imports ((e.ImportDirectory) e.ImportName)* )

<Resolve t.Module t.ErrorList e.QualifiedList>
	== t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

e.QualifiedList ::= ( t.ModuleLocation (e.EntryFnName)* )*
t.ModuleLocation ::= ((e.Directory) e.ModuleName)

===============================
Module MLexer;

===============================
Module MLocation;

<LookupModule-T t.Context (e.Directory) e.ModuleName>
	== t.Context
		s.Known s.Status
		(Sym e.SymFileName)
		(Out e.OutFileName)
		(Src e.SrcFileName)
		(e.Directory) e.ModuleName
s.Known ::= Known | NotKnown
s.Status ::=
	if Known
		Recompiled | Updated | Library | InCompiling
	if NotKnown
		ModuleNotFound | Library | SystemLibrary | NeedRecompile | SrcNotUpdated

===============================
Module MModulesList;

===============================
Module Modules;

===============================
Module MOrder;

===============================
Module MOS;

===============================
Module MParser;

<SrcModule e.SrcFileName>
	== t.Module s.ErrorResult t.ErrorList
s.ErrorResult ::= Success | Warnings | Errors | Fatal

===============================
Module MRefal;

===============================
Module MSelfDiag;

===============================
Module MStrings;

===============================
Module MSymInfo;

<Create>
	== t.SymInfo
<Create e.QualifiedModuleName>
	== t.SymInfo

<Destroy t.SymInfo>
	== empty

<LoadForModule t.Context e.QualifiedModuleName>
	== t.SymInfo t.Context

<LoadFromFile e.FileName>
	== t.SymInfo

<SaveForModule t.SymInfo t.Context>
	== t.Context

<SaveForModule-T t.SymInfo t.Context>
	== t.SymInfo t.Context

<SaveToFile t.SymInfo>
	== empty

<SaveToFile-T t.SymInfo>
	== t.SymInfo

<ToOldSymInfo t.SymInfo>
	= e.OldSymInfo

<ToOldSymInfo-T t.SymInfo>
	= t.SymInfo e.OldSymInfo

<CreateFromSymTable t.SymTable>
	== t.SymTable t.SymInfo

===============================
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста. Поиск стартовых функций должен осуществлять
линковщик.

<LoadInfo t.Context (e.Directory) e.ModuleName>
	== t.UpdatedContext
		( Module (e.Directory) e.ModuleName )
		( Functions (e.FnName)* )
		( Imports ((e.ImportDirectory) e.ImportName)* )
	== t.Context SymInfoNotFound

===============================
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
	== s.Char t.SymStream //Если символ из набора.
	== t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
	== t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
	== t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

===============================
Module MSymTable;

<ExtractLocalInfo t.SymTable>
	== t.SymTable (s.ScopeClass e.EntityName)*
s.ScopeClass ::= Entry | Local | Swap

===============================
Module Types;

