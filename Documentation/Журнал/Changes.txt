[29.09.2007 - 20:25:52,85]

  Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
  Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
  Список приоритетных изменений:

  [TODO: Механизм поиска модулей]
  Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

  [TODO: Использование нескольких front-end и back-end]
  Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

  [TODO: Указатели на функции или функция Mu]
  ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
  Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

  Mu {
    F e.Arg = <F e.Arg>;
    G e.Arg = <G e.Arg>;
    H e.Arg = <H e.Arg>;
    Mod1 A e.Arg = <Mod1::A e.Arg>;
    Mod1 B e.Arg = <Mod1::B e.Arg>;
    Mod1 C e.Arg = <Mod1::C e.Arg>;
    Mod2 A e.Arg = <Mod2::A e.Arg>;
    Mod2 C e.Arg = <Mod2::C e.Arg>;
    Mod2 D e.Arg = <Mod2::D e.Arg>;
  }

  Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
  Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

  [TODO: Статические ящики]
  Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
  Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

  ModuleName::SomeHolder::Swap {
    e.NewValue =
      <Dg ('ModuleName::SomeHolder')>
      <Br ('ModuleName::SomeHolder') '=' e.NewValue>;
  }

  Синтаксически можно использовать конструкцию, похожую на список импорта:

  $SWAP SomeHolder, OtherSomeHolder;

  Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

  [TODO: RASL и интерпретатор]
  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

  [TODO: Резервное копирование]
  Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

  Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

  [DONE: Резервное копирование]
  Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

  Ещё вспомнил.

  [TODO: Элемент (Module e.ModuleName)]
  Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

  [TODO: Доделать механизм переименования модулей]
  Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

  [DONE: Элемент (Module e.ModuleName)]
  Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
  
  Было:

  t.Module ::=
    (t.SymTable t.ModuleContent)

  t.ModuleContent ::=
    ( (ModuleName e.ModuleName)
      t.Element*
    )

  Стало:

  t.Module ::= (t.SymTable e.ModuleContent)

  e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

  [DONE: Статические ящики]
  Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
  Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
  Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

  [TODO: FileIO-дескрипторы в статическом ящике]
  Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.

  [TODO: Переименовать модуль Refal5]
  Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

  [DONE: FileIO-дескрипторы в статическом ящике]
  С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

  [TODO: Расширения .rout2 -> .rout]
  Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

  [TODO: Единица компоновки -- функция вместо модуля]
  На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

  [TODO: Новая семантика идентификатора]
  Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.


[06.10.2007 - 18:35:07,82]

  [CHANGED: Компиляция структурных скобок по-новому]
  Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.

  [TODO: Абстрактные типы данных]
  Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".


[07.10.2007 -  0:23:54,89]

  [DONE: Указатели на функции или функция Mu]
  Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождественны
идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова ука-
зателей таков (см. Syntax.txt).
  
  FunctionCall = '<' Callable ResultExpr '>' .
  Callable = FunctionName | Qualifier '::' FunctionName
    | SwapName | S-VARIABLE .

  Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
  Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

  Context::FnPtr::Local {
    Create =
      $Context::Create::Entry$ ;
    UpdateModuleInfo =
      $Context::UpdateModuleInfo::Entry$ ;

    // Часть пропущена

    AppendError =
      $Context::AppendError::Entry$ ;
    FnPtr =
      $Context::FnPtr::Local$ ;
    MModulesList UpdateModuleInfo =
      $MModulesList::UpdateModuleInfo::Entry$ ;
    MModulesList LastModule =
      $MModulesList::LastModule::Entry$ ;
    MModulesList ExtractOption =
      $MModulesList::ExtractOption::Entry$ ;
    MModulesList GetProgName =
      $MModulesList::GetProgName::Entry$ ;
    MModulesList ExtractModulesList =
      $MModulesList::ExtractModulesList::Entry$ ;
  }

  В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
  Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

  Test::IndirectCall::Local {
    s.Function =
      <Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
  }

  Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
  $MODULE Indirect;

  /*
    <ForAll s.FnPtr t.Term*>
      == e.Result*
    где e.Result = <s.FnPtr t.Term>
  */
  $ENTRY ForAll {
    s.FnPtr t.Next e.Tail =
      <s.FnPtr t.Next>
      <ForAll s.FnPtr e.Tail>;

    s.FnPtr = ;
  }

  $END Indirect.

  Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

  $MODULE Convert;

  $IMPORT MStrings, Indirect;

  $ENTRY NumsToStrings
    e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

  ToStr s.Num = <MStrings::Symb s.Num> ' ';

  $END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
  Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


[12.10.2007 - 22:09:54,55]

  [CHANGED: Папка ROut2]
  По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.

  [DONE: Переименовать модуль Refal5]
  Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


[16.10.2007 - 21:50:54,61]

  [FIXED: MOS::Env корректно работает с кириллицей]
  Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.

  [TODO: Исправить зависимую от MOS::Env MOS::EnvList]
  Изменить соответствующим образом MOS::EnvList.


[16.10.2007 - 22:06:30,03]

  [DONE: Исправить зависимую от MOS::Env MOS::EnvList]
  Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.

  [CHANGED: Удалена ROut]
  Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


[19.10.2007 -  1:04:32,32]

  [TODO: eXpression eXchange in/out]
  В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).

  [ERROR: Ошибка в MFileSystem при работе с кириллицей]
  Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
  Возможные пути решения:
  (1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
  Преимущества. Подход обобщается на использования других команд консоли Windows.
  Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
  (2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
  Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
  Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

  Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

  Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
  Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.

  [CHANGED: MFileSystem стал библиотечным]
  Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


[20.10.2007 - 16:06:51,06]

  [TODO: Автоматизация списка TODO]
  Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
  \[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).

  [TODO: Функция MOS::ArgList]
  Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
  <MOS::ArgList> == e.Args
  e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
  t.ArgK ::= (e.ArgK)


[20.10.2007 - 17:59:43,10]

  [DONE: Функция MOS::ArgList]
  В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).

  [DONE: Автоматизация списка TODO]
  Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


[20.10.2007 - 19:08:06,05]

  [CHANGED: TODOs.txt -- сводка только TODO и ERROR]
  Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.

  [TODO: Стандартные модули контейнеров и распространённых функций]
  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.


[27.10.2007 - 18:34:49,78]

  [TODO: Новая модель модулей]
  Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
  Подробности задачи см. в файле "Module conception for Module Refal.txt".


[27.10.2007 - 22:34:49,97]

  Законспектирую основные идеи из "Module conception for Module Refal.txt".
  [TODO: Модуль-программа]
  [TODO: Иерархия в стиле Java]
  [TODO: Продумать квалификацию точкой]
  [TODO: SymInfo как АТД]
  [TODO: Переписать драйвер]
  [TODO: Промежуточное представление как АТД]
  [TODO: Добавление категории "квалифицированное имя"]


[27.01.2008 - 21:21:01,49]

  [DONE: Новая семантика идентификатора]
  Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
  Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

  Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.

  [TODO: Генерация Info/Log.txt по требованию]
  Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.

  [TODO: Номер версии независимо от компиляции]
  Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.

  [TODO: Вывод номера версии компилятора]
  Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

  Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

  Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.

  [TODO: Создание папок Defs и ROut по требованию]
  Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.


[27.01.2008 - 23:01:49,86]

  [DONE: Генерация Info/Log.txt по требованию]
  [DONE: Создание папок Defs и ROut по требованию]
  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


[02.02.2008 - 17:15:41,26]

  [TODO: Удалить MRefalRTS::Lenw]
  Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.


[02.02.2008 - 17:27:23,22]

  [TODO: Удалить прозрачные функции вывода из RTS]
  Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.


[02.02.2008 - 17:49:08,69]

  Оказалось всё не так просто. Функцией MRefalRTS::Putout пользуется весьма полезная функция
MSelfDiag::Log-T. Так что пускай пока остаётся MRefalRTS::Putout.


[02.02.2008 - 17:55:52,95]

  [DONE: Удалить MRefalRTS::Lenw]
  [DONE: Удалить прозрачные функции вывода из RTS]
  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.

  [TODO: Удалить MRefalRTS::Put]
  См. выше, почему это не особо критично.


[04.02.2008 - 16:08:22,32]

  [TODO: Исключение промежуточного представления модуля]
  Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.


[04.02.2008 - 23:26:22,87]

  [TODO: Таблица перекрёстных ссылок]
  Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
  Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
  В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.

  [TODO: Составить список приоритетных TODO]
  Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.


[05.02.2008 -  1:09:32,10]

  [TODO: TODO_list изменяет порядок TODO]
  Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.


[05.02.2008 -  1:22:49,77]

  [DONE: TODO_list изменяет порядок TODO]
  Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).

  [DONE: Составить список приоритетных TODO]
  Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.

  [TODO: //== Список приоритетных TODO ==\\]
  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
  Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.
  [TODO: Механизм поиска модулей]

  [TODO] Использование нескольких front-end и back-end
  Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".
  [TODO: Использование нескольких front-end и back-end]

  [TODO] RASL и интерпретатор
  Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
  Не выделяем.

  [TODO] Доделать механизм переименования модулей
  Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.
  [TODO: Доделать механизм переименования модулей]

  [TODO] Расширения .rout2 -> .rout
  Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
  Не выделяем.

  [TODO] Единица компоновки -- функция вместо модуля
  Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.
  [TODO: Единица компоновки -- функция вместо модуля]

  [TODO] Абстрактные типы данных
  Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.
  [TODO: Абстрактные типы данных]

  [TODO] eXpression eXchange in/out
  Совсем не торопит. Не выделяем.

  [ERROR] Ошибка в MFileSystem при работе с кириллицей
  Ошибку необходимо исправить. Даже не обсуждается.
  [ERROR: Ошибка в MFileSystem при работе с кириллицей]

  [TODO] Стандартные модули контейнеров и распространённых функций
  Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

  [TODO] Новая модель модулей
  Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.
  [TODO: Новая модель модулей]

  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  Обсуждалось. Добавляем.
  [TODO: Модуль-программа]
  [TODO: Иерархия в стиле Java]
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
  Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.
  [TODO: SymInfo как АТД]

  [TODO] Переписать драйвер
  Обсуждалось. Добавляем.
  [TODO: Переписать драйвер]

  [TODO] Промежуточное представление как АТД
  См. комментарий к "SymInfo как АТД". Вопрос решать надо.
  [TODO: Промежуточное представление как АТД]

  [TODO] Добавление категории "квалифицированное имя"
  Добавление этого является прямым следствием иерархии языка Java.
  [TODO: Добавление категории "квалифицированное имя"]

  [TODO] Номер версии независимо от компиляции
  [TODO] Вывод номера версии компилятора
  Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
  Не выделяем.

  [TODO] Удалить MRefalRTS::Put
  Идеологически не принципиально. Всё равно это деталь реализации.
  Не выделяем.

  [TODO] Исключение промежуточного представления модуля
  Продумать и исключить.
  [TODO: Исключение промежуточного представления модуля]

  [TODO] Таблица перекрёстных ссылок
  Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.
  [TODO: Таблица перекрёстных ссылок]

  [TODO: \\== Вот список приоритетных TODO ==//]


[05.02.2008 -  2:46:46,28]

  [CHANGED: Директива $CLEARMODULE]
  Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.



[08.02.2008 -  2:54:59,96]

  [CHANGED: Квадратные скобки]
  Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


[09.02.2008 -  3:00:29,53]

  Исправил пару ошибок, продолжил работу над человеческой линковкой, изменил вывод сообщений.

  [FIXED: Ошибка в MOrder::Sort]
  Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.

  [FIXED: Ошибка в MParser::NImportBlock-AfterName]
  Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $IMPORT. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.

  [CHANGED: Изменился вывод сообщений о процессе компиляции]
  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  [TODO: Пересмотреть/переписать mOutModuleStatus.mref]
  См. выше.


[10.02.2008 - 23:17:42,34]

  [DONE: Единица компоновки -- функция вместо модуля]
  Правильная компоновка наконец реализована. Теперь идеологически .rout-файл представляет собой не
фрагмент генерируемого .ref-файла, в котором требуется только осуществить переименование элементов
и приклеить к .ref-файлу, а набор единиц компоновки (link unit), содержащих в себе ссылки на другие
единицы компоновки. Единицей компоновки может быть локальная или entry-функция или реализация стати-
ческого ящика. Задача линковщика теперь состоит в том, чтобы сгенерировать стартовую функцию Go для
Рефала-5 и прилинковать прямо или косвенно зависящие от неё единицы компоновки. При этом линковщик
производит переименование фукций, индексов и идентификаторов, давая им короткие имена.
  Также теперь .rout-файлы содержат в себе тег версии, который проверяется во время компоновки.


[12.02.2008 - 19:48:21,36]

  [FIXED: Ошибка в MFileSystem при работе с кириллицей]
  Исправлена эта ошибка путём введения функции перекодировщика Dos <--> Win (см. описание ошибки
и способов исправления в записи от 19.10.2007). Создавать приложение для вывода листинга папки я не
стал, т.к.
  (а) лень -- способ более трудоёмок, его преимущества не оправдывают усилий: листингом папки я ещё
ни разу не пользовался;
  (б) привязка Рефала к постороннему приложению -- не удобно;
  (в) перекодировщик полезен сам по себе.
  Помимо перекодировки вывода программы dir, перекодировщик используется в функциях ввода/вывода
модуля InOut, поэтому теперь изнутри программа работает в кодировке Windows. Можно в файлах исходного
текста использовать текстовые строки в кодировке Windows, которые затем будут успешно выводиться пра-
вильно на консоль.
  Недостатком данного подхода является то, что перекодировке подлежат только символы кириллицы, лю-
бые другие символы второй половины кодовой таблицы сохраняются на выходе как есть.
  В идеале Рефал должен использовать внутри себя Unicode.


[12.02.2008 - 20:14:38,84]

  [TODO: Подготовить совместимый с АТД синтаксис]
  Это значит, что необходимо подготовить синтаксис, совместимый с Модульным Рефалом версии 0.2+.
Т.е. надо подготовить директиву типа $DATA (см. ATD Support.txt) для обозначения имени абстрактного
типа данных. Квадратные скобки язык поддерживает.
  Просто я хочу заменить текущую стабильную версию (0.1.356) на более новую, в которой и приступить
к разработке АТД и прочей лабуды.

  [TODO: Продумать упрощение структуры Lexer'а и Parser'а]
  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).


[13.02.2008 - 22:59:00,41]

  [CHANGED: Создана утилита для обновления номера версии]
  Утилита называется VersionUpdater. Синтаксис вызова:
  refgo VersionUpdater /verfile:файл_с_номером_версии /srcfile:исходный_текст
  Параметр /srcfile может повторяться. Файл /verfile представляет собой файл того же формата, что
и Info/Version.txt. При запуске утилита считывает номер версии, инкрементирует его и записывает в
файлы, указанные в параметрах /srcfile. В исходном файле должны присутствовать специальные метки
  //{{GEN:VERSION
  //}}GEN
между которыми будет вставлен текст VerNumber = '1.2.3';, окружённый пустыми строками. Вместо 1.2.3
в файле находится инкрементированный номер версии. Если в файле имеется несколько вхождений пар ме-
ток, то текст будет вставлен несколько раз. Если в файле имеется неправильная метка (после GEN: нахо-
дится не VERSION) или будет лишняя //}}GEN без соответствующей открывающей метки, то будет выдано
сообщение об ошибке и файл изменён не будет. Генерируемый текст вставляется между этими двумя мет-
ками, предыдущий текст между ними удаляется. Если в файле отсутствует закрывающая метка //}}GEN, то
она подразумевается перед меткой //{{GEN:* или перед концом файла и при обновлении файла будет до-
бавлена.
  Всем утилитам был в начале присвоен номер компиляции 64 (от балды) и номер версии 0.1 (так же,
как и Модульному Рефалу).

[13.02.2008 - 23:17:52,92]

  [DONE: Номер версии независимо от компиляции]
  [DONE: Вывод номера версии компилятора]
  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


[17.02.2008 - 12:32:34,15]

  [FIXED: Ошибка с FnPtr]
  Возникала ошибка при работе с FnPtr: если пользователь определял собственную функцию FnPtr, то в
объектный файл заносятся два определения -- сначала пользовательская, потом сгенерированная. Счастье,
что линковщик линковал функции в прямом порядке и вторую таким образом игнорировал. А то при измене-
нии линковки и прочих изменениях могли бы возникать глюки. Правда, исправил криво: работоспособно, но
эстетически некрасиво. В любом случае надо переписывать Resolver и создавать атрибутную таблицу сим-
волов.


[21.02.2008 - 15:23:05,30]

  [DONE: Подготовить совместимый с АТД синтаксис]
  Для объявления абстрактных типов данных используются директивы $DATA и $data, синтаксис тот же,
что и при объявлении статических ящиков. Действие директивы состоит в том, имя АТД резервируется в
таблице символов, а значит не может использоваться при объявлении функций, swap-ов и в именах моду-
лей. Т.к. синтаксис подготовлен и, хочется в это верить, программа работает довольно стабильно, то
можно заменить старую стабильную версию на новую. Вероятно, также имеет смысл заменить расширение
выходных файлов, например, снова на .rout.


[21.02.2008 - 15:51:11,21]

  [DONE: Расширения .rout2 -> .rout]
  [CHANGED: Новая стабильная версия!]
  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.

  [TODO: Вынести из компилятора метаданные]
  Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
  Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.


[21.02.2008 - 18:29:09,77]

  [TODO: Атрибутная таблица символов]
  Подробности в файле AttSymTable.txt


[23.02.2008 - 18:50:39,32]

  [DONE: Атрибутная таблица символов]
  Атрибутная таблица символов реализована, правда не в полном соответствии со спецификацией.
  Реализованы:
  (+) Добавление имени в таблицу символов. В случае, если такое имя уже присутствует, таблица сим-
волов изменяться не должна.
  (+) Получение заданного атрибута заданного имени. Возвращаемое значение должно предусматривать
возможность сообщить об отсутствии этого имени.
  (+) Получение списка всех имён в таблице.
  (+) Установка (обновление) значения заданного атрибута заданного имени. При отсутствии имени
оно должно создаваться с набором атрибутов по умолчанию (возможно, пустым).
  (+) Удаление имени из таблицы. Вопрос о том, что делать при отсутствии имени решится в процессе
кодирования.
  (+) На начальном этапе таблица символов должна предоставлять интерфейс старой таблицы символов.

  (?) Получение списка имён с заданным значением заданного атрибута.*
  Можно получить список имён, имеющих определённое значение атрибута Kind. Атрибут Kind определяет
сорт имени: имя модуля, функция, импорт или АТД, и за каждым сортом закреплён строго определённый
набор атрибутов.

  (-) Получение списка атрибутов, связанных с данным именем. Возвращаемое значение должно предус-
матривать возможность сообщить об отсутствии этого имени.
  Будет добавлено позже.
  (-) Удаление атрибута заданного имени из таблицы. Предусловие: имя должно присутствовать в таб-
лице.
  Будет добавлено позже.
  (-) Проверка существования заданного имени.*
  Вместо этого используется проверка существования атрибута Kind.
  (-) Получение списка имён с заданным атрибутом.*
  (-) Удаление заданного атрибута у всех имён.*
  Будет реализовано позже.

  Функции для работы с таблицей символов делятся на базовые -- реализующие сам АТД, производные,
дополняющие базовые для типичных операций (установка нескольких атрибутов, добавление нового имени
в таблицу, при этом имя в таблице должно отсутствовать, поиск имён по сорту) и специальные, оставлен-
ные в наследство предыдущей таблицей символов. Последний класс функций нужно постепенно удалять из
таблицы, сменяя их на базовые и производные. Уже таким образом устранена функция AddImportModule Так-
же, в процессе работы над проектом, будут добавляться те функции таблицы символов, которые "Будут
реализованы позже".

  [FIXED: Синтакс переименования модулей]
  При обработке консткукции переименования модулей, написанной первоначально, обнаружена ошибка,
позволяющая компилятору принять такие неверные конструкции, как $IMPORT A = B = C;. Когда синтакси-
ческий анализатор писался в первый раз, не планировалось реализовывать переименование модулей в бли-
жайшее время и код был написан небрежно. Теперь эта ошибка исправлена. При обработке конструкции
переименования модуля в атрибут Alias имени импорта (ImportName) добавляется имя псевдонима модуля,
если модуль импортируется без псевдонима, то в Alias добавляется действительное имя.


[23.02.2008 - 19:20:11,82]

  [TODO: Вынести проверку соответствия имени модуля имени файла из MSymTable]
  Эта проверка происходит в модуле таблицы символов, что значительно усложняет модуль и реализова-
но неестественно (добавляется символ FsName как имя и ему назначается атрибут LowerName, затем эта
запись удаляется). Проще будет организовать эту проверку вне таблицы символов.

  [TODO: Реорганизация таблицы символов]
  Модуль таблицы символов выполняет две мало связанные функции -- реализует АТД и выполняет конт-
роль ошибок. Все функции, использующие t.ErrorList, коих немного, желательно вынести из модуля. Одна
из них (AddCurrentModule) вынесется автоматически при выполнении предыдущего TODO. Остальные две
также вынести не сложно.


[23.02.2008 - 21:33:32,54]

  [TODO: Перевести Parser на квалифицированные имена]
  Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.



[24.02.2008 - 23:49:32,95]
  [CHANGED: Реорганизован каталог документации]
  Теперь в папке Documentation появились свои каталоги для журнала и спецификаций. В каталог специ-
фикаций я складываю все TODO, вынесенные в отдельные файлы по причине своего размера (про модульную
концепцию, абстрактные типы данных и атрибутную таблицу символов).

  [TODO: Обдумать замену FnPtr на что-то другое]
  См. файл "Замена FnPtr на что-то другое.txt" (в каталоге спецификаций).
  Когда обдумаю, сделаю DONE для этого TODO и добавлю новое TODO: замена FnPtr на ... .


[28.02.2008 -  0:40:56,27]

  [DONE: Вынести проверку соответствия имени модуля имени файла из MSymTable]
  Просто вынес. Теперь эта проверка в MParser. Надо ещё вынести добавление новой сущности и, самое
главное, сравнение имён модуля в начале и конце файла. TODO "Реорганизация таблицы символов" как раз
этому посвящено.


[08.03.2008 - 20:17:27,04]

  [TODO: Промежуточное представление модуля]
  Атрибутная таблица символов (которая, по сути, лишь двухуровневый ассоциативный массив) -- сама
по себе очень гибкий инструмент: имя может иметь любой набор атрибутов, набор допустимых атрибутов
описывается в файле Attributes.txt, компилятором никак не проверяется. В дальнейшей работе можно про-
сто утонуть во всей этой гибкости. Поэтому нужна оболочка вокруг этой таблицы символов, которая конт-
ролировала бы доступ.


[08.03.2008 - 20:57:45,78]

  [DONE: Реорганизация таблицы символов]
  Теперь контроль ошибок действий с таблицей символов осуществляется без списка ошибок из MError.
Контроль добавления имени в таблицу символов осуществляется функцией AddNewName, которая помимо таб-
лицы символов возвращает Success или Fails. Добавление ошибки в t.ErrorList осуществляется в модуле
MParser.
  Однако, я всё ещё в стороне от цели. Модуль MParser должен работать не напрямую с таблицей симво-
лов, а с промежуточным представлением модуля. Т.е. нужно создать дополнительный уровень абстракции.


[08.03.2008 - 23:59:52,21]

  [TODO: Особым образом обрабатывать <FnPtr>]
  Проблема FnPtr всё ещё актуальна. Пока я нового синтаксиса для указателей на функции не придумал,
хотя в промежуточном представлении они успешно существуют. Временное решение проблемы состоит в том,
чтобы вызовы <FnPtr ИДЕНТИФИКАТОР*> обрабатывать не как вызов функции, а особым образом -- сразу за-
менять их на указатель в промежуточном представлении.


[19.03.2008 - 23:24:46,88]

  [DONE: Особым образом обрабатывать <FnPtr>]
  Казалось бы, за что боролся, на то и напоролся. Раньше функция FnPtr была автоматически генериру-
емой, то теперь она встроенная. При чём, эту функцию пользователь не может переопределить: если поль-
зователь объявит собственную функцию FnPtr, то она просто не будет вызвана. Вызов <FnPtr ИДЕНТИФИКА-
ТОР* > распознаётся на уровне синтаксического анализа (parser'ом).
  Относительно нового синтаксиса для указателей на функции я склоняюсь к следующему: вводится ква-
лификация точкой, указатель описывается так:
  FuncPointer = "&" IDENTIFIER | ["&"] NonEmptyDotQualifier .
  NonEmptyDotQualifier = IDENTIFIER "." IDENTIFIER | NonEmptyDotQualifier "." IDENTIFIER .
  Т.е. указатель на функцию состоит из "&" и следующим за ним квалифицированным точкой именем. Если
в квалификаторе более, чем два сегмента (т.е. есть хотя бы одна точка). Синтаксически это выражается
нетерминалом -- непустым квалификатором (см. выше). В приципе, можно использовать квалификацию точкой
и в вызовах функций -- ведь по смыслу вызов известным указателем это ведь непосредственный вызов фун-
кции. Но надо подумать, обождать. Хотя додумать надо до того, как я буду вводить в компилятор неско-
лько front- и back-end'ов.
  Кстати, текущая версия компилятора 888.


[19.03.2008 - 23:38:04,78]

  [TODO: Научить Resolver проверять образцовое выражение]
  [TODO: Несуррогатно реализовать АТД]
  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.


[20.03.2008 -  0:08:54,21]

  [TODO: Отучить Resolver от старого представления модуля]
  Модуль MResolver сначала преобразовывает таблицу символов в модуль в старом формате, его проверя-
ет и снова модуль превращает в таблицу символов. Решить этот вопрос. Можно решать этот вопрос в то же
время, когда и буду учить Resolver проверять образцовое выражение. Хотя, вероятно, Resolver придётся
приучать к промежуточному представлению модуля в виде АТД.
  При этом автоматически мы избавимся от MSymTable-Module.


[20.03.2008 - 23:03:24,42]

  [DONE: Научить Resolver проверять образцовое выражение]
  [DONE: Несуррогатно реализовать АТД]
  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


[22.03.2008 - 21:17:30,11]

  [ERROR: В таблице символов ошибка -- имя может оказаться без сорта]
  Если выполнить команду <MSymTable::RemoveAttrib t.SymTable e.Name Kind>, то в таблице символов
имя вообще окажется без атрибута.


[23.03.2008 - 14:22:12,04]

  [FIXED: Исправлена ошибка в Parser]
  Если при обработке тела модуля функцией MParser::NModuleBody встречался конец файла, функция воз-
вращала результат неправильного формата: t.ErrorList t.SymTable Error, хотя по завершению рекурсив-
ного анализа синтаксиса, должно возвращаться t.ErrorList t.SymTable. Происходила, в общем ошибка.
  Похожая ошибка была и в MParser::MSymModuleBody. Но в этом случае компилятор просто бы завис.


[23.03.2008 - 20:27:33,79]

  [FIXED: В таблице символов ошибка -- имя может оказаться без сорта]
  Ошибка исправлена. В функцию MSymTable::RemoveAttrib просто добавлен частный случай.


[29.03.2008 - 19:33:03,08]

  [DONE: Отучить Resolver от старого представления модуля]
  Теперь Resolver пользуется только таблицей символов. Хотя модуль, инкапсулирующий промежуточное
представление модуля MIModule, написан, он ещё в проекте не используется. Т.е. надо интегрировать.

  [CHANGED: Удалён модуль MSymInfo]
  Предполагалось, что модуль MSymInfo будет предоставлять АТД для представления символической ин-
формации. Однако, этот модуль никак не развивался. В качестве промежуточного представления символи-
ческой информации можно использовать структуру IModule, удалив при этом из неё тела функций и инфор-
мацию об не-entry-функциях.
  Потом, когда я переведу компилятор целиком на IModule, я удалю TODO: SymInfo как АТД.

  [TODO: Интегрировать IModule]
  Необходимо интегрировать структуру данных IModule в компилятор, т.е. заменить SymTable на неё
там, где надо.

  [TODO: Создать "диспетчеры" back-end'ов и front-end'ов]
  Создать модули, хранящие списки зарегистрированных входных и выходных частей. При этом диспетчеры
должны сообщать о зарегистрированных расширениях, папках, в которых следует искать, должны осуществ-
лять вызов анализаторов и генераторов кода.

  [TODO: Создать модуль для оценки необходимости перекомпиляции]
  Т.е. создать модуль, основная функция которого получает имя модуля, ищет входные и выходные файлы
модуля, считывает sym-файл и проверяет необходимость в перекомпиляции рекурсивно. Возвращает функция
сведения о небходимости перекомпиляции или сообщение об ошибке. При этом собственно перекомпиляцию
этот модуль осуществлять не должен.


[30.03.2008 - 22:57:12,84]

  [DONE: Интегрировать IModule]
  [DONE: Промежуточное представление модуля]
  [DONE: Промежуточное представление как АТД]
  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


[13.04.2008 -  2:04:35,41]

  [CHANGED: Изменена реализация контекста]
  [TODO: Перейти от модуля Context к модулю MContext]
  [TODO: Искать имя программы другим способом]
  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.


[13.04.2008 - 21:06:47,07]

  [ERROR: Ошибка в FnPtr]
  Реализация этой злополучной функции явила новый сюрприз. Если в качестве параметра указать вместо
имени функции имя АТД, то будет получен "указатель" на этот АТД, т.е. результат будет ошибочным. Нуж-
но на стадии компиляции проверять то, что аргумент FnPtr должен быть не только реально существующей
сущностью, но и должен быть именем функции.

  [TODO: Ввести особый тип компоновки для особых функций]
  Было бы красиво, на мой взгляд, для функций Init и Final обычных модулей и функции Go головного
модуля иметь специальный тип компоновки.


[13.04.2008 - 22:05:09,47]

  [TODO: Синтаксис для указателей на функции]
  Диспетчеры предполагают регистрацию callback'ов. Для более красивой реализации этого лучше испо-
льзовать вместо FnPtr специальный синтаскис указателей. О том, какой синтаксис надо использовать,
я уже писал в DONE: Особым образом обрабатывать <FnPtr> от 19.03.2008. Тогда я хотел обождать, но
ждать уже хватит. Надо делать. Синтаксис.

  QualifiedName =
    IDENTIFIER | QuadQualified | DotQualified .
  QuadQualified =
    IDENTIFIER '::' IDENTIFIER | QuadQualified '::' IDENTIFIER .
  DotQualified =
    IDENTIFIER '.' IDENTIFIER | DotQualified '.' IDENTIFIER .
  FnPtr =
    '&' IDENTIFIER | ['&'] DotQualified .
  Callable =
    QualifiedName | FnPtr | S-VARIABLE .

  FnPtr может быть как результатным, так и образцовым термом.
  
  Таким образом, квалифицированное имя -- это или квалифицированное квадратиком '::' или квалифици-
рованное точкой имя. Или просто идентификатор. Там где был раньше допустим только квадратик, теперь
допустима и точка. В качестве вызываемой сущности может быть использован и указатель на функцию,
что вполне логично. Такой вызов семантически ничем не должен отличаться от обычного вызова.

  [TODO: Пересмотреть Parser]
  Необходимо разобраться с функциями, реализующими нетерминалы: унифицировать их интерфейс. Разоб-
раться, что должно быть в момент вызова нетерминалов на стеке и что должно оставаться на стеке после
их выполнения. Результат унификации должен быть закомментирован в шапке модуля.


[18.04.2008 - 22:57:27,21]

  [DONE: Исключение промежуточного представления модуля]
  Это TODO я давно выполнил, когда реализовал IModule. Промежуточного представления в старом смысле
в программе нет. Просто по ошибке я забыл удалить это TODO. Вот так, не меняя ни строчки кода, я уст-
ранил одно TODO.

  [TODO: Изменить обработку командной строки]
  Сейчас (в текущей версии 0.1.904) модули/файлы в командной строке мыслятся как модули/файлы, вхо-
дящие в проект. "Лишние" файлы, которые компилируются и прилинковываются, могут иметь свои функции
инициализации, что позволяет осуществить гамак. Сие не есть хорошо. Надо изменить смысл командной
строки следующим образом.
  (1) Если некоторый аргумент командной строки является головным модулем, то он рекурсивно компи-
лируется и линкуется в .exe-шник. Если аргумент явяляется обычным модулем, то он рекурсивно компили-
руется, но не линкуется.
  (2) В командной строке можно указать несколько имён файлов/модулей. Каждый из них обрабатывается
согласно пункту (1). Таким образом, можно одновременно компилировать и собирать несколько проектов
одновременно. Если эти проекты имеют общие модули, то общее время компиляции должно снизиться.
  (3) Если расширение файла не указано, то поиск модуля выполняется по всем доступным front-end'ам.
Если расширение указано, то компиляция осуществляется указанным front-end'ом.
  (4) В командной строке могут быть опции, позволяющие выбрать необходимые back-end'ы.

  [TODO: Примерное описание работы диспетчеров back- и front-end'ов]
  Это TODO я удалю, когда дам точные спецификации для работы этих диспетчеров. Или когда эти диспет-
черы я реализую.
  Back-end manager должен позволять зарегистрировать в себе конкретные генераторы выходного кода.
Генератор характеризуется функцией для генерации файла из IModule, расширением выходного объектного
файла, расширением исполнимого файла, папкой для выходных файлов и др. Также может предоставлять фун-
кцию, создающую имя файла из квалифицированного имени.
  Front-end manager должен позволять также регистрировать front-end'ы. Front-end должен предостав-
лять расширение исходного текста, (возможно) имя папки, функцию для парсинга.
  Модуль компиляции и модуль проверки необходимости компиляции ничего не знают о конкретных front-
и back-end'ах, просто пользуются диспетчерами. Модуль компиляции посылает диспетчеру сообщение "гене-
рировать" и тот генерирует.



[23.04.2008 - 20:49:40,97]

  [ERROR: Возможна ошибка при чтении папок]
  Команду dir можно заместить, добавив в текущую папку/в один из каталогов PATH файл с именем, нап-
ример dir.exe. Такая ситуация может возникнуть, если на комп установлен cygwin (команда dir имитирует
команду ls системы Linux) -- сам видел. А это значит, что программы становятся непереносимыми.
  Решить проблему можно, если разработать отдельную программу с некоторым редким именем типа
mr_extent.exe, которая может в том числе выводить и листинг папки в более удобном для распознавания
формате. Эта же программа может возвращать значения переменных среды, конвертировать бинарные файлы
в текстовые специального формата и наоборот (чтобы имитировать работу с бинарными файлами). Для под-
держки этой программы можно создать отдельный стандартный модуль, который в момент инициализации про-
веряет наличие программы и корректность её версии.
  Примерный внешний вид програмы.
    > mr_extent.exe VERSION
  MRefal Extensions version 0.1.123
  или (в виде XXIO)
  MR_extent#0 #1 #123
  > mr_extent.exe LIST DirName
  file1.ext
  file2.txt
  dir3
  или
  (file1.ext)(file2.exe)(dir3)
  > mr_extent.exe INFO file1.ext
  #2048 #2008 #5 #9 #23 #59 #59 file1.ext
  Размер,  дата, время, имя
  > mr_extent.exe INFO dir3
  D#2008 #5 #9 #23 #59 #59 dir3
  > mr_extent.exe INFO file3.lst
  N
для папок может возвращаться вместо размера буква D, для несуществующих файлов N.
  Это ERROR я удалю, когда реализую эту программку.

  [DONE: Обдумать замену FnPtr на что-то другое]
  Замену я обдумал ещё 13.04.2008 -- синтаксис и семантика для указателей на функции. Просто опять
по ошибке забыл удалить TODO.
  Первое время front- и back-end диспетчеры будут регистрироваться при помощи FnPtr, т.к. необходи-
мо обеспечить совместимость с текущей стабильной версией.

  [ERROR: Ошибка при разрешении имени функции]
  Ранее была найдена ошибка в функции FnPtr. Оказывается ошибка не только в ней. Ошибка возникает
при разрешении любого вызова функции и при разрешении любого описания АТД. Имена функций и АТД разре-
шаются и затем компилируются абсолютно одинаковым образом: заменяется неквалифицированное имя на ква-
лифицированное с известной областью видимости. Причём место замены никак не контролируется: может
быть "правильно" разрешена функция после квадратной или АТД после угловой скобки.
  Слава богу, что синтаксис не позволяет записывать после квадратной скобки квалифицированное имя.
А то можно было бы делать "экспортируемые АТД", используя имя entry-функции после квадратной скобки.
  Кстати, эта ошибка нарушала один из негласных принципов компилятора: генерируемый код на входе
Рефал-5 должен быть абсолютно безошибочным или не генерироваться вообще. А так можно было сгенериро-
вать "вызов АТД" после угловой скобки. Рефал-5 в таких случаях справедливо ругается на необъявленную
функцию.
  Это ERROR я удалю тогда, когда исправлю ошибку. Вместе с ним я удалю упомянутое ERROR про FnPtr.


[23.04.2008 - 22:49:01,30]

  [FIXED: Ошибка при разрешении имени функции]
  [FIXED: Ошибка в FnPtr]
  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.

  [TODO: При компоновке заменять самые примитивные функции на функции Рефала-5]
  Т.е. идея в том, что нужно будет заменять вызовы функций типа MRefalRTS::Card сразу на <Card...>.
Причём это можно реализовать так, что в линковщик явно не будут встраиваться эти функции. Примитивные
функции будут описаны как псевдоними в файле MRefalRTS особыми директивами линковщика. Можно, напри-
мер, ввести тег 'p ' с таким синтаксисом
  p Entry::MRefalRTS::Prout Prout
или
  b Entry::MRefalRTS::Prout
  p Prout.
  В этом случае в таблицу MLinkerAliasTable вместо сгенерированного псевдонима вида X123 будет до-
бавлен псевдоним Prout.
  Способ этот ортогонален компилятору, т.к. позволяет легко изменять набор встроенных функций не
меняя ни строчки кода самого компилятора. Файл MRefalRTS всё равно пишется вручную.


[24.04.2008 -  0:14:07,31]

  [DONE: Доделать механизм переименования модулей]
  Давно у меня это TODO висело. Аж с 29.09.2007. Наконец то сделал. Теперь работает. Как только
я сделаю новый синтаксис для указателей на функции, я заменю стабильную версию и начну активно ис-
пользовать короткие псевдонимы для модулей.


[01.06.2008 -  1:58:55,72]

  [DONE: Создать "диспетчеры" back-end'ов и front-end'ов]
  [DONE: Примерное описание работы диспетчеров back- и front-end'ов]
  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


[01.06.2008 -  2:32:18,92]

  [TODO: Добавить к BE-Mgr поддержку линковщика]
  Полная ортогональность не достигнута. Вперёд!


[08.06.2008 -  2:49:01,70]

  [ERROR: Ошибка при рекурсивном сканировании папок]
  При попытке использовать имя папки, возвращённое функцией MFileSystem::FilesInfo для рекурсивного
просмотра этой папки вылетает ошибка. Эту ошибку можно увидеть в папке Tests/DirSync.



[11.06.2008 - 22:03:06,42]

  [ERROR: Ошибка в MFileSystem::FilesInfo при работе с кириллицей]
  Выяснено: выскакивает ошибка при работе с кириллицей. Надо разбираться.


[11.06.2008 - 22:26:35,36]

  [FIXED: Ошибка при рекурсивном сканировании папок]
  [FIXED: Ошибка в MFileSystem::FilesInfo при работе с кириллицей]
  [ERROR: Ошибка в именах файлов с пробелами]
  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


[12.06.2008 -  1:32:20,20]

  [FIXED: Ошибка в именах файлов с пробелами]
  Исправил. Вроде работает.


[13.06.2008 - 15:12:23,27]

  [CHANGED: Создан файл спецификаций "Поиск исходников.txt"]
  [TODO: Законспектировать спецификацию модели модулей]
  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.

  [DONE: Абстрактные типы данных]
  В сегодняшней версии (0.1.948) абстрактные типы данных по сути представляют собой надстройку над
идиомой АТД. И я считаю это вполне достаточным для версии 0.2. В дальнейших версиях, вероятно, будут
реализованы более сложные виды АТД: с некоторой внутренней структурой задаваемой образцом, с несколь-
кими конструкторами (как в Haskell). Также будут созданы ограничители на тип переменной, типа тех,
которые описаны в спецификации на АТД ("ATD support.txt"). Также будет возможность полного или час-
тичного экспорта АТД (т.к. если большая часть инварианта заключена в внутреннем формате АТД, то при
автоматической проверке формата инвариант будет сохраняться автоматически). Но это уже относится к
какой-нибудь версии 0.3 или больше. Сейчас надо сконцентрироваться на движке.

  [TODO: Модуль имитации функций высших порядков]
  Одно из совсем будущих изменений Модульного Рефала заключается во введении в него функций высших
порядков: возможность порождения (безымянных или с именем) локальных функций со связанными в них
локальными переменными, возврат этих функций (как возвращаемого значения) и т.д. Возможность передачи
объекта-функции (в виде указателя на функцию) внутрь функции и вызова этой функции есть уже сейчас
и реализована средстами FnPtr и <s.X ...>.
  Основными средствами, предоставляемыми этим модулем, должны быть функции Map и Reduce. У меня в
программе активно используются Map- и Reduce-подобные циклы (фактически, это можно рассматривать как
идиому). Но в некоторых случаях идиома скрывается под большим количеством строк, описывающих циклы.
(Интересно то, что здесь я, говоря о циклах, имел ввиду остаточную рекурсию. Циклов в Модульном Рефа-
ле нет. Я уже мыслю остаточную рекурсию в виде циклов). Использование явным образом функций Map и
Reduce сделает код более читабельным.
  Модуль я планирую назвать MLambda.mref. Если он докажет свою полезность, то станет библиотечным.
  Основные средства, предоставляемые модулем.

  Тип лямбда-функции:
    t.Lambda ::= s.FnPtr | [АТД, определённое внутри модуля]

  Вызов лямбда-фукции:
    <Apply t.Lambda e.Arg>
      == e.Result

  Создание лямбда-функции со связыванием слева:
  <BindLeft t.Lambda e.Left>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.Left e.ARG>;
  }

  Создание лямбда-функции со связыванием справа
  <BindRight t.Lambda e.Right>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.ARG e.Right>;
  }

  Функции семейства Map-Reduce
  <Map t.Lambda t.Src*>
    == e.Result*
  <Apply t.Lambda t.Src> == e.Result

  <Reduce t.Lambda t.Accum t.Src*>
    == t.Accum'
  <Apply t.Lambda t.Accum t.Src> == t.Accum'

  <MapReduce t.Lambda t.Accum t.Src*>
    == t.Accum' e.Result*
  <Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

  Функция MapReduce сочетает в себе действие функций Map и Reduce -- преобразует исходное выражение
в новое выражение вместе с передачей состояния. Для функций Reduce и MapReduce существуют парные им
фукнции Reduce-R и MapReduce-R, осуществляющие преобразование справа налево.
  Для АТД, представляющего собой лямбда-функцию, не предоставляется функция Destroy, т.к. объект
первого класса (которым и должен быть объект-функция) может беспрепятственно создаваться, копировать-
ся, возвращаться из функции и уничтожаться.

  [DONE: Добавить к BE-Mgr поддержку линковщика]
  Поддержка линковщика добавлена. Более того, теперь линковка выполняется также обобщённо, как и
генерация выходных файлов. Модуль mLinker.mref говорит диспетчеру "связывай" и диспетчер вызывает
функцию связывания для каждого из back-end'ов.


[13.06.2008 - 21:17:14,10]

  [DONE: Модуль имитации функций высших порядков]
  Модуль написан в точности с описанием. Модуль компилируется нормально, но не протестирован. Ни-
чего, оттестируется в процессе использования.


[14.06.2008 -  1:28:52,75]

  [DONE: Законспектировать спецификацию модели модулей]
  Законспектировал. Теперь TODO очень много. Даже не умещаются на одной странице. Модули, относя-
щиеся к поиску модулей, содержат префикс ПИ. Некоторые подчинённые модули не имеют того же префикса.

  [TODO: ПИ:Проверять корректность имени модуля/пакета]
  [TODO: Продумать максимальную длину имени модуля]
  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.

  [TODO: ПИ:Поддержка переменной MODULEPATH с проверкой корректности]
  Надо осуществлять проверку того, что никакой каталог в переменной MODULEPATH не является подка-
талогом другого MP-каталога. А также проверять существование данного каталога.

  [TODO: Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов]
  Необходимо добавить следующие функции:
  (*) Функция, которая склеивает имя папки с относительным именем.
  (*) Функция, которая унифицирует имя папки -- т.к. в Windows одни и те же пути к файлам могут
выглядеть по-разному (прямой и обратный слеш, регистр символов).
  (*) Функция, возвращающая абсолютное имя для относительного. Такая функция может проверять также
наличие данного файла/папки. А может и не проверять.

  [TODO: ПИ:Полная поддержка parser'ом квалифицированных имён]
  Одно из требований гласит:  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно
быть указано в файле исходного текста (синтаксис файла исходного текста должен позволять это делать)
и в файлах с информацией о межмодульных связях (структура хотя бы одного из этих файлов должна поз-
волять это делать).
  Таким образом, синтаксис файлов исходного текста (распознаётся в mParser.mref) и структура (она
же синтаксис) файлов символической информации (распознаётся там же) должна полностью поддерживать
квалифицированные имена.

  [TODO: ПИ:Хранить в контексте также информацию о пакетах]
  В контексте хранить информацию также и о модулях. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.

  [TODO: ПИ:Написать функцию для поиска модулей]
  Поиск модулей должен осуществляться в соответствии со спецификацией. Здесь дословно её цитировать
не буду, а просто сошлюсь на файл "Поиск исходников.txt".

  [TODO: ПИ:Написать средства для оценки необходимости перекомпиляции]
  Написать функцию для оценки необходимости перекомпиляции в соответствии со следующими требовани-
ями (дословно из спецификации):
  Компилятор может предоставлять режим "быстрой перекомпиляции", в котором некоторые компилируемые
модули могут исключаться из процесса компиляции при одновременном выполнении следующих условий:
  (*) Для данного модуля присутствуют ВСЕ выходные файлы.
  (*) Выходные файлы созданы/обновлены позже исходного файла данного модуля.
  (*) Модули, от которых зависит данный модуль, либо библиотечные, либо были исключены из процесса
компилирования, хотя были компилируемыми.
  (*) Исходные тексты компилируемых модули, от которых зависит данный модуль, созданы/обновлены
раньше, чем данный модуль.
  (*) Выходные файлы библиотечных модулей, от которых зависит даннный модуль, созданы/обновлены
раньше, чем данный модуль.
  Этот набор эвристических условий позволяет с высокой вероятностью гарантировать непротиворечи-
вость проекта.
  Если всё равно есть сомнения, то рекомендуется включать режим для полной перекомпиляции.

  [TODO: ПИ:Режимы "только связывание" и "полной перекомпиляции"]
  Должна быть возможность выбора режима перекомпиляции (на начальном этапе -- опцией командной
строки): make (быстрая перекомпиляция), build (полная перекомпиляция), linkonly (только связывание).

  [TODO: ПИ:Обработка командной строки]
  Для модулей, перечисленных в командной строке, обработку выполнять в соответствии со специфика-
цией (см. "Поиск исходников.txt").


[20.06.2008 - 20:59:14,30]

  Сейчас я постепенно ввожу синтаксис указателей на функции. Уже ввёл <A::B::C::D> <A.B.C.D> и
& A и & A.B. Задумываюсь о том, чтобы ввести новую стабильную версию. Появилось несколько новых мыс-
лей. Ниже они оформлены в виде TODO.
  Теперь TODO станет ещё больше.

  [TODO: Новая стабильная версия]
  Введение новой стабильной версии позволит сейчас (пока указатели на функции целиком не завладели
исходными текстами) уже избавиться от позорной псевдофункции FnPtr. Уже соответствующий синтаксис
готов. Для себя ставлю веху: когда будет готов следующий синтаксис:
  ... = <MLambda.Reduce Math.Add 0 e.NumList>;
т.е. квалифицированное имя посреди выражения интерпретируется как указатель на функцию, я заменю ста-
бильную версию.

  [TODO: Обдумать введение видов для квалифицированных имён]
  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.

  [TODO: Перевести IModule на квалифицированные имена]
  [TODO: Продумать детали перевода IModule на квалифицированные имена]
  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?

  [TODO: Расширить утилиту TODO_list]
  Для лучшей ориентации в недоделках надо научиться извлекать из журнала не только заголовки невы-
полненных TODO, но и сами описания TODO. Т.е. помимо краткого списка выводить подробный, в котором
будут выводиться сами тексты TODO. А также список выполненных TODO, в котором приводится сводка всех
выполненных TODO, причём описания TODO и DONE должны располагаться рядом.


[20.06.2008 - 23:12:35,60]

  [TODO: Переворошить Parser -- форматы функций]
  Кратко. Надо поменять формат всех функций на
  <NFn
    [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  >
    == [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  В квадратных скобках показаны необязательные элементы.
  Мотивация. Параметр t.IModule присутствует во всех функциях-нетерминалах, но используется он
только в нетерминалах верхнего уровня. Аналогично в случае t.VarTable, которая тоже не везде исполь-
зуется. Однако, все функции принимают t.ErrorList t.Lexer и t.NextToken. Вышеназванные балластные
элементы находятся между t.ErrorList и t.Lexer, поэтому приходится балластные элементы передавать.
  Дело не в тех иллюзорных тактах процессора, требуемых на распознавание этих элементов, а в том,
что (а) удлиняется код -- на экране элементарно влезает меньше, (б) усложняется код -- необходимо
следить за правильной передачей тех данных, которые не используются.
  Проблема явила свою гадкую личину после того, как я написал универсальные функции для распозна-
вания квалифицированных имён. Формат этих функций не был приспособлен для работы с форматом, содер-
жащим таблицу локальных переменных. Поэтому для использования внутри выражений приходилось (не)ес-
тественным образом таблицу локальных переменных прятать в стек.
  Ожидаемые результаты. Новый формат позволит не передавать во внутренние функции балластные аргу-
менты. Например, если функция NFn1 принимает t.IModule, а функция NFn2 его не принимает, то можно
записать:
  t.IModule e.Stack t.ErrorList t.Lexer t.NextToken =
    <NFn1
      t.IModule
      e.ParentStack
      <NFn2
        e.LocalStack
        t.ErrorList t.Lexer t.NextToken
      >
    >
вместо
  t.ErrorList t.IModule (e.Stack) t.Lexer t.NextToken =
    <NFn1
      <NFn2
        t.ErrorList t.IModule
        (e.LocalStack (e.ParentStack))
        t.Lexer t.NextToken
      >
    >
  Вторым преимуществом является упрощение соглашения о вызовах функций. Стек в данном случае рас-
тёт справа, поэтому можно принять соглашение о том, что функция, распознающая нетерминал всегда нахо-
дится на вершине стека. Родительский стек автоматически конкатенируется с дочерним.


[23.06.2008 - 21:36:49,43]
  Сейчас список TODO полегчает немного.
  Все нижеперечисленные TODO выполнены.

  [DONE: Продумать квалификацию точкой]
  Забавно то, что в комментарии к этому TODO я планировал решить этот вопрос только после выхода
версии 0.2. Уже давно продумано и даже реализовано. О том, как это было реализовано, написано в DONE
к Синтаксис указателей на функции. Вполне неплохо получилось.

  [DONE: Синтаксис для указателей на функции]
  Реализован в полном соответствии с TODO. Однако, нетерминал FnPtr распознаётся не отдельной цели-
ковой функцией, а по кусочкам -- кусочки в распознавателях выражений NPatternExpr и NResultExpr (на-
чинается с обнаружения амперсенда или идентификатора) и в NCallable.
  Про вариант синтаксиса < & Module.Function ... > я сначала забыл (поэтому он не определяется ста-
бильной версией), а потом всё-таки вспомнил.

  [DONE: Пересмотреть Parser]
  Parser пересмотрел, переворошил, интерфейс нетерминалов частично унифицировал. Однако, стек для
распознавателей выражений я не переделывал, т.к. он пока и так выполняет свои обязанности и допускает
расширение. Привожу шапку из Parser'а (в дальнейшем она может измениться).

/*------------------------------------------------------------------------------
  Функции синтаксического анализа делятся на три категории:
  (1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
  После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
  (2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
  (3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

  Формат функций-распознавателей работает в соответствии с TODO Переворошить Parser -- форматы фун-
кций.

  [DONE: Новая стабильная версия]
  Стабильная версия написана. Стабильная версия поддерживает как указатели на функции в новом сти-
ле: с '&' и без '&' в случае явно написанного квалифицированного имени. Однако, как уже сказано выше,
стабильная версия не поддерживает синтаксис < & Module.Function ... >.
  Стабильная версия имеет номер версии 0.1.951.
  По сравнению с предыдущей стабильной версией, в этой стабильной версии полностью поддерживаются
АТД (разумеется, без спецификаций переменных, я их в версию 0.2 добавлять не планирую). Папка и рас-
ширение выходных файлов этой стабильной версии соответственно ROutS и .srout.

  [DONE: Переворошить Parser -- форматы функций]
  Форматы функций, распознающих нетерминалы, написаны в соответствии с TODO. Однако есть здесь два
варианта стека: тот, который описан в TODO, и оставшийся со старых времён стек в скобках для распоз-
навателей выражений.

  [TODO: Удалить поддержку FnPtr]
  Закономерное следствие введения синтаксиса указателей на функции и поддержки этого синтаксиса.
Стабильная версия поддерживает оба варианта получения FnPtr, поэтому можно вызовы FnPtr постепенно
удалить и заменить на нормальный человеческий синтаксис.


[23.06.2008 - 23:01:39,17]

  [DONE: Удалить поддержку FnPtr]
  Удалил из парсера поддержку FnPtr и парсер полегчал на 88 строк программного кода. Также заменил
все вызовы <FnPtr ... > в исходных кодах компилятора на конструкцию с амперсандом.


[05.07.2008 - 13:29:02,69]

  [TODO: Разбить Parser на модули]
  Кратко. Разбить модуль парсера на три модуля: mParser_Common.mref, mParser_Source.mref,
mParser_Sym.mref.
  Мотивация. Модуль MParser прямо или косвенно импортируется следующими модулями: MSymModule,
Compiler, MStartupSeqGenerator, MLinker_Refal5, MBackEnd_Refal5_init, MFrontEnd_MRefal. И при каждом
изменении парсера для всех этих модулей проходит каскадная перекомпиляция. Дело в том, что модуль
MParser выполняет две похожие задачи: анализ и распознавание файла исходного текста и файла символи-
ческой информации. Эти две задачи объединяет то, что код их реализации имеет очень много компонентов,
поэтому они реализуются в одном модуле.
  Поэтому надо разделить код из модуля MParser на три разных модуля: модуль для распознавания общих
нетерминалов, модули для распознавания исходного и символического файлов. В принципе, можно было бы
объединить модули с общими термами и распознавания символических файлов, т.к. для распознавания пос-
ледних нужно только две специализированные функции: тело модуля и объявление функции. Однако, это ре-
шение мне кажется непоследовательным, т.к. объединяются модули только по признаку объёма файла, а не
по смыслу.
  Вообще, решение об разделении одного модуля на три мне кажется больше техническим, нежели концеп-
туальным. Ведь после разделения связь между модулем с общими средствами и модулями распознавания фай-
лов будет большой (определяется количеством используемых entry-функций). Но, с другой стороны, сейчас
модуль парсера является самым большим среди всех исходных файлов проекта (45594 байта). Поэтому для
удобства работы с ним его надо разбить на несколько маленьких.

  [TODO: Продумать введение тега "Продумать"]
  Очень много TODO в журнале проекта содержат в заголовке слова "продумать", "обдумать". Тег TODO
семантически предназначен для описания задач, которые в конце концов должны быть решены в виде исход-
ного кода. Тег ERROR предназначен для описания ошибок, требующих исправления. Однако, как уже было
сказано, теги TODO со словами в заголовке типа "продумать" предназначены не для описания тех задач,
которые следует закодировать, а для задач, для которых ещё надо найти форму для воплощения. Поэтому
имеет смысл ввести тег ПРОДУМАТЬ для тех задач, решение которых представляет собой проектное решение
или ответ на вопрос, а не написанный код. При чём если в результате обдумывания некоторой возможнос-
ти я приду к выводу, что реализовывать эту возможность совсем не нужно, я могу закрыть этот тег с
обоснованием ненужности. Тот же случай в теге TODO/DONE выглядит противоречиво: в теге "сделано" опи-
сывается то, что не сделано и не будет сделано никогда.
  Эту TODO легко реализовать в коде, но есть одно препятствие, которое надо преодолеть прежде, чем
закодировать. Это имена для указанных тегов. Вариант THINK/THINKED выглядит как-то не красиво.
  Другая мысль. Указанный тег можно было бы закрывать не только специальным закрывающим тегом, но и
тегом TODO, если в результате обдумывания появилось решение, которое можно воплотить в коде. Можно
ввести специально различные закрывающие теги для описания положительных и отрицательных резолюций по
поводу вносимых изменений, это позволит яснее определять те решения, которые в процессе работы были
отклонены.
  Возможно, не стоит ограничиваться только англоязычными тегами. Можно даже наоборот, для TODO/DONE
ERROR/FIXED CHANGED ввести синонимы СДЕЛАТЬ/ГОТОВО ОШИБКА/ИСПРАВЛЕНО ИЗМЕНЕНИЯ.
  В общем, надо продумать детали.


[05.07.2008 - 15:53:28,01]

  [DONE: Разбить Parser на модули]
  Теперь в проекте вместо модуля MParser имеются три модуля MParser_Common, MParser_MRefal,
MParser_Sym. В принципе, сделано всё в соответствии с TODO.


[05.07.2008 - 20:27:00,31]

  [DONE: Продумать детали перевода IModule на квалифицированные имена]
  [TODO: Додумать детали перевода IModule на квалифицированные имена]
  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.


[05.07.2008 - 23:58:33,14]

  [CHANGED: Отступ в два пробела]
  Недавно узнал, что у нас на кафедре при программировании на Си++ требуется делать отступы в два
пробела (при чём пробелами и ни в коем случае не табуляцией). Чтобы исследовать на себе этот стиль,
я установил в настройках Far'а табуляцию в два пробела, замена всех табуляций пробелом (заменяет при
сохранении файла), а также макрос Пробел-Backspace на кнопку табуляции. Привыкаю потихоньку.

  [TODO: Частично перевести IModule на квалифицированные имена]
  [TODO: Подготовиться к переходу на пакеты]
  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.


[06.07.2008 - 13:15:05,41]

  [ERROR: Конфликт имён между псевдонимом модуля и функцией]
  Если в файле исходного текста одновременно присутствуют функция и псевдоним модуля с одинаковым
именем, то компилятор умирает с ошибкой. А на самом деле должна выскакивать ошибка переопределения
имени. Причина ошибки в том, что IModule индексируется по полным именам импортируемых модулей, а не
по их псевдонимам. Надо это исправить.

  [TODO: Создать средство для поиска модулей, подлежащих линковке]
  Нужно создать средство, которое по заданному имени корневого модуля находит все модули, от которых
зависит данный модуль, при чём в топологическом порядке от зависимых к зависящим.


[07.07.2008 -  2:08:58,93]

  [ERROR: Плохо проверяется попытка переопределения]
  Внутри одного исходного файла можно определить две функции, два АТД, два импорта с одинаковым име-
нем, лишь бы их виды (Kinds) совпадали. Проверка на переопределение выполняется только для сущностей
разных видов.


[14.07.2008 - 20:42:05,95]

  [DONE: eXpression eXchange in/out]
  Написал модуль для средств обмена выражениями. Для XXIO формата принят следующий синтаксис:
  * Структурные скобки ( ) отображаются соответственно в '(' ')'.
  * Объектные скобки '(' ')' отображаются соответственно в '#(' '#)'
  * Символы табуляции и новой строки отображаются соответственно в '\t' и '\n'.
  * Символы с кодами от 33 до 127 отображаются как есть.
  * Остальные символы отображаются как '\dNNN', где NNN -- трёхзначный десятичный код символа.
  * Макроцифры отображаются в '#число ', где число -- десятичное представление числа.
  Если в исходном выражении были идентификаторы или АТД-термы, то функция сохранения MXXIO::Save
сохранения файла не выполняет, возвращает Fails.
  При обнаружении первой же ошибки во входном файле разбор файла прекращается, функция MXXIO::Load
возвращает Fails.
  При чтении файла не имеет значения разбиение исходного файла на строки, при записи файл разбива-
ется на строки длиной 63 символа.

  [CHANGED: Устранены MRefalRTS::Lenw и MRefalRTS::ExistFile-T]
  Из модуля поддержки времени выполнения удалены эти две функции, которые не используются в библио-
течных модулях. Когда-то я удалял Lenw, но, видимо или не до конца удалил. Или забыл всё-таки уда-
лить из самого MRefalRTS, или случайно когда-то потёр MRefalRTS и восстановил старую версию.


[22.09.2008 - 23:27:35,87]

  После долгого перерыва несколько новых идей.

  [TODO: Продумать back-end C++]
  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.

  [TODO: Продумать генераторы лексического и синтаксического анализаторов]
  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.

  [TODO: Продумать двухуровневую структуру синтаксического анализа]
  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.

  [TODO: Продумать изменения в лексике и комментариях]
  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.


[23.09.2008 - 12:50:36,46]

  [TODO: Продумать блоки $INIT и $FINAL]
  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.



[15.10.2008 - 22:39:31,17]

  [CHANGED: ПИ: Расширения в нижнем регистре]
  Меняю спецификацию. Теперь расширения должны быть в нижнем регистре. Подробности в файле специфи-
кации "Поиск исходников.txt".
  Мотивация. Искать файлы с расширениями, различающимися регистром, неэффективно.


[17.10.2008 - 22:58:13,00]

  [CHANGED: ПИ: Конфликт между именами импортируемых модулей и модулей в командной строке]
  Проблема такая. В спецификации указано, что модули, перечисленные в командной строке, являются как
бы "головными". Если в командной строке указан головной модуль, который компилируется в отдельный
exe-шник, то он образует проект. Если же указан не головной модуль, то подлежит компиляции он и все
зависимые от него модули. В любом случае каждый модуль в командной строке образует "гроздь" из зави-
симых модулей. В принципе, эти "гроздья" могут частично пересекаться или даже вкладываться друг в
друга. Для всех гроздей имеется одинаковая переменная MODULEPATH, одинаковый набор back- и front-
end'ов. Поэтому можно предположить (а я так для этого молчаливо и полагал, не отражая свои мысли в
журнале или спецификациях) что модули, одновременно присутсвующие в нескольких "гроздьях", должны
быть обработаны только однократно и при обработке последующей "грозди" можно воспользоваться обрабо-
танными модулями из предыдущих "гроздей".
  Но тут возникает проблема. Правила поиска модулей по квалифицированному имени (когда ищется импор-
тируемый модуль) и правила поиска модулей, указанных в командной строке различаются. Поэтому если
модуль импортируется, то он может быть найден по одному пути, если же он указан в командной строке,
то имея то же квалифицированное имя, может находиться по другому пути. Пример.
  compile_mr /* разные опции, MODULEPATH=".;D:\MyLib;C:\MR" */ MainModule.mref C:\MR\SubModule.mref

  $PROGRAM MainModule;
  
  $IMPORT SubModule;

  /* прочий код */;

  $END MainModule.

  В данном случае, если SubModule находится в текущей папке или папке D:\MyLib, то как импортируемый
модуль он не будет обнаружен в папке C:\MR, но по правилам поиска модуля, указанного в командной
строке, будет SubModule должен быть найден в папке C:\MR (должен быть, иначе произойдёт ошибка ком-
пиляции "Модуль не найден"). Возникает конфликт.

  Решение проблемы. Предполагается следующее решение. Сначала производится поиск (только поиск без
компиляции или анализа) модулей, перечисленных в командной строке. Их местоположения запоминаются.
В дальнейшем производится последовательная компиляция этих модулей. Теперь, если где-либо в списке
импорта будет указан тот же модуль, что и тот, который указан в командной строке, будет использо-
ваться модуль, указаннный в командной строке. Т.е. для примера выше модулем MainModule.mref будет
импотирован модуль C:\MR\SubModule.mref.


[18.10.2008 - 21:53:30,07]

  [TODO: Разработать функцию поиска импортируемого модуля]
  [TODO: Разработать функцию поиска модуля из командной строки]
  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.


[18.10.2008 - 23:54:58,07]

  [FIXED: Конфликт имён между псевдонимом модуля и функцией]
  [FIXED: Плохо проверяется попытка переопределения]
  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.a


[08.11.2008 - 19:37:27,98]

  [TODO: Контекст индексируется по именам в нижнем регистре]
  Мотивация. Согласно спецификации модули и пакеты, находящиеся в одном проекте (в принципе, это
правило можно распространить и на весь набор проектов, компилируемых за раз), не могут иметь имена,
различающиеся лишь регистром. Однако, полное квалифицированное имя того модуля, который импортиру-
ется, должно быть известно точно: имя в директиве $IMPORT и имя импортируемого модуля в директивах
$MODULE и $END (как в исходных, так и в sym-файлах) должны совпадать с учётом регистра. Поэтому
имеет смысл индексировать контекст именами без учёта регистра (например, приведя все имена в верх-
ний или нижний регистр), но при этом в контексте хранить сведения о настоящем имени модуля (если
таковое известно -- модуль компилировался или читался его sym-файл).
  Цель. Индексировать контекст именами в нижнем регистре, при этом храня информацию о дествитель-
ном имени модуля (если таковая имеется). При попытке индексировать квалифицированным именем кон-
текст должно проверяться соответствие имени на входе настоящему имени, если таковое известно.
  /* И опять список заданий и ошибок не влезает на один экран :-). */


[09.11.2008 - 22:05:55,79]

  [CHANGED: Организация файлов спецификаций]
  Ранее я однажды редактировал спецификацию "Поиск исходников", старый текст при этом я "закомменти-
ровал", добавления и изменения я пометил "комментариями" (комментарии Си и Си++). Очевидно, что при
дальнейшей модификации спецификации, под навалом комментариев трудно будет почитать сам текст. Поэ-
тому я восстановил как предыдущий вариант, так и текущий, очистив их от комментариев и переименовав
их в соответственно "Поиск исходников.01.txt" и "Поиск исходников.02.txt". При дальнейшем развитии
спецификации я буду создавать файлы с номерами 03, 04 и так далее. Эволюцию спецификаций можно от-
следить программой fc.

  [DONE: Разработать функцию поиска импортируемого модуля]
  [DONE: Разработать функцию поиска модуля из командной строки]
  [DONE: ПИ:Написать функцию для поиска модулей]
  [DONE: ПИ:Обработка командной строки]
  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.

  [DONE: Контекст индексируется по именам в нижнем регистре]
  Указанная схема реализована, но только пока не используется: нигде в программе не устанавливается
атрибут RealName, поэтому теперь контекст индексируется только по неквалифицированным именам.


[11.11.2008 - 13:18:37.09]

  [DONE: Создать средство для поиска модулей, подлежащих линковке]
  Такое средство создано -- это функция MClusters::ListForLinking. По заданному корневому имени она
находит все зависимые имена и сортирует их в топологическом порядке. Формат функции
  <MClusters::ListForLinking t.hContext t.RootModule>
    == t.hContext Success e.Modules
    == t.hContext Fails
  Функция завершается неуспешно если хотя бы один из модулей в "грозди", растущей из t.RootModule
не был откомпилирован или обновлён, а также если среди модулей каким-то чудом оказались циклические
зависимости. Теперь можно удалить из контекста функции LastModule и GetProgName.


[18.11.2008 - 23:56:49,37]

  [DONE: Создать модуль для оценки необходимости перекомпиляции]
  [DONE: ПИ:Написать средства для оценки необходимости перекомпиляции]
  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


[25.11.2008 - 15:52:21,87]

  [ERROR: Не определяется обновлённость импортированного модуля]
  Согласно спецификации, перекомпиляция модуля должна осуществляться в случае, если исходные тексты
импортируемых модулей или выходные файлы импортируемых библиотек обновлены позже рассматриваемого
модуля. Для исходных текстов это правило не выполняется, для библиотек -- ещё не проверял. Надо ис-
править.

  [DONE: Механизм поиска модулей]
  [DONE: Использование нескольких front-end и back-end]
  [DONE: Модуль-программа]
  [DONE: SymInfo как АТД]