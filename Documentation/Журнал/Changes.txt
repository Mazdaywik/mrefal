[29.09.2007 - 20:25:52,85]

	Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
	Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
	Список приоритетных изменений:

	[TODO: Механизм поиска модулей]
	Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

	[TODO: Использование нескольких front-end и back-end]
	Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

	[TODO: Указатели на функции или функция Mu]
	... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
	Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

	Mu {
		F e.Arg = <F e.Arg>;
		G e.Arg = <G e.Arg>;
		H e.Arg = <H e.Arg>;
		Mod1 A e.Arg = <Mod1::A e.Arg>;
		Mod1 B e.Arg = <Mod1::B e.Arg>;
		Mod1 C e.Arg = <Mod1::C e.Arg>;
		Mod2 A e.Arg = <Mod2::A e.Arg>;
		Mod2 C e.Arg = <Mod2::C e.Arg>;
		Mod2 D e.Arg = <Mod2::D e.Arg>;
	}

	Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
	Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

	[TODO: Статические ящики]
	Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
	Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

	ModuleName::SomeHolder::Swap {
		e.NewValue =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.NewValue>;
	}

	Синтаксически можно использовать конструкцию, похожую на список импорта:

	$SWAP SomeHolder, OtherSomeHolder;

	Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

	[TODO: RASL и интерпретатор]
	Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

	[TODO: Резервное копирование]
	Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

	Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

	[DONE: Резервное копирование]
	Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

	Ещё вспомнил.

	[TODO: Элемент (Module e.ModuleName)]
	Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

	[TODO: Доделать механизм переименования модулей]
	Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

	[DONE: Элемент (Module e.ModuleName)]
	Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
	
	Было:

	t.Module ::=
		(t.SymTable t.ModuleContent)

	t.ModuleContent ::=
		( (ModuleName e.ModuleName)
			t.Element*
		)

	Стало:

	t.Module ::= (t.SymTable e.ModuleContent)

	e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

	[DONE: Статические ящики]
	Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
	Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
	Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

	[TODO: FileIO-дескрипторы в статическом ящике]
	Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.

	[TODO: Переименовать модуль Refal5]
	Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

	[DONE: FileIO-дескрипторы в статическом ящике]
	С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

	[TODO: Расширения .rout2 -> .rout]
	Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

	[TODO: Единица компоновки -- функция вместо модуля]
	На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

	[TODO: Новая семантика идентификатора]
	Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.


[06.10.2007 - 18:35:07,82]

	[CHANGED: Компиляция структурных скобок по-новому]
	Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.

	[TODO: Абстрактные типы данных]
	Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".


[07.10.2007 -  0:23:54,89]

	[DONE: Указатели на функции или функция Mu]
	Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождественны
идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова ука-
зателей таков (см. Syntax.txt).
	
	FunctionCall = '<' Callable ResultExpr '>' .
	Callable = FunctionName | Qualifier '::' FunctionName
		| SwapName | S-VARIABLE .

	Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
	Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

	Context::FnPtr::Local {
		Create =
			$Context::Create::Entry$ ;
		UpdateModuleInfo =
			$Context::UpdateModuleInfo::Entry$ ;

		// Часть пропущена

		AppendError =
			$Context::AppendError::Entry$ ;
		FnPtr =
			$Context::FnPtr::Local$ ;
		MModulesList UpdateModuleInfo =
			$MModulesList::UpdateModuleInfo::Entry$ ;
		MModulesList LastModule =
			$MModulesList::LastModule::Entry$ ;
		MModulesList ExtractOption =
			$MModulesList::ExtractOption::Entry$ ;
		MModulesList GetProgName =
			$MModulesList::GetProgName::Entry$ ;
		MModulesList ExtractModulesList =
			$MModulesList::ExtractModulesList::Entry$ ;
	}

	В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
	Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

	Test::IndirectCall::Local {
		s.Function =
			<Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
	}

	Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
	$MODULE Indirect;

	/*
		<ForAll s.FnPtr t.Term*>
			== e.Result*
		где e.Result = <s.FnPtr t.Term>
	*/
	$ENTRY ForAll {
		s.FnPtr t.Next e.Tail =
			<s.FnPtr t.Next>
			<ForAll s.FnPtr e.Tail>;

		s.FnPtr = ;
	}

	$END Indirect.

	Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

	$MODULE Convert;

	$IMPORT MStrings, Indirect;

	$ENTRY NumsToStrings
		e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

	ToStr s.Num = <MStrings::Symb s.Num> ' ';

	$END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
	Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


[12.10.2007 - 22:09:54,55]

	[CHANGED: Папка ROut2]
	По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.

	[DONE: Переименовать модуль Refal5]
	Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


[16.10.2007 - 21:50:54,61]

	[FIXED: MOS::Env корректно работает с кириллицей]
	Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.

	[TODO: Исправить зависимую от MOS::Env MOS::EnvList]
	Изменить соответствующим образом MOS::EnvList.


[16.10.2007 - 22:06:30,03]

	[DONE: Исправить зависимую от MOS::Env MOS::EnvList]
	Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.

	[CHANGED: Удалена ROut]
	Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


[19.10.2007 -  1:04:32,32]

	[TODO: eXpression eXchange in/out]
	В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).

	[ERROR: Ошибка в MFileSystem при работе с кириллицей]
	Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
	Возможные пути решения:
	(1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
	Преимущества. Подход обобщается на использования других команд консоли Windows.
	Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
	(2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
	Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
	Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

	Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

	Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
	Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.

	[CHANGED: MFileSystem стал библиотечным]
	Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


[20.10.2007 - 16:06:51,06]

	[TODO: Автоматизация списка TODO]
	Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
	\[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).

	[TODO: Функция MOS::ArgList]
	Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
	<MOS::ArgList> == e.Args
	e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
	t.ArgK ::= (e.ArgK)


[20.10.2007 - 17:59:43,10]

	[DONE: Функция MOS::ArgList]
	В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).

	[DONE: Автоматизация списка TODO]
	Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


[20.10.2007 - 19:08:06,05]

	[CHANGED: TODOs.txt -- сводка только TODO и ERROR]
	Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.

	[TODO: Стандартные модули контейнеров и распространённых функций]
	Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
	А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.


[27.10.2007 - 18:34:49,78]

	[TODO: Новая модель модулей]
	Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
	Подробности задачи см. в файле "Module conception for Module Refal.txt".


[27.10.2007 - 22:34:49,97]

	Законспектирую основные идеи из "Module conception for Module Refal.txt".
	[TODO: Модуль-программа]
	[TODO: Иерархия в стиле Java]
	[TODO: Продумать квалификацию точкой]
	[TODO: SymInfo как АТД]
	[TODO: Переписать драйвер]
	[TODO: Промежуточное представление как АТД]
	[TODO: Добавление категории "квалифицированное имя"]


[27.01.2008 - 21:21:01,49]

	[DONE: Новая семантика идентификатора]
	Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
	Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

	Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.

	[TODO: Генерация Info/Log.txt по требованию]
	Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.

	[TODO: Номер версии независимо от компиляции]
	Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.

	[TODO: Вывод номера версии компилятора]
	Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

	Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

	Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.

	[TODO: Создание папок Defs и ROut по требованию]
	Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.


[27.01.2008 - 23:01:49,86]

	[DONE: Генерация Info/Log.txt по требованию]
	[DONE: Создание папок Defs и ROut по требованию]
	Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


[02.02.2008 - 17:15:41,26]

	[TODO: Удалить MRefalRTS::Lenw]
	Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.


[02.02.2008 - 17:27:23,22]

	[TODO: Удалить прозрачные функции вывода из RTS]
	Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.


[02.02.2008 - 17:49:08,69]

	Оказалось всё не так просто. Функцией MRefalRTS::Putout пользуется весьма полезная функция
MSelfDiag::Log-T. Так что пускай пока остаётся MRefalRTS::Putout.


[02.02.2008 - 17:55:52,95]

	[DONE: Удалить MRefalRTS::Lenw]
	[DONE: Удалить прозрачные функции вывода из RTS]
	Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.

	[TODO: Удалить MRefalRTS::Put]
	См. выше, почему это не особо критично.


[04.02.2008 - 16:08:22,32]

	[TODO: Исключение промежуточного представления модуля]
	Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.


[04.02.2008 - 23:26:22,87]

	[TODO: Таблица перекрёстных ссылок]
	Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
	Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
	В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.

	[TODO: Составить список приоритетных TODO]
	Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.


[05.02.2008 -  1:09:32,10]

	[TODO: TODO_list изменяет порядок TODO]
	Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.


[05.02.2008 -  1:22:49,77]

	[DONE: TODO_list изменяет порядок TODO]
	Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).

	[DONE: Составить список приоритетных TODO]
	Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.

	[TODO: //== Список приоритетных TODO ==\\]
	Выполнив все эти TODO, я увеличу номер версии до 0.2.

	[TODO] Механизм поиска модулей
	Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.
	[TODO: Механизм поиска модулей]

	[TODO] Использование нескольких front-end и back-end
	Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".
	[TODO: Использование нескольких front-end и back-end]

	[TODO] RASL и интерпретатор
	Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
	Не выделяем.

	[TODO] Доделать механизм переименования модулей
	Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.
	[TODO: Доделать механизм переименования модулей]

	[TODO] Расширения .rout2 -> .rout
	Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
	Не выделяем.

	[TODO] Единица компоновки -- функция вместо модуля
	Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.
	[TODO: Единица компоновки -- функция вместо модуля]

	[TODO] Абстрактные типы данных
	Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.
	[TODO: Абстрактные типы данных]

	[TODO] eXpression eXchange in/out
	Совсем не торопит. Не выделяем.

	[ERROR] Ошибка в MFileSystem при работе с кириллицей
	Ошибку необходимо исправить. Даже не обсуждается.
	[ERROR: Ошибка в MFileSystem при работе с кириллицей]

	[TODO] Стандартные модули контейнеров и распространённых функций
	Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

	[TODO] Новая модель модулей
	Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.
	[TODO: Новая модель модулей]

	[TODO] Модуль-программа
	[TODO] Иерархия в стиле Java
	Обсуждалось. Добавляем.
	[TODO: Модуль-программа]
	[TODO: Иерархия в стиле Java]
	
	[TODO] Продумать квалификацию точкой
    Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
    Не выделяем.

	[TODO] SymInfo как АТД
	Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.
	[TODO: SymInfo как АТД]

	[TODO] Переписать драйвер
	Обсуждалось. Добавляем.
	[TODO: Переписать драйвер]

	[TODO] Промежуточное представление как АТД
	См. комментарий к "SymInfo как АТД". Вопрос решать надо.
	[TODO: Промежуточное представление как АТД]

	[TODO] Добавление категории "квалифицированное имя"
	Добавление этого является прямым следствием иерархии языка Java.
	[TODO: Добавление категории "квалифицированное имя"]

	[TODO] Номер версии независимо от компиляции
	[TODO] Вывод номера версии компилятора
	Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
	Не выделяем.

	[TODO] Удалить MRefalRTS::Put
	Идеологически не принципиально. Всё равно это деталь реализации.
	Не выделяем.

	[TODO] Исключение промежуточного представления модуля
	Продумать и исключить.
	[TODO: Исключение промежуточного представления модуля]

	[TODO] Таблица перекрёстных ссылок
	Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.
	[TODO: Таблица перекрёстных ссылок]

	[TODO: \\== Вот список приоритетных TODO ==//]


[05.02.2008 -  2:46:46,28]

	[CHANGED: Директива $CLEARMODULE]
	Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.



[08.02.2008 -  2:54:59,96]

	[CHANGED: Квадратные скобки]
	Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


[09.02.2008 -  3:00:29,53]

	Исправил пару ошибок, продолжил работу над человеческой линковкой, изменил вывод сообщений.

	[FIXED: Ошибка в MOrder::Sort]
	Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.

	[FIXED: Ошибка в MParser::NImportBlock-AfterName]
	Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $IMPORT. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.

	[CHANGED: Изменился вывод сообщений о процессе компиляции]
	Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

	[TODO: Пересмотреть/переписать mOutModuleStatus.mref]
	См. выше.


[10.02.2008 - 23:17:42,34]

	[DONE: Единица компоновки -- функция вместо модуля]
	Правильная компоновка наконец реализована. Теперь идеологически .rout-файл представляет собой не
фрагмент генерируемого .ref-файла, в котором требуется только осуществить переименование элементов
и приклеить к .ref-файлу, а набор единиц компоновки (link unit), содержащих в себе ссылки на другие
единицы компоновки. Единицей компоновки может быть локальная или entry-функция или реализация стати-
ческого ящика. Задача линковщика теперь состоит в том, чтобы сгенерировать стартовую функцию Go для
Рефала-5 и прилинковать прямо или косвенно зависящие от неё единицы компоновки. При этом линковщик
производит переименование фукций, индексов и идентификаторов, давая им короткие имена.
	Также теперь .rout-файлы содержат в себе тег версии, который проверяется во время компоновки.


[12.02.2008 - 19:48:21,36]

	[FIXED: Ошибка в MFileSystem при работе с кириллицей]
	Исправлена эта ошибка путём введения функции перекодировщика Dos <--> Win (см. описание ошибки
и способов исправления в записи от 19.10.2007). Создавать приложение для вывода листинга папки я не
стал, т.к.
	(а) лень -- способ более трудоёмок, его преимущества не оправдывают усилий: листингом папки я ещё
ни разу не пользовался;
	(б) привязка Рефала к постороннему приложению -- не удобно;
	(в) перекодировщик полезен сам по себе.
	Помимо перекодировки вывода программы dir, перекодировщик используется в функциях ввода/вывода
модуля InOut, поэтому теперь изнутри программа работает в кодировке Windows. Можно в файлах исходного
текста использовать текстовые строки в кодировке Windows, которые затем будут успешно выводиться пра-
вильно на консоль.
	Недостатком данного подхода является то, что перекодировке подлежат только символы кириллицы, лю-
бые другие символы второй половины кодовой таблицы сохраняются на выходе как есть.
	В идеале Рефал должен использовать внутри себя Unicode.


[12.02.2008 - 20:14:38,84]

	[TODO: Подготовить совместимый с АТД синтаксис]
	Это значит, что необходимо подготовить синтаксис, совместимый с Модульным Рефалом версии 0.2+.
Т.е. надо подготовить директиву типа $DATA (см. ATD Support.txt) для обозначения имени абстрактного
типа данных. Квадратные скобки язык поддерживает.
	Просто я хочу заменить текущую стабильную версию (0.1.356) на более новую, в которой и приступить
к разработке АТД и прочей лабуды.

	[TODO: Продумать упрощение структуры Lexer'а и Parser'а]
	Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
	Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
	В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).


[13.02.2008 - 22:59:00,41]

	[CHANGED: Создана утилита для обновления номера версии]
	Утилита называется VersionUpdater. Синтаксис вызова:
	refgo VersionUpdater /verfile:файл_с_номером_версии /srcfile:исходный_текст
	Параметр /srcfile может повторяться. Файл /verfile представляет собой файл того же формата, что
и Info/Version.txt. При запуске утилита считывает номер версии, инкрементирует его и записывает в
файлы, указанные в параметрах /srcfile. В исходном файле должны присутствовать специальные метки
	//{{GEN:VERSION
	//}}GEN
между которыми будет вставлен текст VerNumber = '1.2.3';, окружённый пустыми строками. Вместо 1.2.3
в файле находится инкрементированный номер версии. Если в файле имеется несколько вхождений пар ме-
ток, то текст будет вставлен несколько раз. Если в файле имеется неправильная метка (после GET: нахо-
дится не VERSION) или будет лишняя //}}GEN без соответствующей открывающей метки, то будет выдано
сообщение об ошибке и файл изменён не будет. Генерируемый текст вставляется между этими двумя мет-
ками, предыдущий текст между ними удаляется. Если в файле отсутствует закрывающая метка //}}GEN, то
она подразумевается перед меткой //{{GEN:* или перед концом файла и при обновлении файла будет до-
бавлена.
	Всем утилитам был в начале присвоен номер компиляции 64 (от балды) и номер версии 0.1 (так же,
как и Модульному Рефалу).

[13.02.2008 - 23:17:52,92]

	[DONE: Номер версии независимо от компиляции]
	[DONE: Вывод номера версии компилятора]
	Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
	Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
	Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


[17.02.2008 - 12:32:34,15]

	[FIXED: Ошибка с FnPtr]
	Возникала ошибка при работе с FnPtr: если пользователь определял собственную функцию FnPtr, то в
объектный файл заносятся два определения -- сначала пользовательская, потом сгенерированная. Счастье,
что линковщик линковал функции в прямом порядке и вторую таким образом игнорировал. А то при измене-
нии линковки и прочих изменениях могли бы возникать глюки. Правда, исправил криво: работоспособно, но
эстетически некрасиво. В любом случае надо переписывать Resolver и создавать атрибутную таблицу сим-
волов.


[21.02.2008 - 15:23:05,30]

	[DONE: Подготовить совместимый с АТД синтаксис]
	Для объявления абстрактных типов данных используются директивы $DATA и $data, синтаксис тот же,
что и при объявлении статических ящиков. Действие директивы состоит в том, имя АТД резервируется в
таблице символов, а значит не может использоваться при объявлении функций, swap-ов и в именах моду-
лей. Т.к. синтаксис подготовлен и, хочется в это верить, программа работает довольно стабильно, то
можно заменить старую стабильную версию на новую. Вероятно, также имеет смысл заменить расширение
выходных файлов, например, снова на .rout.


[21.02.2008 - 15:51:11,21]

	[DONE: Расширения .rout2 -> .rout]
	[CHANGEN: Новая стабильная версия!]
	Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
	Новая стабильная версия имеет версию 0.1.790.

	[TODO: Вынести из компилятора метаданные]
	Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
	Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.


[21.02.2008 - 18:29:09,77]

	[TODO: Атрибутная таблица символов]
	Подробности в файле AttSymTable.txt


[23.02.2008 - 18:50:39,32]

	[DONE: Атрибутная таблица символов]
	Атрибутная таблица символов реализована, правда не в полном соответствии со спецификацией.
	Реализованы:
	(+) Добавление имени в таблицу символов. В случае, если такое имя уже присутствует, таблица сим-
волов изменяться не должна.
	(+) Получение заданного атрибута заданного имени. Возвращаемое значение должно предусматривать
возможность сообщить об отсутствии этого имени.
	(+) Получение списка всех имён в таблице.
	(+) Установка (обновление) значения заданного атрибута заданного имени. При отсутствии имени
оно должно создаваться с набором атрибутов по умолчанию (возможно, пустым).
	(+) Удаление имени из таблицы. Вопрос о том, что делать при отсутствии имени решится в процессе
кодирования.
	(+) На начальном этапе таблица символов должна предоставлять интерфейс старой таблицы символов.

	(?) Получение списка имён с заданным значением заданного атрибута.*
	Можно получить список имён, имеющих определённое значение атрибута Kind. Атрибут Kind определяет
сорт имени: имя модуля, функция, импорт или АТД, и за каждым сортом закреплён строго определённый
набор атрибутов.

	(-) Получение списка атрибутов, связанных с данным именем. Возвращаемое значение должно предус-
матривать возможность сообщить об отсутствии этого имени.
	Будет добавлено позже.
	(-) Удаление атрибута заданного имени из таблицы. Предусловие: имя должно присутствовать в таб-
лице.
	Будет добавлено позже.
	(-) Проверка существования заданного имени.*
	Вместо этого используется проверка существования атрибута Kind.
	(-) Получение списка имён с заданным атрибутом.*
	(-) Удаление заданного атрибута у всех имён.*
	Будет реализовано позже.

	Функции для работы с таблицей символов делятся на базовые -- реализующие сам АТД, производные,
дополняющие базовые для типичных операций (установка нескольких атрибутов, добавление нового имени
в таблицу, при этом имя в таблице должно отсутствовать, поиск имён по сорту) и специальные, оставлен-
ные в наследство предыдущей таблицей символов. Последний класс функций нужно постепенно удалять из
таблицы, сменяя их на базовые и производные. Уже таким образом устранена функция AddImportModule Так-
же, в процессе работы над проектом, будут добавляться те функции таблицы символов, которые "Будут
реализованы позже".

	[FIXED: Синтакс переименования модулей]
	При обработке консткукции переименования модулей, написанной первоначально, обнаружена ошибка,
позволяющая компилятору принять такие неверные конструкции, как $IMPORT A = B = C;. Когда синтакси-
ческий анализатор писался в первый раз, не планировалось реализовывать переименование модулей в бли-
жайшее время и код был написан небрежно. Теперь эта ошибка исправлена. При обработке конструкции
переименования модуля в атрибут Alias имени импорта (ImportName) добавляется имя псевдонима модуля,
если модуль импортируется без псевдонима, то в Alias добавляется действительное имя.


[23.02.2008 - 19:20:11,82]

	[TODO: Вынести проверку соответствия имени модуля имени файла из MSymTable]
	Эта проверка происходит в модуле таблицы символов, что значительно усложняет модуль и реализова-
но неестественно (добавляется символ FsName как имя и ему назначается атрибут LowerName, затем эта
запись удаляется). Проще будет организовать эту проверку вне таблицы символов.

	[TODO: Реорганизация таблицы символов]
	Модуль таблицы символов выполняет две мало связанные функции -- реализует АТД и выполняет конт-
роль ошибок. Все функции, использующие t.ErrorList, коих немного, желательно вынести из модуля. Одна
из них (AddCurrentModule) вынесется автоматически при выполнении предыдущего TODO. Остальные две
также вынести не сложно.


[23.02.2008 - 21:33:32,54]

	[TODO: Перевести Parser на квалифицированные имена]
	Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.



[24.02.2008 - 23:49:32,95]
	[CHANGED: Реорганизован каталог документации]
	Теперь в папке Documentation появились свои каталоги для журнала и спецификаций. В каталог специ-
фикаций я складываю все TODO, вынесенные в отдельные файлы по причине своего размера (про модульную
концепцию, абстрактные типы данных и атрибутную таблицу символов).

	[TODO: Обдумать замену FnPtr на что-то другое]
	См. файл "Замена FnPtr на что-то другое.txt" (в каталоге спецификаций).
	Когда обдумаю, сделаю DONE для этого TODO и добавлю новое TODO: замена FnPtr на ... .


[28.02.2008 -  0:40:56,27]

	[DONE: Вынести проверку соответствия имени модуля имени файла из MSymTable]
	Просто вынес. Теперь эта проверка в MParser. Надо ещё вынести добавление новой сущности и, самое
главное, сравнение имён модуля в начале и конце файла. TODO "Реорганизация таблицы символов" как раз
этому посвящено.


[08.03.2008 - 20:17:27,04]

	[TODO: Промежуточное представление модуля]
	Атрибутная таблица символов (которая, по сути, лишь двухуровневый ассоциативный массив) -- сама
по себе очень гибкий инструмент: имя может иметь любой набор атрибутов, набор допустимых атрибутов
описывается в файле Attributes.txt, компилятором никак не проверяется. В дальнейшей работе можно про-
сто утонуть во всей этой гибкости. Поэтому нужна оболочка вокруг этой таблицы символов, которая конт-
ролировала бы доступ.


[08.03.2008 - 20:57:45,78]

	[DONE: Реорганизация таблицы символов]
	Теперь контроль ошибок действий с таблицей символов осуществляется без списка ошибок из MError.
Контроль добавления имени в таблицу символов осуществляется функцией AddNewName, которая помимо таб-
лицы символов возвращает Success или Fails. Добавление ошибки в t.ErrorList осуществляется в модуле
MParser.
	Однако, я всё ещё в стороне от цели. Модуль MParser должен работать не напрямую с таблицей симво-
лов, а с промежуточным представлением модуля. Т.е. нужно создать дополнительный уровень абстракции.


[08.03.2008 - 23:59:52,21]

	[TODO: Особым образом обрабатывать <FnPtr>]
	Проблема FnPtr всё ещё актуальна. Пока я нового синтаксиса для указателей на функции не придумал,
хотя в промежуточном представлении они успешно существуют. Временное решение проблемы состоит в том,
чтобы вызовы <FnPtr ИДЕНТИФИКАТОР*> обрабатывать не как вызов функции, а особым образом -- сразу за-
менять их на указатель в промежуточном представлении.


[19.03.2008 - 23:24:46,88]

	[DONE: Особым образом обрабатывать <FnPtr>]
	Казалось бы, за что боролся, на то и напоролся. Раньше функция FnPtr была автоматически генериру-
емой, то теперь она встроенная. При чём, эту функцию пользователь не может переопределить: если поль-
зователь объявит собственную функцию FnPtr, то она просто не будет вызвана. Вызов <FnPtr ИДЕНТИФИКА-
ТОР* > распознаётся на уровне синтаксического анализа (parser'ом).
	Относительно нового синтаксиса для указателей на функции я склоняюсь к следующему: вводится ква-
лификация точкой, указатель описывается так:
	FuncPointer = "&" IDENTIFIER | ["&"] NonEmptyDotQualifier .
	NonEmptyDotQualifier = IDENTIFIER "." IDENTIFIER | NonEmptyDotQualifier "." IDENTIFIER .
	Т.е. указатель на функцию состоит из "&" и следующим за ним квалифицированным точкой именем. Если
в квалификаторе более, чем два сегмента (т.е. есть хотя бы одна точка). Синтаксически это выражается
нетерминалом -- непустым квалификатором (см. выше). В приципе, можно использовать квалификацию точкой
и в вызовах функций -- ведь по смыслу вызов известным указателем это ведь непосредственный вызов фун-
кции. Но надо подумать, обождать. Хотя додумать надо до того, как я буду вводить в компилятор неско-
лько front- и back-end'ов.
	Кстати, текущая версия компилятора 888.


[19.03.2008 - 23:38:04,78]

	[TODO: Научить Resolver проверять образцовое выражение]
	[TODO: Несуррогатно реализовать АТД]
	Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
	Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.