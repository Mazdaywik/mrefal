[29.09.2007 - 20:25:52,85]

  Решил начать журнал изменений. Кратко опишу состояние проекта. Реализован компилятор неполного
цикла для диалекта Модульный Рефал. Выполняет полный синтаксический и семантический анализ файлов
исходного текста, анализ межмодульных связей, но для генерации используется компилятор Рефала-5
(версия PZ Oct 29 2004). Интегрирована в программу утилита make, т.е. выполняется трансляция только
тех файлов, которые изменились или зависят от изменившихся.
  Добавлена возможность обновлять информацию о версии. Текущая версия проекта хранится в файле
Info\Version.txt в формате e.MajorNumber '.' e.MinorNumber '.' e.BuildNumber. При каждой сборке (а
иначе он не может, работает только в режиме make) инкрементируется e.BuildNumber. Поскольку я до
того момента сборки не считал, то в качестве начального значения установил 256.
  Список приоритетных изменений:

  [TODO: Механизм поиска модулей]
  Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".

  [TODO: Использование нескольких front-end и back-end]
  Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...

  [TODO: Указатели на функции или функция Mu]
  ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
  Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

  Mu {
    F e.Arg = <F e.Arg>;
    G e.Arg = <G e.Arg>;
    H e.Arg = <H e.Arg>;
    Mod1 A e.Arg = <Mod1::A e.Arg>;
    Mod1 B e.Arg = <Mod1::B e.Arg>;
    Mod1 C e.Arg = <Mod1::C e.Arg>;
    Mod2 A e.Arg = <Mod2::A e.Arg>;
    Mod2 C e.Arg = <Mod2::C e.Arg>;
    Mod2 D e.Arg = <Mod2::D e.Arg>;
  }

  Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
  Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.

  [TODO: Статические ящики]
  Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
  Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

  ModuleName::SomeHolder::Swap {
    e.NewValue =
      <Dg ('ModuleName::SomeHolder')>
      <Br ('ModuleName::SomeHolder') '=' e.NewValue>;
  }

  Синтаксически можно использовать конструкцию, похожую на список импорта:

  $SWAP SomeHolder, OtherSomeHolder;

  Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).

  [TODO: RASL и интерпретатор]
  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.

  [TODO: Резервное копирование]
  Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

  Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.


[29.09.2007 - 21:53:16,11]

  [DONE: Резервное копирование]
  Реализовано резервное копирование.


[29.09.2007 - 22:22:40,36]

  Ещё вспомнил.

  [TODO: Элемент (Module e.ModuleName)]
  Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.

  [TODO: Доделать механизм переименования модулей]
  Доделать наполовину сделанный механизм переименования модулей.


[29.09.2007 - 23:18:10,03]

  [DONE: Элемент (Module e.ModuleName)]
  Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
  
  Было:

  t.Module ::=
    (t.SymTable t.ModuleContent)

  t.ModuleContent ::=
    ( (ModuleName e.ModuleName)
      t.Element*
    )

  Стало:

  t.Module ::= (t.SymTable e.ModuleContent)

  e.ModuleContent ::= t.Element*


[30.09.2007 -  0:37:49,72]

  [DONE: Статические ящики]
  Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
  Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
  Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.

  [TODO: FileIO-дескрипторы в статическом ящике]
  Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.

  [TODO: Переименовать модуль Refal5]
  Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.


[30.09.2007 -  0:57:58,78]

  [DONE: FileIO-дескрипторы в статическом ящике]
  С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.

  [TODO: Расширения .rout2 -> .rout]
  Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).

  [TODO: Единица компоновки -- функция вместо модуля]
  На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.

  [TODO: Новая семантика идентификатора]
  Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.


[06.10.2007 - 18:35:07,82]

  [CHANGED: Компиляция структурных скобок по-новому]
  Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.

  [TODO: Абстрактные типы данных]
  Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".


[07.10.2007 -  0:23:54,89]

  [DONE: Указатели на функции или функция Mu]
  Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождественны
идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова ука-
зателей таков (см. Syntax.txt).
  
  FunctionCall = '<' Callable ResultExpr '>' .
  Callable = FunctionName | Qualifier '::' FunctionName
    | SwapName | S-VARIABLE .

  Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
  Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

  Context::FnPtr::Local {
    Create =
      $Context::Create::Entry$ ;
    UpdateModuleInfo =
      $Context::UpdateModuleInfo::Entry$ ;

    // Часть пропущена

    AppendError =
      $Context::AppendError::Entry$ ;
    FnPtr =
      $Context::FnPtr::Local$ ;
    MModulesList UpdateModuleInfo =
      $MModulesList::UpdateModuleInfo::Entry$ ;
    MModulesList LastModule =
      $MModulesList::LastModule::Entry$ ;
    MModulesList ExtractOption =
      $MModulesList::ExtractOption::Entry$ ;
    MModulesList GetProgName =
      $MModulesList::GetProgName::Entry$ ;
    MModulesList ExtractModulesList =
      $MModulesList::ExtractModulesList::Entry$ ;
  }

  В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
  Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

  Test::IndirectCall::Local {
    s.Function =
      <Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
  }

  Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
  $MODULE Indirect;

  /*
    <ForAll s.FnPtr t.Term*>
      == e.Result*
    где e.Result = <s.FnPtr t.Term>
  */
  $ENTRY ForAll {
    s.FnPtr t.Next e.Tail =
      <s.FnPtr t.Next>
      <ForAll s.FnPtr e.Tail>;

    s.FnPtr = ;
  }

  $END Indirect.

  Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

  $MODULE Convert;

  $IMPORT MStrings, Indirect;

  $ENTRY NumsToStrings
    e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

  ToStr s.Num = <MStrings::Symb s.Num> ' ';

  $END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
  Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


[12.10.2007 - 22:09:54,55]

  [CHANGED: Папка ROut2]
  По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.

  [DONE: Переименовать модуль Refal5]
  Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


[16.10.2007 - 21:50:54,61]

  [FIXED: MOS::Env корректно работает с кириллицей]
  Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.

  [TODO: Исправить зависимую от MOS::Env MOS::EnvList]
  Изменить соответствующим образом MOS::EnvList.


[16.10.2007 - 22:06:30,03]

  [DONE: Исправить зависимую от MOS::Env MOS::EnvList]
  Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.

  [CHANGED: Удалена ROut]
  Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


[19.10.2007 -  1:04:32,32]

  [TODO: eXpression eXchange in/out]
  В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).

  [ERROR: Ошибка в MFileSystem при работе с кириллицей]
  Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
  Возможные пути решения:
  (1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
  Преимущества. Подход обобщается на использования других команд консоли Windows.
  Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
  (2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
  Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
  Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

  Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

  Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
  Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.

  [CHANGED: MFileSystem стал библиотечным]
  Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


[20.10.2007 - 16:06:51,06]

  [TODO: Автоматизация списка TODO]
  Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
  \[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).

  [TODO: Функция MOS::ArgList]
  Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
  <MOS::ArgList> == e.Args
  e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
  t.ArgK ::= (e.ArgK)


[20.10.2007 - 17:59:43,10]

  [DONE: Функция MOS::ArgList]
  В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).

  [DONE: Автоматизация списка TODO]
  Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


[20.10.2007 - 19:08:06,05]

  [CHANGED: TODOs.txt -- сводка только TODO и ERROR]
  Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.

  [TODO: Стандартные модули контейнеров и распространённых функций]
  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.


[27.10.2007 - 18:34:49,78]

  [TODO: Новая модель модулей]
  Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
  Подробности задачи см. в файле "Module conception for Module Refal.txt".


[27.10.2007 - 22:34:49,97]

  Законспектирую основные идеи из "Module conception for Module Refal.txt".
  [TODO: Модуль-программа]
  [TODO: Иерархия в стиле Java]
  [TODO: Продумать квалификацию точкой]
  [TODO: SymInfo как АТД]
  [TODO: Переписать драйвер]
  [TODO: Промежуточное представление как АТД]
  [TODO: Добавление категории "квалифицированное имя"]


[27.01.2008 - 21:21:01,49]

  [DONE: Новая семантика идентификатора]
  Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
  Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

  Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.

  [TODO: Генерация Info/Log.txt по требованию]
  Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.

  [TODO: Номер версии независимо от компиляции]
  Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.

  [TODO: Вывод номера версии компилятора]
  Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

  Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

  Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.

  [TODO: Создание папок Defs и ROut по требованию]
  Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.


[27.01.2008 - 23:01:49,86]

  [DONE: Генерация Info/Log.txt по требованию]
  [DONE: Создание папок Defs и ROut по требованию]
  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


[02.02.2008 - 17:15:41,26]

  [TODO: Удалить MRefalRTS::Lenw]
  Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.


[02.02.2008 - 17:27:23,22]

  [TODO: Удалить прозрачные функции вывода из RTS]
  Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.


[02.02.2008 - 17:49:08,69]

  Оказалось всё не так просто. Функцией MRefalRTS::Putout пользуется весьма полезная функция
MSelfDiag::Log-T. Так что пускай пока остаётся MRefalRTS::Putout.


[02.02.2008 - 17:55:52,95]

  [DONE: Удалить MRefalRTS::Lenw]
  [DONE: Удалить прозрачные функции вывода из RTS]
  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.

  [TODO: Удалить MRefalRTS::Put]
  См. выше, почему это не особо критично.


[04.02.2008 - 16:08:22,32]

  [TODO: Исключение промежуточного представления модуля]
  Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.


[04.02.2008 - 23:26:22,87]

  [TODO: Таблица перекрёстных ссылок]
  Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
  Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
  В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.

  [TODO: Составить список приоритетных TODO]
  Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.


[05.02.2008 -  1:09:32,10]

  [TODO: TODO_list изменяет порядок TODO]
  Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.


[05.02.2008 -  1:22:49,77]

  [DONE: TODO_list изменяет порядок TODO]
  Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).

  [DONE: Составить список приоритетных TODO]
  Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.

  [TODO: //== Список приоритетных TODO ==\\]
  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
  [TODO: Механизм поиска модулей]
  Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.

  [TODO] Использование нескольких front-end и back-end
  [TODO: Использование нескольких front-end и back-end]
  Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".

  [TODO] RASL и интерпретатор
  Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
  Не выделяем.

  [TODO] Доделать механизм переименования модулей
  [TODO: Доделать механизм переименования модулей]
  Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.

  [TODO] Расширения .rout2 -> .rout
  Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
  Не выделяем.

  [TODO] Единица компоновки -- функция вместо модуля
  [TODO: Единица компоновки -- функция вместо модуля]
  Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.

  [TODO] Абстрактные типы данных
  [TODO: Абстрактные типы данных]
  Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.

  [TODO] eXpression eXchange in/out
  Совсем не торопит. Не выделяем.

  [ERROR] Ошибка в MFileSystem при работе с кириллицей
  [ERROR: Ошибка в MFileSystem при работе с кириллицей]
  Ошибку необходимо исправить. Даже не обсуждается.

  [TODO] Стандартные модули контейнеров и распространённых функций
  Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

  [TODO] Новая модель модулей
  [TODO: Новая модель модулей]
  Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.

  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO: Модуль-программа]
  [TODO: Иерархия в стиле Java]
  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
  [TODO: SymInfo как АТД]
  Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.

  [TODO] Переписать драйвер
  [TODO: Переписать драйвер]
  Обсуждалось. Добавляем.

  [TODO] Промежуточное представление как АТД
  [TODO: Промежуточное представление как АТД]
  См. комментарий к "SymInfo как АТД". Вопрос решать надо.

  [TODO] Добавление категории "квалифицированное имя"
  [TODO: Добавление категории "квалифицированное имя"]
  Добавление этого является прямым следствием иерархии языка Java.

  [TODO] Номер версии независимо от компиляции
  [TODO] Вывод номера версии компилятора
  Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
  Не выделяем.

  [TODO] Удалить MRefalRTS::Put
  Идеологически не принципиально. Всё равно это деталь реализации.
  Не выделяем.

  [TODO] Исключение промежуточного представления модуля
  [TODO: Исключение промежуточного представления модуля]
  Продумать и исключить.

  [TODO] Таблица перекрёстных ссылок
  [TODO: Таблица перекрёстных ссылок]
  Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.

  [TODO: \\== Вот список приоритетных TODO ==//]


[05.02.2008 -  2:46:46,28]

  [CHANGED: Директива $CLEARMODULE]
  Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.



[08.02.2008 -  2:54:59,96]

  [CHANGED: Квадратные скобки]
  Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


[09.02.2008 -  3:00:29,53]

  Исправил пару ошибок, продолжил работу над человеческой линковкой, изменил вывод сообщений.

  [FIXED: Ошибка в MOrder::Sort]
  Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.

  [FIXED: Ошибка в MParser::NImportBlock-AfterName]
  Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $IMPORT. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.

  [CHANGED: Изменился вывод сообщений о процессе компиляции]
  [TODO: Пересмотреть/переписать mOutModuleStatus.mref]
  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.


[10.02.2008 - 23:17:42,34]

  [DONE: Единица компоновки -- функция вместо модуля]
  Правильная компоновка наконец реализована. Теперь идеологически .rout-файл представляет собой не
фрагмент генерируемого .ref-файла, в котором требуется только осуществить переименование элементов
и приклеить к .ref-файлу, а набор единиц компоновки (link unit), содержащих в себе ссылки на другие
единицы компоновки. Единицей компоновки может быть локальная или entry-функция или реализация стати-
ческого ящика. Задача линковщика теперь состоит в том, чтобы сгенерировать стартовую функцию Go для
Рефала-5 и прилинковать прямо или косвенно зависящие от неё единицы компоновки. При этом линковщик
производит переименование фукций, индексов и идентификаторов, давая им короткие имена.
  Также теперь .rout-файлы содержат в себе тег версии, который проверяется во время компоновки.


[12.02.2008 - 19:48:21,36]

  [FIXED: Ошибка в MFileSystem при работе с кириллицей]
  Исправлена эта ошибка путём введения функции перекодировщика Dos <--> Win (см. описание ошибки
и способов исправления в записи от 19.10.2007). Создавать приложение для вывода листинга папки я не
стал, т.к.
  (а) лень -- способ более трудоёмок, его преимущества не оправдывают усилий: листингом папки я ещё
ни разу не пользовался;
  (б) привязка Рефала к постороннему приложению -- не удобно;
  (в) перекодировщик полезен сам по себе.
  Помимо перекодировки вывода программы dir, перекодировщик используется в функциях ввода/вывода
модуля InOut, поэтому теперь изнутри программа работает в кодировке Windows. Можно в файлах исходного
текста использовать текстовые строки в кодировке Windows, которые затем будут успешно выводиться пра-
вильно на консоль.
  Недостатком данного подхода является то, что перекодировке подлежат только символы кириллицы, лю-
бые другие символы второй половины кодовой таблицы сохраняются на выходе как есть.
  В идеале Рефал должен использовать внутри себя Unicode.


[12.02.2008 - 20:14:38,84]

  [TODO: Подготовить совместимый с АТД синтаксис]
  Это значит, что необходимо подготовить синтаксис, совместимый с Модульным Рефалом версии 0.2+.
Т.е. надо подготовить директиву типа $DATA (см. ATD Support.txt) для обозначения имени абстрактного
типа данных. Квадратные скобки язык поддерживает.
  Просто я хочу заменить текущую стабильную версию (0.1.356) на более новую, в которой и приступить
к разработке АТД и прочей лабуды.

  [TODO: Продумать упрощение структуры Lexer'а и Parser'а]
  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).


[13.02.2008 - 22:59:00,41]

  [CHANGED: Создана утилита для обновления номера версии]
  Утилита называется VersionUpdater. Синтаксис вызова:
  refgo VersionUpdater /verfile:файл_с_номером_версии /srcfile:исходный_текст
  Параметр /srcfile может повторяться. Файл /verfile представляет собой файл того же формата, что
и Info/Version.txt. При запуске утилита считывает номер версии, инкрементирует его и записывает в
файлы, указанные в параметрах /srcfile. В исходном файле должны присутствовать специальные метки
  //{{GEN:VERSION
  //}}GEN
между которыми будет вставлен текст VerNumber = '1.2.3';, окружённый пустыми строками. Вместо 1.2.3
в файле находится инкрементированный номер версии. Если в файле имеется несколько вхождений пар ме-
ток, то текст будет вставлен несколько раз. Если в файле имеется неправильная метка (после GEN: нахо-
дится не VERSION) или будет лишняя //}}GEN без соответствующей открывающей метки, то будет выдано
сообщение об ошибке и файл изменён не будет. Генерируемый текст вставляется между этими двумя мет-
ками, предыдущий текст между ними удаляется. Если в файле отсутствует закрывающая метка //}}GEN, то
она подразумевается перед меткой //{{GEN:* или перед концом файла и при обновлении файла будет до-
бавлена.
  Всем утилитам был в начале присвоен номер компиляции 64 (от балды) и номер версии 0.1 (так же,
как и Модульному Рефалу).

[13.02.2008 - 23:17:52,92]

  [DONE: Номер версии независимо от компиляции]
  [DONE: Вывод номера версии компилятора]
  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


[17.02.2008 - 12:32:34,15]

  [FIXED: Ошибка с FnPtr]
  Возникала ошибка при работе с FnPtr: если пользователь определял собственную функцию FnPtr, то в
объектный файл заносятся два определения -- сначала пользовательская, потом сгенерированная. Счастье,
что линковщик линковал функции в прямом порядке и вторую таким образом игнорировал. А то при измене-
нии линковки и прочих изменениях могли бы возникать глюки. Правда, исправил криво: работоспособно, но
эстетически некрасиво. В любом случае надо переписывать Resolver и создавать атрибутную таблицу сим-
волов.


[21.02.2008 - 15:23:05,30]

  [DONE: Подготовить совместимый с АТД синтаксис]
  Для объявления абстрактных типов данных используются директивы $DATA и $data, синтаксис тот же,
что и при объявлении статических ящиков. Действие директивы состоит в том, имя АТД резервируется в
таблице символов, а значит не может использоваться при объявлении функций, swap-ов и в именах моду-
лей. Т.к. синтаксис подготовлен и, хочется в это верить, программа работает довольно стабильно, то
можно заменить старую стабильную версию на новую. Вероятно, также имеет смысл заменить расширение
выходных файлов, например, снова на .rout.


[21.02.2008 - 15:51:11,21]

  [DONE: Расширения .rout2 -> .rout]
  [CHANGED: Новая стабильная версия!]
  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.

  [TODO: Вынести из компилятора метаданные]
  Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
  Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.


[21.02.2008 - 18:29:09,77]

  [TODO: Атрибутная таблица символов]
  Подробности в файле AttSymTable.txt


[23.02.2008 - 18:50:39,32]

  [DONE: Атрибутная таблица символов]
  Атрибутная таблица символов реализована, правда не в полном соответствии со спецификацией.
  Реализованы:
  (+) Добавление имени в таблицу символов. В случае, если такое имя уже присутствует, таблица сим-
волов изменяться не должна.
  (+) Получение заданного атрибута заданного имени. Возвращаемое значение должно предусматривать
возможность сообщить об отсутствии этого имени.
  (+) Получение списка всех имён в таблице.
  (+) Установка (обновление) значения заданного атрибута заданного имени. При отсутствии имени
оно должно создаваться с набором атрибутов по умолчанию (возможно, пустым).
  (+) Удаление имени из таблицы. Вопрос о том, что делать при отсутствии имени решится в процессе
кодирования.
  (+) На начальном этапе таблица символов должна предоставлять интерфейс старой таблицы символов.

  (?) Получение списка имён с заданным значением заданного атрибута.*
  Можно получить список имён, имеющих определённое значение атрибута Kind. Атрибут Kind определяет
сорт имени: имя модуля, функция, импорт или АТД, и за каждым сортом закреплён строго определённый
набор атрибутов.

  (-) Получение списка атрибутов, связанных с данным именем. Возвращаемое значение должно предус-
матривать возможность сообщить об отсутствии этого имени.
  Будет добавлено позже.
  (-) Удаление атрибута заданного имени из таблицы. Предусловие: имя должно присутствовать в таб-
лице.
  Будет добавлено позже.
  (-) Проверка существования заданного имени.*
  Вместо этого используется проверка существования атрибута Kind.
  (-) Получение списка имён с заданным атрибутом.*
  (-) Удаление заданного атрибута у всех имён.*
  Будет реализовано позже.

  Функции для работы с таблицей символов делятся на базовые -- реализующие сам АТД, производные,
дополняющие базовые для типичных операций (установка нескольких атрибутов, добавление нового имени
в таблицу, при этом имя в таблице должно отсутствовать, поиск имён по сорту) и специальные, оставлен-
ные в наследство предыдущей таблицей символов. Последний класс функций нужно постепенно удалять из
таблицы, сменяя их на базовые и производные. Уже таким образом устранена функция AddImportModule Так-
же, в процессе работы над проектом, будут добавляться те функции таблицы символов, которые "Будут
реализованы позже".

  [FIXED: Синтакс переименования модулей]
  При обработке консткукции переименования модулей, написанной первоначально, обнаружена ошибка,
позволяющая компилятору принять такие неверные конструкции, как $IMPORT A = B = C;. Когда синтакси-
ческий анализатор писался в первый раз, не планировалось реализовывать переименование модулей в бли-
жайшее время и код был написан небрежно. Теперь эта ошибка исправлена. При обработке конструкции
переименования модуля в атрибут Alias имени импорта (ImportName) добавляется имя псевдонима модуля,
если модуль импортируется без псевдонима, то в Alias добавляется действительное имя.


[23.02.2008 - 19:20:11,82]

  [TODO: Вынести проверку соответствия имени модуля имени файла из MSymTable]
  Эта проверка происходит в модуле таблицы символов, что значительно усложняет модуль и реализова-
но неестественно (добавляется символ FsName как имя и ему назначается атрибут LowerName, затем эта
запись удаляется). Проще будет организовать эту проверку вне таблицы символов.

  [TODO: Реорганизация таблицы символов]
  Модуль таблицы символов выполняет две мало связанные функции -- реализует АТД и выполняет конт-
роль ошибок. Все функции, использующие t.ErrorList, коих немного, желательно вынести из модуля. Одна
из них (AddCurrentModule) вынесется автоматически при выполнении предыдущего TODO. Остальные две
также вынести не сложно.


[23.02.2008 - 21:33:32,54]

  [TODO: Перевести Parser на квалифицированные имена]
  Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.



[24.02.2008 - 23:49:32,95]
  [CHANGED: Реорганизован каталог документации]
  Теперь в папке Documentation появились свои каталоги для журнала и спецификаций. В каталог специ-
фикаций я складываю все TODO, вынесенные в отдельные файлы по причине своего размера (про модульную
концепцию, абстрактные типы данных и атрибутную таблицу символов).

  [TODO: Обдумать замену FnPtr на что-то другое]
  См. файл "Замена FnPtr на что-то другое.txt" (в каталоге спецификаций).
  Когда обдумаю, сделаю DONE для этого TODO и добавлю новое TODO: замена FnPtr на ... .


[28.02.2008 -  0:40:56,27]

  [DONE: Вынести проверку соответствия имени модуля имени файла из MSymTable]
  Просто вынес. Теперь эта проверка в MParser. Надо ещё вынести добавление новой сущности и, самое
главное, сравнение имён модуля в начале и конце файла. TODO "Реорганизация таблицы символов" как раз
этому посвящено.


[08.03.2008 - 20:17:27,04]

  [TODO: Промежуточное представление модуля]
  Атрибутная таблица символов (которая, по сути, лишь двухуровневый ассоциативный массив) -- сама
по себе очень гибкий инструмент: имя может иметь любой набор атрибутов, набор допустимых атрибутов
описывается в файле Attributes.txt, компилятором никак не проверяется. В дальнейшей работе можно про-
сто утонуть во всей этой гибкости. Поэтому нужна оболочка вокруг этой таблицы символов, которая конт-
ролировала бы доступ.


[08.03.2008 - 20:57:45,78]

  [DONE: Реорганизация таблицы символов]
  Теперь контроль ошибок действий с таблицей символов осуществляется без списка ошибок из MError.
Контроль добавления имени в таблицу символов осуществляется функцией AddNewName, которая помимо таб-
лицы символов возвращает Success или Fails. Добавление ошибки в t.ErrorList осуществляется в модуле
MParser.
  Однако, я всё ещё в стороне от цели. Модуль MParser должен работать не напрямую с таблицей симво-
лов, а с промежуточным представлением модуля. Т.е. нужно создать дополнительный уровень абстракции.


[08.03.2008 - 23:59:52,21]

  [TODO: Особым образом обрабатывать <FnPtr>]
  Проблема FnPtr всё ещё актуальна. Пока я нового синтаксиса для указателей на функции не придумал,
хотя в промежуточном представлении они успешно существуют. Временное решение проблемы состоит в том,
чтобы вызовы <FnPtr ИДЕНТИФИКАТОР*> обрабатывать не как вызов функции, а особым образом -- сразу за-
менять их на указатель в промежуточном представлении.


[19.03.2008 - 23:24:46,88]

  [DONE: Особым образом обрабатывать <FnPtr>]
  Казалось бы, за что боролся, на то и напоролся. Раньше функция FnPtr была автоматически генериру-
емой, то теперь она встроенная. При чём, эту функцию пользователь не может переопределить: если поль-
зователь объявит собственную функцию FnPtr, то она просто не будет вызвана. Вызов <FnPtr ИДЕНТИФИКА-
ТОР* > распознаётся на уровне синтаксического анализа (parser'ом).
  Относительно нового синтаксиса для указателей на функции я склоняюсь к следующему: вводится ква-
лификация точкой, указатель описывается так:
  FuncPointer = "&" IDENTIFIER | ["&"] NonEmptyDotQualifier .
  NonEmptyDotQualifier = IDENTIFIER "." IDENTIFIER | NonEmptyDotQualifier "." IDENTIFIER .
  Т.е. указатель на функцию состоит из "&" и следующим за ним квалифицированным точкой именем. Если
в квалификаторе более, чем два сегмента (т.е. есть хотя бы одна точка). Синтаксически это выражается
нетерминалом -- непустым квалификатором (см. выше). В приципе, можно использовать квалификацию точкой
и в вызовах функций -- ведь по смыслу вызов известным указателем это ведь непосредственный вызов фун-
кции. Но надо подумать, обождать. Хотя додумать надо до того, как я буду вводить в компилятор неско-
лько front- и back-end'ов.
  Кстати, текущая версия компилятора 888.


[19.03.2008 - 23:38:04,78]

  [TODO: Научить Resolver проверять образцовое выражение]
  [TODO: Несуррогатно реализовать АТД]
  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.


[20.03.2008 -  0:08:54,21]

  [TODO: Отучить Resolver от старого представления модуля]
  Модуль MResolver сначала преобразовывает таблицу символов в модуль в старом формате, его проверя-
ет и снова модуль превращает в таблицу символов. Решить этот вопрос. Можно решать этот вопрос в то же
время, когда и буду учить Resolver проверять образцовое выражение. Хотя, вероятно, Resolver придётся
приучать к промежуточному представлению модуля в виде АТД.
  При этом автоматически мы избавимся от MSymTable-Module.


[20.03.2008 - 23:03:24,42]

  [DONE: Научить Resolver проверять образцовое выражение]
  [DONE: Несуррогатно реализовать АТД]
  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


[22.03.2008 - 21:17:30,11]

  [ERROR: В таблице символов ошибка -- имя может оказаться без сорта]
  Если выполнить команду <MSymTable::RemoveAttrib t.SymTable e.Name Kind>, то в таблице символов
имя вообще окажется без атрибута.


[23.03.2008 - 14:22:12,04]

  [FIXED: Исправлена ошибка в Parser]
  Если при обработке тела модуля функцией MParser::NModuleBody встречался конец файла, функция воз-
вращала результат неправильного формата: t.ErrorList t.SymTable Error, хотя по завершению рекурсив-
ного анализа синтаксиса, должно возвращаться t.ErrorList t.SymTable. Происходила, в общем ошибка.
  Похожая ошибка была и в MParser::MSymModuleBody. Но в этом случае компилятор просто бы завис.


[23.03.2008 - 20:27:33,79]

  [FIXED: В таблице символов ошибка -- имя может оказаться без сорта]
  Ошибка исправлена. В функцию MSymTable::RemoveAttrib просто добавлен частный случай.


[29.03.2008 - 19:33:03,08]

  [DONE: Отучить Resolver от старого представления модуля]
  Теперь Resolver пользуется только таблицей символов. Хотя модуль, инкапсулирующий промежуточное
представление модуля MIModule, написан, он ещё в проекте не используется. Т.е. надо интегрировать.

  [CHANGED: Удалён модуль MSymInfo]
  Предполагалось, что модуль MSymInfo будет предоставлять АТД для представления символической ин-
формации. Однако, этот модуль никак не развивался. В качестве промежуточного представления символи-
ческой информации можно использовать структуру IModule, удалив при этом из неё тела функций и инфор-
мацию об не-entry-функциях.
  Потом, когда я переведу компилятор целиком на IModule, я удалю TODO: SymInfo как АТД.

  [TODO: Интегрировать IModule]
  Необходимо интегрировать структуру данных IModule в компилятор, т.е. заменить SymTable на неё
там, где надо.

  [TODO: Создать "диспетчеры" back-end'ов и front-end'ов]
  Создать модули, хранящие списки зарегистрированных входных и выходных частей. При этом диспетчеры
должны сообщать о зарегистрированных расширениях, папках, в которых следует искать, должны осуществ-
лять вызов анализаторов и генераторов кода.

  [TODO: Создать модуль для оценки необходимости перекомпиляции]
  Т.е. создать модуль, основная функция которого получает имя модуля, ищет входные и выходные файлы
модуля, считывает sym-файл и проверяет необходимость в перекомпиляции рекурсивно. Возвращает функция
сведения о небходимости перекомпиляции или сообщение об ошибке. При этом собственно перекомпиляцию
этот модуль осуществлять не должен.


[30.03.2008 - 22:57:12,84]

  [DONE: Интегрировать IModule]
  [DONE: Промежуточное представление модуля]
  [DONE: Промежуточное представление как АТД]
  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


[13.04.2008 -  2:04:35,41]

  [CHANGED: Изменена реализация контекста]
  [TODO: Перейти от модуля Context к модулю MContext]
  [TODO: Искать имя программы другим способом]
  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.


[13.04.2008 - 21:06:47,07]

  [ERROR: Ошибка в FnPtr]
  Реализация этой злополучной функции явила новый сюрприз. Если в качестве параметра указать вместо
имени функции имя АТД, то будет получен "указатель" на этот АТД, т.е. результат будет ошибочным. Нуж-
но на стадии компиляции проверять то, что аргумент FnPtr должен быть не только реально существующей
сущностью, но и должен быть именем функции.

  [TODO: Ввести особый тип компоновки для особых функций]
  Было бы красиво, на мой взгляд, для функций Init и Final обычных модулей и функции Go головного
модуля иметь специальный тип компоновки.


[13.04.2008 - 22:05:09,47]

  [TODO: Синтаксис для указателей на функции]
  Диспетчеры предполагают регистрацию callback'ов. Для более красивой реализации этого лучше испо-
льзовать вместо FnPtr специальный синтаскис указателей. О том, какой синтаксис надо использовать,
я уже писал в DONE: Особым образом обрабатывать <FnPtr> от 19.03.2008. Тогда я хотел обождать, но
ждать уже хватит. Надо делать. Синтаксис.

  QualifiedName =
    IDENTIFIER | QuadQualified | DotQualified .
  QuadQualified =
    IDENTIFIER '::' IDENTIFIER | QuadQualified '::' IDENTIFIER .
  DotQualified =
    IDENTIFIER '.' IDENTIFIER | DotQualified '.' IDENTIFIER .
  FnPtr =
    '&' IDENTIFIER | ['&'] DotQualified .
  Callable =
    QualifiedName | FnPtr | S-VARIABLE .

  FnPtr может быть как результатным, так и образцовым термом.
  
  Таким образом, квалифицированное имя -- это или квалифицированное квадратиком '::' или квалифици-
рованное точкой имя. Или просто идентификатор. Там где был раньше допустим только квадратик, теперь
допустима и точка. В качестве вызываемой сущности может быть использован и указатель на функцию,
что вполне логично. Такой вызов семантически ничем не должен отличаться от обычного вызова.

  [TODO: Пересмотреть Parser]
  Необходимо разобраться с функциями, реализующими нетерминалы: унифицировать их интерфейс. Разоб-
раться, что должно быть в момент вызова нетерминалов на стеке и что должно оставаться на стеке после
их выполнения. Результат унификации должен быть закомментирован в шапке модуля.


[18.04.2008 - 22:57:27,21]

  [DONE: Исключение промежуточного представления модуля]
  Это TODO я давно выполнил, когда реализовал IModule. Промежуточного представления в старом смысле
в программе нет. Просто по ошибке я забыл удалить это TODO. Вот так, не меняя ни строчки кода, я уст-
ранил одно TODO.

  [TODO: Изменить обработку командной строки]
  Сейчас (в текущей версии 0.1.904) модули/файлы в командной строке мыслятся как модули/файлы, вхо-
дящие в проект. "Лишние" файлы, которые компилируются и прилинковываются, могут иметь свои функции
инициализации, что позволяет осуществить гамак. Сие не есть хорошо. Надо изменить смысл командной
строки следующим образом.
  (1) Если некоторый аргумент командной строки является головным модулем, то он рекурсивно компи-
лируется и линкуется в .exe-шник. Если аргумент явяляется обычным модулем, то он рекурсивно компили-
руется, но не линкуется.
  (2) В командной строке можно указать несколько имён файлов/модулей. Каждый из них обрабатывается
согласно пункту (1). Таким образом, можно одновременно компилировать и собирать несколько проектов
одновременно. Если эти проекты имеют общие модули, то общее время компиляции должно снизиться.
  (3) Если расширение файла не указано, то поиск модуля выполняется по всем доступным front-end'ам.
Если расширение указано, то компиляция осуществляется указанным front-end'ом.
  (4) В командной строке могут быть опции, позволяющие выбрать необходимые back-end'ы.

  [TODO: Примерное описание работы диспетчеров back- и front-end'ов]
  Это TODO я удалю, когда дам точные спецификации для работы этих диспетчеров. Или когда эти диспет-
черы я реализую.
  Back-end manager должен позволять зарегистрировать в себе конкретные генераторы выходного кода.
Генератор характеризуется функцией для генерации файла из IModule, расширением выходного объектного
файла, расширением исполнимого файла, папкой для выходных файлов и др. Также может предоставлять фун-
кцию, создающую имя файла из квалифицированного имени.
  Front-end manager должен позволять также регистрировать front-end'ы. Front-end должен предостав-
лять расширение исходного текста, (возможно) имя папки, функцию для парсинга.
  Модуль компиляции и модуль проверки необходимости компиляции ничего не знают о конкретных front-
и back-end'ах, просто пользуются диспетчерами. Модуль компиляции посылает диспетчеру сообщение "гене-
рировать" и тот генерирует.



[23.04.2008 - 20:49:40,97]

  [ERROR: Возможна ошибка при чтении папок]
  Команду dir можно заместить, добавив в текущую папку/в один из каталогов PATH файл с именем, нап-
ример dir.exe. Такая ситуация может возникнуть, если на комп установлен cygwin (команда dir имитирует
команду ls системы Linux) -- сам видел. А это значит, что программы становятся непереносимыми.
  Решить проблему можно, если разработать отдельную программу с некоторым редким именем типа
mr_extent.exe, которая может в том числе выводить и листинг папки в более удобном для распознавания
формате. Эта же программа может возвращать значения переменных среды, конвертировать бинарные файлы
в текстовые специального формата и наоборот (чтобы имитировать работу с бинарными файлами). Для под-
держки этой программы можно создать отдельный стандартный модуль, который в момент инициализации про-
веряет наличие программы и корректность её версии.
  Примерный внешний вид програмы.
    > mr_extent.exe VERSION
  MRefal Extensions version 0.1.123
  или (в виде XXIO)
  MR_extent#0 #1 #123
  > mr_extent.exe LIST DirName
  file1.ext
  file2.txt
  dir3
  или
  (file1.ext)(file2.exe)(dir3)
  > mr_extent.exe INFO file1.ext
  #2048 #2008 #5 #9 #23 #59 #59 file1.ext
  Размер,  дата, время, имя
  > mr_extent.exe INFO dir3
  D#2008 #5 #9 #23 #59 #59 dir3
  > mr_extent.exe INFO file3.lst
  N
для папок может возвращаться вместо размера буква D, для несуществующих файлов N.
  Это ERROR я удалю, когда реализую эту программку.

  [DONE: Обдумать замену FnPtr на что-то другое]
  Замену я обдумал ещё 13.04.2008 -- синтаксис и семантика для указателей на функции. Просто опять
по ошибке забыл удалить TODO.
  Первое время front- и back-end диспетчеры будут регистрироваться при помощи FnPtr, т.к. необходи-
мо обеспечить совместимость с текущей стабильной версией.

  [ERROR: Ошибка при разрешении имени функции]
  Ранее была найдена ошибка в функции FnPtr. Оказывается ошибка не только в ней. Ошибка возникает
при разрешении любого вызова функции и при разрешении любого описания АТД. Имена функций и АТД разре-
шаются и затем компилируются абсолютно одинаковым образом: заменяется неквалифицированное имя на ква-
лифицированное с известной областью видимости. Причём место замены никак не контролируется: может
быть "правильно" разрешена функция после квадратной или АТД после угловой скобки.
  Слава богу, что синтаксис не позволяет записывать после квадратной скобки квалифицированное имя.
А то можно было бы делать "экспортируемые АТД", используя имя entry-функции после квадратной скобки.
  Кстати, эта ошибка нарушала один из негласных принципов компилятора: генерируемый код на входе
Рефал-5 должен быть абсолютно безошибочным или не генерироваться вообще. А так можно было сгенериро-
вать "вызов АТД" после угловой скобки. Рефал-5 в таких случаях справедливо ругается на необъявленную
функцию.
  Это ERROR я удалю тогда, когда исправлю ошибку. Вместе с ним я удалю упомянутое ERROR про FnPtr.


[23.04.2008 - 22:49:01,30]

  [FIXED: Ошибка при разрешении имени функции]
  [FIXED: Ошибка в FnPtr]
  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.

  [TODO: При компоновке заменять самые примитивные функции на функции Рефала-5]
  Т.е. идея в том, что нужно будет заменять вызовы функций типа MRefalRTS::Card сразу на <Card...>.
Причём это можно реализовать так, что в линковщик явно не будут встраиваться эти функции. Примитивные
функции будут описаны как псевдонимы в файле MRefalRTS особыми директивами линковщика. Можно, напри-
мер, ввести тег 'p ' с таким синтаксисом
  p Entry::MRefalRTS::Prout Prout
или
  b Entry::MRefalRTS::Prout
  p Prout.
  В этом случае в таблицу MLinkerAliasTable вместо сгенерированного псевдонима вида X123 будет до-
бавлен псевдоним Prout.
  Способ этот ортогонален компилятору, т.к. позволяет легко изменять набор встроенных функций не
меняя ни строчки кода самого компилятора. Файл MRefalRTS всё равно пишется вручную.


[24.04.2008 -  0:14:07,31]

  [DONE: Доделать механизм переименования модулей]
  Давно у меня это TODO висело. Аж с 29.09.2007. Наконец то сделал. Теперь работает. Как только
я сделаю новый синтаксис для указателей на функции, я заменю стабильную версию и начну активно ис-
пользовать короткие псевдонимы для модулей.


[01.06.2008 -  1:58:55,72]

  [DONE: Создать "диспетчеры" back-end'ов и front-end'ов]
  [DONE: Примерное описание работы диспетчеров back- и front-end'ов]
  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


[01.06.2008 -  2:32:18,92]

  [TODO: Добавить к BE-Mgr поддержку линковщика]
  Полная ортогональность не достигнута. Вперёд!


[08.06.2008 -  2:49:01,70]

  [ERROR: Ошибка при рекурсивном сканировании папок]
  При попытке использовать имя папки, возвращённое функцией MFileSystem::FilesInfo для рекурсивного
просмотра этой папки вылетает ошибка. Эту ошибку можно увидеть в папке Tests/DirSync.



[11.06.2008 - 22:03:06,42]

  [ERROR: Ошибка в MFileSystem::FilesInfo при работе с кириллицей]
  Выяснено: выскакивает ошибка при работе с кириллицей. Надо разбираться.


[11.06.2008 - 22:26:35,36]

  [FIXED: Ошибка при рекурсивном сканировании папок]
  [FIXED: Ошибка в MFileSystem::FilesInfo при работе с кириллицей]
  [ERROR: Ошибка в именах файлов с пробелами]
  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


[12.06.2008 -  1:32:20,20]

  [FIXED: Ошибка в именах файлов с пробелами]
  Исправил. Вроде работает.


[13.06.2008 - 15:12:23,27]

  [CHANGED: Создан файл спецификаций "Поиск исходников.txt"]
  [TODO: Законспектировать спецификацию модели модулей]
  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.

  [DONE: Абстрактные типы данных]
  В сегодняшней версии (0.1.948) абстрактные типы данных по сути представляют собой надстройку над
идиомой АТД. И я считаю это вполне достаточным для версии 0.2. В дальнейших версиях, вероятно, будут
реализованы более сложные виды АТД: с некоторой внутренней структурой задаваемой образцом, с несколь-
кими конструкторами (как в Haskell). Также будут созданы ограничители на тип переменной, типа тех,
которые описаны в спецификации на АТД ("ATD support.txt"). Также будет возможность полного или час-
тичного экспорта АТД (т.к. если большая часть инварианта заключена в внутреннем формате АТД, то при
автоматической проверке формата инвариант будет сохраняться автоматически). Но это уже относится к
какой-нибудь версии 0.3 или больше. Сейчас надо сконцентрироваться на движке.

  [TODO: Модуль имитации функций высших порядков]
  Одно из совсем будущих изменений Модульного Рефала заключается во введении в него функций высших
порядков: возможность порождения (безымянных или с именем) локальных функций со связанными в них
локальными переменными, возврат этих функций (как возвращаемого значения) и т.д. Возможность передачи
объекта-функции (в виде указателя на функцию) внутрь функции и вызова этой функции есть уже сейчас
и реализована средстами FnPtr и <s.X ...>.
  Основными средствами, предоставляемыми этим модулем, должны быть функции Map и Reduce. У меня в
программе активно используются Map- и Reduce-подобные циклы (фактически, это можно рассматривать как
идиому). Но в некоторых случаях идиома скрывается под большим количеством строк, описывающих циклы.
(Интересно то, что здесь я, говоря о циклах, имел ввиду остаточную рекурсию. Циклов в Модульном Рефа-
ле нет. Я уже мыслю остаточную рекурсию в виде циклов). Использование явным образом функций Map и
Reduce сделает код более читабельным.
  Модуль я планирую назвать MLambda.mref. Если он докажет свою полезность, то станет библиотечным.
  Основные средства, предоставляемые модулем.

  Тип лямбда-функции:
    t.Lambda ::= s.FnPtr | [АТД, определённое внутри модуля]

  Вызов лямбда-фукции:
    <Apply t.Lambda e.Arg>
      == e.Result

  Создание лямбда-функции со связыванием слева:
  <BindLeft t.Lambda e.Left>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.Left e.ARG>;
  }

  Создание лямбда-функции со связыванием справа
  <BindRight t.Lambda e.Right>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.ARG e.Right>;
  }

  Функции семейства Map-Reduce
  <Map t.Lambda t.Src*>
    == e.Result*
  <Apply t.Lambda t.Src> == e.Result

  <Reduce t.Lambda t.Accum t.Src*>
    == t.Accum'
  <Apply t.Lambda t.Accum t.Src> == t.Accum'

  <MapReduce t.Lambda t.Accum t.Src*>
    == t.Accum' e.Result*
  <Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

  Функция MapReduce сочетает в себе действие функций Map и Reduce -- преобразует исходное выражение
в новое выражение вместе с передачей состояния. Для функций Reduce и MapReduce существуют парные им
фукнции Reduce-R и MapReduce-R, осуществляющие преобразование справа налево.
  Для АТД, представляющего собой лямбда-функцию, не предоставляется функция Destroy, т.к. объект
первого класса (которым и должен быть объект-функция) может беспрепятственно создаваться, копировать-
ся, возвращаться из функции и уничтожаться.

  [DONE: Добавить к BE-Mgr поддержку линковщика]
  Поддержка линковщика добавлена. Более того, теперь линковка выполняется также обобщённо, как и
генерация выходных файлов. Модуль mLinker.mref говорит диспетчеру "связывай" и диспетчер вызывает
функцию связывания для каждого из back-end'ов.


[13.06.2008 - 21:17:14,10]

  [DONE: Модуль имитации функций высших порядков]
  Модуль написан в точности с описанием. Модуль компилируется нормально, но не протестирован. Ни-
чего, оттестируется в процессе использования.


[14.06.2008 -  1:28:52,75]

  [DONE: Законспектировать спецификацию модели модулей]
  Законспектировал. Теперь TODO очень много. Даже не умещаются на одной странице. Модули, относя-
щиеся к поиску модулей, содержат префикс ПИ. Некоторые подчинённые модули не имеют того же префикса.

  [TODO: ПИ:Проверять корректность имени модуля/пакета]
  [TODO: Продумать максимальную длину имени модуля]
  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.

  [TODO: ПИ:Поддержка переменной MODULEPATH с проверкой корректности]
  Надо осуществлять проверку того, что никакой каталог в переменной MODULEPATH не является подка-
талогом другого MP-каталога. А также проверять существование данного каталога.

  [TODO: Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов]
  Необходимо добавить следующие функции:
  (*) Функция, которая склеивает имя папки с относительным именем.
  (*) Функция, которая унифицирует имя папки -- т.к. в Windows одни и те же пути к файлам могут
выглядеть по-разному (прямой и обратный слеш, регистр символов).
  (*) Функция, возвращающая абсолютное имя для относительного. Такая функция может проверять также
наличие данного файла/папки. А может и не проверять.

  [TODO: ПИ:Полная поддержка parser'ом квалифицированных имён]
  Одно из требований гласит:  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно
быть указано в файле исходного текста (синтаксис файла исходного текста должен позволять это делать)
и в файлах с информацией о межмодульных связях (структура хотя бы одного из этих файлов должна поз-
волять это делать).
  Таким образом, синтаксис файлов исходного текста (распознаётся в mParser.mref) и структура (она
же синтаксис) файлов символической информации (распознаётся там же) должна полностью поддерживать
квалифицированные имена.

  [TODO: ПИ:Хранить в контексте также информацию о пакетах]
  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.

  [TODO: ПИ:Написать функцию для поиска модулей]
  Поиск модулей должен осуществляться в соответствии со спецификацией. Здесь дословно её цитировать
не буду, а просто сошлюсь на файл "Поиск исходников.txt".

  [TODO: ПИ:Написать средства для оценки необходимости перекомпиляции]
  Написать функцию для оценки необходимости перекомпиляции в соответствии со следующими требовани-
ями (дословно из спецификации):
  Компилятор может предоставлять режим "быстрой перекомпиляции", в котором некоторые компилируемые
модули могут исключаться из процесса компиляции при одновременном выполнении следующих условий:
  (*) Для данного модуля присутствуют ВСЕ выходные файлы.
  (*) Выходные файлы созданы/обновлены позже исходного файла данного модуля.
  (*) Модули, от которых зависит данный модуль, либо библиотечные, либо были исключены из процесса
компилирования, хотя были компилируемыми.
  (*) Исходные тексты компилируемых модули, от которых зависит данный модуль, созданы/обновлены
раньше, чем данный модуль.
  (*) Выходные файлы библиотечных модулей, от которых зависит даннный модуль, созданы/обновлены
раньше, чем данный модуль.
  Этот набор эвристических условий позволяет с высокой вероятностью гарантировать непротиворечи-
вость проекта.
  Если всё равно есть сомнения, то рекомендуется включать режим для полной перекомпиляции.

  [TODO: ПИ:Режимы "только связывание" и "полной перекомпиляции"]
  Должна быть возможность выбора режима перекомпиляции (на начальном этапе -- опцией командной
строки): make (быстрая перекомпиляция), build (полная перекомпиляция), linkonly (только связывание).

  [TODO: ПИ:Обработка командной строки]
  Для модулей, перечисленных в командной строке, обработку выполнять в соответствии со специфика-
цией (см. "Поиск исходников.txt").


[20.06.2008 - 20:59:14,30]

  Сейчас я постепенно ввожу синтаксис указателей на функции. Уже ввёл <A::B::C::D> <A.B.C.D> и
& A и & A.B. Задумываюсь о том, чтобы ввести новую стабильную версию. Появилось несколько новых мыс-
лей. Ниже они оформлены в виде TODO.
  Теперь TODO станет ещё больше.

  [TODO: Новая стабильная версия]
  Введение новой стабильной версии позволит сейчас (пока указатели на функции целиком не завладели
исходными текстами) уже избавиться от позорной псевдофункции FnPtr. Уже соответствующий синтаксис
готов. Для себя ставлю веху: когда будет готов следующий синтаксис:
  ... = <MLambda.Reduce Math.Add 0 e.NumList>;
т.е. квалифицированное имя посреди выражения интерпретируется как указатель на функцию, я заменю ста-
бильную версию.

  [TODO: Обдумать введение видов для квалифицированных имён]
  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.

  [TODO: Перевести IModule на квалифицированные имена]
  [TODO: Продумать детали перевода IModule на квалифицированные имена]
  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?

  [TODO: Расширить утилиту TODO_list]
  Для лучшей ориентации в недоделках надо научиться извлекать из журнала не только заголовки невы-
полненных TODO, но и сами описания TODO. Т.е. помимо краткого списка выводить подробный, в котором
будут выводиться сами тексты TODO. А также список выполненных TODO, в котором приводится сводка всех
выполненных TODO, причём описания TODO и DONE должны располагаться рядом.


[20.06.2008 - 23:12:35,60]

  [TODO: Переворошить Parser -- форматы функций]
  Кратко. Надо поменять формат всех функций на
  <NFn
    [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  >
    == [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  В квадратных скобках показаны необязательные элементы.
  Мотивация. Параметр t.IModule присутствует во всех функциях-нетерминалах, но используется он
только в нетерминалах верхнего уровня. Аналогично в случае t.VarTable, которая тоже не везде исполь-
зуется. Однако, все функции принимают t.ErrorList t.Lexer и t.NextToken. Вышеназванные балластные
элементы находятся между t.ErrorList и t.Lexer, поэтому приходится балластные элементы передавать.
  Дело не в тех иллюзорных тактах процессора, требуемых на распознавание этих элементов, а в том,
что (а) удлиняется код -- на экране элементарно влезает меньше, (б) усложняется код -- необходимо
следить за правильной передачей тех данных, которые не используются.
  Проблема явила свою гадкую личину после того, как я написал универсальные функции для распозна-
вания квалифицированных имён. Формат этих функций не был приспособлен для работы с форматом, содер-
жащим таблицу локальных переменных. Поэтому для использования внутри выражений приходилось (не)ес-
тественным образом таблицу локальных переменных прятать в стек.
  Ожидаемые результаты. Новый формат позволит не передавать во внутренние функции балластные аргу-
менты. Например, если функция NFn1 принимает t.IModule, а функция NFn2 его не принимает, то можно
записать:
  t.IModule e.Stack t.ErrorList t.Lexer t.NextToken =
    <NFn1
      t.IModule
      e.ParentStack
      <NFn2
        e.LocalStack
        t.ErrorList t.Lexer t.NextToken
      >
    >
вместо
  t.ErrorList t.IModule (e.Stack) t.Lexer t.NextToken =
    <NFn1
      <NFn2
        t.ErrorList t.IModule
        (e.LocalStack (e.ParentStack))
        t.Lexer t.NextToken
      >
    >
  Вторым преимуществом является упрощение соглашения о вызовах функций. Стек в данном случае рас-
тёт справа, поэтому можно принять соглашение о том, что функция, распознающая нетерминал всегда нахо-
дится на вершине стека. Родительский стек автоматически конкатенируется с дочерним.


[23.06.2008 - 21:36:49,43]
  Сейчас список TODO полегчает немного.
  Все нижеперечисленные TODO выполнены.

  [DONE: Продумать квалификацию точкой]
  Забавно то, что в комментарии к этому TODO я планировал решить этот вопрос только после выхода
версии 0.2. Уже давно продумано и даже реализовано. О том, как это было реализовано, написано в DONE
к Синтаксис указателей на функции. Вполне неплохо получилось.

  [DONE: Синтаксис для указателей на функции]
  Реализован в полном соответствии с TODO. Однако, нетерминал FnPtr распознаётся не отдельной цели-
ковой функцией, а по кусочкам -- кусочки в распознавателях выражений NPatternExpr и NResultExpr (на-
чинается с обнаружения амперсенда или идентификатора) и в NCallable.
  Про вариант синтаксиса < & Module.Function ... > я сначала забыл (поэтому он не определяется ста-
бильной версией), а потом всё-таки вспомнил.

  [DONE: Пересмотреть Parser]
  Parser пересмотрел, переворошил, интерфейс нетерминалов частично унифицировал. Однако, стек для
распознавателей выражений я не переделывал, т.к. он пока и так выполняет свои обязанности и допускает
расширение. Привожу шапку из Parser'а (в дальнейшем она может измениться).

/*------------------------------------------------------------------------------
  Функции синтаксического анализа делятся на три категории:
  (1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
  После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
  (2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
  (3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

  Формат функций-распознавателей работает в соответствии с TODO Переворошить Parser -- форматы фун-
кций.

  [DONE: Новая стабильная версия]
  Стабильная версия написана. Стабильная версия поддерживает как указатели на функции в новом сти-
ле: с '&' и без '&' в случае явно написанного квалифицированного имени. Однако, как уже сказано выше,
стабильная версия не поддерживает синтаксис < & Module.Function ... >.
  Стабильная версия имеет номер версии 0.1.951.
  По сравнению с предыдущей стабильной версией, в этой стабильной версии полностью поддерживаются
АТД (разумеется, без спецификаций переменных, я их в версию 0.2 добавлять не планирую). Папка и рас-
ширение выходных файлов этой стабильной версии соответственно ROutS и .srout.

  [DONE: Переворошить Parser -- форматы функций]
  Форматы функций, распознающих нетерминалы, написаны в соответствии с TODO. Однако есть здесь два
варианта стека: тот, который описан в TODO, и оставшийся со старых времён стек в скобках для распоз-
навателей выражений.

  [TODO: Удалить поддержку FnPtr]
  Закономерное следствие введения синтаксиса указателей на функции и поддержки этого синтаксиса.
Стабильная версия поддерживает оба варианта получения FnPtr, поэтому можно вызовы FnPtr постепенно
удалить и заменить на нормальный человеческий синтаксис.


[23.06.2008 - 23:01:39,17]

  [DONE: Удалить поддержку FnPtr]
  Удалил из парсера поддержку FnPtr и парсер полегчал на 88 строк программного кода. Также заменил
все вызовы <FnPtr ... > в исходных кодах компилятора на конструкцию с амперсандом.


[05.07.2008 - 13:29:02,69]

  [TODO: Разбить Parser на модули]
  Кратко. Разбить модуль парсера на три модуля: mParser_Common.mref, mParser_Source.mref,
mParser_Sym.mref.
  Мотивация. Модуль MParser прямо или косвенно импортируется следующими модулями: MSymModule,
Compiler, MStartupSeqGenerator, MLinker_Refal5, MBackEnd_Refal5_init, MFrontEnd_MRefal. И при каждом
изменении парсера для всех этих модулей проходит каскадная перекомпиляция. Дело в том, что модуль
MParser выполняет две похожие задачи: анализ и распознавание файла исходного текста и файла символи-
ческой информации. Эти две задачи объединяет то, что код их реализации имеет очень много компонентов,
поэтому они реализуются в одном модуле.
  Поэтому надо разделить код из модуля MParser на три разных модуля: модуль для распознавания общих
нетерминалов, модули для распознавания исходного и символического файлов. В принципе, можно было бы
объединить модули с общими термами и распознавания символических файлов, т.к. для распознавания пос-
ледних нужно только две специализированные функции: тело модуля и объявление функции. Однако, это ре-
шение мне кажется непоследовательным, т.к. объединяются модули только по признаку объёма файла, а не
по смыслу.
  Вообще, решение об разделении одного модуля на три мне кажется больше техническим, нежели концеп-
туальным. Ведь после разделения связь между модулем с общими средствами и модулями распознавания фай-
лов будет большой (определяется количеством используемых entry-функций). Но, с другой стороны, сейчас
модуль парсера является самым большим среди всех исходных файлов проекта (45594 байта). Поэтому для
удобства работы с ним его надо разбить на несколько маленьких.

  [TODO: Продумать введение тега "Продумать"]
  Очень много TODO в журнале проекта содержат в заголовке слова "продумать", "обдумать". Тег TODO
семантически предназначен для описания задач, которые в конце концов должны быть решены в виде исход-
ного кода. Тег ERROR предназначен для описания ошибок, требующих исправления. Однако, как уже было
сказано, теги TODO со словами в заголовке типа "продумать" предназначены не для описания тех задач,
которые следует закодировать, а для задач, для которых ещё надо найти форму для воплощения. Поэтому
имеет смысл ввести тег ПРОДУМАТЬ для тех задач, решение которых представляет собой проектное решение
или ответ на вопрос, а не написанный код. При чём если в результате обдумывания некоторой возможнос-
ти я приду к выводу, что реализовывать эту возможность совсем не нужно, я могу закрыть этот тег с
обоснованием ненужности. Тот же случай в теге TODO/DONE выглядит противоречиво: в теге "сделано" опи-
сывается то, что не сделано и не будет сделано никогда.
  Эту TODO легко реализовать в коде, но есть одно препятствие, которое надо преодолеть прежде, чем
закодировать. Это имена для указанных тегов. Вариант THINK/THINKED выглядит как-то не красиво.
  Другая мысль. Указанный тег можно было бы закрывать не только специальным закрывающим тегом, но и
тегом TODO, если в результате обдумывания появилось решение, которое можно воплотить в коде. Можно
ввести специально различные закрывающие теги для описания положительных и отрицательных резолюций по
поводу вносимых изменений, это позволит яснее определять те решения, которые в процессе работы были
отклонены.
  Возможно, не стоит ограничиваться только англоязычными тегами. Можно даже наоборот, для TODO/DONE
ERROR/FIXED CHANGED ввести синонимы СДЕЛАТЬ/ГОТОВО ОШИБКА/ИСПРАВЛЕНО ИЗМЕНЕНИЯ.
  В общем, надо продумать детали.


[05.07.2008 - 15:53:28,01]

  [DONE: Разбить Parser на модули]
  Теперь в проекте вместо модуля MParser имеются три модуля MParser_Common, MParser_MRefal,
MParser_Sym. В принципе, сделано всё в соответствии с TODO.


[05.07.2008 - 20:27:00,31]

  [DONE: Продумать детали перевода IModule на квалифицированные имена]
  [TODO: Додумать детали перевода IModule на квалифицированные имена]
  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.


[05.07.2008 - 23:58:33,14]

  [CHANGED: Отступ в два пробела]
  Недавно узнал, что у нас на кафедре при программировании на Си++ требуется делать отступы в два
пробела (при чём пробелами и ни в коем случае не табуляцией). Чтобы исследовать на себе этот стиль,
я установил в настройках Far'а табуляцию в два пробела, замена всех табуляций пробелом (заменяет при
сохранении файла), а также макрос Пробел-Backspace на кнопку табуляции. Привыкаю потихоньку.

  [TODO: Частично перевести IModule на квалифицированные имена]
  [TODO: Подготовиться к переходу на пакеты]
  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.


[06.07.2008 - 13:15:05,41]

  [ERROR: Конфликт имён между псевдонимом модуля и функцией]
  Если в файле исходного текста одновременно присутствуют функция и псевдоним модуля с одинаковым
именем, то компилятор умирает с ошибкой. А на самом деле должна выскакивать ошибка переопределения
имени. Причина ошибки в том, что IModule индексируется по полным именам импортируемых модулей, а не
по их псевдонимам. Надо это исправить.

  [TODO: Создать средство для поиска модулей, подлежащих линковке]
  Нужно создать средство, которое по заданному имени корневого модуля находит все модули, от которых
зависит данный модуль, при чём в топологическом порядке от зависимых к зависящим.


[07.07.2008 -  2:08:58,93]

  [ERROR: Плохо проверяется попытка переопределения]
  Внутри одного исходного файла можно определить две функции, два АТД, два импорта с одинаковым име-
нем, лишь бы их виды (Kinds) совпадали. Проверка на переопределение выполняется только для сущностей
разных видов.


[14.07.2008 - 20:42:05,95]

  [DONE: eXpression eXchange in/out]
  Написал модуль для средств обмена выражениями. Для XXIO формата принят следующий синтаксис:
  * Структурные скобки ( ) отображаются соответственно в '(' ')'.
  * Объектные скобки '(' ')' отображаются соответственно в '#(' '#)'
  * Символы табуляции и новой строки отображаются соответственно в '\t' и '\n'.
  * Символы с кодами от 33 до 127 отображаются как есть.
  * Остальные символы отображаются как '\dNNN', где NNN -- трёхзначный десятичный код символа.
  * Макроцифры отображаются в '#число ', где число -- десятичное представление числа.
  Если в исходном выражении были идентификаторы или АТД-термы, то функция сохранения MXXIO::Save
сохранения файла не выполняет, возвращает Fails.
  При обнаружении первой же ошибки во входном файле разбор файла прекращается, функция MXXIO::Load
возвращает Fails.
  При чтении файла не имеет значения разбиение исходного файла на строки, при записи файл разбива-
ется на строки длиной 63 символа.

  [CHANGED: Устранены MRefalRTS::Lenw и MRefalRTS::ExistFile-T]
  Из модуля поддержки времени выполнения удалены эти две функции, которые не используются в библио-
течных модулях. Когда-то я удалял Lenw, но, видимо или не до конца удалил. Или забыл всё-таки уда-
лить из самого MRefalRTS, или случайно когда-то потёр MRefalRTS и восстановил старую версию.


[22.09.2008 - 23:27:35,87]

  После долгого перерыва несколько новых идей.

  [TODO: Продумать back-end C++]
  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.

  [TODO: Продумать генераторы лексического и синтаксического анализаторов]
  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.

  [TODO: Продумать двухуровневую структуру синтаксического анализа]
  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.

  [TODO: Продумать изменения в лексике и комментариях]
  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.


[23.09.2008 - 12:50:36,46]

  [TODO: Продумать блоки $INIT и $FINAL]
  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.



[15.10.2008 - 22:39:31,17]

  [CHANGED: ПИ: Расширения в нижнем регистре]
  Меняю спецификацию. Теперь расширения должны быть в нижнем регистре. Подробности в файле специфи-
кации "Поиск исходников.txt".
  Мотивация. Искать файлы с расширениями, различающимися регистром, неэффективно.


[17.10.2008 - 22:58:13,00]

  [CHANGED: ПИ: Конфликт между именами импортируемых модулей и модулей в командной строке]
  Проблема такая. В спецификации указано, что модули, перечисленные в командной строке, являются как
бы "головными". Если в командной строке указан головной модуль, который компилируется в отдельный
exe-шник, то он образует проект. Если же указан не головной модуль, то подлежит компиляции он и все
зависимые от него модули. В любом случае каждый модуль в командной строке образует "гроздь" из зави-
симых модулей. В принципе, эти "гроздья" могут частично пересекаться или даже вкладываться друг в
друга. Для всех гроздей имеется одинаковая переменная MODULEPATH, одинаковый набор back- и front-
end'ов. Поэтому можно предположить (а я так для этого молчаливо и полагал, не отражая свои мысли в
журнале или спецификациях) что модули, одновременно присутсвующие в нескольких "гроздьях", должны
быть обработаны только однократно и при обработке последующей "грозди" можно воспользоваться обрабо-
танными модулями из предыдущих "гроздей".
  Но тут возникает проблема. Правила поиска модулей по квалифицированному имени (когда ищется импор-
тируемый модуль) и правила поиска модулей, указанных в командной строке различаются. Поэтому если
модуль импортируется, то он может быть найден по одному пути, если же он указан в командной строке,
то имея то же квалифицированное имя, может находиться по другому пути. Пример.
  compile_mr /* разные опции, MODULEPATH=".;D:\MyLib;C:\MR" */ MainModule.mref C:\MR\SubModule.mref

  $PROGRAM MainModule;
  
  $IMPORT SubModule;

  /* прочий код */;

  $END MainModule.

  В данном случае, если SubModule находится в текущей папке или папке D:\MyLib, то как импортируемый
модуль он не будет обнаружен в папке C:\MR, но по правилам поиска модуля, указанного в командной
строке, будет SubModule должен быть найден в папке C:\MR (должен быть, иначе произойдёт ошибка ком-
пиляции "Модуль не найден"). Возникает конфликт.

  Решение проблемы. Предполагается следующее решение. Сначала производится поиск (только поиск без
компиляции или анализа) модулей, перечисленных в командной строке. Их местоположения запоминаются.
В дальнейшем производится последовательная компиляция этих модулей. Теперь, если где-либо в списке
импорта будет указан тот же модуль, что и тот, который указан в командной строке, будет использо-
ваться модуль, указаннный в командной строке. Т.е. для примера выше модулем MainModule.mref будет
импотирован модуль C:\MR\SubModule.mref.


[18.10.2008 - 21:53:30,07]

  [TODO: Разработать функцию поиска импортируемого модуля]
  [TODO: Разработать функцию поиска модуля из командной строки]
  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.


[18.10.2008 - 23:54:58,07]

  [FIXED: Конфликт имён между псевдонимом модуля и функцией]
  [FIXED: Плохо проверяется попытка переопределения]
  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.


[08.11.2008 - 19:37:27,98]

  [TODO: Контекст индексируется по именам в нижнем регистре]
  Мотивация. Согласно спецификации модули и пакеты, находящиеся в одном проекте (в принципе, это
правило можно распространить и на весь набор проектов, компилируемых за раз), не могут иметь имена,
различающиеся лишь регистром. Однако, полное квалифицированное имя того модуля, который импортиру-
ется, должно быть известно точно: имя в директиве $IMPORT и имя импортируемого модуля в директивах
$MODULE и $END (как в исходных, так и в sym-файлах) должны совпадать с учётом регистра. Поэтому
имеет смысл индексировать контекст именами без учёта регистра (например, приведя все имена в верх-
ний или нижний регистр), но при этом в контексте хранить сведения о настоящем имени модуля (если
таковое известно -- модуль компилировался или читался его sym-файл).
  Цель. Индексировать контекст именами в нижнем регистре, при этом храня информацию о дествитель-
ном имени модуля (если таковая имеется). При попытке индексировать квалифицированным именем кон-
текст должно проверяться соответствие имени на входе настоящему имени, если таковое известно.
  /* И опять список заданий и ошибок не влезает на один экран :-). */


[09.11.2008 - 22:05:55,79]

  [CHANGED: Организация файлов спецификаций]
  Ранее я однажды редактировал спецификацию "Поиск исходников", старый текст при этом я "закомменти-
ровал", добавления и изменения я пометил "комментариями" (комментарии Си и Си++). Очевидно, что при
дальнейшей модификации спецификации, под навалом комментариев трудно будет почитать сам текст. Поэ-
тому я восстановил как предыдущий вариант, так и текущий, очистив их от комментариев и переименовав
их в соответственно "Поиск исходников.01.txt" и "Поиск исходников.02.txt". При дальнейшем развитии
спецификации я буду создавать файлы с номерами 03, 04 и так далее. Эволюцию спецификаций можно от-
следить программой fc.

  [DONE: Разработать функцию поиска импортируемого модуля]
  [DONE: Разработать функцию поиска модуля из командной строки]
  [DONE: ПИ:Написать функцию для поиска модулей]
  [DONE: ПИ:Обработка командной строки]
  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.

  [DONE: Контекст индексируется по именам в нижнем регистре]
  Указанная схема реализована, но только пока не используется: нигде в программе не устанавливается
атрибут RealName, поэтому теперь контекст индексируется только по неквалифицированным именам.


[11.11.2008 - 13:18:37.09]

  [DONE: Создать средство для поиска модулей, подлежащих линковке]
  Такое средство создано -- это функция MClusters::ListForLinking. По заданному корневому имени она
находит все зависимые имена и сортирует их в топологическом порядке. Формат функции
  <MClusters::ListForLinking t.hContext t.RootModule>
    == t.hContext Success e.Modules
    == t.hContext Fails
  Функция завершается неуспешно если хотя бы один из модулей в "грозди", растущей из t.RootModule
не был откомпилирован или обновлён, а также если среди модулей каким-то чудом оказались циклические
зависимости. Теперь можно удалить из контекста функции LastModule и GetProgName.


[18.11.2008 - 23:56:49,37]

  [DONE: Создать модуль для оценки необходимости перекомпиляции]
  [DONE: ПИ:Написать средства для оценки необходимости перекомпиляции]
  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


[25.11.2008 - 15:52:21,87]

  [ERROR: Не определяется обновлённость импортированного модуля]
  Согласно спецификации, перекомпиляция модуля должна осуществляться в случае, если исходные тексты
импортируемых модулей или выходные файлы импортируемых библиотек обновлены позже рассматриваемого
модуля. Для исходных текстов это правило не выполняется, для библиотек -- ещё не проверял. Надо ис-
править.

  [DONE: Механизм поиска модулей]
  [DONE: Использование нескольких front-end и back-end]
  [DONE: Модуль-программа]
  [DONE: SymInfo как АТД]
  [DONE: Переписать драйвер]
  [DONE: Перейти от модуля Context к модулю MContext]
  [DONE: Искать имя программы другим способом]
  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


[07.12.2008 - 13:40:55,38]

  [DONE: Продумать введение тега "Продумать"]
  Ограничимся пока введением пары тегов TOTHINK/THINKED, причём тег TOTHINK можно закрывать и одно-
имённым тегом TODO, когда результатом обдумывания является готовое задание.



[07.12.2008 - 20:30:08,12]

  [DONE: Расширить утилиту TODO_list]
  [TOTHINK: Отдельно собирать информацию об ошибках в журнале проекта]
  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.


[Џ­ 08.12.2008 - 19:19:37.31]

  [DONE: Новая модель модулей]
  [DONE: Иерархия в стиле Java]
  [DONE: Добавление категории "квалифицированное имя"]
  [DONE: Перевести Parser на квалифицированные имена]
  [DONE: ПИ:Полная поддержка parser'ом квалифицированных имён]
  [DONE: Перевести IModule на квалифицированные имена]
  [DONE: Додумать детали перевода IModule на квалифицированные имена]
  [DONE: Частично перевести IModule на квалифицированные имена]
  [DONE: Подготовиться к переходу на пакеты]
  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.

  [FIXED: Не определяется обновлённость импортированного модуля]
  Теперь всё определяется. И для случая с библиотеками, и для случая с простыми модулями. И всё ра-
ботает в соответствии со спецификацией.

  [TODO: Стандартные модули контейнеров и распространённых функций]
  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.

  [TODO: Стабильная версия и сценарии make]
  Данное TODO подразумевает, что надо создать новую стабильную версию (которая будет поддерживать
пакеты) и обновить файлы make, чтобы иметь возможность пересобрать проект, т.к. имеющиеся уже уста-
рели.

  [TODO: Изменить обработку командной строки]
  Практически все вышеперечисленные пункты поддерживаются, кроме последнего (пока нет необходимости
выбирать back-end -- выбор сильно ограничен :-)), но поддерживаются они криво. В случае неверной ко-
мандной строки компилятор просто рушится с выдачей дампа. За образец можно взять обработку командной
строки из утилиты TODO_list, которую я недавно переписал с нуля.


[09.12.2008 -  0:37:17,92]

  [TODO: Пересмотреть/переписать mOutModuleStatus.mref]
  Добавить также строчку вывода Recompiled, заменяющую последовательный вывод Compiling/Compiled для
одного и того же модуля.


[04.01.2009 - 17:54:39,75]

  [DONE: ПИ:Режимы "только связывание" и "полной перекомпиляции"]
  Появились соответсвующие режимы в полном соответствии со спецификацией "Поиск исходников02.txt" и
с текущим TODO. Командная строка имеет следущий синтаксис:

  refgo /* опции для refgo */ mrefal РЕЖИМ "=MP:MP-КАТАЛОГИ" ИМЕНА МОДУЛЕЙ

где РЕЖИМ -- одно из +make+, +build+, +linkonly+; MP-КАТАЛОГИ -- имена MP-каталогов, перечисленных
через точку с запятой; ИМЕНА МОДУЛЕЙ -- имена модулей, которые являются "корнями" "гроздей", подле-
жащих компиляции.

  О внутреней реализации.
  Изнутри в контектсте модуль характеризуются двумя параметрами: статусом (Status) и типом (Type).
Названия параметров не очень удачные, но на большее фантазии не хватило. Статус определяется уров-
нем, на котором уже обработан модуль (статусы Found, Raw, Ready устанавливаются в модулях MModules,
MClusters и MCompiler соответственно).

  (*) Модуль MModules для запроса состояния-типа (информация о статусе и типе) имеет функцию Lookup\
ImportModule. Данная функция для модуля с заданным квалифицированным именем возвращает его статус и
тип, причём если модуль был заранее известен (имелся в контексте), то возвращается его статус-тип.
Иначе, запускается процедура поиска модуля в соответствии со спецификацией. По завершении поиска
возвращается статус Found и соответствующий тип (см. ниже). Эти же статус-тип добавляются в кон-
текст. Для запроса статус-типа используется функция MContext::GetStatusType.
  (*) Модуль MClusters для запроса состояния-типа использует семейство функций CheckNeedCompile-??,
где ?? -- это Make, Build или LinkOnly. Именно на этом уровне происходит разделение режимов работы
компилятора. Для запроса статус-типа используется функция MModules::LookupImportModule. Если пос-
ледняя функция возвращает статус Found, то на уровне модуля MClusters производится обработка и ана-
лиз данного модуля, после которой модуль получает статус Raw. На уровне MClusters модули не подвер-
гаются компиляции, осуществляется только поиск модулей и анализ их типа.
  (*) Модуль MCompiler уже производит компиляцию модулей, если это необходимо. Для получения статус-
типа используется одна из трёх функций предыдущего уровня. На начальном уровне выбирается функция-
запросчик, которая затем по указателю передаётся во все функции обработки. После завершения обработ-
ки модуля (компиляция, подтверждение обновлённости или библиотечности, обнаружение ошибок), модуль
получает статус Ready.

  Тип определяет разновидность модуля по характеру его обработки:
  (*) Тип Errors устанавливается в случае, если при обработке модулей произошла ошибка (Found Errors
-- модуль не найден, Raw Errors -- был Found Errors или в данном режиме имел недопустимый Found-тип,
Ready Errors -- был Raw Errors или произошла ошибка в процессе обработки).
  (*) Тип Changed означает, что модуль должен быть перекомпилирован, т.к. изменялся после предыдущей
перекомпиляции.
  (*) Тип Updated означает, что модуль можно не перекомпилировать, т.к. модуль имеет полный набор
корреткных выходных файлов, которые не изменялись после предыдущей компиляции.
  (*) Тип Library означает, что модуль является библиотечным, т.е. отстутствует файл исходного текс-
та, но при этом все выходные файлы корректны.

  Стратегия обработки.
  (*) На уровне Found модуль только обнаруживается, тип Updated устанавливается для всех модулей, у
которых присутствуют все выходные файлы и присутствует файл исходного текста. Если отсутствует хотя
бы один из выходных файлов, устанавливается тип Changed, файл исходного текста -- тип Library. Если
модуль найти не удалось -- тип Errors.
  (*) На уровне Raw в зависимости от текущего режима уточняется тип модуля. Если модуль имел до это-
го тип Errors, то он и остаётся.
  В режиме полной перекомпиляции (когда должны быть перекомпилированы все модули), модули имевшие до
этого тип Updated, получают тип Changed. Типы Changed и Library сохраняются.
  В режиме только перекомпоновки все модули, входящие в проект, должны быть найдены и скомпонованы в
конечный .exe-шник. При этом перекомпиляция не требуется. В данном режиме тип Changed заменяется на
Errors, т.к. невозможно слинковать проект, в котором отсутствуют хотя бы один выходной файл. Осталь-
ные типы сохраняются.
  В режиме частичной перекомпиляции типы Errors, Changed и Library сохраняются без изменений. Для
модулей типа Updated производится сначала анализ времени последнего изменения самого модуля (его ис-
ходных и выходных файлов), затем производится анализ импортируемых модулей -- нет ли среди них моду-
лей, имеющих тип Changed (независимо от статуса это означает необходимость перекомпиляции) или тип
Errors. Т.к. в модуль MClusters t.hErrorList не спускается, то в случае импорта ошибочных модулей
возвращается (на всякий случай) режим Changed, чтобы при перекомпиляции на уровне Ready ошибка была
обнаружена. Аналогично обрабатывается ошибка при рекурсивных зависимостях. Если же все импортируемые
модули являются Raw/Ready Updated/Library, то сравнивается время последнего изменения импортируемых
модулей и времени последнего изменения обрабатываемого модуля. На его основе выносится окончательный
вердикт.
  (*) На уровне Ready для модулей Raw Changed производится перекомпиляция и анализ зависимых модулей,
для модулей Raw Updated/Library просто анализируются зависимостей. При этом модуль Raw Changed может
зависеть только от модулей типа Changed/Updated/Library независимо от статуса (для модулей статуса
Raw производится анализ и установка статуса Ready), модуль типа Raw Updated может зависеть только от
модулей Updated/Library, библиотечный модуль может зависеть только от библиотечных. 

  [DONE: Стабильная версия и сценарии make]
  После завершения работы над встроенной утилитой make я обновил стабильную версию и файлы make.bat
и make-s.bat. При этом номер весии был поднят до 0.1.959. Ранее я не мог поднять номер версии, т.к.
bat-файлы не были обновлены для поддержки новой командной строки, а обновлять "руки не доходили".



[05.01.2009 - 18:08:30,74]

  [FIXED: Возможна ошибка при чтении папок]
  Данная ошибка исправлена -- реализована соответствующая программа. Работает в почти полном соот-
ветствии с описанием в ERROR, за тем исключением, что имя этой утилиты mr-extent.exe и она при не-
правильном аргументе на stdout выводит E. При запросах INFO и LIST первым термом вывода (вывод в
stdout осуществляется в формате XXIO) является символ S.


[05.01.2009 - 21:31:08,54]

  [TODO: АТД "Конфигурация"]
  Предполагается ввести абстрактный тип данных (по аналогии с контекстом), хранящий текущую конфигу-
рацию программы, т.е. сведения о front- и back-end'ах (расширения, подпапки, callback-функции), све-
дения об окружении (MP-каталоги, режим работы: полная перекомпиляция, частичная перекомпиляция, то-
лько сборка). Данный АТД дескриптором считать не будем, чтобы после инициализации его можно было ко-
пировать и удалять нужное число раз -- т.к. после создания необходимости в его пополнении/модифика-
ции быть не должно. Конфигурация должна инициализироваться в парсере командной строки (который тоже
должен быть написан) и в дальнейшем оставаться неизменной.

  [ERROR: Функция MOS::Exit и финализаторы]
  На данный момент функция MOS::Exit перенаправляет вызов к одноимённой функции модуля MRefalRTS,
которая в свою очередь, перенаправляет вызов к функции Exit Рефала 5. Поэтому, если в программе име-
ются модули с нетривиальной инициализацией (которая устанавливает некоторый инвариант) и нетривиаль-
ной финализацией (которая разрушает этот инвариант), финализаторы при вызове функции Exit не вызыва-
ются.
  Необходимо продумать пути исправления и исправить данную ошибку.
  Возможен такой вариант. Линковщик собирает все вызовы функций финализации в некоторую с заранее
известным именем. Далее, эту же функцию вызывает функция MRefalRTS::Exit. Недостаток этого варианта
в том, что при вызове функции Exit из финализатора поведение программы будет неопределено (хотя фак-
тически она зависнет). К тому же, при вызове функции Exit из инициализатора будут вызваны финализа-
торы ещё не инициализированных модулей.
  Другой вариант состоит в том, что список функций-финализаторов заносится в копилку Рефала 5 под
некоторым именем, каждый из финализаторов заносится в момент выполнения функции инициализации соот-
ветствующего модуля (стековая архитектура копилки для этого подходит чрезвычайно хорошо). Затем,
после выполнения функции Go происходит вызов <MRefalRTS::Exit s.RetCode> с s.RetCode == 0, который,
если стек финализаторов в копилке не пуст, вызывает финализатор с верхушки и за тем себя же
(<MRefalRTS::Exit s.RetCode>), если же стек пуст -- вызывается <Exit s.RetCode>. Данный метод хорош
тем, что позволяет безопасно вызвать Exit в инициализаторах и финализаторах. Недостаток в том, что
обработка инициализаторов усложняется (нужно определённым образом вставлять в них код сохранения фи-
нализатора).



[05.01.2009 - 22:47:50,90]

  [DONE: Пересмотреть/переписать mOutModuleStatus.mref]
  Пересмотрел код вывода сообщений. Написан он достаточно прилично, поэтому переписывать необходи-
мости нет. Код обработки Recompiled также написал. Всё работает.


[01.02.2009 -  2:38:40,13]

  [CHANGED: Добавлены теги +TODO, +ERROR, +TOTHINK]
  Смысл этих тегов в том, что эти теги не перемещают записи в файлах TODOs.txt и LIST.txt при пов-
торении, в отличие от одноимённых тегов без знака плюс.


[01.02.2009 - 20:00:56,79]

  [TODO: Переупорядочить список приоритетных задач]
  Работа над таблицей перекрёстных ссылок завершена ещё в новогодние выходные. Поэтому, если я сей-
час завершу это TODO, то формально получится так, что необходимо повысить номер версии до 0.2 (т.к.
это -- последнее TODO между скобками). Однако, с тех пор, когда я составил список приоритетных за-
дач, ситуация сильно изменилась. Поэтому необходимо обновить этот список. Обновлять я его буду тем
же путём, что и раньше при создании списка. Теперь за счёт использования тегов со знаком '+' стало
возможным обновлять сведения о задаче, не перемещая её в списке. Этим и воспользуюсь.


[01.02.2009 - 21:42:25,09]

  [DONE: Переупорядочить список приоритетных задач]
  Этим я займусь ниже (см. в журнале проекта, в экстрактах этого не видно).

  [TODO: //== Список приоритетных TODO ==\\]
  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.

  [+TODO: RASL и интерпретатор]
  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.

  [+TODO: Удалить MRefalRTS::Put]
  Можно и удалить. Ведь, если необходимо, всегда можно добавить. На данный момент функцией MSelfDi\
ag::Log-T я пользуюсь довольно редко. Чаще я с целью трассировки функции Func пишу следующий код:

// До трассировки

Func {
  // Тело функции Func. Формат функции такой: <Func t.X e.Y (e.Z)> == ...
}

// После трассировки

Func
  t.X e.Y (e.Z) =
    <MSelfDiag::Log>
    <MSelfDiag::Log '<Func>'>
    <MSelfDiag::Log '  t.X = ' t.X>
    <MSelfDiag::Log '  e.Y = ' e.Y>
    <MSelfDiag::Log '  e.Z = ' e.Z>
    <?Func t.X e.Y (e.Z)>;

?Func {
  // Тело функции Func.
}

  Очевидно, что вместо этого лучше включить в язык/компилятор нормальное средство трассировки, но
я сейчас не буду описывать это как TODO. Т.к. (а) до выхода версии 0.2 я не собираюсь изменять син-
таксист, (б) запись прямо здесь этого как TODO сделает его приоритетным. Пункт (б) не критичен, т.к.
описать TODO можно и после закрывающей скобки.

  [DONE: Таблица перекрёстных ссылок]
  Сделано. Реализовано как отдельный back-end, который на данный момент включен всегда (т.е. его
нельзя отключить), при проработке командной строки этот недостаток будет устранён. Выходные файлы
помещаются в каталог ~XLinx, расширение .xlinx. Информация о перекрёстных ссылках помещается в
Info/%exename%.xlinx.txt. Из тех возможностей, которые хотелось бы реализовать, но не реализованы,
можно назвать получение списка нелинкованных элементов и обобщение перекрёстных ссылок при одновре-
менной компиляции нескольких "гроздей".

  [+TODO: Продумать упрощение структуры Lexer'а и Parser'а]
  [+TODO: Продумать генераторы лексического и синтаксического анализаторов]
  [+TODO: Продумать двухуровневую структуру синтаксического анализа]
  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.

  [TODO: Вынести из компилятора метаданные]
  Данная задача будет частично (а может даже и полностью) выполнена при выполнении TODO АТД "Конфи-
гурация". Данное АТД будет создаваться после анализа командной строки, но до того, как будет прово-
диться анализ модулей; АТД как раз и будет содержать то, что здесь названо как "метаданные".

  [TODO: Ввести особый тип компоновки для особых функций]
  [TODO: Продумать блоки $INIT и $FINAL]
  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).

  [+TODO: При компоновке заменять самые примитивные функции на функции Рефала-5]
  Сейчас, когда были достигнуты определённые успехи в генерации кода на Си++, выглядит уже малоперс-
пективным развитие back-end'а Рефала 5. Поэтому дальнейшие усилия на этом пути не кажутся необходи-
мыми и приоритетными. Поэтому данное TODO я к приоритетным не отношу.

  [TODO: ПИ:Проверять корректность имени модуля/пакета]
  [TODO: Продумать максимальную длину имени модуля]
  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.

  [TODO: ПИ:Поддержка переменной MODULEPATH с проверкой корректности]
  [TOTHINK: Ограничения на MODULEPATH]
  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.

  [TODO: Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов]
  Помимо этого необходима функция, способная распарсить имя папки на сегменты вида t.RootMode
(e.NameSegment), где t.RootMode ::= (Relative) | (Relative-Disk s.Disk) | (Absolut) | (Absolut-Disk
s.Disk) | (Absolut-Net e.Server), соответственно для 'Dir/File', 'C:Dir/File', '/Dir/File', 'C:/Dir'
'/File', '//SERVER/Dir/File'. Очевидно, поведение этой функциии будет зависеть от используемой опе-
рационной системы, т.к. в POSIX-системах имя папки может содержать любые символы, кроме 0x00 и пря-
мого слеша.

  [TODO: ПИ:Хранить в контексте также информацию о пакетах]
  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.

  [+TODO: Обдумать введение видов для квалифицированных имён]
  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.

  [TODO: Продумать back-end C++]
  Если я буду представлять версию 0.2 широкой общественности (списку рассылки Рефала), то реализо-
вать генерацию сишного кода необходимо. Удобнее, конечно, вариант с генерацией самим компилятором
Модульного Рефала Си++-файлов, но вариант с генерацией файлов Простого Рефала проще в реализации
(хотя для этого придётся расширять Простой Рефал аналогом квалифицированных имён, АТД, статическими
ящиками). Как обычно, ничто не мешает совмещать оба подхода в разных back-end'ах.
  Поэтому надо продумать необходимость этого средства в версии 0.2.

  [+TODO: Продумать изменения в лексике и комментариях]
  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.

  [+TOTHINK: Отдельно собирать информацию об ошибках в журнале проекта]
  К версии 0.2 непосредстенно не относится.

  [TODO: Стандартные модули контейнеров и распространённых функций]
  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.

  [TODO: Изменить обработку командной строки]
  Безусловно необходимо для выпуска версии 0.2.

  [TODO: АТД "Конфигурация"]
  Необходимо для выпуска версии 0.2, т.к. это является частью поддержки модулей и "мультикомпиляции"
(несколько front- и back-end'ов).

  [ERROR: Функция MOS::Exit и финализаторы]
  Для выпуска версии 0.2 ошибку надо исправлять безусловно.

  [TODO: \\== Вот список приоритетных TODO ==//]
  Когда я выполню эти задачи, я повышу номер версии до 0.2.



[05.02.2009 -  1:25:50,27]

  [TODO: Сделать Простой Рефал частью проекта]
  Т.к. я в том и/или ином виде буду объединять Простой и Модульный Рефалы, необходимо будет "слить"
оба проекта. В данном TODO под слиянием подразумевается следующее: перенос исходников Простого Ре-
фала в подкаталог Модульного Рефала, файлов note00?.txt -- в подпапку "Простой Рефал" каталога спе-
цификаций, использование настоящего журнала также для развития Простого Рефала.

  [TODO: Реорганизация каталоговой структуры проекта]
  На данном этапе в корне каталога проекта находятся: (а) исходники компилятора и "стандартных" биб-
лиотечных модулей, (б) сопутствующих им папок с выходными файлами (~Defs, ~ROut, ~SRout, ~XLinx),
(в) каталог внутренней документации Documentation, (г) каталог подпроекта -- утилиты mr-extent,
(д) каталог сопуствующих утилит и (е) каталог MR-Home, содержащий библиотечные модули, использовае-
мые для компиляции программ, находящихся вне проекта (используется в сценарии compile_mr как одна
из MODULEPATH-папок).
  Очевидно, что (а) из всех частей проекта только исходники не оформлены как отдельные подпапки в
папке проекта и (б) исходники самого компилятора и "стандартной" библиотеки к нему перемешаны.
  Поэтому имеет смысл выделить отдельные подкаталоги для стандартных модулей и исходных файлов са-
мого компилятора. Подобным образом организованы каталоги в проекта Простой Рефал (который станет
подпроектом Модульного Рефала) -- это очень удобно.
  Кроме того, при размещении модулей по отдельным пакетам, папки, соответствующие пакетам и папки,
соответствующие отдельным частям проекта, не будут сливаться. (Папки пакетов и папки выходных фай-
лов не будут сливаться по той простой причине, что первые должны начинаться с буквы, а вторые на-
чинаются (в текущей реализации) со знака тильда).


[11.02.2009 -  0:37:17,89]

  [DONE: Реорганизация каталоговой структуры проекта]
  Реорганизация завершена. Структура каталогов теперь такая (каталоги выходных файлов и тестовых
программ не отображены):
    +---Bin
    +---Documentation
    |   +---Журнал
    |   \---Спецификации
    +---Libraries
    |   +---all.all
    |   +---all.r5
    |   +---windows.all
    |   \---windows.r5
    +---Sources
    |   +---Compiler
    |   +---Libraries
    |   |   +---all.all
    |   |   +---all.r5-b
    |   |   +---all.r5-s
    |   |   +---Projects
    |   |   +---windows.all
    |   |   +---windows.r5-b
    |   |   \---windows.r5-s
    |   +---MR-Extent
    |   \---Utilities
    \---Tests
  В папке Bin находятся исполнимые файлы компилятора и утилит (экзешник mr-extent.exe, остальные --
это rsl-файлы).
  В папке Documentation находится внутренняя документация проекта. Её структура не претерпела ника-
ких изменений.
  В папке Libraries находятся откомпилированные модули библиотечных модулей. О каталоговой структуре
этой папки будет сказано позже.
  В папке Sources находятся исходные файлы самого компилятора, библиотек, вспомогательной программы
MR-Extent и утилит.
  Подкаталоги исходных текстов библиотек имеют следующий вид: оп-система.back-end[-b|-s]. Если опе-
рационная система указана как all, то указанные модули могут использоваться для всех операционных
систем. Если в качестве back-end'а указан all, то данные библиотечные модули представлены в виде
исходных текстов Модульного Рефала и не зависят от back-end'а. Для конкретных back-end'ов использу-
ется суффикс '-b' или '-s'. Суффикс '-b' означает, что библиотечные модули не имеют исходного тек-
ста на Модульном Рефале, написаны непосредственно на выходном языке соответствующего back-end'а.
Суффикс '-s' означает, что библиотечные модули написаны на Модульном Рефале, но в то же время, не
переносятся на другие back-end'ы.


[28.02.2009 - 13:05:34,27]

  [DONE: Сделать Простой Рефал частью проекта]
  Сделано в полном соответствии с TODO.


[08.03.2009 - 12:30:50,10]

  [DONE: АТД "Конфигурация"]
  АТД "Конфиругация" реализовано в полном соответствии с TODO. На данный момент в Конфиругацию вклю-
чаются (а) список MP-каталогов, (б) информация о back- и front-end'ах и (в) режим сборки (полная пе-
рекомпиляци, частичная перекомпиляция или только компоновка). Однако, до сих пор не реализован дос-
тойный парсер командной строки.


[09.03.2009 - 13:30:36,79]

  [+TODO: Изменить обработку командной строки]
  В связи с тем, что на данный момент компилятор ориентируется генерацию кода на Рефале 5, а функ-
ция Arg при возврате аргумента командной строки игнорирует параметры, начинающиеся с дефиса ('-'),
для обозначения опций будем использовать знак '+'. Конфликта с именами модулей, подлежащих компиля-
ции в этом случае произойти не должно: имена модулей могут начинаться только на буквы латинского
алфавита или знак '!'. Будут поддерживаться следующие опции:
  '+MP' MP-каталог -- указывает каталог поиска модулей, данная опция может встречаться в командной
строке неограниченное количество раз, при этом каталоги в переменную MODULEPATH добавляются в по-
рядке перечисления.
  '+make', '+build', '+linkonly' -- определяет режим компиляции. Если ни одна из этих опций не ука-
зана, то по умолчанию предполагается режим частичной сборки. В командной строке может присутство-
вать только одна из перечисленных опций.
  '+be' имя-back-end -- определяет набор back-end'ов, используемых для генерации исполнимого файла.
Дело в том, что по низкоуровневым библиотечным файлам различные back-end'ы несовместимы (например,
если используется списковое представление объектных выражений, то функцию Length, вычисляющую дли-
ну выражения, можно описать на Рефале, в то время как для векторного представления такую функцию
целесообразнее реализовать как примитив). К тому же может так оказаться, что внешнее понимание back-
end'а может соовтествовать нескольким внутренним back-end'ам, например при генерации C++-кода .cpp-
и .h-файлам могут соответствовать два back-end'а, которые всегда должны активизироваться одновре-
менно.
  На данный момент из имён back-end'ов будет поддерживаться только 'R5' (очевидно, Рефал 5). В даль-
нейшем появится поддержка и Простого Рефала.
  Данная опция должна быть указана однократно.
  '+xlinx' -- включает генерацию таблицы перекрёстных связей. Может присутствовать не более одного
раза.
  Кроме этих опций в командной строке указываются головные имена модулей.

  [TODO: Обновить спецификацию "Поиск исходников" новым пониманием back-end'ов]
  Как было упомянуто в предыдущем TODO (Изменить обработку командной строки), существует понятие
back-end'а для пользователя и внутреннее понятие back-end'а. Для пользователя под back-end'ом под-
разумевается режим работы компилятора, при котором исполнимый файл создаётся тем или иным средст-
вом. Внутреннее понятие back-end'а включает в себя информацию о выходном расширении, выходной пап-
ке и функциях генерации и компоновки. Эти понятия нужно подробно раскрыть в спецификации.


[09.03.2009 - 22:04:18,02]

  [DONE: Изменить обработку командной строки]
  Реализована командная строка с семантикой, указанной в TODO, но с несколько отличным синтаксисом.
В частности, используются следующие опции: +MP:Каталог, +make, +build, +linkonly, +be:Back-end,
+xlinx. В качестве имени back-end'а можно использовать R5 или Refal5 с одним и тем же смыслом.


[15.04.2009 - 19:27:08,40]

  [CHANGED: Командная строка]
  Появились следующие возможности командной строки:
  (1) Префиксы '-' и '+'. В качестве префиксов опций командной строки можно использовать как символ
плюса, так и символ минуса. На данный момент, пока используется back-end Рефал 5, опции командной
строки, начинающиеся с минуса, недоступны. Но при подгрузке опций из файла (см. ниже) и в дальнейшем
при развитии компилятора (появлении других back-end'ов) опции с префиксом '-' (будут) доступны.
  (2) Опции с группой. Синтаксис
  -option ( -subopt1 -subopt2:value filename -file:finename -subopt4 ... )
для опций без параметра и
  -option:value ( ... )
для опций с параметром. Скобки должны являться отдельными аргументами командной строки -- должны
отбиваться пробелами (в случае загрузки из файла -- в отдельных строчках (см. ниже)).
  (3) Опция -file:filename.ext. Данная опция позволяет в командной строке задавать имена файлов,
начинающихся с '+' или '-'. Хотя в Модульном Рефале имена модулей не могут начинаться на знаки
препинания, имя модуля может быть указано относительным путём начиная с папки. А у папки имя мо-
жет начинаться и с '+', и с '-'.
  (4) Подгрузка опций из файла. Задаётся опцией -cfg:filename.ext. В этом случае каждая строка
соответствует аргументу командной строки, пустые строки и строки комментариев игнорируются. Коммен-
тариями являются строки, начинающиеся со знака '#', перед которым может следовать любое количество
пробельных символов.

  [DONE: Вынести из компилятора метаданные]
  Теперь компилятор поддерживает возможность тонкой настройки back- и front-end'ов. Эта возможность
реализуется параметрами командной строки -tune-be и -tune-fe. Данные опции имеют параметр -- имя
back-end'а или front-end'а соответственно, а также группу. В состав групп входит опция -ext:ext,
определяющая расширение выходного файла (для обоих видов end'ов) и опция -dir:subdir (только для
выходной части). На данный момент поддерживаются имена: Refal5, XLinx, SymInfo и MRefal.



[Џ­ 20.04.2009 - 16:00:13.96]

  [DONE: Обновить спецификацию "Поиск исходников" новым пониманием back-end'ов]
  В обновлении спецификации нет никакой необходимости, т.к. собственно, понятия back-end'а в ней не
фигурирует. Спецификация описывает лишь физическое представление модулей как файлов файловой систе-
мы и их взаимное расположение. Низкоуровневое понятие back-end'а в ней соответствует понятию выход-
ного языка или файла межмодульных связей. Высокоуровневое понятие back-end'а в ней не фигурирует,
т.к. спецификация не касается того, как формируется набор выходных языков или файлов межмодульных
связей. Поэтому, данное TODO не относится к указанной спецификации (возможно, касается какой-то дру-
гой, на данный момент не написанной).


[‚в 21.04.2009 - 13:02:07.17]

  [DONE: При компоновке заменять самые примитивные функции на функции Рефала-5]
  Не смотря на то, что дальнейшее развитие back-end'а Рефала-5 я считаю не перспективным, это TODO
было выполнено. Дело в том, что параллельно с этим TODO исправлялась ошибка, связанная с инициали-
заторами и финализаторами, так что я за одно и изменил этот аспект компоновки. Сделано в полном со-
ответствии со вторым вариантом:
  b Entry::MRefalRTS::Prout
  p Prout
(точка в конце не стоит в отличие от TODO).

  [TODO: Продумать блоки $INIT и $FINAL]
  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.

  [FIXED: Функция MOS::Exit и финализаторы]
  Одновременно с разработкой кода точек входа модуля (стартовой для головного модуля, точек инициа-
лизации и финализации для регулярного модуля) была исправлена и эта ошибка. Ошибка была исправлена
следующим путём: в объектных файлах back-end'а Рефала 5 было создано место для точек запуска моду-
лей. В объектный файл головного модуля в точку запуска помещается стартовый код, в объектный файл
регулярного модуля в точку запуска помещается код инициализации, при наличии кода финализации в объ-
ектный файл помещается функция __Finalizer, вызывающая оный код, а в точку запуска помещается после
кода инициализации код регистрации финализатора. Последняя осуществляется путём добавления указате-
ля на функцию __Finalizer в копилку под именем 'Finalizers'.
  Код функции $ENTRY Go в выходном файле Рефала 5 собирается линковщиком из кода точек запуска моду-
лей проекта в порядке от импортируемых к импортирующим и вызова функции <RefalRTS::Exit 0>.
  Функция RefalRTS::Exit если копилка с именем 'Finalizers' не пустая, вызывает самый верхний фина-
лизатор и затем рекурсивно себя, до тех пор, пока копилка не опустошится. При опустошении копилки
вызывается функция Exit Рефала 5.


  [DONE: Ввести особый тип компоновки для особых функций]
  В этом уже нет необходимости, т.к. структура компилятора изменена таким образом, что стартовый
код, код инициализации и код финализации уже не зависит от имён соответствующих функций (ранее
Go, Init и Final), а стало лишь особенностью синтаксического анализа. Так что теперь можно разрабо-
тать ситнаксис, использующий другие имена для этой цели или даже не использующий их вовсе (например,
используя директивы $START, $INIT и $FINAL, после которых следует результатное выражение.


[26.04.2009 - 12:56:39,09]

  [DONE: Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов]
  Набор указанных возможностей реализован. Реализованы следующие средства:
  (*) Поддержка структуры данных (не АТД) "Путь к файлу" в полном соответствии с TODO: выражение,
начинающееся с типа корня и содержащее элементы пути (подпапки и собственно имя файла) в скобках.
  (*) Функция конкатенации путей, указанных выше.
  (*) Для получения полного имени папки необходимо запросить у файла атрибут LongName при помощи
функции FileAttribute. Кроме того, фукция FileAttribute проверяет наличие файла.
  (*) Для унификации имени папки используются функции CanonicalPath-Str и CanonicalPath-Pt, уни-
фицирующие соответственно путь заданный обычным (s.Char*) образом или как вышеупомянутый тип.

  [+TODO: Продумать максимальную длину имени модуля]
  Сегодняшняя реализация на Модульном Рефале потенциально способна работать с именами модулей, па-
кетов или квалифицированными именами любой длины. Однако создать модуль с килобайтным именем. Слиш-
ком длинные квалифицированные имена невозможны из-за ограничений файловой системы: максимальная дли-
на пути в Windows равна 260 байтам. Поэтому при попытке создать модуль с очень длинным именем, мы
всего лишь столкнёмся с ошибкой невозможности открытия файла: программа рухнет.
  В дальнейшей перспективе при переходе на Unicode можно будет использовать UNC-имена, т.к. для та-
ких имён практически не существует ограничения на длину (максимальная длина имени -- 64К unicode-
символа, что на практике дофига).
  Поэтому необходимо продумать проверку корректности имени файлов front- и back-end'ов (с точки
зрения длины) на уровне поиска модулей, а для подобной проверки создать платформенно-зависимую
функцию проверки корректности имени (т.к. на POSIX-системах другие ограничения). В таком случае
модули с длинными именами ко входным и выходным файлам будут просто игнорироваться при поиске
(не будут найдены, даже если они есть) и обрушений программ при открытии подобных файлов можно будет
избежать.

  [DONE: ПИ:Проверять корректность имени модуля/пакета]
  Проверка осуществляется только на отсутствие знака '?' внутри квалифицированного имени модуля.
Анализ длины имени модуля пока не выполняется.
  Реализован многоуровый контроль корректности имени модуля/пакета, хотя и неполный. Контроль осу-
ществляется на двух (для Windows на трёх уровнях):
  1. На стадии поиска модуля (в модуле MModules) среди всех гипотез (front-end + место расположе-
ния) отбрасываются те, квалифицированное имя модуля которых содержит знак '?'. Таким образом, при
поиске модуля командной строки модуль с некорректным именем найден не будет. Аналогичная проверка
потенциально выполняется для импортируемого модуля, но (см. ниже) функция LookupImportModule не дол-
жна вызываться с некорректным именем.
  2. На стадии компиляции (в модуле MCompiler) при анализе импортируемых модулей некорректные имена
отбрасываются, а информация о них помещается в список ошибок.
 (3.) Для Windows-приложений отсев некорректных имён модулей, заданных в командной строке происхо-
дит ещё на стадии анализа командной строки: при преобразовании имени модуля в специальный формат
пути производится проверка имени файла на корректность.
  Проверка не полна, т.к. можно было бы проверять корректность и на стадии синтаксического анализа:
требовать, чтобы имена, указанные после директив $MODULE ($PROGRAM) и $END, а также действительные
имена импортируемых модулей (в отличие от псевдонимов) являлись корректными именами.

  [DONE: ПИ:Поддержка переменной MODULEPATH с проверкой корректности]
  Проверка корректности (ссылки вверх и вложенность) вынесены в другое задание (на данный момент в
TOTHINK), а проверка на существование каталога излишняя, т.к. в любом случае требуется наличие фай-
лов в этой папке (файла исходного текста для компилируемого модуля или всех выходных файлов для
библиотечного). Выдавать сообщение об ошибке я считаю нерациональным, т.к. на компьютер может быть
установлена неполная версия библиотеки, а список MP-каталогов подгружается из единого cfg-файла.
В этом случае компиляция будет невозможна. Поэтому при отсутствии MP-каталога надо выдавать макси-
мум предупреждение.


[26.04.2009 - 21:59:57,53]

  [DONE: Продумать back-end C++]
  [TODO: Реализовать back-end C++]
  Собственно, всё продумано, приступаем к реализации.
  Независимо от того, как будет осуществляться генерация кода на Си++ -- напрямую компилятором с
"пришитым" генератором от Простого Рефала (генератор Простого Рефала состоит из модуля создания "ал-
горитма" -- команд языка сборки промежуточного представления предложения и модуля собственно генера-
ции) или путём генерации исходных текстов Простого Рефала, в любом случае надо пополнить Простой Ре-
фал средствами, необходимыми для Модульного Рефала:
  1. Идентификаторы (имена, метки, compound-символы). Далее по тексту "идентификаторы". Идентифика-
торы представляют собой элементы глобального множества, смысл которых состоит только в возможности
сравнения на равенство/неравенство средствами сопоставления с образцом с известным идентификатором
или между собой.
  2. Квалифицированные имена Модульного Рефала, т.е. имена, составленные из сегментов. Сегмент под-
чиняется правилам Модульного Рефала. т.е. может содержать символы типа '!', '?', '_', '-', причём
последние два различаются.
  3. Абстрактные типы данных.
  4. Статические ящики.
  5. Инициализация и финализация.
  Все задачи, относящиеся к генерации C++-кода, будут иметь префикс C++.



[27.04.2009 - 16:34:27,25]

  [TOTHINK: C++: Имена Модульного Рефала в Простом Рефале]
  Способ, которым можно представить имена (сегменты квалифицированного имени) в Простом Рефале,
прост: достаточно выбрать систему кодирования дополнительных символов. Наиболее подходящий способ
такой: символы '!', '?', '_', '-' заменяются соответственно на 'B_', 'Q_', 'U_', 'D_', остальные
символы остаются без изменений. Данное кодирование обладает следующими преимуществами:
  (+) Оно взаимно однозначно.
  (+) Кодированное имя не содержит двух соседних прочерков, не может начинаться на прочерк. Это яв-
ляется преимуществом, т.к. имена, начинающиеся на прочерк и содержащие два прочерка внутри являются
зарезервированными для Стандартной библиотеки Си++.
  (+) Имена, начинающиеся на '!' или '?', после кодирования будут начинаться с большой буквы -- имя
будет соответствовать правилам имён Простого Рефала.
  (+) По кодированному имени легко понять оригинал.
  Явных недостатков такой способ не имеет.
  Квалифицированные имена можно реализовать двумя способами: простым и сложным.
  Простой способ заключается в том, что вводится дополнительная управляющая последовательность,
представляющая собой разделитель квалификаторов, например 'P_'. Таким образом имя InOut::WriteLine
будет выглядеть как 'InOutP_WriteLine'.
  (+) Способ довольно простой.
  (+) Ничего не нужно менять в компиляторе Простого Рефала.
  (-) Слишком длинные имена таким способом кодировать нельзя слишком длинные имена (ограничение на
максимальную длину в Си++ составляет примерно 200 символов, дальше компилятор обрезает).
  Сложный способ заключается в том, что сущности, кодированные квалифицированными именами, будут
находиться в соответствующих пространствах имён. Таким образом, сгенерированный сишный код для имени
Std::InOut::WriteLine будет иметь вид:
  namespace Std {
  namespace InOut {
  refalrts::FnResult WriteLine( аргументы ) {
  }
  }
  }
  (+) Можно получить выигрыш в максимальной общей длине квалифицированного имени: на Visual Studio
2005 длинное квалифицированное имя не обрезается.
  (+) Пространства имён являются неотъемлемой возможностью Си++.
  (+) Такой способ интереснее
  (-) Необходимо изменять кодогенератор, формирователь конца функции должен знать имя функции, чтобы
поставить нужное число закрывающих фигурных скобок.
  (-) Не все компиляторы сохраняют в объектных файлах столь длинные имена. Borland C++ Builder 6,
например, имена в объектных файлах обрезает по 260-и символам.
  Надо заметить, что очень длинные квалифицированные имена мне встречались довольно редко (пока).
Однако, если в дальшейшем будет реализовываться синтаксис, основанный на действиях и с функциями
высших порядков, автоматически генерируемые промежуточные функции могут получать внутренние имена
вида ИмяРодительскойФункции::Какой-либоИдентификаторНапримерНомер. Конечно, в этом случае нужно по-
заботиться о том, чтобы имена автоматически генерируемых функций были короче.

  Синтаксис квалифицированных имён. Синтаксис в целом может быть похож на синтаксис квалифицирован-
ных имён в Модульном Рефале. В качестве разделителя имён можно использовать хоть точку, хоть двоето-
чие, хоть квадратик (два двоеточия).

  [TOTHINK: C++: Идентификаторы в Простом Рефале]
  Идентификаторы представляют собой элементы глобального множества, смысл которых состоит только в
возможности сравнения на равенство/неравенство средствами сопоставления с образцом с известным иден-
тификатором или между собой. Упорядочивание (сравнение на '<', '>', '==') иденификаторов не определе-
но, требуется лишь, чтобы выполнялись следующие законы:
  (1) Если s.A:s.B (отображается путём сопоставления с образцом), то s.A == s.B.
  (2) Выполняется только одно из трёх соотношений: s.A < s.B, s.A == s.B, s.A > s.B.
  (3) Если s.A < s.B и s.B < s.C, то s.A < s.C.
  Допустимо, если все идентификаторы будут считаться равными (как это сейчас сделано в back-end'е
Рефала 5). В идеале идентификаторы должны сравниваться по их текстовому представлению, т.к. подобное
поведение интуитивно понятно пользователю.
  Сравнение на равенство/неравенство средствами сопоставления с образцом должны выполняться эффек-
тивно, т.е. выполняться за постоянное время.

  Идентификаторы можно реализовать несколькими способами, их можно разделить на статические (пред-
ставления идентификаторов задаются на этапе компиляции) и динамические (представления задаются на
этапе выполнения), поддерживающие раздельную компиляцию (не требуют явного дополнительного прохода
на этапе компоновки) и не поддерживающие (требуют оного).

  1. Представление идентификаторов в виде функций заданного формата, размещаемых в специальной сек-
ции объектного файла. Статический, поддерживает раздельную компиляцию. Идея состоит в том, что су-
ществуют секции объектного файла, дублирующиеся элементы которых в разных единицах трансляции устра-
няются компоновщиком. В качестве типа можно выбрать функцию, не принимающую никаких аргументов и
возвращающую const char *. В качестве возвращаемого значения можно использовать текстовое представ-
ление идентификатора, что упростит вывод на экран.
  Пример.
  // Файл Module1.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F1( .... ) {
    .... & Success ....
  }

  // Файл Module2.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F2( .... ) {
    .... & Success ....
  }

  В итоге за счёт использования особой секции файла (секция указывается в директиве #pragma), компо-
новщик. видя в двух объектных файлах идентичные определения, одно из них устранит и в исполнимом
файле окажется только одно определение функции Success, на которое будут ссылаться функции F1 и F2.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы.
  (*) Указатели на функции можно сравнивать на равенство и неравенство.
  (*) Сравнение двух указателей выполняется за постоянное время.

  Оценка.
  (+) Способ статический -- не требуется динамических расходов во время выполнения программы.
  (+) Не требуется явного дополнительного прохода на стадии компоновки (неявный проход делает компо-
новщик Си++).
  (+) Способ работает как в Си, так и в Си++ (если понадобится написать генератор кода языка Си).
  (+) Доступно текствое представление на этапе времени выполнения: это облегчает отладку, позволяя
выводить идентификаторы на экран.
  (+) Возможность упорядочить по текстовому представлению.
  (-) Способ непереносим -- требуемая прагма зависит от компилятора, некоторые компиляторы могут та-
кую прагму не предоставлять.
  (-) Затруднена загрузка динамических библиотек: динамические библиотеки будут использовать свои
адреса к функциям-представлениям идентификаторов. В этом случае или интерфейс динамической библиоте-
ки не должен использовать идентификаторы (из-за чего пострадает или ясность программы -- обмен будет
осуществляться буквами либо цифрами, либо быстродействие -- обмен будет осуществляться целыми слова-
ми, либо удобство -- если в интерфейсе будут участвовать пустые функции -- по образцу $EENUM), или
идентификаторы должны будут сравниваться по текстовому представлению (что может снизить быстродей-
cтвие).
  Таким образом, при использовании динамической загрузки цель будет не достигнута.

  2. Представление идентификаторов в виде статических функций шаблонного класса. Статический, под-
держивает раздельную компиляцию. Аналогичен предыдущему, с тем отличием что идентификаторы представ-
ляются так:
  // Файл Module1.cpp
  template<typename T>
  class Success {
    static const char* name { return "Success"; }
  };
  refalrts::FnResult F1( .... ) {
    .... & Success<int>::name ....
  }

  Идея состоит в том, что шаблоны по умолчанию помещяются в секцию, описанную в первом способе.

  Цель достигнута -- см. способ №1.

  Оценка.
  Достоинства в целом те же, что и в способе №1, с тем исключением, что способ работает только в
Си++. На тех компиляторах, на которых я его проверял (g++ под Линукс, BCC 5.5 и Visual Studio 2005
под Windows) этот способ работает. Требует ли того Стандарт, я не знаю, т.к. в Стандарт не глядел.
  Недостатки в целом тоже те же, только с оговоркой на переносимость -- шаблоны являются неотъем-
лемым средством Си++, а вот объединяются ли они на любом компиляторе?..

  3. Создание перечисления идентификаторов. Статический, требует дополнительного прохода. Идея сос-
тоит в том, что идентификаторы представляются целыми числами, ссылки на идентификатор в сгенериро-
ванном тексте ссылки выглядят заметными для автоматического анализа, например как ident::Success,
в каждом сгенерированном файле присутствует ссылка на заголовок "idents.h", перед передачей сгене-
рированных файлов компилятору C++, выходные файлы будут сканироваться на предмет наличия идентифи-
каторов, после чего будет создаваться файл "idents.h" с таким содержимым:
  // Файл idents.h
  namespace ident {
    enum {
      ...
      Success,
      ...
    };
  }

  extern const char* textual(unsigned id);

и файл "idents.cpp" с таким содержанием
  // Файл idents.cpp

  const char* idents[] = {
    ...
    "Success",
    ...
  };

  const char* textual(unsigned id)
  {
    return idents[ id ];
  }

  Если текстовое представление идентификаторов на этапе выполнения не требуется, то на этапе компо-
новки будет подключаться не сгенерированный файл idents.cpp, а на заранее заготовленный файл
noidents.cpp:
  // Файл noidents.cpp
  const char* textual(unsigned id)
  {
    // Возврат например "?" или число id в текством представлении, например "42"
  }

  Очевидно, что имена в определении enum и в массиве должны следовать в одинаковом порядке. Если
идентификаторы располагать в enum в алфавитном порядке, то будет возможность упорядочивания иденти-
фикаторов по текстову представлению путём лишь сравнения числовых значений.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы -- файл idents.h един для всех единиц трансляции.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка:
  (+) Способ статический -- не требуется затрат во время выполнения программы.
  (+) Возможность отключать текстовое представление, когда этого не нужно.
  (+) Сравнение по текстовому представлению.
  (+) Способ работает как в Си, так и в Си++.
  (-) Требует дополнительного прохода на стадии компоновки.
  (-) Сложность с размещением файла "idents.h", если отдельные модули располагаются в разных папках.
Директива #include "idents.h" может по умолчанию искать файл idents.h в той же папке, что и файл ис-
ходного текста. Если файл idents.h присутствует в той же папке, что и исходник, то глобальный файл
может быть не найден.
  (-) Так же как и в способах №1 и №2, затруднена загрузка динамических библиотек. Если для динами-
ческих библиотек генерировать код тем же путём, что и для программы, совершенно разные идентификато-
ры будут получать одинаковые числовые представления, что потенциально способно привести к хаосу.
Если же изменить генерацию кода так, чтобы ссылки на идентификатор имели вид:
  refalrts::FnResult F(...) {
    ... ident::Success + g_offset ...
  }
где g_offset -- глобальная переменная, для основной программы равная нулю, при загрузке динамической
библиотеки наращиваемая на количество известных идентификаторов. В этом случае идентификаторы с оди-
наковым текстовым представлением в главной программе и библиотеке численно эквивалентны не будут.
  В этом случае недостатки способа по отношению к динамической загрузке будут те же, что и в спосо-
бах №1 и №2.
  Упорядочивание по численным значениям не будет эквивалентно упорядочиванию по текстовым представ-
лениям.
  При использовании динамической загрузки цель достигнута не будет.

  4. Динамическая таблица идентификаторов. Динамический, поддерживает раздельную компиляцию. Идея
следующая.
  // Функция, осуществляющая поиск в таблице и если необходимо добавление
  unsigned lookup( const char *name );

  // Некоторая сгенерированная функция
  refalrts::FnResult F(...) {
    const static unsigned Success = lookup("Success");
    const static unsigned Fails = lookup("Fails");
    ......
  }

  Идея заключается в том, что в Си++ инициализация статических переменных выполняется при первом
выполнении функции, на протяжении оставшегося времени программы переменные Success и Fails будут
хранить значения, соответствующие данным идентификаторам.
  В программе присутствует динамическая таблица, связывающая текстовое представление с числовым.
Функция lookup проверяет наличие отображения Текст <--> Число для данной текстовой строки, если
его нет, возвращается следующее числовое значение, которое ассоциируется с данным идентификато-
ром, если есть -- возвращается число.

  Цель достигнута:
  (*) Таблица глобальна для всей программы.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка
  (+) Не требуется прохода на стадии компоновки.
  (+) Работает как на Си, так и на Си++
  (+) Полностью совместим с динамическими библиотеками -- указатель на таблицу можно передать в ди-
намическую библиотеку, идентичные идентификаторы получат одинаковые числовые значения.
  (+) Текстовое представление доступно во время выполнения.
  (+) Есть возможность расширять множество идентификаторов, используемых в программе, пользователем
(точно также, как и в Рефал 5 -- фунцией типа Implode). Однако, для уничтожения неиспользованных
идентификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Затраты времени выполнения на инициализацию: каждая функция при первом вызове будет подторма-
живать, хотя и незначительно.
  (-) В каждой функции, использующией идентификатор, будет упоминаться текстовая строка, его пред-
ставляющая. Компиляторы могут не объединять дубликаты текстовых строк, отсюда возможно распухание
объёма исполнимого файла (хотя он и так распухает от кода).
  (-) Наиболее простой метод упорядочивания -- по числовым значениям, т.е. упорядочивает не в алфа-
витном порядке.

  Если отказаться от требования сравнения на равенство за постоянное время, то можно рассмотреть ещё
один способ. Самый простой и самый очевидный.

  (5.) Си-строки. Идея в том, что идентификаторы следует представлять в виде обычных Си-строк, т.е.
указателей на char. Выглядит это так:
  refalrts::FnResult F(...) {
    ..... "Success" ...
  }
  Сравнение на равенство осуществляется функцией strcmp языка Си.

  Цель не достигнута:
  (*) Текстовое представление инвариантно, т.к. представляет самого себя.
  (*) Текстовые строки можно сравнивать на равенство/неравенство.
  (!) Сравнение текстовых строк осуществляется за время O( min( length(s1, s2) ) ), т.е. пропорцио-
нально длине строк, причём максимальное время достигается при одинаковых идентификаторах. (Для опре-
деления неравенства идентификаторов Success и Fails требуется одно сравнение, для определения равен-
ства Success и Success требуется 7 сравнений (включая завершающий ноль.)

  Оценка.
  (+) Способ статический -- не требуется затрат на время выполнения.
  (+) Не требует прохода на стадии компоновки.
  (+) Полностью совместим с динамической загрузкой библиотек.
  (+) Чрезвычайная простота реализации.
  (+) Возможность расширения пользователем набора идентификаторов на стадии выполнения. Для этого
достаточно распределить в динамической памяти новую строку. Однако для удаления неиспользуемых иден-
тификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Расход памяти на используемые идентификаторы -- на каждое упоминание идентификатора требуется
одна Си-строка, В Простом Рефале, как показывает внутренний осмотр исполнимого файла, достаточно
много места занимают имена функций, Си-строки, которые используются для инициализации атомов-функ-
ций. Атомы-функции содержат строковое представление для удобства отладки -- для того, что бы можно
было проанализировать дамп поля зрения. Хотя, надо заметить, расход памяти на нерациональную гене-
рацию кода гораздо больше.
  (-) Как уже было сказано, требуется расход времени на сравнение двух строк. На самом деле сравне-
ние иногда можно оптимизировать, сравнивая сначала указатели на равенство, а затем уже сравнивая
содержимое.

  Синтаксис идентификаторов. Чтобы отличать идентификаторы от имён функций, можно идентификаторы об-
рамлять двойными кавычками (тогда потенциально можно разрешить в идентификаторах использовать многие
другие символы, а значит и расширить их систему кодирования) -- "Name", можно обрамлять слешами --
/Name/ как в Рефале 2, можно начинать с какого-либо символа, например, с # -- #Name, как это сделано
в Smalltalk.

  [TODO: C++: Абстрактные типы данных в Простом Рефале]
  Абстрактные типы данных сравнительно несложно реализовать. Синтаксис можно позаимствовать из Мо-
дульного Рефала, в качестве метки АТД можно использовать имя $ENUM или даже $EENUM (для экспортиру-
емых АТД в перспективе). Синтаксис:
  PatternAbstractTerm ::= '[' Name Pattern']' .
  ResultAbstractTerm ::= '[' Name Result ']' .
  Проверку "приклеенности" имён функций к квадратным скобкам можно проводить за отдельный проход
после проверки парности скобок или в одном проходе с оной парности.


[29.04.2009 - 17:40:52,94]

  [TOTHINK: Статические ящики в back-end'е Простого Рефала]
  Статический ящик -- разновидность функции с побочным эффектом, возвращающей при вызове свой преды-
дущий аргумент. Возможная очевидная реализация:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter old_begin = 0;
    static refalrts::Iter old_end = 0;
    /*
      Присваиваем ссылкам old_begin и old_end текущий аргумент.
      В поле зрения вызов статического ящика заменяем на цепочку
      между old_begin и old_end.
    */
  }

обладает тем недостатком, что по завершении программы узлы между old_begin и old_end будут недоступ-
ны виртуальной машине, а значит не будут удалены. Хотя это для данной реализации некритично, но не-
красиво. В дальнейшем при возможной оптимизации выделения и освобождения памяти с простой схемой
сборки мусора это может стать проблемой. К тому же содержимое статических ящиков в данной реализации
не будет доступно для наблюдения в дампе памяти. Поэтому виртуальная рефал-машина должна иметь доступ
ко всем используемым статическим ящикам во время выполнения.
  Возникают следующие варианты.

  1. Использование копилки. Вводится копилка -- дополнительный двусвязный список, доступный рефал-
машине с операциями Br и Dg. В дальнейшем всё эквивалентно реализации статических ящиков Модульного
Рефала.

  Оценка.
  (+) Синтаксис Простого Рефала остаётся без изменений. Изменения касаются только рефал-машины (вво-
дится третий (после поля зрения и списка свободных блоков) список копилки -- фактически единственный
статический ящик, две библиотечные функции Простого Рефала Br и Dg (или одна Replace).
  (+) Удобство чтения дампа поля зрения.
  (-) Два уровня косвенности: копилка и статические ящик и как следствие снижение быстродействия.
  (-) Использование копилки. Копилку я не люблю.

  2. Хранение содержимого статических ящиков в специальном двусвязанном списке. Выглядит это так:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter begin = 0;
    static refalrts::Iter end = 0;
    if( (begin == 0) && (end == 0) && аргумент непустой ) {
      refalrts::Iter begin_swap = refalrts::get_begin_swap_list();
      вставить аргумент перед begin_swap
      присвоить begin и end начало и конец аргумента
      удалить вызов функции из поля зрения
    } else if( (begin == 0) && (end == 0) && аргумент пустой ) {
      удалить вызов функции из поля зрения
    } else if( (begin != 0) && (end != 0) && аргумент непустой ) {
      в двусвязанном списке вместо поддиапазона [begin, end] вставить аргумент
      и вызов функции в поле зрения заменить на поддиапазон [begin, end]
    } else if( (begin != 0) && (end != 0) && аргумент пустой ) {
      удалить поддиапазон [begin, end] из двусвязанного списка
      вставить поддиапазон [begin, end] вместо вызова в поле зрения
    }

    return refalrts::cSuccess;
  }

  Итераторы begin и end указывают на крайние узлы текущего содержимого статического ящика или оба
равны нулю (как это принято в Простом Рефале). Двусвязанный список статических ящиков представлен
точно также, как поле зрения и список свободных блоков -- парой глобальных переменных типа Node.
Функция get_begin_swap_list() возвращает g_begin_swap_list.next, в этом случае содержимое нового
статического ящика помещается в начало списка, или & g_end_swap_list, в этом случае содержимое но-
вого статического ящика помещается в конец списка (тогда функцию следует назвать get_end_swap_list).

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (-) В случае дампа памяти содержимое всех статических ящиков будет конкатенировано друг с другом
-- трудности понимания дампа памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  3. Хранение содержимого статических ящиков в специальном двусвязанном списке с головными узлами.
Отличие состоит в том, что содержимое каждого статического ящика в общем двусвязанном списке предва-
ряется головным узлом с именем этого ящика. Выглядит это так:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter head = 0;
    static refalrts::Iter next_head = 0;

    if( head == 0 ) {
      // Первое использование
      assert( next_head == 0 );
      next_head = refalrts::get_begin_swap_list();
      head = refalrts::insert_head_node_before( next_head, "SomeSwap" );
    }

    /*
      Содержимое двусвязанного списка расположено между узлами head и next_head
    */
    обмен с аргументом операциями с двусвязанным списком
  }

  Головной узел -- специальный вид атома, содержащий имя статического ящика и при распечатке дампа
служащий разделителем между содержимыми статических ящиков.

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (+) Читабельный дамп памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  4. Статические ящики, связанные в однонаправленный список.
  Это выглядит так:
  // Файл refalrts.h
  namespace refalrts {

  struct SwapInfo {
    Iter begin;
    Iter end;
    SwapInfo *next;
    const char *name;
  };

  void link_swap( SwapInfo *swap_info );

  }

  // Файл refalrts.cpp

  refalrts::SwapInfo g_swap_top = 0;

  void refalrts::link_swap( SwapInfo *swap_info ) {
    swap_info->next = g_swap_top;
    g_swap_top = swap_info;
  }

  // сгенерированный код
  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::SwapInfo info = { 0, 0, 0, "SomeSwap" };
    if( info.begin == 0 ) {
      refalrts::link_swap( & info );
    }
    дальше оперируем с диапазоном [info.begin, info.end] и аргументом
  }

  В этом случае рефал-машине доступны все статические ящики, задействованные в программе, по указа-
телю g_swap_top.

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (+) Читабельный дамп памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  Если статические ящики будут добавлены в Простой Рефал, то будут иметь очевидный синтаксис: ди-
рективы $SWAP или $ESWAP и список имён через запятую.


[01.05.2009 - 14:46:30,01]

  [TODO: C++: Имена Модульного Рефала в Простом Рефале]
  Простой способ лучше, т.к. (а) он более переносимый (Borland обрезает длинные имена в любом слу-
чае) и (б) он более прост, что в духе Простого Рефала (сделать всё максимально просто не заботясь
об эффективности.
  К тому же стоит рассмотреть и такой аспект: пополнять ли синтаксис Простого Рефала квалифициро-
ванными именами или нет: кодирование имени можно осуществлять как на уровне back-end'а Модульного
Рефала, так и на этапе генерации кода в Простом Рефале. Очевидно, что кодирование на уровне Модуль-
ного Рефала проще, т.к. не требует изменения синтаксиса Простого Рефала.
  Поэтому будем квалифицированные имена представлять простым способом, кодирование будем осуществ-
лять на уровне генерации .sref-файлов.

  [TOTHINK: C++: Идентификаторы в Простом Рефале]
  Дополнение по поводу синтаксиса. Я склоняюсь к использованию синтаксиса типа #Name, причём '#' и
'Name' будут двумя отдельными лексемами. (точно также, как и в Модульном Рефале, где & -- отдельная
лексема). Связывание # и Name в один элемент будет осуществляться на отдельном проходе по лексемам.

  [TODO: C++: Инициализация и финализация в back-end'е Простого Рефала]
  Реализация инициализации и финализации никак не затронет язык и компилятор Простого Рефала (за ис-
ключением того, что для этого статические ящики уже должны присутствовать в языке). IModule содержит
для каждого модуля стартовый код (инициализация+финализация или функция Go) и список всех импортиру-
емых модулей.
  Если в каждый сгенерированный файл Простого Рефала включить функцию ModuleNameP_InitE_, представ-
ляющая код инициализации соответствующего модуля (наличие суффикса E_ гарантирует несовпадение имени
с каким-либо сгенерированным именем), которая вызывает функции OtherModuleNameP_InitE_ импортируемых
модулей и затем вызовет стартовый код инициализации, который выполняется только один раз при первом
запуске, то стартовые коды инициализации будут вызваны в правильном порядке.
  Действительно, если модуль A импортирует модуль B, то код инициализации модуля A будет вызван пос-
ле вызова функции BP_InitE_, т.е. функция инициализации модуля B будет вызвана хотя бы один раз до
инициализации модуля A, а следовательно, модуль B будет проинициализироват до модуля A.
  Очевидно, что код финализации можно вынести в отдельную функцию, которую можно зарегистрировать
после завершения стартового кода инициализации. Сам факт регистрации финализатора можно использовать
для проверки того факта, что инициализирующий код выполнен.
  Схема реализации следующая:

  $EXTERN RegisterE_;
  $FORWARD ModuleNameP_InitializeE_, ModuleNameP_FinalizeE_;

  $EXTERN ImportModule1P_InitE_;
  $EXTERN ImportModule2P_InitE_;

  $ENTRY ModuleNameP_InitE_ { =
    <ImportModule1P_InitE_>
    <ImportModule2P_InitE_>
    <Register
      ModuleNameP_InitializeE_
      ModuleNameP_FinalizeE_
    >;
  }

  Очевидно, что можно применить и любую другую систему кодирования имён.


[02.05.2009 -  0:53:33,64]

  [TOTHINK: C++: Идентификаторы в Простом Рефале]
  Компилятор Простого Рефала осуществляет синтаксический разбор и генерацию кода в один проход на
на уровне всего файла: сразу же после разбора таких элементов, как объявление функции, определения
перечисления (пустых функций), в ближайшем будущем статических ящиков, начала функции, предложения,
конца функции происходит их генерация.
  При генерации идентификаторов способами № 1 и № 2 требуется дополнительный проход по всей функции
для того, чтобы определить список используемых идентификаторов и определить их перед функцией. А до-
полнительный проход по функции потребует изменение структуры синтаксического анализатора. Для спосо-
ба № 1 можно было бы в самой функции обнаруживать идентификаторы, их объявлять непосредственно внут-
ри функции, заносить их в таблицу символов, а при генерации конца функции, определять вновь объяв-
ленные идентификаторы.
  В качестве альтернативы можно было бы перед использованием идентификатора, их явно объявлять как
функцию типа:

  $NAME Name, OtherName;

  F { # Name = # OtherName; }

но это несколько усложнит генерацию на уровне Модульного Рефала (хотя было бы в духе Простого Рефа-
ла -- объявление сущностей перед их использованием).
  От способов, требующих дополнительного прохода на этапе компоновки, я планирую отказаться, т.к.
они, собственно, требуют дополнительного прохода, а значит усложняют генерации кода, поэтому от спо-
соба № 3 я отказываюсь.
  Способ № 4 требует разработки специального ассоциативного массива для идентификаторов (использова-
ние стандартных классов Си++ не соответствует духу RTS Простого Рефала -- он построен практически
как подмножество Си языка Си++, поэтому std::map сюда не вписывается), т.е. требует довольно нетри-
виальной RTS. Поэтому я от него отказываюсь.
  Способ № 5, хотя и не достигает цели с точки зрения быстродействия (линейная сложность сравнения),
но больше соответствует духу Простого Рефала (задача должна быть решена наиболее просто, пусть и да-
же в ущерб быстродействию.
  Хотя, если быть честным, первые три способа не достигают цели при использовании динамических биб-
лиотек.

  P.S. К моменту написания этого TOTHINK уже реализована поддержка генератора кода для способа № 5,
хотя в принципе не сложно и перейти к способам № 1 и № 2, добавив возможность предобъявления.


[02.05.2009 - 16:11:55,89]

  [DONE: C++: Абстрактные типы данных в Простом Рефале]
  Реализовано в соответствии с TODO.
  Добавлено два новых типа узлов (теги cDataOpenADT и cDataCloseADT), которые устроены в точности
также, как и обычные скобки. На уровне синтаксического анализа гарантируется, что после "[" следу-
ет имя функции. Также добавнены в алгоритм команды распознавания АТД (примитивы распознавания
adt_left и adt_right обнаруживают обе АТД-скобки и требуемое имя функции после открывающей скобки),
генерации АДТ-скобок (примитивы alloc_open_adt и alloc_close_adt просто распределяют узлы, проини-
циализированные как "[" и "]" соответственно, распределение имени после "[" выполняется отдельным
примитивом).

  [TODO: C++: Идентификаторы в Простом Рефале]
  Идентификаторы реализованы в точности по схеме № 2, RTS идентификаторы полностью поддерживаются.
Также добавлен соответствующий тип узла cDataIdentifier и, соответственно, поле информации
ident_info.
  На данный момент требуется расширить библиотеку примитивов поддержкой идентификаторов (вывод, упо-
рядочивание, запрос типа).



[02.05.2009 - 17:51:31,35]

  [DONE: C++: Идентификаторы в Простом Рефале]
  Идентификаторы полностью реализованы. Порядок сортировки (функцией-примитивом SymbCompare): чис-
ло > character > функция > идентификатор > дескриптор файла. Функции сравниваются сначала по тексто-
вому представлению, затем по указателю. Идентификаторы всегда сравниваются по текстовому представле-
нию.

  [TODO: C++: Собственно back-end]
  Реализация back-end'а Модульного Рефала, генерящая sref-файлы.


[03.05.2009 - 14:56:57,84]

  [TOTHINK: Статические ящики в back-end'е Простого Рефала]
  Способы № 1, № 2 и № 3 можно считать разновидностями одного и того же способа, только в случае ко-
пилки обработка единого двусвязанного списка для хранения содержимого ящиков пишется на Рефале, а в
двух других способах пишется на Си++, что несколько более эффективно.
  В первых трёх способах подразумевается, что содержимое статических ящиков принадлежит рефал-маши-
не, в четвёртом -- самим ящикам.
  Для всех упомянутых выше подхдов (включая очевидную реализацию) можно освобождать память, просто
вызывая статические ящики с пустым аргументом в коде финализации модуля. Однако при этом необходимо
или требовать от программиста на Простом Рефале, чтобы он опустошал ящики явно, или требовать, что-
бы Простой Рефал использовался только как back-end Модульного Рефала. Последнее можно гарантировать
встроив генератор кода Простого Рефала в Модульный (но это уже следующий шаг, сейчас ведётся разра-
ботка back-end'а, генерящего .sref-файлы).
  Способ № 2 неперспективен, т.к. потенциально затрудняет отладку программ, да и генерируемый код
мне кажется сложным.
  Одним из требований к статическим ящикам можно считать требование к беспровальности (nofail) их
работы: ошибки распознавания быть в принципе не может -- статический ящик должен быть способен при-
нять любой аргумент, ошибки распределения памяти тоже быть не должно (по крайней мере, для списко-
вой реализации) -- ящик лишь осуществляет обмен содержимого. Поэтому способ № 3 не может распреде-
лять элемент головы в списке свободных блоков -- это потенциальная (хотя и маловероятная) ошибка
распределения памяти. Поэтому ситуацию можно упростить тем, что при первом использовании ящика в
качестве маркера использовать или угловые скобки, или имя функции (после "<"). Имя функции предпоч-
тительнее, т.к. маркер головы всё равно должен содержать имя статического ящика, для превращения
узла-имени функции в маркер головы достаточно лишь изменить поле типа (Node::tag). Более того, мож-
но вообще отказаться от использования маркеров головы: в список статических ящиков при первом вызо-
ве ящика помещать его вызов вместе со скобками конкретизации, читабельность дампа памяти от этого
не пострадает. В таком случае можно даже ограничиться использованием одной статической переменной
-- открывающая скобка содержит указатель на закрывающую скобку конкретизации.
  Головные узлы не обязательно создавать из имени функции, их можно распределять статически внутри
самого ящика:
  Node head_node = { инициализация };
  При этом усложнится освобождение двусвязанного списка -- если раньше для каждого элемента просто
вызывалась функция free, то теперь нужно будет проверять, является ли элемент головным. Т.к. голов-
ных элементов в поле зрения должно быть существенно меньше, чем распределённых в динамической памя-
ти, то такая проверка будет неэффективна, т.к. почти для всех узлов будет выполняться и проверка, и
освобождение.
  Вместо использования отдельного двусвязанного списка для содержимого статических ящиков можно ис-
пользовать и само поле зрения (при этом надо будет ввести один указатель, отделяющий поле зрения
от памяти статических ящиков). Двусвязный список будет выглядеть так:
  [якорь] --- узлы поля зрения --- Голова1 --- Тело1 --- ... --- ГоловаN --- ТелоN --- [якорь]
                                   ^--- указатель на начало.
  Здесь якоря -- это глобальные переменные типа узел, которые двунаправленно связаны с полем зрения.


[03.05.2009 - 23:32:25,48]

  [TODO: Статические ящики в back-end'е Простого Рефала]
  Будем реализовывать статические ящики по способу № 3 с использованием поля зрения в качестве хра-
нилища. При первом использовании ящика головоной узел будет создаваться из узла имени функции. Но-
вые ящики будут добавляться слева от существующих.
  Головной элемент будет содержать два поля: поле имени типа char* и указатель на следующую голову.
Для инициализации головы будем использовать функцию refalrts::Iter refalrts::initialize_swap_head(
refalrts::Iter head_elem);, которая включает узел перед предыдущей крайне левой головой (при этом
узел исключается из предыдущего местоположения), инициализирует его как голову и сохраняет его мес-
тоположение как крайне левую голову. Таким образом удастся обойтись всего одной статической пере-
менной в функции ящика, что также упростит его инициализацию. Момент инициализации можно доверить
компилятору Си++, записав так:
  static refalrts::Iter s_head = refalrts::initialize_swap_head( func_name );
где func_name -- узел с именем функции.


[04.05.2009 -  1:36:05,40]

  [DONE: Статические ящики в back-end'е Простого Рефала]
  Выполнено в полном соответствии с TODO.
  В RefalRTS добавлены следующие функции.

  Iter initialize_swap_head( Iter head );

  Инициализирует головной узел (см. TODO).

  void swap_info_bounds( Iter& first, Iter& last, Iter head );

  По головному узлу находит содержимое статического ящика. Возвращает его как обычный диапазон Прос-
того Рефала ([first, last] или [0, 0] для пустого диапазона).

  void swap_save( Iter head, Iter first, Iter last );

  Сохраняет содержимое по элементу головы.


[07.05.2009 - 16:49:08,03]

  [DONE: C++: Имена Модульного Рефала в Простом Рефале]
  Выполнено в полном соответствии с TODO. Имена функций, имеющих отношение к инициализации и финали-
зации, оканчиваются на 'E_', имена идентификаторов оканчиваются на 'I_'. В модуле может одновременно
упоминаться и идентификатор Name и функция с тем же имененм Name. Однако, компилятор Си++ (Visual
Studio) не позволяет использовать одновременно в одном файле шаблон класса и функцию с одним именем
(ругается). Поэтому все идентификаторы имеют суффикс 'I_'.


[07.05.2009 - 17:44:20,12]

  [DONE: C++: Инициализация и финализация в back-end'е Простого Рефала]
  Сделано в точном соответствии с TODO.

  [DONE: C++: Собственно back-end]
  Реализован back-end, генерирующий .sref-файлы. У данного подхода, как выяснилось, есть существен-
ный недостаток, а именно неудобна реализация низкоуровневых средств на Си++. Самый низкоуровневый
код для данного back-end'а, очевидно, это Простой Рефал. Пополнение последнего низкоуровневыми сред-
ствами возможно только путём редактирования файлов refalrts.cpp и Library.cpp. Поэтому низкоуровне-
вые средства (см. RefalRTS.sref) выглядят примерно так:

  $EXTERN GetEnv;

  $ENTRY MRefalRTSP_Env {
    e.EnvName = <GetEnv e.EnvName>;
  }

т.е. практически та же ситуация, что и с Рефалом 5 с тем отличием, что можно пополнять набор "встро-
енных" функций. Так например, чтобы запрашивать атрибуты файла непосредственно, без mr-extent, пот-
ребуется или (а) написать функцию типа GetFileAttribute в Library.cpp и потом вызвать её из Core::
MFileSystem (как это сделано в MRefalRTS), или (б) создать библиотечный (в смысле, без исходника)
модуль типа Core::MFileSystem. Файл Core/MFileSystem.sref оставить пустым, в Core/MFileSystem.rsym
описать функцию GetFileAttribute, а функцию CoreP_MFileSystemP_GetFileAttribute описать в
Library.cpp.
  В случае же генерации кода на Си++ необходимости в файлах Library и LibraryEx уже быть не должно,
весь нативный сишный код должен быть представлен библиотечными модулями. Разумеется, это не касается
файла refalrts.cpp. Хотя и его можно сделать статической/динамической библиотекой.


[07.05.2009 - 20:23:04,51]

  [TODO: C++: Реализовать генерацию кода на Си++ самим Модульным Рефалом]
  Это существенно упростит пополнение Модульного Рефала низкоуровневым кодом, по сравнению с генера-
цией .sref-файлов. Кроме того, уйдёт лишний уровень косвенности (генерировать файлы исходного тек-
ста, затем проводить их синтаксический анализ), что приведёт к некоторому повышению быстродействия.
  Для этого необходимо сконвертить файлы Algorithm.sref и Generator.sref из Простого Рефала в Мо-
дульый, а для этого необходимо актуализировать srprep с учётом последних изменений синтаксиса
(в особенности касательно директивы $FORWARD).

  [TODO: C++: Доработка srprep]
  Необходимо доработать srprep таким образом, чтобы он поддерживал директиву $FORWARD. Остальными
возможностями типа идентификаторов или АДТ дорабатывать необязательно, т.к. эти возможности не ис-
пользуются в модулях Algorithm.sref и Generator.sref.

  [TODO: Запрос атрибутов файла написать на Си++]
  Цель очевидна. Повышение быстродействия. Предполагается, что много времени уходит на проверку ан-
тивирусом каждого вызова функции System, поэтому получение атрибутов непосредственно в самом компи-
ляторе должно резко снизить затраты времени, ведь это всего лишь пара API-вызовов.
  Сама функция будет описана в библиотечном модуле MFileSystem::Core и будет называться GetFileAtt\
ribute, файл Core/MFileSystem.sref будет пустым, сишный код будет включён в файл Library.cpp.

  [TODO: Более прямая реализация файлов в FileIO]
  На данный момент MRefalRTS эмулирует одноимённый модуль back-end'а Рефала 5 со всеми его косяками
и нелогичностями. Таким образом, не смотря на то, что функции работы с файлами (открытие, закрытие
построчное чтение и построчная запись) имеют идентичные интерфейсы, обмен осуществляется через не-
удобный интерфейс языка Рефал 5 с фиксированными числами-дескрипторами. Для отображения дескрипто-
ров Простого Рефала в чиселки используется таблица на уровне MRefalRTS, для контроля открытых дес-
крипторов-чиселок используется таблица на уровне FileIO.
  Очевидно, эту косвенность надо устранить.


[07.05.2009 - 21:46:39,84]

  [TODO: C++: Функции для преобразований между C-строкой и рефал-выражением]
  Требуется добавить в refalrts функции, преобразующие char* <--> рефал-выражение. Возможные сигна-
туры:
  unsigned read_chars(char buffer[], unsigned buflen, Iter& first, Iter& last);
  void alloc_chars(Iter& first, Iter& last, const char buffer[], unsigned buflen);
  void alloc_string(Iter& first, Iter& last, const char *string);
При этом функции ***_chars работают не с C-строками, а с массивами символов, поэтому alloc_chars не
обращает внимания на нулевой байт.
  Поскольку распределение цепочек characters довольно распространено (по-другому генерацию файлов не
сделаешь), то использовать функцию alloc_chars целесообразно и в качестве оптимизации генерируемого
кода.


[07.05.2009 - 23:17:35,42]

  [DONE: Более прямая реализация файлов в FileIO]
  Создан библиотечный модуль Core::MFileIO, перенаправляющий вызовы функций Open, Close, WriteLine и
ReadLine к функциям на Простом Рефале.


[10.05.2009 - 14:21:13,26]

  [DONE: C++: Доработка srprep]
  Доработка коснулась лишь одного: директива $FORWARD сделана эквивалентной директиве $EXTERN. За-
бавным оказалось то, что директива $SWAP уже поддерживалась -- когда я писал srprep, я не подозре-
вал, что долгое время Simple Refal не будет поддерживать статические ящики.

  [TODO: C++: Замер времени выполнения программы]
  Было бы интересным добавить возможность замера времени выполнения программы. В принципе, можно
и осуществлять замер и чистого времени выполнения (для этого нужно слегка изменить кодогенерацию).


[10.05.2009 - 20:17:33,25]

  [DONE: C++: Замер времени выполнения программы]
  Сделано в соответствии с TODO. Для сгенерированных функций пришлось добавить ещё один возвращаемый
результат: cExit, а также RTS-функция set_return_code. Указанные средства используются для реализа-
ции библиотечной функции Exit, которая как раз устанавливает код возврата и возвращает cExit. Ранее
она вызывала exit(), завершая тем самым выполнение программы. Такое поведение оказалось недопусти-
мым, т.к. требовалось после завершения работы рефал-машины выдавать сведения о быстродействии (до-
бавлять обработчик в at_exit мне не хотелось).

  [DONE: C++: Функции для преобразований между C-строкой и рефал-выражением]
  Сделано в соответствии с TODO с тем отличием, что аргументы alloc_***, соответствующие началу и
концу рефал-выражения, называются res_b и res_e для единообразия стиля.


[11.05.2009 - 14:03:21,79]

  [DONE: Запрос атрибутов файла написать на Си++]
  Выполнено в соответствии с TODO. Кроме того, на Си++ реализован запрос листинга папки. Однако зап-
рос листинга просто выводит имена файлов в указанной папке, а не их абсолютные имена. При переделке
библиотеки это надо доработать.


[19.05.2009 - 22:23:09,31]

  [DONE: C++: Реализовать генерацию кода на Си++ самим Модульным Рефалом]
  Back-end на основе Простого Рефала реализован. Даже с одной оптимизацией: оптимизация объёма сге-
нерированных файлов за счёт генерации цепочек char не по отдельности, а непрерывной последователь-
ностью (См. TODO C++: функции для преобразований между C-строкой и рефал-выражением), за счёт чего
удалось сократить объём исполнимого файла примерно на 15 %.
  Однако, back-end получился и не без недостатков. Помимо имманентных недостатков Простого Рефала
к ним добавились и следующие недостатки (многие из которых суть недоделки). А именно:
  (*) Непараметризуемость по компилятору (этим же страдает и back-end Простого Рефала) -- напрямую
в код зашит запуск программы compile_cl (которая есть пакетный файл compile_cl.bat, вызывающий ком-
пилятор MS Visual C++) с явно заданными некоторыми параметрами.
  (*) Кривая реализация низкоуровневых функций -- по прежнему используется Library.cpp. Необходимо
(а) реализовать самостоятельный рантайм применительно к Модульному Рефалу (слегка изменив
refalrts.h и refalrts.cpp) -- скорее, только косметические изменения); (б) перенести низкоуровневый
код в .cpp-файлы библиотеки.
  (*) Недостаток, сохранившийся из Простого Рефала, с тех времён, когда ещё не было идентификаторов,
но дамп поля зрения хотелось бы видеть в читабельном виде. А именно: имена функций для узлов-функций
задаются как C-строки. И эти c-строки слишком часто повторяются (приблизительный подсчёт показывает,
общий вес этих строк составляет 100 Кбайт). Следует имена функций в узлах хранить как ссылки на
идентификаторы.
  (*) Следует реализовать функции операционный и файловой систем, такие как создание папки, примити-
вами, а не вызовом функции System.

  [TODO: Командная строка: дополнительная параметризация back-end'ов]
  Следует разрешить генераторам входных и выходных файлов (вместо ранее использованного термина
"внутреннее понятие back-end'а") параметризоваться дополнительными своими опциями (например, для
компилятора Си++ -- это путь к компилятору, дополнительные опции и др.). А если смотреть шире, то
помимо обработчика дефолтовых зависимых от самой опции команд группы, должен быть и обработчик
зависимых от значения опции команд группы.

  [TODO: Командная строка: упорядочить метаданные -- список back-end'ов и зависимые перехватчики]
  Хотя сейчас метаданные (дефолтовые расширения и папки вынесены) в отдельный файл, они там совер-
шенно не упорядочены -- одно и то же расширение упоминается несколько раз. Кроме того, компоновка
набора выходных файлов в единый back-end должна осуществляться также независимо от обработчика
командной строки. Кроме того, независимо от обработчика информация о выбранных опциях (в конкрет-
ном случае -- это командная строка вызова компилятора Си++) должна передаваться в функции генерато-
ра и компоновщика.

  [TOTHINK: Имя и путь целевого файла]
  Под целевым файлом будем понимать или исполнимый файл, или файл, обобщающий какую либо информацию
по всей программе (перекрёстные связи, отладочная информация, та или иная статистика о программе).
На данный момент в компоновщик передаётся только конечный сегмент имени головного модуля (так на-
пример, если головной файл имеет имя Packet::Module, то сгенерированный исполнимый файл будет распо-
лагаться в текущей папке с именем Module. Для целевого файла таблицы перекрёстных связей XLinx про-
водится в компоновщике дополнительная обработка имени файла и тот оказывается в каталоге .Info в те-
кущей папке.
  Back-end Рефала 5 помимо "исполнимого" файла -- исходного текста на Рефале 5, компилируемого в
единый .rsl-файл, создаётся файл отладочной информации в каталоге .Info с именем Aliases.als и файл
со списком нескомпонованных функций в том же каталоге с именем Not linked.txt. Если одновременно
компилируется несколько проектов, то последний компилируемый проект перезапишет эти файлы.
  Следует продумать несколько вариантов.
  (1) В качестве каталога с целевым файлом всегда использовать текущую папку.
  (2) В качетсве каталога с целевым использовать MP-каталог головного модуля.
  (3-4) В качетсве каталога с целевым файлом использовать имя пакета + текущий каталог или MP-ката-
лог головного модуля.
  Кроме того, каталог с целевыми файлами можно задавать как параметр командной строки, а также зада-
вать само имя целевого файла. Поскольку одновременно может компилироваться несколько проектов, то
имя целевого файла должно распространяться на ближайшее (а) имя файла-корня грозди или (б) имя го-
ловного файла. Имя файла, указанного в командной строке, не обязательно должно быть именем грозди.
  Компоновщик должен без лишних усилий, получив на входе путь к файлу (папка+собственно имя), пос-
троить из него путь с подпапкой (как в случае с каталогом .Info для XLinx), выбрать расширение.

  [TODO: C++: Устранить Library.cpp и RefalRTS]
  Будем различать модули библиотеки -- модули, реализующие API для языка и поставляемые вместе с
компилятором и библиотечные модули -- модули, у которых отсутствует исходный текст.
  Генеральный план действий. Модули библиотеки содержат как низкоуровневые функции (реализуемые
ручным написанием библиотечных модулей), так и высокоуровневые, вполне реализуемые на самом Модуль-
ном Рефале (например, разбор пути к файлу в строковом представлении). Поэтому логично их разнести
в разные модули. Низкоуровневые модули, реализуемые на целевом языке, будут иметь то же имя, что
и модули-клиенты низкоуровневых функций, но будут находиться в пакете Core (как это сейчас сдела-
но для FileIO и MFileSystem, но с оговорками).

  [TODO: Устранить лишние вызовы функции MOS::System]
  Устранить вызовы, используемые для создания папки, удаления файлов, получения списка переменных
среды. Реализовать эти средства или средствами языка Си, или средствами ОС.

  [TODO: Научить XLinx выводить список нескомпонованных функций]
  Как показала практика, вывод неиспользуемых функций -- весьма полезная вещь, упрощает поиск не-
ревантного кода, а также помогает найти некоторые ошибки. Однако, сейчас вывод подобного списка
привязан к back-end'у Рефала 5, от которого в ближайшей перспективе я планирую отказаться. Очевидно,
задача перекладывается на плечи XLinx, как средства как раз и нацеленного на анализ использований
функций.

  [TODO: Научить XLinx выводить иерархический список использований модулей]
  XLinx должен уметь строить дерево зависимостей модулей как в прямом направлении (модуль исполь-
зует) с корнем в головном модуле, так и в обратном (модуль используется) -- несколько деревьев,
корнем каждого из которых является модуль, ничего не импортирующий, это как правило библиотечный
модуль реализации примитивов (теоретически, и библиотечный модуль может иметь зависимости от дру-
гих модулей, но это вырожденный случай).

  [TODO: C++: Имена функций -- идентификаторы вместо C-строк]
  В качестве имени функции внутри узла-указателя на функцию, необходимо использовать идентификатор
-- указатель на статическую функцию идентификатора. Тогда, соответственно, каждый вызов функции
будет требовать идентификатор. Но этот недостаток незначителен, т.к. лишние идентификаторы устра-
няются компоновщиком языка Си++.


[20.05.2009 - 15:28:26,81]

  [TODO: Обновить стабильную версию и поднять версию компилятора]
  Требуется выбрать из имеющихся реализаций стабильно работающую, т.к. предыдущая стабильная версия
уже морально устарела: не может компилировать новый синтаксис (лексика пополнена \r). Кроме того,
компилятор потрясли значительные изменения: появилось несколько новых back-end'ов, изменилась обра-
ботка командной строки. Это стоит отметить повышением номера версии.


[24.05.2009 - 16:26:52,40]

  [DONE: C++: Имена функций -- идентификаторы вместо C-строк]
  Сделано. Результат скромный -- исполнимый файл за счёт автоматической уборки лишних копий имён
функций полегчал менее чем 50 Кбайт.


[29.06.2009 - 22:16:48,85]

  [DONE: Научить XLinx выводить иерархический список использований модулей]
  Выполнено в полном соответствии с TODO. В процессе работы возникла проблема: один и тот же модуль
может использоваться другими модулями и сам при этом иметь "развесистое" дерево зависимостей. Сие
развесистое дерево много раз включается в общее дерево, вследствие чего последнее разрастается, за-
туманивает структуру, которая из-за этого теряет свою информативность. Проблема была решена следу-
ющим образом: модули, упоминаемые впервые, обозначаются знаком '*' слева от имени и раскрываются
в дерево; модули, упоминаемые повторно, обозначаются знаком '@' и в дерево не разворачиваются.
  Однако, результат оказался не настолько интересен, как я преполагал заранее. Возможно, стоит что-
то переделать, например, скрыть @-записи и в качестве корней деревьев использовать каждый модуль,
а не модуль, не имеющий предков. В таком случае (а) мы будем наблюдать список прямо и косвенно за-
висящих (зависимых) модулей от данного, (б) отступы будут иллюстрировать примерный характер зави-
симостей -- будем знать путь (правда, только один) по которому импортирует(ся) искомый модуль.
  Сгенерированный результат имеет следующий вид (часть вывода):

MRefal =>
 * MCompiler, ('MRefal.mref', 5)
   * MClusters, ('MCompiler.mref', 3)
     * MContext, ('MClusters.mref', 10)
       * MQualifiedName, ('MContext.mref', 3)
         * MSelfDiag, ('MQualifiedName.mref', 14)
           * MRefalRTS, ('..\Libraries\all.cpp-s\MSelfDiag.mref', 3)
           * Core::MFileIO, ('..\Libraries\all.cpp-s\MSelfDiag.mref', 4)
         * MStrings, ('MQualifiedName.mref', 15)
           @ MRefalRTS, ('..\Libraries\all.cpp-s\MStrings.mref', 3)
           * Math, ('..\Libraries\all.cpp-s\MStrings.mref', 4)
             @ MRefalRTS, ('..\Libraries\all.cpp-s\Math.mref', 3)
           * MLambda, ('..\Libraries\all.cpp-s\MStrings.mref', 5)
       @ MStrings, ('MContext.mref', 4)
     * MFileSystem, ('MClusters.mref', 11)


  [DONE: Научить XLinx выводить список нескомпонованных функций]
  Выполнено в полном соответствии с TODO. Однако, в отличие от аналогичного инструмента back-end'а
Рефала 5, здесь отбрасывать библиотечные модули затруднительнее. Список выводится в виде дерева,
группируя функции по модулям и пакетам. Так сделано в надежде на то, что я перенесу, наконец, все
модули библиотеки в пространство имён Std и все неиспользуемые средства библиотек будут находиться
рядом.
  Фрагмент вывода показан ниже.

Not linked: 
Core::MFileSystem::DirList, ('..\Libraries\windows.sr-b\Core\MFileSystem.mref', 10)
Cpp-SR-BE::
  Generator::
    GenEEnum, ('Cpp-SR-BE\Generator.mref', 74)
    GenESwap, ('Cpp-SR-BE\Generator.mref', 102)
    PrintableName, ('Cpp-SR-BE\Generator.mref', 627)
    PrintableName-Aux, ('Cpp-SR-BE\Generator.mref', 630)
FileIO::
  G_Handles, ('..\Libraries\all.cpp-s\FileIO.mref', 7)
  WriteLine-T, ('..\Libraries\all.cpp-s\FileIO.mref', 28)


[07.08.2009 - 21:04:53,72]

  [TODO: Командная строка: дополнительная параметризация back-end'ов]
  Написана спецификация нового движка командной строки и нового способа описания опций командной
строкиа, т.к. прежний движок был неудобен: не отслеживал такие характиристики опций как обязатель-
ность/опциональность, однократность/многократность и опции в режиме переключателей -- все эти ха-
рактеристики приходилось отслеживать вручную. Кроме того, новый движок позволяет иметь группу и
именам файлов в командной строке, что позволяет задавать имя и расположение целевого файла индиви-
дуально для каждого файла, например так: filename.mref ( -target:program -path:C:\Dir ).


[16.11.2009 -  8:48:44,69]

  [TODO: Реализовать back-end C++]
  На данный момент back-end C++ уже работает, однако это TODO я не удаляю только по одной причине:
формально осталось одно TODO с префиксом C++, а именно "Устранить Library.cpp и MRefalRTS". Когда
это TODO будет устранено, будет закрыто и текущее TODO.

  [TODO: Командная строка: дополнительная параметризация back-end'ов]
  Новый движок реализован в полном соответствии со спецификацией. Кроме того, для унифицированной
обработки расширений конкретный back-end'ов и для инкапсуляции конкретных команд был реализован на-
бор функций-помощников (см. модуль Config::MHelpers). Инкапсуляция заключается в том, что конкрет-
ные списки команд скрыты внутри модулей-инициализаторов конфигурации конкретных back-end'ов (в фун-
кциях ...::MInit::Extent).
  Однако, функции-помощники имеют и один недостаток: расширяющие опции могут быть только опциональ-
ными, без группы и с параметром.
  Дополнительная параметризация на текущий момент реализована частично --- параметризуется только
выбор компилятора, опция компилятора Си++ include и каталог файлов поддержки времени выполнения.
В дополнение к этому желательно реализовать сам список файлов поддержки времени выполнения, опцию
компилятора define и опцию, означающую "дополнительные опции компилятора C++".


[12.12.2009 - 21:17:14,56]

  [DONE: Командная строка: дополнительная параметризация back-end'ов]
  Недостаток, заключающийся в том, что расширяющие опции могут быть только опциональными, однократ-
ными, с параметром и без группы, так и не исправлен, т.к. я его считаю несущественным.
  Дополнительные опции, перечисленные выше (список файлов времени выполнения, опция define и допол-
нительные опции компилятора Си++) добавлены. К сожалению, недостаток расширяющихся опций, заключаю-
щийся в их однократности, вынудил меня указывать файлы поддержки времени выполнения через запятую
в одной опции.
  Указанные опции расширения относятся только к генератору кода на Си++, т.к. генератор кода на
Простом Рефале параметризуется командной строкой запуска самого компилятора Простого Рефала, где
можно указать все эти дополнительные опции (список файлов времени выполнения, -DINTERPRET для режи-
ма интерпретации, а также любые другие опции компилятора Си++).

  [DONE: Командная строка: упорядочить метаданные -- список back-end'ов и зависимые перехватчики]
  Обработка командной строки и метаданные сейчас уже несколько более упорядочены:
  1. Обработка командной строки разделена на достаточно хороший DSL-движок, способный понимать раз-
личные свойства опций (необязательность/необходимость, однократность/многократность, наличие зави-
симых подопций, наличие опций-переключателей), а также поддерживать достаточно гибкий и мощный син-
таксис: опции с параметром и без, опции с группой подопций и без и т.д., и на собственно описание
конкретно командной строки средствами этого движка.
  2. Кроме того, в рамках описания командной строки средствами упомянутого DSL, сведения о каждом
из возможных парсеров и генераторов вынесены в функцию-таблицу BackEndsTable модуля Config.MLoad,
что также позволяет централизовано управлять метаданными.
  3. Сведения о дополнительных подопциях, соответствующих генераторам Си++ и Простого Рефала под-
гружаются из описания в специальном формате в функциях SRefal-BE.MInit.Extent и Cpp-SR-BE.MInit.\
Extent.
  4. Дополнительные опции, передаваемые в генераторы Си++ и Простого Рефала, на данный момент ис-
пользуются только внутри компоновщиков. Чтобы логически разделить опции командной строки и сам код
компоновщиков, создано средство т.н. "конфигурации" генератора --- абстрактный тип данных t.Config,
передаваемый в обработчик компоновки и представляющий собой ассоциативный массив, индексируемый
именем опции и возвращающий указанное значение (см. Config.MHelpers, функции Extent и Register
в модулях SRefal-BE.MInit и Cpp-SR-BE.MInit).


[14.12.2009 -  0:59:50,39]

  [TODO: Командная строка: параметризация компилятора Си++ опцией "имя исполнимого файла"]
  Различные компиляторы используют различные опции для задания имени результирующего исполнимого
файла. А именно:
  --- компилятор g++ использует ключ командной строки -ofile или -o file;
  --- компилятор MS VC --- ключ /Fefile (также поддерживается и -ofile, но эта опция объявлена не-
желательной);
  --- компилятор BCC 6.0 --- ключ -efile.
  Как следствие, это необходимо параметризовать. На данный момент по соглашению используется опция
-o, для компиляции профилем C++/SR применяются только компиляторы g++ и MS VC.


[24.12.2009 -  3:21:04,72]

  [DONE: Командная строка: параметризация компилятора Си++ опцией "имя исполнимого файла"]
  Добавлена дополнительная опция '-exec', задающая опцию "имя исполнимого файла". Как показала про-
верка, с её использованием можно откомпилировать проект всеми тремя вышеупомянутыми компиляторами.
  Преимущество использования разных компиляторов в том, что они выдают различную диагностику как в
случае ошибок (сравнивая различные сообщения об ошибках, легче понять в чём именно ошибка), так и в
случае предупреждений. В частности компиляция при помощи Borland C++ Compiler 5.5 привела к обнару-
жению погрешностей в коде, которые не обнаруживались двумя другими компиляторами. Об устранении
этих предупреждений будет отдельное TODO.

  [TODO: Устранить предупреждения компилятора BCC55]
  При компиляции компилятором Borland C++ Compiler 5.5 (BCC55) выскакивает множество предупреждений.
Необходимо выяснить их причину и устранить её.


[24.12.2009 - 23:38:45,65]

  [DONE: Устранить предупреждения компилятора BCC55]
  БОльшая часть предупреждений устранена. Причины предупреждений и способы устранения оказались
следующими:
  1. Статическая переменная s_counter в инициализирующей функции в ряде случаев не использовалась.
Для подавления данного предупреждения уже был разработан механизм: переменная по ссылке передава-
лась в пустую функцию, как и в случае с "неиспользуемыми" итераторами. Однако, ряд модулей или
(а) не был после этого перекомпилирован (и, соответственно, в сгенерённом коде эти изменения отра-
жения не нашли), или (б) эти модули перекомпилировались предыдущими версиями (стабильными или уста-
ревшими версиями других back-end'ов). Полная перекомпиляция решила проблему.
  2. В низкоуровневых функциях библиотеки, написанных вручную, код был несколько небрежно написан,
но так как ранее использовались другие компиляторы, предупреждений это не вызывало. Решение: не-
брежности исправлены.
  3. При использовании std::vector<char> внутри написанных вручную функциях возникали предупрежде-
ния внутри самой стандартной библиотеки. Т.к. в стандартную библиотеку лезть нельзя (потому что
нельзя), эти предупреждения будем игнорировать. Переписывать иные функции без использования std::
vector'а трудоёмко и делает код более опасным (т.к. в случае стандартного вектора не приходится за-
ботиться о распределении памяти, в то время как использование realloc вынуждает контролировать па-
мять самостоятельно).
  4. Одно предупреждение (значение присваивалось переменной, но затем не использовалось) было выз-
вано несовершенством генерации кода сопоставления с образцом, содержащим открытые e-переменные. Как
оказалось, сгенерированный код для образцов вида e.Argument e.Tail (т.е. в случаях, когда открытая
e-переменная граничит с закрытой e-переменной) содержит подобное (лишнее) присваивание. Образцы та-
кого рода очень редки, поэтому не имеет смысл исправлять данный частный случай. В настоящий момент
во всём массиве исходных текстов компилятора Модульного Рефала такие образцы не используются, слу-
чай, приведший к предупреждению был всего лишь опиской, не влияющей на семантику программы.
Переменная e.Argument в образце жёсткая_часть e.Argument e.Tail была единственной открытой e-пере-
менной, в результате чего при сопоставлении она получала значение пустого выражения. В результатной
части она не использовалась. Т.е. здесь мы наблюдали забавный случай, заключающийся в том, что ком-
пилятор целевого языка (Си++) сумел обнаружить (совершенно некритичную) ошибку в исходном коде на
входном языке, выдав предупреждение :-).
  Данное конкретное предупреждение устранено путём исправления ошибки в исходном коде, первопричина
ошибки, заключающаяся в несовершенстве генерации кода для сопоставления с образцом устранена не бы-
ла, т.к. бороться с несовершенством надо глобально (переписывая генератор кода) и рано или поздно
это придётся сделать --- внедрение в язык неуспехов потребует отката и возврата к другому варианту
сопоставления, а значит, проектировать код циклов удлинения e-переменных придётся более тщательно.
  5. (Добавлено позже.) Одно из предупреждений компилятора было связано с тем, что пустые функции
компилировались в целевой код обычным образом, а именно, сначала генерировался заголовок, затем
последовательно код каждого предложения, после которых записывалась инструкция возврата refalrts::
cRecognitionImpossible и  закрывающая фигурная скобка. Таким образом, если функция не имела ни од-
ного предложения (как например, функция MSelfDiag::FailDown), генерировался только обычный заголо-
вок, после которого следовал возврат сигнала о неудачном распознавании. Таким образом формальные
параметры функции arg_begin и arg_end оказывались неиспользованными, о чём и сообщал бдительный
компилятор Borland C++. Решение: случай функций с пустым телом обрабатывался как специальный, такие
функции компилировались как $ENUM и $EENUM Простого Рефала (оказалось очень полезно не удалять этот
код из проекта).


[30.12.2009 - 21:10:34,94]

  [TOTHINK: Размещение низкоуровневых функций в отдельном файле рантайма]
  На данный момент библиотечные модули (т.е. написанные вручную на целевом языке --- не путать с
модулями библиотеки --- модулями, входящими в библиотеку языка) пишутся вручную следующим способом:
пишется заготовка на Рефале, компилируется, файл исходного текста удаляется (или переименовывается),
в сгенерированном коде тело функций частично переписывается вручную. Метод хорош и применим на пра-
ктике, однако у него имеются и недостаток. Недостаток заключается в том, что для работы со структу-
рами поля зрения зачастую недостаточно элементарных операций одного только рантайма (точнее, ими
пользоваться можно, но неудобно): нужны более высокоуровневые средства, например для прочтения из
поля зрения текстовой строки переменной длины разработана функция считывания данных в вектор STL
переменного размера. На данный момент эта функция тупо скопирована в каждый из файлов реализаций
библиотечных модулей, что, очевидно, нарушает правила модульности и хорошего стиля программирования.
Кроме того, при подобной практике в библиотечных модулях помимо написанного вручную кода, присутст-
вуют и артефакты кодогенерации, такие как предобъявления функций, блоки инициализации-финализации и
закодированные полные квалифицированные имена функций, что затрудняет прочтение, понимание и после-
дующее сопровождение этих файлов.
  Для решения этих проблем предлагается код, реализующий низкоуровневые детали реализации, помещать
в отдельный файл исходного текста, который будет затем подключаться точно таким же образом, как сей-
час подключается файл refalrts.cpp. Этим функциям (реализующим, например, ввод-вывод, арифметику
или средства операционной системы) предлагается давать ясные имена, возможно, помещая их в специаль-
ное пространство имён (например, refal_lib::add). Затем, из кода собственно библиотечных модулей
непосредственно вызывать эти функции, например:

refalrts::FnResult StdP_MathP_Add(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  return refal_lib::add(arg_begin, arg_end);
}

  В примере предполагается, что функция refal_lib::add объявлена выше. Кроме того, файл реализации
низкоуровневых функций может содержать сразу несколько функций разных модулей библиотеки, что упро-
стит повторное использование кода, общего для нескольких функций.
  Данное TOTHINK вовсе не конфликтует с TODO "C++: Устранить Library.cpp и RefalRTS", а даже наобо-
рот, выполняет схожую задачу. Вместо имеющегося на данный момент объединения низкоуровневых функций
в уродливых полунаписанных-полусгенерированных модулях Library.cpp и RefalRTS, код, который непо-
средственно пишется вручную на целевом языке (Си++), будет находиться в файле, целиком (или почти
целиком) написанном вручную, в автоматически созданных заготовках будет минимум написанного вручную
кода.
  Кроме того, данная стратегия может быть полезна и для реализации низкоуровневых функций, совместно
используемых back-end'ами Си++ и Простого Рефала (хотя вопросы совмещения этих двух back-end'ов на-
до отдельно прорабатывать): библиотечные модули обоих языков могут ссылаться на функции, описанные
в отдельном файле исходного текста, подключаемом на этапе генерации целевого языка.
  Кроме того, организация низкоуровневых модулей таким образом облегчит дальнейшую реструктуризацию
стандартной библиотеки.


[05.01.2010 -  1:45:39,45]

  [TODO: Размещение низкоуровневых функций в отдельном файле рантайма]
  Это TODO --- чистая формальность, т.к. к выполнению этой задачи я уже приступил и даже сделал не
менее трети работы. Как не трудно догадаться, процесс идёт параллельно с переписыванием библиотеки
back-end'а Си++. На данный момент уже переписаны модули Math, FileIO, MStrings, InOut, MOS. Модуль
MStrings был перемещён в каталог all.all с вызовом функций модуля CoreBE::MStrings, который в back-
end'е Си++ написан на Си++, в остальных back-end'ах --- на Модульном Рефале с вызовом функций моду-
ля MRefalRTS.
  Как положительный результат на этом этапе можно отметить написание ряда вспомогательных средств:
макросы REFAL_FUNC, DECL_REFAL_IDENT и REFAL_IDENT, вспомогательные классы CharArray и AllocArray,
первый представляет собой строковой класс, поддерживающий размещение данных в виде массивов языка
Си --- поверх класса std::vector<char> (класс std::string не даёт гарантий такого размещения), вто-
рой позволяет хранить неопределённое количество фрагментов распределённой памяти, которые затем
можно сконкатенировать и построить результат, а также функция string_from_seq (правда, написанная
давно), считывающая цепочку char'ов из рефал-выражения в массив CharArray.
  Впрочем, этот процесс имеет и один недостаток. Он заключается в том, что реализации всех функций
находятся в одном файле, в то время как идеологически предполагается разбиение функций, специфичных
для каждого back-end'а на платформенно-независимые функции и функции, специфичные для конкретной
операционной системы. Этот недостаток устраним: достаточно один файл разбить на два, в одном из ко-
торых будут находиться определения переносимых функций, в другом --- определения функций, специфич-
ных для Windows. Но этот недостаток я буду устранять не ранее, чем после того, как допишу и отлажу
текущую библиотеку.
  Написан большой массив кода, который компилируется (проверял), но ещё ни разу не запускался. Как
только допишу текущую версию библиотеки, буду развлекаться с отладкой. Чувствую, что получу немало
удовольствия.

  [TODO: Устранить лишние вызовы функции MOS::System]
  В текущей рабочей версии библиотеки back-end'а Си++ функции создания папки и удаления файла уже
реализованы как элементарные, в пишушейся версии библиотеки функции работы с переменными среды ис-
пользуются функции WinAPI, поэтому, отлажу новую версию библиотеки, это TODO можно будет считать
выполненным для профиля (тут всё-таки корректнее говорить о профиле) Си++.
  Относительно других профилей: устранить из профиля Рефала 5 подобные вызовы невозможно, т.к.
иначе (не меняя сами интерпретатор и компилятор Рефала 5) невозможно реализовать внешние функции;
профиль Простого Рефала даёт больший простор для надежды, т.к. можно написать вручную ещё один
модуль примитивных функций или даже расширить WinLib.cpp.

  [CHANGED: Упрощён код генерации циклов по открытым e-переменным в back-end'е Си++]
  Вместо использования переменных c суффиксом _stk и перекрытия имён функций во вложенных блоках
явным образом используются переменные с различными именами для представления диапазонах на различ-
ных уровнях вложенности. Цикл теперь выглядит примерно следующим образом:

    //Открытая e-переменная e.Set1_B
    for( 
      refalrts::Iter boe_1_0 = bb_1_0;
      ! empty_seq( boe_1_0, be_1_0 );
      refalrts::next_term( boe_1_0, be_1_0 )
    ) {
      refalrts::Iter bb_1_1 = bb_1_0;
      refalrts::Iter be_1_1 = be_1_0;
      refalrts::Iter bb_2_1 = bb_2_0;
      refalrts::Iter be_2_1 = be_2_0;
      bb_1_1 = boe_1_0;
      eSet1U_B_b_1 = bb_1_0;
      eSet1U_B_e_1 = boe_1_0;
      refalrts::move_right( eSet1U_B_b_1, eSet1U_B_e_1 );
      ...
      //Открытая e-переменная e.Set2_B
      for( 
        refalrts::Iter boe_2_1 = bb_2_1;
        ! empty_seq( boe_2_1, be_2_1 );
        refalrts::next_term( boe_2_1, be_2_1 )
      ) {
        refalrts::Iter bb_2_2 = bb_2_1;
        refalrts::Iter be_2_2 = be_2_1;
        bb_2_2 = boe_2_1;
        eSet2U_B_b_1 = bb_2_1;
        eSet2U_B_e_1 = boe_2_1;
        refalrts::move_right( eSet2U_B_b_1, eSet2U_B_e_1 );
        ...

  Теперь логикой работы цикла целиком управляет заголовок цикла for: начальное состояние инициали-
зируется как диапазон [boe_K_N, be_K_N], в точности соответствующий исходному диапазону, цикл про-
должается до тех пор, пока упомянутый диапазон не станет пустым, на каждой итерации этот диапазон
укорачивается.
  За циклом следует операция инициализации/восстановления границ тех диапазонов (со вторыми индек-
сами на единицу бОльшими), которые перемещаются в процессе сопоставления. После чего происходит
инициализация собственно открытой e-переменной, которая получает значение, представляющее диапазон
между исходной левой границей диапазона и перемещающейся границей-переменной цикла.
  Данная модификация генерации кода делает логику сопоставления с образцом более простой и понят-
ной, что упростит будущее внедрение в язык откатов (даже если потом придётся писать новый генера-
тор кода).



[06.01.2010 - 22:15:43,19]

  [ERROR: Ошибка при циклическом импорте модулей]
  Обнаружена ошибка, приводящая к дампу поля зрения, возникающая, предположительно, при циклическом
импорте модуля, импортируемого с псевдонимом. Ошибка выскочила на файле с таким содержимым:

$MODULE CoreBE::MOrder;

...

$IMPORT Core = CoreBE::MOrder;

...

$END CoreBE::MOrder.


[07.01.2010 - 23:12:41,12]

  [DONE: C++: Устранить Library.cpp и RefalRTS]
  Рукотворная часть библиотеки профиля Си++ (т.е. тот функционал, который реализуется примитивными
функциями, написанными на Си++) полностью переписана таким образом, что она не использует код, на-
писанный на Простом Рефале/для профиля Простого Рефала/для профиля Рефала 5. Хронологически профили
появлялись в следующем порядке: Рефал 5, Простой Рефал, C++/SR (такое официальное название профиля
Си++, т.к. он основан на рантайме и генераторе кода компилятора Простого Рефала). Поддержка времени
выполнения и базовая часть библиотеки Рефала 5 представляла (да и сейчас представляет) собой един-
ственный модуль MRefalRTS, написанный на целевом языке (своебразный фрагмент кода на Рефале 5) и
содержащий функции, одноимённые встроенным функциям Рефала 5 и вызыващих оные. В целях упрощения и
ускорения разработки базовые функции профиля Простого Рефала сначала представляли собой тот же мо-
дуль MRefalRTS, который впоследствии был дополнен другими модулями примитивных функций, в частности,
для работы с файловой системой и вводом-выводом, т.к. файловый ввод-вывод в стиле Рефала 5 крайне
неудобен. При появлении профиля C++/SR модули элементарных функций были позаимствованы от предыду-
щего профиля, т.к. на тот момент их рантаймы были совместимыми. Таким образом профиль Си++ был отя-
гощён рудиментами типа подключения библиотеки Library.cpp, функции которой косвенно вызывались из
библиотечных модулей библиотеки, т.к. базовые модули, целевой код которых должен был писаться вруч-
ную был фактически сконвертирован их Простого Рефала. Кроме того, немалая доля элементарных функций
была доступна из модуля MRefalRTS, что никак не соответствует исходному предназначению последнего
(редиректы к функциям Рефала 5).
  Выходом из этой ситуации, очевидно, является коренное переписывание библиотечных модулей библио-
теки профиля Си++ таким образом, чтобы не реализуемые средствами Рефала функции, вызываемые из поль-
зовательского кода, были или непосредственно написаны на целевом языке, или вызывались из других
библиотечных модулей с небольшой дополнительной обработкой (желательно не более двух уровней подоб-
ной косвенности). Что и было сделано для рассматриваемого профиля. Использовалась стратегия "Разме-
щение низкоуровневых функций в отдельном файле рантайма" (TOTHINK/TODO/DONE).
  Следующим шагом является такая же ревизия библиотек, относящимся к двум другим профилям компиля-
ции. Возможно, она будет выполнена к текущей структуре библиотеки, возможно параллельно с реструк-
туризацией.
  Положительным побочным эффектом этого этапа работы можно считать более тщательный анализ библио-
теки и её декомпозицию на переносимую и непереносимую часть. В структуре каталогов библиотеки ряд
модулей переместился в папки all.all и windows.all, непереносимый же код переместился в пакет
CoreBE как в библиотечные модули, так и в модули с исходным текстом.

  [DONE: Реализовать back-end C++]
  Фактически, back-end (вернее, профиль) был реализован давно и давно уже успешно использовался.
Это TODO висело так долго только из-за того, что одна из задач, помеченная как подзадача, долго де-
лалась. TODO "C++: Устранить Library.cpp и MRefalRTS" закрыто, значит закрыто и текущее TODO.

  [DONE: Размещение низкоуровневых функций в отдельном файле рантайма]
  Данное TODO выполнено в полном соответствии с описанием. Разделять baselib.h/baselib.cpp на две
части: переносимую и непереносимую я пока не стал, т.к. задач переноса под другие платформы в обоз-
римом будущем пока не стоит.
  Отлаживал на на удивление быстро --- за один день компилятор уже смог компилировать свой исходный
текст. Возможно, есть и скрытые ошибки, которые находятся в неиспользуемых (в компиляторе) функциях
или проявляются в тех ситуациях, которые в исходных текстах компилятора не возникают, но задачи ком-
плексного тестирования я пока не ставил (возможно, поставлю позже).

  [TOTHINK: Написание комплексных тестов для библиотеки]
  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.

  [TODO: Устранить лишние вызовы функции MOS::System]
  В новой версии библиотеки профиля Си++ функция MOS::System больше не используется для реализации
посторонних операций, таких как получение списка переменных среды или файловые операции. Однако,
чрезмерное использование MOS::System (а если говорить шире, то командного интерпретатора Windows)
cохраняется как в профиле Простого Рефала, так и в самом компиляторе (в частности, в компоновщиках
порождаются командные файлы, которые тут же исполняются). Устранение лишних вызовов из профиля Про-
стого Рефала возможно только после реорганизации соотвествующей библиотеки (благо, процесс уже на-
чат). Улучшение структуры самого компилятора возможно только со стороны написания новых библиотеч-
ных функций для копирования или переименования файлов (отсутствие которых и вынуждает генерить па-
кетные файлы с командами копирования и переименования).

  [TODO: Реорганизация имеющейся библиотеки (РБ)]
  Точно также, как сейчас была реорганизована библиотека профиля Си++, нужно реорганизовать профили
Простого Рефала и Рефала 5. В скобках указан префикс для подзадач.

  [TODO: РБ: Реорганизация библиотеки профиля Простого Рефала]
  Необходимо реорганизовать библиотеку профиля Простого Рефала по аналогии с профилем Си++, а имен-
но избавится от рудимента --- модуля MRefalRTS. Возможно задействие модуля baselib.h/baselib.cpp
профиля Си++.

  [TODO: РБ: Реорганизация библиотеки профиля Рефала 5]
  См. надзадачу. Реорганизация по аналогии с профилем Си++. Кроме того, желательно написать новые
библиотечные модули взамен модуля MRefalRTS. В частности, можно инкапсулировать факт конечного чис-
ла дескрипторов файлов взамен функций MRefalRTS::Open и сопуствующих. Неплохо было бы пересмотреть
утилиту mr-extent.exe.

  [TODO: Ревизия задач]
  Необходимо пересмотреть список приоритетных задач.


[12.01.2010 - 11:01:24,51]

  [TOTHINK: Объединение рантаймов профиля C++/SR и компилятора Простого Рефала]
  В заголовке написано "компилятор Простого Рефала". Это означает, что речь идёт не о профиле ком-
пиляции в Простой Рефал, а именно о самом Простом Рефале. Под рантаймом тут подразумевается пара
файлов refalrts.h и refalrts.cpp.
  После появления самостоятельного профиля компиляции C++/SR оба рантайма развивались параллельно:
для Простого Рефала Вадимом Сухаревым был разработан режим интерпретации, позже были внедрены вло-
женные функции. Вложенные функции привели к распределению памяти в пуле, а не по одному узлу; в
рантайме профиля компиляции в Си++ для обозначения имён замыканий стали использоваться идентифика-
торы вместо константных C-строк.
  Из-за последней особенности рантаймы стали несовместимы. Несовместимость можно преодолеть, ис-
пользуя условную компиляцию и, например, на время компиляции в C++/SR определять макрос MREFAL или
MODULE_REFAL.
  Объединение рантаймов позволит использовать функции высших порядков в двух профилях Модульного
Рефала.


[12.01.2010 - 11:52:13,25]

  [TODO: Объединение рантаймов профиля C++/SR и компилятора Простого Рефала]
  Ещё одна причина. Это упростит использование baselib.h/baselib.cpp и в библиотеке профиля Просто-
го Рефала.


[12.01.2010 - 12:46:39,51]

  [DONE: Объединение рантаймов профиля C++/SR и компилятора Простого Рефала]
  Объединил, всё теперь компилируется и работает (профиль C++/SR, профиль Простого Рефала, сам Про-
стой Рефал). Более того, внесены незачительные изменения в baselib.cpp, позволяющие компилировать
библиотеку как в режиме Простого, так и в режиме Модульного Рефала. Таким образом, можно применить
наработки для библиотеки профиля C++/SR и для библиотеки профиля Простого Рефала.

  [TODO: Модуль компиляции исходных файлов на Си++]
  Идея этого задания в том, что компиляцию сгенерированных исходных текстов на Си++ локализовать в
одном модуле. В модуль войдёт кроме функции компиляции ещё и набор опций компилятора Си++. Данный
модуль позволит более тонко управлять компиляцией "сишных" файлов в профиле Простого Рефала, самому
же Простому Рефалу оставив только преобразование .sref в .cpp. При дальнейшей эволюции компилятора,
а именно, при разработке новых back-end'ов в Си++, данный модуль можно использовать повторно.


[15.01.2010 - 23:43:58,82]

  [DONE: РБ: Реорганизация библиотеки профиля Простого Рефала]
  Т.к. рантаймы компилятора Простого Рефала и профиля C++/SR Модульного Рефала объединены, было ре-
шено использовать наработки профиля C++/SR в профиле Простого Рефала. Для этой цели написан файл
MR-BaseLib.cpp, представляющий собой библиотечный модуль Простого Рефала, подключаемый к нему на
этапе компоновки. Функции этого модуля осуществляют перенаправление к соответствующим (с точностью
до соглашений об именах одноимённым) функциям модуля baselib.h/baselib.cpp, что позволило написать
новую библиотеку для Простого Рефала, параллельную библиотеке профиля Си++.
  Т.к. небиблиотечные модули библиотеки для обоих профилей оказались одинаковыми, а библиотечные
модули имеют одинаковый интерфейс (т.к. они просто перенаправляют вызовы к функциям из baselib.*),
было решено объединить каталоги библиотек в общие подкаталоги с суффиксом srcpp: ***.srcpp01-?, где
вместо *** используется all и windows, ? замещает s и b.
  К сожалению, я не могу удалить старые версии файлов ***.cpp-? и ***.sr-?, т.к. их используют ста-
бильные версии компиляторов, которые не знают о существовании baselib.***.


[15.03.2010 - 22:26:57,71]

  [ERROR: Завершение программы и функция Exit]
  Согласно модульной модели языка (пардон за тавтологию), при завершении программы должны быть выз-
ваны финализаторы модулей, причём независимо от того, завершилась она естественным образом (выпол-
нение функции Go завершилось) или принудительно (вызывана MOS::Exit или MSelfDiag::ExitFailure в
текущей редакции библиотеки).
  Чтобы упростить себе работу, для профилей Простого Рефала и Рефала 5 функции финализаторов я ре-
гистрировал в соответствующих инициализаторов (аналогично atexit в Си), а затем в конце функции
Go вызывал функцию Exit для выполнения кода финализации. Код регистрации и завершения программы был
опрометчиво помещён в библиотеку, поэтому, если программа не использует модуль MOS::Exit, код этих
функций не подключается к программе и программа не компонуется.
  Данная проблема не коснулась профиля Cpp-SR, т.к. он использует свой (хоть и кривой) механизм
работы инициализаторов и финализаторов. Функция финализации Exit генерится одновременно с функцией
Go в одном файле и вызывает все требуемые финализаторы.
  Эту ошибку можно (и нужно) рассматривать как TODO, т.к. она требует проанализировать и переписать
имеющиеся механизмы инициализации и финализации.
  Напоследок, пример кода, где программа валится:

$PROGRAM Test;

$IMPORT InOut;

$ENTRY Go = <InOut::WriteLine 'Test'>;

$END Test.

  Ошибка вылезла в связи с переписыванием библиотеки профиля Рефала 5, т.к. раньше весь функционал
находился в модуле MRefalRTS, а теперь при переписывании библиотеки (на данный момент --- MSelfDiag
с функцией ExitFailure) пришлось продумывать механизм завершения программы.


[18.03.2010 - 20:39:33,71]

  [FIXED: Завершение программы и функция Exit]
  Ошибка исправлена.
  В профиль Простого Рефала внесены следующие изменения:
  1. Теперь инициализаторы модулей содержат только код инициализации и код регистрации финализато-
ров. Инициализаторы теперь имеют имя %полное имя модуля%P_EntryPointE_.
  2. Функция Main головного модуля теперь также вызывается из функции %полное имя головного модуля%
P_EntryPointE_.
  3. На стадии компоновки формируется модуль с именем %имя программы%.main.sref, в котором распола-
гаются следующие три функции:
    1) статический ящик G_Finalizers, хранящий стек функций финализации;
    2) функция RegisterE_, предназначенная для регистрации финализаторов;
    3) функция Go, содержащая последовательность вызовов функций ...EntryPointE_ в порядке от им-
портируемых модулей к импортирующим, которая завершается функцией ExitE_;
    4) функция ExitE_, вызывающая финализаторы модулей (из стека G_Finalizers) и функцию Exit биб-
лиотеки baselib.
  Профиля Рефала 5 изменения почти не коснулись: в генерируемый код была лишь добавлена функция
$Entry::__Exit$, которая вызывает финализаторы, закопанные под именем Finalizers.
  Кривой механизм финализации профиля Cpp-SR я не трогал, хотя следовало бы.


[12.04.2010 -  1:05:18,48]

  [DONE: РБ: Реорганизация библиотеки профиля Рефала 5]
  Все библиотечные модули Рефала 5 были сделаны по интерфейсу аналогичных библиотечных модулей объ-
динённого профиля Простого Рефала и C++/SR, что позволило .rout-файлы поместить в каталоги all.cpp\
01-b и windows.cppsr01-b, удалив при этом каталоги с суффиксами .r5-b и .r5-s. Сложностей с модуля-
ми Core::Math, Core::MFileIO, CoreBE::MOrder, CoreBE::MSelfDiag, CoreBE::MStrings не было, почти не
возникло проблем с модулем CoreOS::MOS, а вот с CoreOS::MFileSystem пришлось повозиться.
  Модули, с которыми проблем не было, как правило просто перенаправляли вызовы к аналогичным встро-
енным функциям Рефала 5 или реализованы очевидно. Некоторая возня возникла с модулем MOS в связи с
интерфейсами: наружу предоставляется функция CommandLine, возвращающая командную строку, которая
затем разбивается на аргументы, в то время как целевая платформа (Рефал 5) предоставляет уже разби-
тую на аргументы командную строку. Поэтому пришлось эти аргументы склеивать в одну командную стро-
ку, что на целевом языке (язык .rout-файлов на входе линковщика), делать сравнительно тоскливо.
  Столь же тоскливым по процессу (dx/dt), но более тоскливым по достижению конечного результата
(INT...dt) было написание модуля CoreOS::MFileSystem, т.к. функций целевой платформы, реализующих
требуемые возможности, просто нет. Поэтому пришлось как и раньше писать и вызывать функцией System
стороннюю программу, выполняющую требуемую работу, а значит сериализовывать и десериализовывать ар-
гументы и результаты функций. Т.к. библиотечные модули не могут использовать модули с исходным ко-
дом, а писать на Модульном Рефале, а затем тереть (или переименовывать) исходник мне западло ибо
неэлегантно, сериализацию и десериализацию я написал на целевом языке.
  Новшеством здесь было то, что сама внешняя программа была написана на Модульном Рефале, при этом
откомпилирована при помощи профиля C++/SR. Это позволяет:
  а) сохранить общую семантику функций для разных профилей;
  б) упростить сериализацию/десериализацию, т.к. её на Рефале писать несколько проще;
  в) несколько упростить отладку.
  Относительно отладки следует сказать отдельно. Новая программа (FS-Extent) разрабатывалась сов-
местно с другими т.н. утилитами, т.е. программами каталога Sources/Utilities дерева проекта. Утили-
ты компилируются в текущей конфигурации в двух режимах: сначала для профиля C++/SR, затем для про-
филя Рефала 5. Исходный текст программы непосредственно вызывает функции модуля CoreOS::FileSystem,
так что таким образом программа, откомпилированная профилем Рефала 5 должна была для работы вызывать
саму себя (точнее, C++/SR-версию). Это позволило проверить работу как самой внешней программы, так
и библиотечного модуля, написанного на целевом языке, т.к. позволяло сравнивать результаты .rsl- и
.cpp.exe-версий.
  В общем, не считая тягомотины с написанием на тоскливом целевом языке сериализации/десериализации
выражений, писать получилось весело.
  В качестве недостатка можно указать неиспользование возможностей Рефала 5. Для проверки существо-
вания файла используется запрос атрибутов файла --- если он успешен, то файл существует. С точки
зрения профиля Рефала 5 это означает вызов внешней программы, хотя в библиотеке встроенных функций
присутствует функция ExistFile, которая проверяет файл на существование за гораздо меньшее время.
Возможно, это следует исправить.
  В целом, результатом я доволен.

  [DONE: Реорганизация имеющейся библиотеки (РБ)]
  Библиотеки профилей Простого Рефала и Рефала 5 реорганизованы. Подробности в соответствующих DONE.


[17.04.2010 - 17:40:47,00]

  [DONE: Удалить MRefalRTS::Put]
  В результате реорганизации библиотеки был удалён и сам модуль MRefalRTS --- уже по-этому можно
считать это TODO нерелевантным. Ранее эту функцию (MRefalRTS::Put) использовал модуль MSelfDiag для
реализации функции Log-T. Теперь MSelfDiag для реализации функций Log и Log-T использует функции
CoreBE::MSelfDiag::Log и CoreBE::MSelfDiag::Log-T, написанные на целевом языке профиля. Вызовы функ-
ций Put и Putout внутри этих файлов выглядят вполне законченно и гармонично --- модули на целевом
языке могут использовать всю мощь целевой платформы, если это необходимо для реализации требуемого
интерфейса.

  [DONE: Устранить лишние вызовы функции MOS::System]
  "Неуместные" вызовы MOS::System устранены: теперь она используется только внутри компоновщиков,
которые её используют для запуска внеших компиляторов. Для выполнения посторонних утилитарных нужд
она больше не используется: т.к. такие действия, как создание папки и удаление файла или папки уже
выполняются библиотечными модулями, написанными на целевом языке, в том числе и в профиле Рефала 5.
В последнем, конечно, применяется вызов фукции System для выполнения внешних операций, но этот вы-
зов присутствует только в библиотечных модулях на самом низком уровне.
  Тот факт, что профили Простого Рефала и C++/SR активно используют командный интерпретатор, т.к.
генерят и тут же запускают bat-файлы, никак не влияет на завершение этого TODO. Во-первых, в заго-
ловке чётко говорится о том, что нужно устранить сами лишние вызовы MOS::System, а не изменять
способ компиляции. Во-вторых, для этого сейчас будет написано отдельное TOTHINK.

  [TOTHINK: Уйти от использования bat-файлов на стадии компоновки]
  На данный момент профили Простого Рефала и C++/SR используют генерацию bat-файлов для вызова сто-
ронних компиляторов. Это нежелательно по следующим причинам:
  (а) снижает переносимость, т.к. привязывает к платформе Windows;
  (б) засоряет каталог ненужными файлами;
  (в) требует использования в качестве компилятора строки вида 'call compile_cl.bat', что открывает
детали реализации (то, что генерится батник).
  В то же время, сгенерированный bat-файл позволяет лучше понять содержимое командной строки и в
ряде случаев упрощает отладку.
  В общем, это надо обдумать.


[01.05.2010 - 17:52:48,14]

  [FIXED: Ошибка при циклическом импорте модулей]
  Как оказалось, ошибка была связана с нарушением инварианта внутри IModule. Дело в том, что импор-
тируемый модуль внутри промежуточного представления представляется двумя записями во внутренней таб-
лице символов: записью для самого модуля и записью для его псевдонима. Инвариант IModule предпола-
гал, что обе записи должны формироваться и изменяться согласованно, однако, это требование не выпол-
нялось. В приведённом выше примере для псевдонима Core запись создавалась, но для настоящего имени
CoreBE::MOrder запись создать не удавалось, т.к. возникал конфликт с записью для самого модуля.
  Программа падала на функции AnalyzeValidSubModule-AddError, её код и код её вызова приведены ниже:

  AnalyzeValidSubModule-AddError
    s.FnAddError t.hErrorList t.Alias
    t.hRawIModule Found t.SrcPos =
      (
        <s.FnAddError t.hErrorList t.SrcPos t.Alias>
        t.hRawIModule
        Errors
      );

    ...
      <AnalyzeValidSubModule-AddError
        & MError.AddBrokenImport
        t.hErrorList t.ImportName
        <MIModule::GetImportAttribute-RealName
          t.hRawIModule Position t.ImportName
        >
      >;
    ...

  Проблема заключалась в том, что список имён модулей подгружался функцией MIModule::GetImportList-\
Aliases, а атрибут (в данном случае --- позиция внутри модуля) брался у реального имени, которого не
было. В результате чего AnalyzeValidSubModule-AddError падала.
  Функция была исправлена путём контроля согласованности псевдонима и реального имени на уровне про-
межуточного представления и добавления контроля ошибок на уровне синтаксического анализа: перед до-
бавлением импорта в IModule теперь проверяется на переопределение не только псевдоним, но и реальное
имя (реальное имя не должно совпадать с именем модуля и именем импорта).

  [TODO: Стандартные модули контейнеров и распространённых функций]
  Относительно предыдущего TODO-звена сделано следующее.
  (1) Математическая библиотека только расширилась вышеупомянутыми функциями.
  (2) Что касается упрощения переносимости, то с этой точки зрения библиотека сильно изменилась. Во
многих случаях добавились дополнительные слои абстракции, выраженные пакетами CoreBE и CoreOS, хотя
внимание было больше сосредоточено на переносимости между back-end'ами в рамках платформы Windows.
  Для достижения более чёткой переносимости между различными операционными системами следует тща-
тельнее проанализировать модули MOS и MFileSystem, вынося из них код на Рефале, характерный для ОС
Windows.
  (3) Поскольку последние изменения библиотеки касались в большей степени внутренней структуры, чем
интерфейса, переносить модули библиотеки в пакет я не счёл нужным. Перенос модулей библиотеки в па-
кет логически относится к изменению интерфейса библиотеки, поэтому его следует отложить до того вре-
мени, когда нужно будет существенно переработать интерфейс. Последнее целесообразнее делать после
введения в язык вложенных функций --- в этом случае замыкания будут гораздо активнее применяться в
языке и, соответственно, интерфейс библиотеки надо будет адаптировать под изменение стилей програм-
мирования.
  Итог. Для завершения данного TODO следует грамотно переработать библиотеку с точки зрения перено-
симости между различными ОС.

  [TODO: СМКиРФ: Подготовка библиотеки к переносимости между различными ОС]
  Суть в том, чтобы подготовить библиотеку к переносу на другие платформы, прежде всего, под плат-
форму POSIX. Выбор последней обусловлен тем, что это достаточно распространённая платформа (вклю-
чает в себя GNU/Linux, *BSD, QNX и даже MacOS X) и у меня есть опыт работы с двумя представителями:
QNX и GNU/Linux. DOS я не рассматриваю вследствие большого объёма исполнимого файла (несколько ме-
габайт) и больших потребностей в оперативной памяти, что затрудняет работу с ним. Мобильные платфор-
мы я не рассматриваю по двум причинам: у меня на данный момент нет смартфона и Рефал на них не так
уж и нужен.


[01.05.2010 - 19:30:19,45]

  Ниже будет выполнена ревизия задач.

  [TODO: //== Список приоритетных TODO ==\\]
  Условия поднятия версии сохраняются.
  Идея версии 0.2 в том, чтобы получить стабильную реализацию языка Модульный Рефал, включающую в
себя компилятор, библиотеку и, возможно, документацию.
  Компилятор должен прежде всего стабильно работать, иметь удобный интерфейс (что уже почти достиг-
нуто) и быть логически законченным --- не иметь каких-либо недоделок и незавершённых начинаний.
  Библиотека тоже должна стабильно работать и предоставлять достаточно юзабельный и кроссплатфор-
менный интерфейс.
  Поскольку добавление ряда фич (например, расширение синтаксиса) не повлияет или слабо повлияет
на упомянутые выше цели, но сильно замедлит разработку, не собираюсь внедрять новые фичи в язык
или компилятор.

  [+TODO: RASL и интерпретатор]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Продумать упрощение структуры Lexer'а и Parser'а]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Обдумать введение видов для квалифицированных имён]
  (Ревизия 01.05.2010) Целесообразность такой функции сомнительна, но как интересную идею оставлю.

  [+TODO: Продумать генераторы лексического и синтаксического анализаторов]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Есть задумка использовать не генератор синтаксического анализа, а интерпретируемый DSL. Задумка
уже есть (Documentation/Перспективы и тупики/Синтаксический анализатор.txt).

  [+TODO: Продумать двухуровневую структуру синтаксического анализа]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.

  [+TODO: Продумать изменения в лексике и комментариях]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Мне хочется, чтобы версия 0.2 была совместима с синтаксисом языка версии 0.1, т.е. чтобы можно
было откомпилировать исходники выпуска 0.1 выпущенной версией 0.2. Поэтому комментарии со звёздоч-
кой я убирать пока не буду, а только назову их deprecated.
  Комментарии со звёздочкой удалю при первой же переработке синтаксиса языка. А имена со строчной
буквы не нужны, т.к. никаких принципиально новых возможностей дать пока не могут.

  [+TOTHINK: Отдельно собирать информацию об ошибках в журнале проекта]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Ошибок у меня обнаруживается, как правило, мало, они своевременно устраняются. Поэтому некритично.

  [TODO: Продумать максимальную длину имени модуля]
  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Эти ограничения в большей степени относятся к возможностям back-end'ов, целевого языка и исполь-
зуемой платформы. А вот нужны ли синтаксические ограничения, этот вопрос надо обдумать.

  [TOTHINK: Ограничения на MODULEPATH]
  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  На уровне программы это никак не контролируется, записано лишь в спецификациях. При отрицательном
ответе на вопрос достаточно лишь поправить строчку текста.

  [TODO: ПИ:Хранить в контексте также информацию о пакетах]
  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Вообще, надо разобраться, как поведёт себя компилятор, если это требование будет нарушено.
  На данный момент в полных квалифицированных именах функций модули всегда являются предпоследними
сегментами в именах, а пакеты --- перед ними. Так что конфликтов быть не должно. Но при появлении
вложенных именованных функций возможны проблемы с этим. Так что надо обдумать это дело.

  [+TODO: Продумать блоки $INIT и $FINAL]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Синтаксис менять я не собираюсь, поэтому оставляю этот пункт в копилку идей.

  [TOTHINK: Имя и путь целевого файла]
  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Этот пункт имеет важное значение с точки зрения юзабельности компилятора, поэтому он требуется для
выпуска версии 0.2.

  [TODO: Обновить стабильную версию и поднять версию компилятора]
  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2.
  Стабильные версии компиляторов обновлены. А вот поднять номер сборки надо. Давно надо. Т.к. я дав-
но не поднимал номер сборки, я сборку выполню от 20 до 40 раз. Столько, сколько потребуется для на-
ладки операции make к новому синтаксису командной строки.
  Следует организовать новый порядок инкремента номера сборок --- когда происходит завершение задачи
в журнале, выполняется новая сборка. Возможны и другие варианты, но они должны быть чётко привязаны
к конкретной деятельности.

  [+TOTHINK: Написание комплексных тестов для библиотеки]
  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.

  [DONE: Ревизия задач]
  Уже делаю (см. сегодняшнюю запись в журнале).

  [TODO: Модуль компиляции исходных файлов на Си++]
  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, т.к. имеет прямое отношение к юзабельности
компилятора.

  [TOTHINK: Уйти от использования bat-файлов на стадии компоновки]
  (Ревизия 01.05.2010) Если версия 0.2 будет кроссплатформенной, то этот пункт важен. В противном
случае bat-файлы можно оставить (разумеется, удаляя пакетные файлы сразу после их выполнения ---
сейчас эта возможность закомментирована).

  [TODO: Стандартные модули контейнеров и распространённых функций]
  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, т.к. в круг задач входит получение стабиль-
ной и логически согласованной библиотеки.

  [TODO: СМКиРФ: Подготовка библиотеки к переносимости между различными ОС]
  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, как подзадача требуемой задачи.

  [TODO: \\== Вот список приоритетных TODO ==//]
  Условия поднятия номера версии сохраняются.


[03.05.2010 - 23:21:46,12]

  [DONE: Обновить стабильную версию и поднять версию компилятора]
  Пакетный файл, применяемый для выполнения сборки, сменил имя с make.bat на build.bat, что более
точно отражает его суть. Кроме того, внутренняя логика изменилась. Теперь сначала выполняется три
прохода компиляции тремя профилями и с соответствующими профилями --- чтобы определить наличие син-
таксических ошибок.
  Если проход оказался успешен, обновляется версия компилятора и производится 9 проходов: каждым
профилем (как результатом компиляции --- исполнимым файлом) с каждым профилем (как режимом компиля-
ции).
  После этого происходит обновление файлов стабильной версии компилятора.
  Утверждаю порядок выполнения сборок.
  1. Сборка должна выполняться, когда после сравнительно крупных изменений была получена устойчивая
версия.
  2. Сборка должна выполняться после завершения очередного TODO или ERROR (до занесения результатов
в отчёт).
  Следствие. После завершения очередного TODO или ERROR необходимо добиваться получения устойчивой
версии.


[16.05.2010 -  0:35:57,09]

  [TODO: Ограничения на MODULEPATH]
  Задачу (обдумывание) я завершил, но это TODO здесь технически необходимо: невозможно закрыть тег
TOTHINK тегом DONE или CHANGED (хотя последние два здесь были бы более уместны). О сделанных изме-
нениях написано ниже в DONE.

  [DONE: Ограничения на MODULEPATH]
  Спецификация была модифицирована, текущая версия находится в файле "Поиск исходников.03.txt".
  Модификации сводятся к следующему:
  1. Снят запрет на использование относительных ссылок ("." и "..") внутри путей MP-каталогов.
  2. Ограничение на вложенные MP-каталоги перешло из разряда запретов в разряд неопределённого по-
ведения.
  3. Более точно раскрыта тема вложенности MP-каталогов, а также приведено разъяснение причин тако-
го ограничения.
  4. Уточнено ограничение на псевдонимы каталогов.

  Так что теперь ссылки вверх разрешены и текущий способ использования компилятора (ссылки на библи-
отечные MP-каталоги реализовывались через "..") легализован.


[27.06.2010 -  0:09:29,47]
(Версия 0.1.965)

  [TODO: Оптимизация MFileSystem::ExistFile для профиля Рефала 5]
  На данный момент библиотеки всех профилей подведены под одну гребёнку. При этом функция MFileSys\
tem::ExistFile реализуется как запрос атрибутов файла и проверка на успешность запроса. Это эффек-
тивно для профилей C++/SR и Простого Рефала, но отвратительно по быстродействию для профиля Рефала
5, тем более, что последний предоставляет встроенную функция языка ExistFile.

  [CHANGED: Номер версии в записях журнала]
  Теперь помимо даты в записи журнала автоматически добавляется текущая версия компилятора.


[27.06.2010 - 16:16:34,09]
(Версия 0.1.966)

  [DONE: Оптимизация MFileSystem::ExistFile для профиля Рефала 5]
  Как сказал классик, большинство проблем в кибернетике можно решить введением дополнительного уро-
вня абстракции. В данном случае был создан дополнительный модуль CoreBE::MExistFile, предоставляю-
щий функцию ExistFile. Модуль для профилей Простого Рефала и C++/SR является модулем с исходным те-
кстом (в нём реализована функция ExistFile также, как и раньше), для профиля Рефала 5 представляет
собой библиотечный модуль, вызывающий одноимённую встроенную функцию целевой платформы.
  Если до оптимизации полная перекомпиляция (с ключом -build) занимала порядка 20 минут, то после
оптимизации --- около 3 минут, что сравнимо (на нетбуке) со временем работы других профилей.

  [FIXED: Множественная настройка back-end'ов]
  Ошибка происходила при задании в командной строке (или файле конфигурации) настроек back-end'ов
(опция -tune-be), не входящих в текущий профиль. В этом случае программа сваливалась с дампом памя-
ти.
  Исправлено.

  [FIXED: Ошибка при компиляции модуля типа $CLEARMODULE]
  Синтаксис языка позволяет начинать модуль с одной из трёх директив: $PROGRAM, $MODULE и $CLEARMO\
DULE. Первая директива соответствует головному модулю, который может содержать функцию Go и после
компиляции и компоновки даёт исполнимый файл. Два других варианта соответствуют простым (регулярным)
модулям, т.е. модулям, которые фактически просто группируют ресурсы (в данном случае функции) и ре-
зультатом их компиляции не может быть исполнимый файл (хотя не исключается вариант генерации стати-
ческой или динамической библиотеки). (Сомнительная) директива $CLEARMODULE добавлялась на будущее,
когда язык будет различать чистые функции или функции с побочными эффектами. На данный момент она не
используется, и не факт, что будет использоваться в дальнейшем, но в описании синтаксиса и синтакси-
ческом анализаторе присутствует.
  Ошибка была связана с тем, что упомянутые три директивы в синтаксическом анализаторе помечали мо-
дуль как Main, Regular и Clear соответственно. Но остальная часть программы оперировала только пер-
выми двумя типами модулей (т.к. к тому моменту я забыл о $CLEARMODULE), поэтому при компиляции син-
таксически корректного модуля, начинающегося с сомнительной директивы, компилятор падал с дампом па-
мяти.
  Решение: директива $CLEARMODULE интерпретируется также как и $MODULE, т.е. модуль получает тип
Regular.


[30.06.2010 - 14:48:51,43]
(Версия 0.1.967)

  [CHANGED: Поддержка работы с бинарными файлами]
  Появилась возможность читать и записывать бинарные файлы в профилях Простого Рефала, C++/SR и Ре-
фала 5, причём запись корректно реализована во всех трёх профилях, а чтение --- только в первых
двух. К сожалению, встроенная функция Рефала 5 Get, выполняющая построчное чтение файлов, при нали-
чии символа с кодом '\0' в прочитанной строке, обрезает считанную строку до этого символа, даже ес-
ли файл открыт с режимом "rb". Поэтому не рекомендуется читать двоичные файлы при использовании это-
го профиля.
  Для этой цели формат библиотечных функций FileIO::Open и Core::MFileIO::Open был модифицирован
следующим образом (у них формат одинаковый, поэтому квалификаторы опускаются):
  <Open 'b' s.Mode e.FileName> == s.Handle
  <Open s.Mode e.FileName> == s.Handle
  s.Mode ::= 'r' | 'w' | 'a'

  Файл по-прежнему построчно читается и пишется теми же самыми функциями: WriteLine, Write и Read\
Line модулей FileIO и Core::MFileIO.


[01.07.2010 - 19:46:23,09]
(Версия 0.1.967)

  [TODO: Интегрировать Простой Рефал в общую структуру каталогов]
  На данный момент файлы, относящиеся к Простому Рефалу, находятся в каталоге /Simple Refal относи-
тельно корня проекта. Папка Simple Refal имеет ту же каталоговую структуру, что и подпапки лаб по
Простому Рефалу (т.к. представляет собой фактически копию лабы версии 004) и включает в себя давно
устаревший bootstrap-каталог (т.к. необходимости в его обновлении нет, скрипт автоматического обно-
вления не предусмотрен); исходные тексты компилятора, библиотеки и сопутствующих утилит: генератора
лексического анализатора и препроцессора Простого Рефала в Модульный; а также папка с набором уста-
ревших тестов и заготовок для написания внешних функций.
  В общем, схема неплохая. Но есть и недостатки, а именно
  1. Исходные тексты Простого Рефала находятся как-то поодаль относительно прочих исходных текстов,
входящих в проект, что идеологически усложняет общее дерево каталогов проекта.
  2. В каталогах bootstrap и "Тесты и заготовки" много уже давно нерелевантных файлов, так что, воз-
можно, их следует удалить.
  3. Обособленность исходных текстов затрудняет написание общего скрипта перекомпиляции и пересбор-
ки.
  4. Файлы библиотеки времени выполнения refalrts.h и refalrts.cpp присутствуют в двух разных ката-
логах, что усложняет их синхронизацию (на данный момент они не синхронизированы).
  Задачу считаю приоритетной (для версии 0.2), т.к. устраняет логическую ошибку, связанную с рассин-
хронизацией исходных текстов библиотеки времени выполнения.

  [TODO: "Подчистить" Простой Рефал]
  Задача состоит в том, чтобы проработать следующие мелкие недостатки Простого Рефала:
  1. Т.к. Простой Рефал поддерживает идентификаторы, заменить в большинстве мест (если не во всех)
использование функций-перечислений ($EENUM) на метки ($LABEL). Недостаток пустых функций в том, что
они должны быть определены только в одном файле, а в остальных --- только объявлены, что создаёт
лишние зависимости между модулями.
  2. Добавить поддержку escape-последовательностей вида \xXX или \ooo, как и в языках семейства Си.
Ранее, Модульный Рефал не поддерживал операций умножения, деления и взятия остатка (глупое ограни-
чение библиотеки), поэтому не поддерживались такого рода escape-последовательности. Возможно добав-
ление и других escape-последовательностей, традиционных для Си.
  3. Удаление интерпретируемого кода. Преимуществ по быстродействию интерпретация не даёт, размер
исполняемого файла в наше время некритичен, а вот структуру кода запутывает.
  Изменение отношу к неприоритетным (для версии 0.2), т.к. не вижу причин делать его приоритетным.

  [TODO: Добавить escape-последовательности в Модульный Рефал]
  Модифицировать лексический анализ таким образом, чтобы компилятор поддерживал больший набор esca-
pe-последовательностей, включая \xXX и \ooo.
  Не смотря на то, что это изменение синтаксиса (а точнее, лексики), я его отношу к приоритетным,
т.к. это имеет прямое отношение к юзабельности компилятора (программисты традиционно привыкли ис-
пользовать шестнадцатиричные или восьмеричные коды в противовес имеющимся десятичным).


[01.07.2010 - 20:39:07,96]
(Версия 0.1.968)

  [DONE: Модуль компиляции исходных файлов на Си++]
  Сделано. Модуль C-Link::MLinker предоставляет две функции: C-Link, которая позволяет тонко выпол-
нять компиляцию набора файлов исходных текстов, включая переименование файлов для избежания конфлик-
тов имён объектных файлов (см. ниже) и функцию LookupRuntimeFiles, которая в наборе каталогов ищет
набор файлов поддержки времени выполнения и возвращает полные пути к ним.
  Функции модуля инвариантны к конкретному целевому языку и расширениям файлов исходного текста,
поэтому их можно использовать не только для работы с языками Си и Си++ (расширения .c, .cpp, .cc),
но и с другими языками, например, Си Шарп (.cs).
  Ряд компиляторов Си++ (MSVC, BCC) при вызове со списком файлов на Си++ сначала выполняют их ком-
пиляцию, размещая объектные файлы в текущей директории, а затем вызывают компоновщик по отношению
к этим объектным файлам. Проблема возникает в случае, если среди исходных файлов попадаются файлы
с одинаковым именем, но в разных каталогах. Тогда одноимённый файл, компилируемый последним, пере-
запишет своим объектным файлом объектный файл другого одноимённого файла, что приведёт в дальней-
шем к ошибке компоновки. Проблема решается копированием в текущую папку файлов, имеющих "использо-
ванные" имена с суффиксами вида @1, @2, например, Linker@1.cpp. 

  [TODO: Уйти от использования bat-файлов на стадии компоновки]
  Опять я нарушил дисциплину и забыл во-время преобразовать TOTHINK в TODO. Поэтому отсюда это фор-
мальное TODO.

  [DONE: Уйти от использования bat-файлов на стадии компоновки]
  Модуль компиляции исходных файлов на Си++ сам отвечает за копирование файлов и вызов компилятора
языка Си++, причём делает это без использования bat-файлов. Поэтому bat-файлы в тех местах, где они
использовались раньше, стали не нужны.


[02.07.2010 - 12:59:05,15]
(Версия 0.1.969)

  [TODO: "Подчистить" Простой Рефал]
  Т.к. требовалось обеспечить поддержку escape-последовательностей в Модульном Рефале, а Простой
Рефал является одним из целевых языков компиляции, то необходимо было релизовать поддержку escape-
последовательностей и в нём.
  Реализована поддержка тех же escape-последовательностей, что и в Модульном Рефале (см. ниже).

  [TODO: Интегрировать Простой Рефал в общую структуру каталогов]
  Есть мысль сконвертировать утилиты типа генератора лексического анализатора и srmake в Модульный
Рефал и поместить в общий каталог утилит. Хотя, сомнительно.

  [DONE: Добавить escape-последовательности в Модульный Рефал]
  Лексический анализатор был пополнен как escape-последовательностями, позволяющими явно задать код
символа в виде восьмеричного или шестнадцатиричного числа, так и односимвольными последовательнос-
тями. Набор односимвольных последовательностей на данный момент включает в себя следующие:

  Символ     Код    Обозначение   Смысл
    \a       \x07       bel       сигнал
    \b       \x08       bs        возврат на шаг
    \f       \x0C       ff        перевод страницы
    \n       \x0A       lf        перевод строки
    \r       \x0D       cr        возврат каретки
    \t       \x09       ht        горизонтальная табуляция
    \v       \x0B       vt        вертикальная табуляция
    \\       \x5C       \         обратная косая черта
    \'       \x27       '         апостроф
    \"       \x22       "         двойная кавычка

  Последовательности для числовых кодов \xHHH...H и \OOO имеют те же особенности, что и в Си++: в
шестнадцатиричном представлении число шестнадцатиричных цифр неограничено, в восьмеричном --- не
больше 3 цифр. Это касается как Модульного, так и Простого Рефала.

  [ERROR: В некоторых случаях падает профиль Простого Рефала]
  Ошибка возникает в back-end'е Простого Рефала, если .cpp-файл (в широком смысле), являющийся ре-
зультатом компиляции исходного текста на Простом Рефале, отсутствует (как правило, из-за ошибок
компиляции).
  Ошибка проявляется, если такой .cpp-файл предполагается копировать для избежания конфликта имён,
в результате возникает ошибка открытия файла.

  [ERROR: Компилятор на Рефале 5 падает на функции System]
  При достаточно длинных аргументах встроенной функции System Рефала 5, интерпретатор падает с ошиб-
кой нехватки памяти. Сначала я предполагал, что ошибка связана обычным переполнением изначально за-
данного фиксированного объёма памяти, но увеличив объём до 300 единиц кода и 200 поля зрения (т.е.
-c300 -l200 в командной строке), я от ошибки не избавился. Так что предположительно, длина команд=
ной строки, принимаемой функцией System, меньше приблизительно 3000 байт (примерно такую длину име-
ет командная строка при самомприменении компилятора с профилями Простого Рефала и C++/SR).
  При превышении этого лимита, функция, вместо стандартного нарушения формата встроенной функции,
возвращает недостаток памяти.
  Возможным путём решения является генерация bat-файла, который и содержит эту длинющую строку.


[09.07.2010 - 20:34:59,06]
(Версия 0.1.970)

  [FIXED: В некоторых случаях падает профиль Простого Рефала]
  Исправлено. Теперь компилятор Простого Рефала предоставляет ключ -e filename, который задаёт имя
файла, который создаётся при наличии синтаксических ошибок. При отсутствии ключа в командной строке
никакой файл не создаётся, т.к. никаких значений по умолчанию для данного поведения не предусмотре-
но. Создаваемый файл является пустым, т.к. предназначен исключительно для использования внутри ком-
поновщика back-end'а Простого Рефала --- наличие этого файла-флага сигнализирует о неудачной компи-
ляции.
  Интересно отметить, что для поддержки этого ключа в компиляторе Простого Рефала был использован
объектно-ориентированный подход (впервые в моей практике в реальном коде). Во-первых, парсером ко-
мандной строки возвращается объект, хранящий информацию о командной строке компилятора и имени фай-
ла-флага. Во-вторых, в самом парсере командной строки используется объект-состояние, который изме-
няется при обнаружении тех или иных опций (-c и -e). В результате у нас имеется 5 разновидностей
объекта-состояния: 4 для случая наличия-отсутствия каждой из двух опций и один для состояния ошиб-
ки, в которое переходит парсер при обнаружении дублирующихся опций. Очевидно, что хотя такой под-
ход с одной стороны инкапсулирует обработку аргументов (парсер при обнаружении опций выполняет ме-
тоды #CAddCompileCommand и #CAddErrorFile, которые возвращают новое состояние-объект), с другой
стороны требует экспоненциального роста числа состояний при расширении компилятора новыми опциями,
требующими уникального появления в командной строке. Более грамотный дизайн объектов-состояний спо-
собен решить эту проблему.
  Альтернативным способом исправления этой ошибки мог бы быть перебор всех ожидаемых скомпилирован-
ных файлов с проверкой существования (MFileSystem::ExistFile), который не потребовал бы переработки
компилятора Простого Рефала. В частности, для этой цели можно было бы использовать функцию поиска
файлов библиотеки времени выполнения C-Link::MLinker::LookupRuntimeFiles, передав которой только
расширение выходных файлов Простого Рефала (в случае компиляции в Си++ --- .cpp). Недостатком этого
способа является то, что проверка наличия файлов не сможет перехватить ошибку в модуле рантайма,
написанного на Простом Рефале, который был недавно изменён, но при этом осталась его старая "тень"
в виде скомпилированного файла. Недостаток устраняется путём принудительного удаления всех "теней",
что может быть проблематично, если библиотечные файлы защищены от записи (например, если они нахо-
дятся в папке %programfiles%, доступном для записи только администраторам; хотя, как тогда можно об-
новить файл рантайма на Простом Рефале (стирать это предложение ввиду глупости не буду, т.к. после-
дующие мысли интересные)). К слову сказать, Модульный Рефал не готов к случаю, если модули библио-
теки будут представлены файлами с исходным текстом, при этом располагающихся в подобных каталогах,
доступных только для чтения. Компиляторы Си++, такие как MS VC или BCC, имеют защиту от подобного
поворота событий, т.к. по умолчанию располагают объектные файлы в текущем каталоге (если, конечно,
текущий каталог доступен для записи), с чем я и борюсь путём копирования.
  Перекомпиляцию компилятором Простого Рефала можно было бы оптимизировать, введя сравнение времён
обновления условно .sref- и .cpp-файлов по принципу утилиты make. Двухкратное сравнение времён пар
.sref-файл--.cpp-файл до и после компиляции могло бы зафиксировать ошибки компиляции, т.к. соответ-
ствующий выходной файл не был бы найден. Однако это замедлит работу устаревшего, но в то же время
используемого профиля Рефала 5.

  [FIXED: Компилятор на Рефале 5 падает на функции System]
  Ошибка исправлена так, как и предполагалось: создаётся временный файл-сценарий, который затем и
запускается. Вроде работает.

  [TOTHINK: Систематизировать имена профилей и end'ов]
  Придумать красивые и краткие имена для профилей и end'ов, а также "венгерскую нотацию" для их
внутренних имён. Единственное красивое имя сейчас имеет только профиль C++/SR, которое лаконично и
отражает суть. На данный момент для back-end'ов и front-end'а применяются следующие внутренние име-
на (файл "Имена end-ов.txt"):

  FrontEnds:
    MRefal_FrontEnd
  BackEnds:
    Refal5BE
    XLinxBE
    SymInfo
    SRefal-BE
    Cpp-SR-BE

  К запрещённым именам относятся Library и None. Как видно, здесь в именовании сплошной хаос: front-
end имеет суффикс _FrontEnd, back-end'ы имеют суффиксы BE, -BE или вообще не имеют.
  Внутренние имена профилей определены в функции Config::Load::ProfileBackEnd, которую я приведу
ниже:

  ProfileBackEnd =
    (Refal5 (Refal5-BE SymInfo) ('Refal5') ('R5'))
    (SimpleRefal (SRefal-BE SymInfo)
      ('SRefal') ('Simple') ('SimpleRefal') ('SR')
    )
    (Cpp-SR (Cpp-SR-BE SymInfo) ('CPPSR'));

  Кроме того, полезно продумать адекватную замену терминам back-end и front-end, т.к. (а) запись
через дефис мне кажется некорректной и (б) приходится переключать раскладку и приписывать окончание
через апостроф.
  Задачу считаю приоритетной, т.к. при объяснении модульной концепции в документации для этих поня-
тий нужно же будет использовать какие-нибудь термины.


[09.07.2010 - 21:50:39,95]
(Версия 0.1.970)

  [TOTHINK: СМКиРФ: Префикс M для модулей]
  На данный момент в библиотеке насчитывается 22 модуля, из них 13 не входят в пакеты Core*, т.е.
представляют собой API языка. Вот они:

  * FileIO
  * InOut
  * Math
  * MDosWinRecoder
  * MFileSystem
  * MLambda
  * MOrder
  * MOS
  * MSelfDiag
  * MStrings
  * MSwapSupport
  * MXXIO
  * Types

  Как видно, 4 модуля, исторически появившиеся раньше других, не имеют префикса M, остальные имеют,
что демострирует неединообразие интерфейса библиотеки.
  Отсюда вопрос: следует ли ради единообразия добавить или удалить у всех модулей префикс M или же
оставить всё как есть?
  Строго говоря, по хорошему надо у некоторых модулей сменить имя (а не только добавлять/удалять
префикс), но это уже серьёзная переработка интерфейса.
  Вопрос отношу к приоритетным, т.к. отражается на эстетической целостности интерфейса. К тому же
это подзадача приоритетной задачи.

  [TOTHINK: СМКиРФ: Нужен ли модуль MDosWinRecoder в интерфейсе библиотеки]
  На данный момент этот модуль используется только для преобразования кодировки в операциях консоль-
ного ввода-вывода (да и то не совсем корректно, т.к. преобразует только символы кириллицы). Раньше
он также применялся для преобразования кодировки переменных среды, получаемых из вывода команды
SET оболочки.
  Таким образом, вне библиотеки он нигде не используется (во всяком случае, я его не использовал).
На мысль спрятать модуль в один из Core-пакетов, меня натолкнул тот факт, что библиотеку следует
делать переносимой между различными платформами, в частности перенести под платформу POSIX, где
консольный ввод-вывод выполняется отнюдь не в кодировке CP866 (скорее всего, в UTF-8). Поэтому наз-
вание модуля MDosWinRecoder будет как минимум неадекватно выполняемой задаче.
  Кроме того, когда писался этот модуль, предполагалось, что файлы исходного текста будут написаны
преимущественно в кодировке CP1251. Сейчас часть модулей уже написана в кодировке UTF-8, что делает
запись выводимого текста кириллицей в надежде на корректный вывод на консоль бессмысленной.
  По-нормальному, следует разработать универсальные гибкие удобные средства локализации, позволяю-
щие работать со множеством различных кодировок, что подразумевает поддержку Юникода на уровне ран-
тайма и поддержку большого количества различных кодовых таблиц, а не использование только двух ва-
риантов.
  Модули исходного текста могут быть написаны скорее всего в трёх возможных кодировках: DOS (CP866),
т.к. она является дефолтовой в консольных текстовых редакторах, в частности в Far Manager'е старых
версий, ANSI (CP1251), т.к. её можно установить в качестве дефолтовой в Far Manager'е современных
версий и большом количестве редакторов под Windows, UTF-8, т.к. эта универсальная кодировка являет-
ся переносимой между различными платформами и скорее всего является дефолтовой в большинстве совре-
менных дистрибутивов Linux (основная реализация платформы POSIX; тщательно это утверждение не про-
верял).
  Дальнейшую разработку Модульного Рефала предполагается продолжать в Far Manager'е, хотя другие
продвинутые текстовые редакторы, такие как Vim и Emacs, тоже нельзя сбрасывать со счетов. При воз-
можном портировании под POSIX будет использован скорее всего Vim, т.к. в отличии от Emacs, я им умею
пользоваться.
  Из всего вышеизложенного можно сделать вывод, что предполагать внутренней кодировкой для символов
в Модульном Рефале CP1251 не следует, проще этот вопрос пока оставить открытым (Модульный Рефал ис-
пользует однобайтовую кодировку ASCII, а какую конкретно --- как повезёт). Точно также говорить о
кодовой странице консоли также не следует.
  Поэтому можно даже поставить вопрос таким образом: нужен ли этот модуль в библиотеке вообще?
  Наличие этого модуля как раз отражает факт использования внутренней кодировки Windows, внешней
(для ввода-вывода) --- DOS, что некорректно.

  Можно сказать, что этот вопрос для обдумывания является подзадачей подзадачи приоритетной задачи,
т.к. относится к переносимости библиотеки, а значит сам является приоритетным.


[10.07.2010 - 15:35:46,55]
(Версия 0.1.970)

  [TODO: СМКиРФ: Нужен ли модуль MDosWinRecoder в интерфейсе библиотеки]
  Не нужен по приведённым выше соображениям.
  К соображениям выше также можно добавить, что функции MStrings::Upper и MStrings::Lower, а также
модуль Types, считают за буквы только символы латинского алфавита, следовательно, можно сказать о
компиляторе и библиотеке то, что используемая кодовая страница не определена.

  Вообще, этот модуль я уже удалил, но не хочу писать DONE, т.к. не хочу пока делать сбоку.

  [TODO: СМКиРФ: Модуль Types объединить с MStrings]
  Модуль содержит средства для определения типа, а точнее, класса символа (character): является ли
он буквой, цифрой или прочим символом. В модуле MStrings находятся функции для преобразования сим-
волов, среди которых есть и функции Upper и Lower, которые выполняют сходные задачи. Поскольку мо-
дуль --- это набор логически взаимосвязанных средств, то имеет смысл эти модули объединить.
  Задача приоритетная как подзадача приоритетной задачи.

  [TOTHINK: Грамотная реализация библиотеки]
  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.


[10.07.2010 - 23:01:10,34]
(Версия 0.1.971)

  [DONE: СМКиРФ: Подготовка библиотеки к переносимости между различными ОС]
  Подготовка к переносимости состояла в локализации кода, который необходимо будет переписать при
переносе Модульного Рефала прежде всего под платформу POSIX. Код, который будет подвержен изменени-
ям, был максимально вынесен в отдельные файлы и отделён от кода, который оставался бы общим для
двух вариантов библиотеки.
  В результате были прежде всего проанализированы и переработаны модули MFileSystem и MOS, косвенно
обращающиеся к функциям Windows API, модуль реализации библиотеки baselib.h/baselib.cpp был разбит
на два модуля: mr_common.h/mr_common.cpp, содержащий общий код для обоих платформ и mr_oslib.h/
mr_oslib.cpp, содержащий специфический для ОС код.
  Кроме того, был удалён модуль MDosWinRecoder, т.к. он не нужен в текущем варианте (или надо делать
полноценную библиотеку для работы с кодовыми страницами, или считать, что Модульный Рефал работает
в какой-то однобайтовой кодировке). Этот модуль был написан из предпосылки, что исходные тексты бу-
дут писаться в кодировке ANSI, а консоль будет работать с OEM-кодировкой. Разумеется, под Линуксом
эти утверждения перестают соответствовать истине. Более того, сейчас ряд исходных текстов сохранён
в кодировке UTF-8, поэтому без поддержки Юникода в рантайме говорить о кодовой таблице бессмысленно.

  [DONE: СМКиРФ: Нужен ли модуль MDosWinRecoder в интерфейсе библиотеки]
  Модуль удалён. Процитирую последний абзац из предыдущего DONE, т.к. он даёт исчерпывающий ответ
на вопрос.

|     Кроме того, был удалён модуль MDosWinRecoder, т.к. он не нужен в текущем варианте (или надо
|   делать полноценную библиотеку для работы с кодовыми страницами, или считать, что Модульный Ре-
|   фал работает в какой-то однобайтовой кодировке). Этот модуль был написан из предпосылки, что
|   исходные тексты будут писаться в кодировке ANSI, а консоль будет работать с OEM-кодировкой. Ра-
|   зумеется, под Линуксом эти утверждения перестают соответствовать истине. Более того, сейчас ряд
|   исходных текстов сохранён в кодировке UTF-8, поэтому без поддержки Юникода в рантайме говорить
|   о кодовой таблице бессмысленно.

  [DONE: СМКиРФ: Модуль Types объединить с MStrings]
  Объединил. Возникшие в модуле MRefal-FE::MLexer (это был единственный модуль, использующий этот
модуль библиотеки) синтаксические ошибки были тут же исправлены.

  [TODO: Интегрировать Простой Рефал в общую структуру каталогов]
  Исходные тексты перенесены в каталог Sources/Compiler.sr, библиотечные модули --- в каталог Sour\
ces/Library.sr, рантайм refalrts.h/refalrts.cpp объёдинён с рантаймом Модульного Рефала. Тесты и
утилиты (LexGen, srmake и srprep) помещены в каталоги Sources/SRTests и Sources/SRUtils соответст-
венно, т.к. что с ними делать, я пока не знаю.
  Есть мысль организовать общий скрипт пересборки, который обновляет не только Модульный Рефал, но
и Простой. Т.к. Простой Рефал предполагается частью Модульного Рефала, то можно ему назначить тот
же номер версии, что и у Модульного Рефала.
  Как только я решу, что сделать с тестами и утилитами, а также разберусь с предыдущей мыслью (воп-
лощу или откажусь), я завершу это TODO.


[17.07.2010 - 20:45:57,84]
(Версия 0.1.971)

  [TOTHINK: Систематизировать имена профилей и end'ов]
  Относительно терминов front-end и back-end.
  Как показал анализ (просмотр текста двух печатных книг, поиск в Google и Википедия, в англоязыч-
ной литературе принято писать front end и back end без дефиса, что не мудрено, т.к. это обычные
английские словосочетания. В частности, такое написание было найдено в статьях
http://en.wikipedia.org/wiki/Front_and_back_ends и http://en.wikipedia.org/wiki/Compiler, в первой
странице поисковых запросов в Google и в книге Дракона (Ахо, Альфред В., Лам, Моника С., Сети, Ра-
ви, Ульман, Джеффри Д. Компиляторы: принципы, технологии и инструментарий, 2-е изд.: Пер. с англ.
--- М.: ООО "И.Д. Вильямс", 2008. --- 1184 с.: ил. --- Парал. тит. англ.): "Анализ часто называют
начальной стадией (front end), а синтез --- заключительной (back end)." (стр. 33).
  В пользу написания через дефис также говорят Википедия
( http://ru.wikipedia.org/w/index.php?title=Front-end_%D0%B8_back-end ), первая страница поиска
Google (с опцией "Только на русском") и книга Сергея Залмановича Свердлова (Свердлов С.З. Языки
программирования и методы трансляции: Учебное пособие. --- СПб.: Питер, 2007. --- 683 с.: ил):

|   Блоки компилятора, зависящие от входного языка, выполняющие анализ исходной программы и её
| преобразование в промежуточное представление, образуют его анализирующию, входную, фронтальную
| часть (по-английски front-end). Блоки, ответственные за формирование выходной программы и не
| зависящие от входного языка, образуют синтезирующую, выходную часть (back-end) [сноска 1].
|
|    [Сноска 1] К сожалению, устоявшиеся русские термины, эквивалентные полезным английским словам
| "front-end" и "back-end", не сформировались и, наверное, уже не сформируются. В устных беседах
| "компиляторостроители" обычно так и говорят: "фронт-энд", "бэк-энд". Ввести такие кальки с ан-
| глийского в письменную речь я не рискну. (стр. 308)

  Таким образом, термины front-end и back-end вполне имеют права на существование, тем более ком-
пактных альтернатив я к ним не знаю.

  [TODO: СМКиРФ: Префикс M для модулей]
  На данный момент осталось всего три модуля без префикса M: FileIO, InOut и Math. Модуль Types был
объединён с модулем MStrings.
  Я решил остановиться на единообразии: поскольку большинство модулей библиотеки имеют префикс M,
то разумнее переименовать более малочисленные модули (хотя в библиотеке для совместимости можно ос-
тавить модули и без префиксов).
  Вывод. Надо переименовать модули.


[19.07.2010 - 22:17:22,22]
(Версия 0.1.972)

  [DONE: СМКиРФ: Префикс M для модулей]
  Указанные модули переименованы. Теперь в интерфейсе библиотеки не осталось ни одного модуля без
префикса M (есть модули без префикса M, но они запрятаны внутри реализации --- пакетов Core***).

  [DONE: Стандартные модули контейнеров и распространённых функций]
  Библиотека версии 0.2 сделана. В её интерфейс входят следующие модули:

  * MFileIO --- чтение и запись текстовых файлов, как построчно, так и загрузка и сохранение цели-
ком;
  * MFileSystem --- функции файловой системы: атрибуты файлов, список файлов в каталоге, создание
каталогов, удаление файлов и каталогов;
  * MInOut --- консольный ввод-вывод;
  * MLambda --- поддержка функций высших порядков: списочные морфизмы (Map, Reduce, MapReduce),
комбинаторы, с которыми проще программировать в языке без вложенных функций;
  * MMath --- поддержка простых математических действий в Модульном Рефале;
  * MOS --- функции операционной системы: аргументы командной строки, переменные окружения, запуск
команды оболочки (функция System);
  * MOrder --- функции сравнения и упорядочивания (сортировки);
  * MSelfDiag --- диагностические функции: утверждения, диагностическая печать;
  * MStrings --- функции работы с объектными выражениями: определение длины, отсечение нужного ко-
личества термов, преобразования типов атомов, с недавнего времени в неё входит и простая классифи-
кация символов (заглавная и строчная буква, цифра);
  * MSwapSupport --- функции работы со статическими ящиками: копирование значения из ящика, добав-
ление с конкатенацией, извлечение первого или последнего терма, эмуляция копилки;
  * MXXIO --- ограниченная сериализация объектых выражений (eXpression eXchange In Out --- XXIO по
образцу Рефала 5).

  Текущее состояние библиотеки должно оставаться неизменным до выхода версии 0.2.


[19.07.2010 - 22:35:02,20]
(Версия 0.1.972)

  [TOTHINK: Систематизировать имена профилей и end'ов]
  Подумать о том, не разбить ли модуль MSymModule на два: для загрузки и для сохранения.


[21.07.2010 -  0:44:01,39]
(Версия 0.1.973)

  [DONE: Интегрировать Простой Рефал в общую структуру каталогов]
  Утилиты, написанные на Простом Рефале (SRMake и LexGen) очень удачно интегрированы в структуру
каталога с остальными утилитами:
  1) команда Far-меню "Make it" умеет распознавать расширение файла и вызывать для исходника на
Простом Рефале соотвествующий компилятор. Более того, можно выделить несколько исходников и отком-
пилировать их единовременно, что целесообразно для Простого Рефала (т.к. он не может по одному ис-
ходному файлу найти все остальные, (когда я делал эту возможность, забыл о SRMake));
  2) аналогично пополнен скрипт make_all.bat, проводящий полную перекомпиляцию всех исходных текс-
тов;
  3) когда я переименовывал библиотечные модули (MFileIO, MInOut, MMath), я забыл поправить исход-
ные тексты утилит, поэтому поправлять их пришлось сейчас.
  Кроме того, был написан общий скрипт для сборки Простого и Модульного Рефала. При запуске Просто-
го Рефала теперь тоже отображается номер версии, который совпадает с версией Модульного Рефала. Как
гласит строка о номере версии (Simple Refal, part of Module Refal 0.1.973 (c) Mazdaywik 2008-2010),
Простой Рефал в текущей ипостаси рассматривается как часть Модульного Рефала.
  Тесты перенесены в подкаталог /Tests/Simple Refal.

  [TODO: Имя и путь целевого файла]
  Как показала практика написания дизассемблера rsl'ек, очень удобно распложить исходные тексты не-
которого проекта в отдельный каталог и запускать компилятор Модульного Рефала в текущей папке, ука-
зав каталог с исходниками как MP-каталог. В этом случае в текущей директории формируется только це-
левой файл (и папка .Info), в то время как каталоги с промежуточными файлами оказываются в той же
папке, что и исходники. Поэтому по умолчанию целевой файл должен создаваться в текущей папке.
  RSL описания командной строки позволяет образовывать аргументы с группами и из аргументов-имён
файлов. Поэтому прелагаю следующий синтаксис:
  ModuleName.mref ( -target:targetname )
где группа не обязательна. По умолчанию targetname совпадает с ModuleName, но пользователь может
явно указать и иное. Если пользователь укажет расширение, например targetname.exe, то поведение за-
висит от текущего back-end'а: он может его отбросить, если оно предполагается по умолчанию (напри-
мер .rsl для Рефала 5 или .exe для Простого Рефала или C++/SR) или не отбрасывать.
  Если ModuleName.mref не является головным модулем, то содержимое группы игнорируется.
  Кроме того, логично было бы изменить компоновщики back-end'ов, чтобы те принимали целевой путь
в Pt-формате (см. MFileSystem).

  [TODO: ИиПЦФ: Имя целевого файла в Pt-формате]
  Компоновщики back-end'ов, т.е. функции Link, которые вызываются для получения из горсти промежу-
точных файлов целевого файла, должны принимать имя целевого файла в Pt-формате.
  Рамки этого TODO ограничены изменением указанных функций для передачи путей в Pt-формате и под-
системы, вызывающей эти функции соответсвующим образом.

  [TODO: ИиПЦФ: Расширить структуру командной строки указаниями целевых файлов]
  Т.е. добавить группы ( -target:targetname ) к именам файлов исходных текстов. Вполне возможно,
что группы могут содержать и ряд дополнительных опций, касаемых компоновки конкретных гроздей.
(т.к. обработка нескольких перекрывающихся гроздей не позволяет тонко управлять компиляцией каждой
грозди индивидуально).
  Рамки этого TODO ограничены лишь поддержкой групп командной строкой --- при указании группы, со-
держащей описание целевого файла, компилятор не должен выдавать синтаксических ошибок.


[22.07.2010 - 23:10:27,08]
(Версия 0.1.973)

  [TODO: Имя и путь целевого файла]
  Оказывается, у меня в MCompiler функция, запускающая линковку, имеет следующий вид:

  Link
    t.Config t.hContext t.RootModuleName =
      <Link-Aux
        t.Config ( <MQualifiedName::Parse t.RootModuleName> )
        <MClusters::ListForLinking t.hContext t.RootModuleName>
      >;

  Link-Aux {
    t.Config ( (e.OutName) ) t.hContext Success e.Modules =
      <MOutModuleStatus::Linking e.OutName>
      <MOutModuleStatus::Flush>
      <MConfig::Link t.Config t.hContext (e.OutName) e.Modules>;

    t.Config ( (e.OutName) ) t.hContext Fails =
      t.hContext Fails;

    t.Config ( e.OtherHeadName ) t.hContext Success e.Modules =
      t.hContext Fails;
  }

  Т.е. если головной модуль находится в пакете, то компоновка считается неуспешной. Т.е. на момент
написания кода я предполагал, что головной модуль не может находиться в пакете, однако на стадии
синтаксического анализа это условие не проверяется. Таким образом, поведение программы, когда вся
гроздь компилируется успешно, но при этом возникает непонятное сообщение о невозможности компонов-
ки, является нелогичным.
  На данный момент ограничение о ненахождении головного модуля в пакете я не считаю целесообразным,
к тому же в спецификации об этом ничего не сказано, поэтому от нелогичного поведения при компоновке
следует отказаться.


[23.07.2010 -  0:48:04,19]
(Версия 0.1.974)

  [DONE: ИиПЦФ: Имя целевого файла в Pt-формате]
  [DONE: ИиПЦФ: Расширить структуру командной строки указаниями целевых файлов]
  Сделано в полном соответствии с TODO в заданных рамках.

  [TODO: Имя и путь целевого файла]
  Изменена семантика работы компоновщика (предыдущее звено). Для головного файла, находящегося в
пакете, префикс пакета отбрасывается --- учитывается только последний сегмент.
  Скорректированы Link-функции back-end'ов, они теперь принимают путь в Pt-формате. Расширена ко-
мандная строка, теперь в ней можно указывать имя целевого файла, но эта информация игнорируется.
  Сейчас необходимо заставить всё это работать вместе: учитывать имя целевого файла, заданного в
командной строке и передавать его функциям-компоновщикам. Вероятнее всего, нужно будет добавить до-
полнительное поле в контекст.

  [TOTHINK: Протаскивать t.hErrorList через анализатор .rsym-файлов]
  На данный момент функция, загружающая содержимое .rsym-файла (MSymModule::LoadInfo), локально
внутри себя создаёт список ошибок (он необходим синтаксическому анализатору) и после анализа унич-
тожает, выводя ошибки на stdout. В этом случае ошибки из .rsym-файлов могут пролететь в консоли
незамеченными и уж тем более не попадут в файл __errors.
  Данная задача потребует переработки MCompiler, MClusters и MContext. Через ряд функций будет тру-
дно протянуть t.hErrorList, например, через функцию MClusters::ListForLinking, т.к. там, где она
вызывается, список ошибок недоступен. Этой функции нужно подгружать символический модуль с целью
определить список импортируемых модулей. Поэтому имеет смысл кэшировать списки зависимых модулей.
  Всё-таки хотелось бы это сделать приоритетным. Но причин для приоритетности нет.

  [TOTHINK: Пt.EЧА.rФ: Кэширование списка зависимостей]
  Список модулей для компоновки требуется только после успешной перекомпиляции всей грозди модулей,
т.е. на тот момент, когда вся информация об импортах могла бы быть доступна. Поэтому необходимо кэ-
шировать информацию о списках зависимостей (импортируемых модулях) для того, чтобы не загружать фай-
лы символической информации на этом этапе (см. материнское TOTHINK).


[23.07.2010 - 21:26:33,11]
(Версия 0.1.975)

  [DONE: Имя и путь целевого файла]
  Всё сделано в полном соответствии с TODO. В случае профилей Простого Рефала и C++/SR передаваемое
имя целевого файла непосредственно передаётся компилятору Си++. В случае профиля Рефала 5 к имени
целевого файла присоединяется расширение .ref.


[23.07.2010 - 21:53:49,70]
(Версия 0.1.975)

  [TODO: Пt.EЧА.rФ: Кэширование списка зависимостей]
  Кэширование следует осуществлять, что наиболее логично, внутри контекста. Альтернативный вариант
кэширования --- кэширование внутри глобальных переменных --- некошерен ибо не труъ. Рамки TODO под-
разумевают добавление контексту двух методов для сохранения списка импорта и его загрузки. О даль-
нейших манипуляциях написано в материнском TODO.

  [TODO: Протаскивать t.hErrorList через анализатор .rsym-файлов]
  Одну из проблем вызывает функция MClusters::DependencesList, которая подгружает список импортиру-
емых модулей для заданного. Она вызывается в двух разных ситуациях: когда можно протащить через неё
список ошибок (функции MClusters::CheckNeedCompile-***), и когда нельзя (MClusters::ListForLinking).
  Один из вариантов решения заключается в том, что функция MClusters::DependencesList дублируется
с двумя разными суффиксами (скажем, -EList и -Cached), затем модуль компилируется и в синтаксичес-
ких ошибках (отсутствующая функция без суффикса) подставляется тот или иной суффикс и, при необхо-
димости, список ошибок.


[24.07.2010 - 22:57:01,29]
(Версия 0.1.976)

  [DONE: Пt.EЧА.rФ: Кэширование списка зависимостей]
  Сделано в полном соответствии с TODO.

  [DONE: Протаскивать t.hErrorList через анализатор .rsym-файлов]
  Сделано. Теперь список ошибок протаскивается через анализатор .rsym-файлов. Функция MClusters::
CheckNeedCompile действительно разделена на две, первая с префиксом -Real, вторая --- с -Cached.
Как оказалось, функция MSymModule::LoadInfo неоднократно используется в MCompiler, поэтому для
передачи списка ошибок через неё понадобилось переделать форматы ряда функций.
  Взгляд на модуль MCompiler показал, его было бы полезно изучить и структурировать, хотя писался
он грамотно и тщательно продумывался и уже несколько структурирован. Проблема заключается в том,
что в нём много фрагментов похожего кода, который, вероятно, можно было бы объединить и параметри-
зовать.
  Но в целом всё вроде работает, ошибки в .rsym-файлах отображаются в общем списке ошибок, что из-
начально и требовалось. Возможно когда-нибудь, при добавлении новых возможностей в модульную кон-
цепцию, я переработаю модуль MCompiler. Сейчас это делать не обязательно, т.к. на 99 % он меня
удовлетворяет, а лучщее --- враг хорошего.

  [TODO: Ревизия задач]
  Осталось, фактически три задачи (ниже пишу четвёртую), выполнив которые я буду должен увеличить
младший номер версии. Теперь, в преддверии этого инкремента, уже чётче видно, что является важным
и что является неважным, поэтому список задач надо проанализировать и определиться с приоритетами.

  [TOTHINK: Выпуск публичной версии (ВПВ)]
  Под публичной версией я подразумеваю версию, которую можно представить другим пользователям, нап-
ример, выложить у себя на сайте/блоге, в рефал-рассылке или рефал-семинаре (на который я, возможно,
поеду).
  Нужно продумать, что требуется для выпуска публичной версии Модульного Рефала, в частности способ
установки (setup.exe, make install и др.), выполнение под POSIX, документация, мелочи в виде дефол-
тового конфигурационного файла (загружаемого, скажем, из %USERPROFILE% и содержащего MP-пути) и др.
  А также нужно продумать, должна ли публичная версия совпадать с ожидаемой версией 0.2.


[25.07.2010 - 12:33:59,02]
(Версия 0.1.976)

  [TODO: //== Список приоритетных TODO ==\\]
  (Ревизия 25.07.2010). Цели и задачи сохраняются.

  [+TODO: RASL и интерпретатор]
  Недавно я написал прототип дизассемблера для .rsl-файлов Рефала 5, соответственно, изучил внут-
ренний формат и набор команд этих файлов интерпретируемого кода. В принципе, при разработке собст-
венного RASL'а можно не изобретать велосипед, а расширить имеющийся формат.
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Продумать упрощение структуры Lexer'а и Parser'а]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Обдумать введение видов для квалифицированных имён]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Продумать генераторы лексического и синтаксического анализаторов]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Продумать двухуровневую структуру синтаксического анализа]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.

  [+TODO: Продумать изменения в лексике и комментариях]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  Вообще, мне бы хотелось, чтобы компилятор версии N мог бы компилировать исходный код версии N-1,
изменение лексики сделало бы это невозможным.

  [THINKED: Отдельно собирать информацию об ошибках в журнале проекта]
  (Ревизия 25.07.2010) Не нужно. На данный момент (да и в ближайшей и далёкой перспективе) разра-
ботка компилятора ведётся силами не более чем одного человека, а ошибки я исправляю достаточно быс-
тро. Более того, у меня задач в списке TODO не на столько много, чтобы ошибки среди них терялись.

  [+TODO: Продумать блоки $INIT и $FINAL]
  (Ревизия 25.07.2010) Как уже сказано, выпуск версии не подразумевает переработки синтаксиса отно-
сительно текущего состояния. Поэтому эти конструкции я сейчас внедрять не буду. Но сделаю их при
первой же существенной переделке синтаксиса.

  [+TOTHINK: Написание комплексных тестов для библиотеки]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  По хорошему, надо писать не только тесты (некоторый небольшой набор тестов у меня есть), но и
средства автоматического тестирования (например, скриптом) и эти средства периодически обновлять.
  Некоторым подобием автоматического теста у меня является большой скрипт пересборки: он пересоби-
рает весь компилятор каждым исполнимым файлом, созданным некоторым профилем, с каждым профилем, что
в некоторой степени гарантирует его корректность.

  [TODO: Продумать максимальную длину имени модуля]
  (Ревизия 25.07.2010) По этому пункту надо написать что-нибудь умное и закрыть его тегом DONE, т.к.
скорее всего по нему ничего кодировать не надо будет. Приоритетно.

  [TODO: ПИ:Хранить в контексте также информацию о пакетах]
  (Ревизия 25.07.2010) Приоритетно.
  Требуется контролировать ограничения, наложенные в спецификации: что ни в каком пакете не может
находиться два модуля, два пакета или модуль и пакет с разными регистрами символов. И, разумеется,
при попытке добавить в контекст модуль, квалифицированное имя которого нарушает эти ограничения,
должно выдаваться внятное сообщение об ошибке.

  [+TODO: "Подчистить" Простой Рефал]
  (Ревизия 25.07.2010) Для версии 0.2. не приоритетно, т.к. не относится к основным целям версии.
Однако, для выпуска публичной версии эта задача важна.

  [+TOTHINK: Грамотная реализация библиотеки]
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2, т.к. текущая версия библиотеки уже не-
плоха и вполне соответствует возможностям синтаксиса языка.
  С точки зрения грамотной реализации, текущая библиотека соответствует варианту пакета Std, но без
префикса Std и без альтернатив (Platform и BackEnd).
  Для выпуска публичной версии также не требуется, т.к. публичную версию вполне можно выпустить и с
текущей реализацией библиотеки.

  [TOTHINK: Систематизировать имена профилей и end'ов]
  (Ревизия 25.07.2010) Безусловно приоритетна для версии 0.2, т.к. относится к целям выпуска этой
версии, поскольку относится к упорядочению возможностей нескольких front- и back-end'ов.

  [DONE: Ревизия задач]
  Сделана (Ревизия 25.07.2010).

  [TOTHINK: Выпуск публичной версии (ВПВ)]
  (Ревизия 25.07.2010) Приоритетна, т.к. требуется прежде всего решить, должна ли публичная версия
совпадать одной из первых сборок версии 0.2.

  [TODO: \\== Вот список приоритетных TODO ==//]
  (Ревизия 25.07.2010). Цели и задачи сохраняются.


[25.07.2010 - 14:27:52,69]
(Версия 0.1.976)

  [TOTHINK: Систематизировать имена профилей и end'ов]
  Для полноты картины добавлю таблицы front- и back-end'ов (переформатированы для наглядности, поля
Register и Extent опущены для краткости)

  BackEndsTable =
    (Refal5-BE ('Refal5')    ((Relative) ('~ROut'))   ('rout')  & ... & ...)
    (SymInfo   ('SymInfo')   ((Relative) ('~Defs'))   ('rsym')  & ... & ...)
    (XLinx-BE  ('XLinx')     ((Relative) ('~XLinx'))  ('xlinx') & ... & ...)
    (SRefal-BE ('SRefal-BE') ((Relative) ('~SimRef')) ('sref')  & ... & ...)
    (Cpp-SR-BE ('Cpp-SR-BE') ((Relative) ('~CppSR'))  ('cpp')   & ... & ...);

  FrontEndsTable =
    (MRefal-FE ('MRefal')                             ('mref')  & ...      );

  А также, продублирую список имён и описания профилей:

  FrontEnds:
    MRefal_FrontEnd
  BackEnds:
    Refal5BE
    XLinxBE
    SymInfo
    SRefal-BE
    Cpp-SR-BE

  ProfileBackEnd =
    (Refal5      (Refal5-BE SymInfo) ('Refal5') ('R5')                           )
    (SimpleRefal (SRefal-BE SymInfo) ('SRefal') ('Simple') ('SimpleRefal') ('SR'))
    (Cpp-SR      (Cpp-SR-BE SymInfo) ('CPPSR')                                   );

  Разрешения промежуточных файлов back-end'ов с промежуточными именами SRefal-BE и Cpp-SR-BE изме-
нить, по понятным причинам, невозможно, а остальные достаточно произвольны.
  В случае профилей промежуточные имена для Refal5 и Cpp-SR совпадают с ключевыми back-end'ами с
точностью до суффикса -BE, и скорее всего, это правильно, т.к. упрощает и систематизирует.
  Внутренние имена профилей совпадают с некоторыми своими строковыми представлениями, указываемыми
в командной строке. Аналагично для back-end'ов: 3 совпадают как есть, 2 --- при отбрасывании суф-
фикса -BE, у двух в строковом представлении присутствует суффикс, у трёх --- отсутствует. Для front-
end'а строковое представление совпадает с именем при отбрасывании суффикса.
  На основании внутренних имён, строковых представлений и имён папок, можно заметить, что для back-
end'а и профиля Рефала 5 подходит имя Refal5; для C++/SR --- Cpp-SR или CppSR, для Простого Рефала
--- SRefal, SimpleRefal или SimRef. Для служебных back-end'ов однозначно можно говорить об имени
XLinx, т.к. оно употребляется по всем параметрам. Имя back-end'а SymInfo никак не присутствует ни в
имени папки, ни в расширении.
  Кстати, файл "Имена end-ов.txt" врёт: используются совсем другие имена back-end'ов.


[01.08.2010 - 13:18:30,86]
(Версия 0.1.976)

  [TODO: Систематизировать имена профилей и end'ов]
  Предлагается следующая схема.
  1. Имена front-end'ов имеют префикс FE-, имена back-end'ов — BE-.
  2. Имена профилей определяются именами основных back-end'ов, только вместо префикса BE- исполь-
зуется префикс Pr-.
  3. Каталоги промежуточных файлов определяются именем back-end'а, но без префикса BE-, но допуска-
ются исключения.
  4. Расширения для каждого back-end'а определяются индивидуально.
  5. Внешние имена end'ов и профилей (указываемые в командной строке) совпадают с внутренними име-
нами с тем отличием, что они не содержат префиксов. Внешние имена профилей могут содержать псевдо-
нимы (как и раньше).
  6. В журнале для называния end'ов и профилей следует использовать внутреннее имя. Префикс можно
опускать, если по контексту понятно, о чём идёт речь: о back-end'е или профиле.
  7. В структуре исходных текстов каждому end'у соответствует отдельный пакет, совпадающий с его
внутренним именем с префиксом (префиксы, в отличие от суффиксов, способствуют тому, что при сорти-
ровке имён файлов по имени по умолчанию пакеты back- и front-end'ов не будут перемешаны между со-
бой и другими пакетами). Внутри пакета должен обязательно присутствовать модуль MInit, содержащий
функцию регистрации end'а в объекте конфигурации.
  7а. Если реализация back-end'а содержит отдельные модули, производящие генерацию промежуточных и
целевых файлов (точнее, содержащие эти функции, регистрируемые в MInit), то они должны иметь имена
MCompiler и MLinker. Если указанный функционал совмещается в одном модуле, то он должен иметь имя
MBackEnd.
  7б. Рекомендуется, чтобы модули верхнего уровня front-end'а, реализующие лексический и синтакси-
ческий анализ, имели имена MLexer и MParser. Под верхним уровнем синтаксического анализа здесь под-
разумевается построение структуры MIModule

  End'ы:
  Имя         Внешнее имя    Папка    Расширение
  BE-CppSR     'CppSR'      '~CppSR'   '.cpp'
  BE-ModIF     'ModIF'      '~ModIF'   '.mif'
  BE-Refal5    'Refal5'     '~ROut'    '.rout'
  BE-SimRef    'SimRef'     '~SimRef'  '.sref'
  BE-XLinx     'XLinx'      '~XLinx'   '.xlinx'
  FE-MRefal    'MRefal'                '.mref'

  Профили:
  Имя         Back-end'ы           Внешние имена
  Pr-CppSR    BE-CppSR, BE-ModIF   'CppSR', 'C++/SR'
  Pr-Refal5   BE-Refal5, BE-ModIF  'Refal5', 'R5'
  Pr-SimRef   BE-SimRef, BE-ModIF  'SimRef', 'SRefal', 'SR'

  Back-end SymInfo был переименован в ModIF, т.к. это название точнее отражает суть: вместо рас-
плывчатой символической информации точно указывается, что речь идёт об интерфейсе модуля.
  При выполнении этого TODO следует написать спецификацию "Имена модулей и end'ов.txt" на основе
вышенаписанного текста (помимо текста выше, возможно, переработанного, туда следует включить поня-
тия профилей, front- и back-end'ов; возможно, надо будет согласовать текст спецификации с текстом
спецификации "Поиск исходников.txt") и привести исходные тексты компилятора в соответствии с этой
спецификацией.


[01.08.2010 - 18:37:37,99]
(Версия 0.1.976)

  [TODO: Пересмотреть спецификации]
  В каталоге спецификаций лежат файлы, написанные в двух стилях: в виде TODO, вынесенных в отдель-
ный файл или в виде собственно спецификаций, написанных в декларативном стиле. Спецификации первого
типа появились исторически раньше и именно как более основательные TODO, содержащие не только дос-
таточно подробные задания, что надо делать, но и раздел "Мотивация", в котором подробно описывает-
ся, зачем это нужно делать.
  Такие "спецификации" по форме уже стали нерелевантными, т.к. задания, описанные в них, давно уже
выполнены, а в разделе мотивации идёт сравнение состояния дел на момент написания с тем, что надо
сделать, т.е. они уже носят исторический характер.
  Поэтому имеет смысл их пересмотреть и переписать их в декларативной манере.
  На настоящий момент в каталоге спецификаций лежат следующие спецификации (версии опущены):
  "ATD support.txt" — спецификация первого типа, в ней описывается синтаксис и семантика термов
абстрактных типов данных;
  "AttSymTable.txt" — спецификация первого типа, в ней описывается атрибутная таблица символов, ре-
ализованная в модуле MSymTable;
  "DSL описания командной строки.txt" — спецификация второго типа, в ней описывается DSL описа-
ния командной строки, в настоящий момент используемый модулем CmdLine::MParser и содержащийся в мо-
дуле Config::MLoad;
  "Замена FnPtr на что-то другое.txt" — спецификация первого типа, в ней мотивируется использование
специального символа для указателей на фукнции, возможно, её не имеет смысл переписывать в деклара-
тивной манере, только если вместо неё написать другую спецификацию, постулирующую синтаксис и семан-
тику указателей на функцию;
  "Концепция модулей для Модульного Рефала.txt" — спецификация первого типа, которую имеет смысл
переписать в декларативной форме, ибо описывает важные вещи. Имеет смысл перенести туда часть текста
из спецификации "Поиск исходников.txt";
  "Поиск исходников.txt" — спецификация, описывающая физическое представление модулей в виде набора
файлов, а также способ поиска этих модулей. Название не совсем точно отражает суть, но тем не менее.


[03.08.2010 - 18:04:29,32]
(Версия 0.1.977)

  [DONE: Систематизировать имена профилей и end'ов]
  Написана спецификация "Имена профилей и end'ов.txt", в которой приводятся определения понятий ис-
ходный, промежуточный и целевой файл, компиляция, компоновка, front- и back-end и профиль, а также
общие правила задания внутренних и внешних имён профилей и end'ов, имён папок и расширений. В при-
ложении к этой спецификации "Имена профилей и end'ов — списки.txt" приводятся списки имеющихся на
данный момент профилей и end'ов, реализованных в компиляторе. Файл "Имена end'ов.txt", ставший бо-
лее не нужным, удалён.
  Разделение спецификации на два файла позволяет при расширении компилятора другими end'ами и про-
филями, не меняя основную спецификацию, содержащую общие правила, содержать при этом внутреннюю до-
кументацию в актуальном состоянии.

  Модуль MSymModule разделён на три части: часть, сохранившая своё имя MSymModule, теперь содержит
только функции загрузки данных об интерфейсе модулей и редукции структуры IModule до объёма, загру-
жаемого из того же файла интерфейса модуля; модули BE-ModuleIF::MInit и BE-ModuleIF::MCompiler со-
держат код, соответствующий рекомендациям именования в спецификации: код регистрации и генерацию
промежуточных файлов.

  Профили и end'ы систематизированы в соответствии со спецификацией: созданы соответствующие паке-
ты, переименованы внутренние и внешние имена, а также имена подпапок и расширения. Но для совмести-
мости с имеющимся кодом в файле mp-work-COMMON.cfg подпапки и расширения были установлены в соот-
ветствие с имеющейся ситуацией. Т.е. несмотря на спецификацию, back-end ModuleIF создаёт свои файлы
в каталоге ~Defs и с расширением .rsym.

  [DONE: Пересмотреть спецификации]
  Спецификации пересмотрены, часть из них перемещена во вновь созданную папку "История", часть об-
новлена и переписана, часть оставлена как есть. Кроме того, спецификации с англоязычными именами
были переименованы в русскоязычные.
  Спецификация "Атрибутная таблица симвлов.txt" была перенесена в каталог "История", т.к. раздел
"Мотивация" отражал отличия от предыдущей несовершенной таблицей символов, а описание дизайна явля-
ется излишним, т.к. те же сведения можно почерпнуть из комментариев к экспортируемым функциям.
  Спецификация "Замена FnPtr на что-то другое.txt" также перенесена в каталог "История", т.к. уже
давно стала неадекватной, а делать отдельную спецификацию, описывающую детали синтаксиса бессмыс-
ленно. Описание синтаксиса находится в файле "Syntax.txt" в каталоге документации и его в данном
аспекте достаточно.
  Тажке была перемещена в каталог "История" спецификация "Поддержка АТД.txt", поскольку часть, пос-
вящённая синтаксису и семантике именованных термов уже реализована в коде, а ограничение типа для
термов целесообразно внедрять вместе с той или иной формой статической типизации.
  Спецификация "DSL описания командной строки.txt" является актуальной и изменения её не коснулись.
  Спецификация "Концепция модулей для Модульного Рефала.txt" была полностью переписана (вместо им-
перативного стиля стала иметь декларативный). Часть текста, касающаяся определения понятия модулей
безотносительно к реализации, была перенесена из спецификации "Поиск исходников.txt". Помимо этих
определений, в спецификации вводятся понятия головного и регулярного модулей, а также подробно рас-
крывается семантика инициализации и финализации. В спецификации также раскрывается семантика рабо-
ты не только проекта, компилируемого в самостоятельный исполнимый файл, но и проекта, компилируемо-
го в динамическую библиотеку, не смотря на то, что такая возможность пока не реализована.
  Данная спецификация после доработки может стать частью руководства пользователя по компилятору.
  Небольшие изменения коснулись спецификации "Поиск исходников.txt", часть текста из неё была пере-
несена в спецификацию "Концепция модулей для Модульного Рефала.txt".
  Вследствие работы с предыдущим TODO Систематизировать имена профилей и end'ов появилась новая
спецификация "Имена профилей и end'ов.txt" и приложение к ней "Имена профилей и end'ов — списки\
.txt". О ней подробнее написано в упомянутом TODO.


[03.08.2010 - 21:38:05,23]
(Версия 0.1.977)

  [DONE: Продумать максимальную длину имени модуля]
  Проблема заключается в том, что компилятор никак не контролирует длины квалифицированных имён.
Поэтому проблемы возможны по следующим направлениям:
  (а) Слишком длинное имя модуля. В этом случае файл, представляющий собой модуль будет иметь очень
длинное имя, являющееся ошибочным с точки зрения файловой системы. Аналогично пакет может иметь
очень длинное имя.
  (б) Слишком длинное квалифицированное имя модуля. В этом случае возможна проблема функциями вво-
да-вывода: сформированное имя ("ModulePath/~BackEnd/Packet/Module.ext") может превышать лимиты опе-
рационной системы (например, ограничение MAX_PATH). Проблем добавляет то, что файловые системы под
некоторые ОС POSIX-семейства используют имена в UTF-8, а внутри используется счётчик байтов. Поэто-
му максимальная длина зависит от набора символов в имени (а MP-каталоги могут содержать любые до-
пустимые файловой системой символы).
  (в) Слишком длинное квалифицированное имя программной сущности (например, функции). В этом случае
всё зависит от поведения компилятора выходного языка (например, Си++) — он может "обрезать" часть
символов, превышающих внутренний лимит, может выдать ошибку или предупреждение.
  Если подходить к задаче дотошно, то компилятор должен знать, на какой платформе он выполняется
(для учёта направлений (а) и (б)) и знать особенности текущего back-end-компилятора. Эти сведения
должны передаваться синтаксическому анализатору и модульному движку, чтобы там можно было бы зара-
нее предупредить проблему, выдав предупреждение или ошибку. Данный подход требует большого объёма
трудо- и мыслезатрат, но больших выгод не сулит. Поэтому пойдём другим путём.
  Объявляю, что максимальная длина квалифицированного имени (сумма длин отдельных компонент) экс-
портируемой программной сущности не должна превышать числа 100, также как и длина отдельной компо-
ненты (имени пакета, модуля или программной сущности). 100 — это уже достаточно много (длины строк
этого документа в среднем около 100 символов). В случае превышения лимита поведение компилятора не
определено (сейчас это никак не контролируется, поэтому может обойтись). Речь идёт только об экс-
портированных сущностях, т.к. локальные для модулей сущности всегда можно переименовать в короткие
имена, т.к. они извне не доступны.
  Число 100 я "взял с потолка". Текущие реализации back-end'ов C++/SR и SimRef для представления
квалифицированных имён в виде обычных имён Си++ используют экранирование символов, поэтому в особо
паталогических случаях длина имени может удвоиться. А 200 < 256, а 256 — наиболее популярное огра-
ничение какой-либо длины. Например, MAX_PATH под Windows имеет длину 260 символов (видимо, с учётом
буквы диска и концевого нуля), ограничения файловой системы FAT32 также близки к этому пределу (не
помню точно).
  На данный момент никаких проверок не предусмотрено, но в дальнейшем их можно постепенно вводить,
снижая тем самым неопределённость непоределённого поведения.
  Примечание. Для данного DONE полная пересборка не проводилась, т.к. со времени последней пере-
сборки никаких изменений в коде не было.

  [TOTHINK: Выпуск публичной версии (ВПВ)]
  Выпуск публичной версии не будет совпадать с выпуском версии 0.2, т.к. задачи выпуска версии 0.2
не совпадают с задачами выпуска публичной версии. Версия 0.2 задумывалась как версия, в которой бу-
дет полностью и отлаженно работать концепция модулей, а также модульная архитектура компилятора.
  Публичная версия подразумевает дружественность к пользователю, а именно, удобную процедуру уста-
новки, удобную процедуру компиляции (практически достигнуто, недостаток в явном указании списка
MP-каталогов, но ведь у многих компиляторов Си++ нужно указывать пути include и library) и понятную
документацию. Основные возможности компилятора (модульность, надёжность, логичная концепция в осно-
ве, библиотека) подразумеваются как само собой разумещееся.
  Поэтому надо или расширять приоритеты версии 0.2, или выпускать публичную версию позже. Выбираю
второй вариант, т.к. во-первых, приоритеты версии 0.2 входят в приоритеты публичной версии, во-вто-
рых, лучше концентрироваться на более узкой задачей, т.к. лучше раньше завершить работу над модуль-
ностью (осталось фактически одно TODO), чем сделать это позже.
  После выпуска версии 0.2 приоритетом будет выпуск публичной версии. Конкретнее определюсь с прио-
ритетами после завершения версии 0.2.

  [+TODO: ПИ:Хранить в контексте также информацию о пакетах]
  Контролировать корректность регистра символов в модулях (требование, что в одном пакете не могут
существовать два модуля, имена которых различаются только регистром) на платформе Windows бессмыс-
ленно, т.к. независимо от регистра символов в имени файла, представляющего собой модуль, файл будет
найден и открыт. Корректность имени с точностью до регистра осуществляется путём сравнения внешнего
(как на модуль ссылаются извне: из другого модуля или командной строки) и внутреннего (записано в
самом модуле) имён, при несовпадении уже давно определяется ошибка. Однако, при переносе на другие
платформы, чувствительные к регистру символов, возможно возникновение ошибки.
  Следует определиться (а) со способом хранения сведений о именах и их регистрах, (б) о местах этих
проверок. А далее уже хранить и проверять.


[05.08.2010 - 23:10:18,51]
(Версия 0.1.978)

  [CHANGED: Структура каталогов исходных текстов]
  Сегодня я спонтанно решил реорганизовать содержимое каталога исходных текстов компилятора Модуль-
ного Рефала:
  1. Модули MClusters, MCompiler, MContext, MModules, MResolver, MResolveTable и MSymModule были
объединены в пакет Driver, т.к. они имеют прямое отношение к управлению процессом компиляции и ком-
поновки. Модуль MModules отвечает за самый низкий уровень работы с модулями — физическое местополо-
жение самих модулей. Модуль MClusters отвечает за промежуточный уровень, а именно определяет необ-
ходимость перекомпиляции модуля на основании времён обновления исходных и выходных файлов самого
модуля, а также тех модулей, от которых он зависит. Модуль MCompiler отвечает за верхний уровень
работы с модулями — в зависимости от сведений предыдущего уровня он выполняет перекомпиляцию моду-
лей и затем компоновку.
  Остальные модули этого пакета выполняют служебные функции. MContext предоставляет АТД таблицы,
содержащей сведения об известных модулях: стадия обработки, состояние (подлежит перекомпиляции или
уже перекомпилирован (в зависимости от стадии), обновлён (не подлежит перекомпиляции), библиотечный
или ошибочный (не найден или в процессе компиляции обнаружены ошибки)), местоположения исходных и
промежуточных файлов для модуля и ряд других сведений. MSymModule осуществляет загрузку информации
об интерфейсе модуля, чтобы затем проверить корректность вызовов экспортируемых функций из импорти-
рующего модуля и список зависимостей. Модули MResolver и MResolveTable используются для проверки
корректности вызовов функций внутри промежуточного представления модуля.
  2. Файлы .cfg и .prj, содержащие аргументы командной строки для различных режимов компиляции, пе-
ренесены в каталог .Config.
  3. Целевые двоичные файлы как стабильных, так и рабочих версий перенесены в подкаталог Bin ката-
лога /Sources.
  В результате этих манипуляций в каталоге /Sources/Compiler стало меньше файлов, что эстетически
выглядит приятнее.

  [FIXED: Ошибки со списком модулей в командной строке]
  Исправлены ошибки, связанные с ошибочным именем модуля в командной строке и с многократными появ-
лениями модулей с одинаковыми квалифицированными именами. Ранее компилятор просто "падал", теперь
формируются нормальные сообщения об ошибке (с использованием t.hErrorList и формированием файла
__errors).


[25.08.2010 - 12:40:01,95]
(Версия 0.1.979)

  [CHANGED: Рефакторинг модуля Driver::MCompiler]
  Для выполнения TODO "ПИ:Хранить в контексте также информацию о пакетах" мне нужно было понять,
где размещать проверки правильности регистра символов в именах пакетов, но поскольку, во-первых,
я забыл логику работы модуля Driver::MCompiler, во-вторых, логика работы была достаточно запутана,
я решил сделать рефакторинг. После рефакторинга логика работы модуля стала для меня яснее, поэтому
теперь будет проще добавить требуемые проверки.
  Теперь вместо трёх ветвей выполнения (первая ветвь отрабатывает, если модуль нуждается в переком-
пиляции, модули, от которых он зависит могут быть либо перекомпилируемыми, либо обновлёнными, либо
библиотечными; вторая — для обновлённых модулей, они могут зависеть только от обновлённых и библио-
течных модулей; треться — для библиотечных модулей, которые могут зависеть только от библиотечных)
используется только одна ветвь, выбор поведения осуществляется флагом, передаваемым из функции в
функцию. Понять, куда следует встраивать проверки, я думаю, будет проще.


[05.09.2010 - 21:20:32,46]
(Версия 0.1.979)
  [+TODO: ПИ:Хранить в контексте также информацию о пакетах]
  Приостановлен рефакторинг модуля Driver::MCompiler. В поисках идеальной структуры программы ре-
факторинг можно выполнять бесконечно, поэтому нужно остановиться на том этапе, когда состояние
исходного текста становится достаточно понятным и приемлемым для внесения изменений в код. Поэтому
рефакторинг не завершён, а приостановлен.
  Модуль Driver::MCompiler предоставляет функцию Make, которая рекурсивно обрабатывает модули, вхо-
дящие в гроздь, с корнем в модуле, указанном в аргументе функции Make. Если корень оказывается го-
ловным модулем программы, выполняется компоновка грозди в исполнимый файл.
  Рекурсивная обработка модуля начинается с вызова функции ScanSubModule, получающей на входе имя
модуля и возвращающей в случае успешной обработки усечённое промежуточное представление. Логика об-
работки представлена в комментарии к модулю, который я здесь приведу.

/*
  На блок-схеме показаны основные этапы обработки модулей.

  Make --> ScanSubModule (определение состояния модуля)
                               |
                               V
                 Compile (загрузка IModule) [1]
                               |
                               V
      Compile-Aux (загрузка и анализ импортируемых модулей)
                               |
                               V
           Рекурсивный анализ импортируемых модулей
           (путём вызова ScanSubModule для каждого)
                               |
                               V
               Synthesis (анализ вызовов функций
          из импортируемых модулей и генерация кода) [2]
                               |
                               V
          Compile-Cache (кэширование списка импорта)
                               |
                               V
         UpdateContext (сохранение финального состояния)

  [1] В зависимости от состояния модуля (s.Type) выполняется загрузка
  промежуточного представления представления или по файлу исходного текста,
  или по файлу интерфейса модуля ("символическая информация").

  [2] В зависимости от состояния модуля (s.Type) или выполняется анализ
  импортируемых функций и генерация кода, или ничего не делается.
*/

  Задача состоит в том, чтобы в обработку модуля внедрить проверки корректности дерева модулей, об-
разованного пакетами и модулями проектов в соответствии со спецификацией, а также отсутствие ошибок
в межмодульных связях и физической организации модулей проекта. Для начала определим, что считать
корректностью дерева модулей.
  В последующем тексте речь будет идти о квалифицированных именах, для краткости прилагательное
"квалифицированный" опустим.
  При обработке модуля фигурируют 3 имени модуля:
  1) входное имя — имя модуля, который надо обработать. Это имя берётся из командной строки или ди-
рективы импорта; является аргументом функции ScanSubModule;
  2) "физическое" имя (в дальнейшем без кавычек) — путь к модулю относительно MP-каталога, в кото-
ром находится модуль. На ОС, не различающих регистр символов в именах файлов (семейство 32- или 64-
разрядных Windows) в физическом имени регистр символов не учитывается. На ОС, различающих регистр
символов (семейство POSIX) в физическом имени регистр учитывается;
  3) внутреннее (истинное) имя модуля — имя модуля, указанное в файле исходного текста или в файле
межмодульных связей, если файл исходного текста отсутствует. В спецификации оно считается основным
— по нему определяются истинные имена пакетов, в которых этот модуль (прямо или косвенно) находит-
ся.
  Для определения корректности дерева модулей, введём понятие набора квалифицированных имён модулей
и пакетов. В этот набор входят все истинные имена модулей, входящие в совместно обрабатываемые гро-
зди (за один акт вызова компилятора) и имена пакетов, образованных из указанных имён модулей путём
последовательного усечения последних сегментов имени.
  Модули образуют корректное дерево модулей, если среди набора квалифицированных имён модулей и па-
кетов
  1) не существует двух имён, различающихся только регистром символов и
  2) никакое имя не может быть одновременно именем какого-либо модуля и какого-либо пакета.

  Под отсутствием ошибок в межмодульных связях и физической организации модулей проекта ЗДЕСЬ будем
подразумевать следующее (сквозная нумерация).
  3. Истинное имя модуля должно соответствовать его физическому имени с учётом ограничений ОС. Не-
совпадение этих имён должно рассматриваться как ошибка в самом модуле — имя, указанное внутри моду-
ля не соответствует его физическому расположению.
  4. Входное имя должно соответствовать истинному модулю с учётом регистра. Несовпадение означает
ошибку в источнике входного имени — в командной строке или в директиве импорта, т.к. внутреннее имя
(при выполнении условия 3) принимается за эталон.
  5. Входное имя должно соответствовать физическому имени с учётом ограничений ОС. Выполнение этого
условия на данный момент осуществляется механизмом поиска модулей — проверка наличия файлов модуля
в данном MP-каталоге осуществляется функцией MFileSystem::ExistFile, которая  реализуется поверх
API используемой платформы.

  Поэтому можно привести следующие соображения по поводу проверки выполнения указанных условий.
  1. Нужна структура, хранящая построенное к этому моменту дерево модулей. В процессе обработки
гроздей обнаруживаются ещё не обработанные модули, их имена и имена пакетов, их содержащих, нужно
включать в эту структуру. Такая структура уже разработана и реализована в модуле Driver::MCaseTable.

  2. На стадии ScanSubModule до загрузки промежуточного представления необходимо проверить допусти-
мость имени — входное имя не должно вызывать конфликтов модуль/пакет, и, если часть имени в дереве
известна (например, если уже обрабатывались модули, находящиеся в том же пакете), то эта часть дол-
жна совпадать с учётом регистра символов.
  Если обнаруживается конфликт модуль/пакет, то обработка данного модуля немедленно прекращается
(бессмысленно обрабатывать модуль, нарушающий корректность дерева). Данное имя модуля нигде не сох-
раняется, даже как ошибочное.
  В случае только нарушения регистра ситуация сложнее. В ОС типа Windows есть возможность найти мо-
дуль даже при некорректном регистре и при этом может оказаться, что истинное имя найденного модуля
не нарушает корректность дерева — ошибка присутствует только в директиве импорта или командной
строке. Сам найденный модуль может оказаться корректным и быть подвергнутым компиляции. На ОС типа
UNIX, вследствие условия 5, найденный модуль неизбежно будет ошибочным: при совпадении истинного
имени физическому он не будет вписываться в дерево модулей, если же истинное имя будет соответство-
вать дереву модулей, то оно не будет совпадать с физическим именем. В обоих случаях гроздь, содер-
жащая эти модули, будет заведомо некорректной и не будет подлежать компоновке; модуль с ошибочной
директивой импорта также будет помечен как ошибочный и для него не будет выполняться генерация ко-
да.
  Если при нарушении регистра сразу же останавливать компиляцию, то поведение компилятора на разных
платформах будет (в этом аспекте) одинаковым: некорректное входное имя (как если бы имя содержало
недопустимые символы, или модуль с корректным именем был бы просто не найден) и всё.
  Если выполнить поиск модуля с некорректным именем, то модуль может обнаружится, что приведёт к
дополнительным поискам модуля, дополнительным стадиям обработки, большему числу найденных ошибок,
т.е. компиляция заведомо ошибочной грозди увеличится по времени с выдачей большего количества
диагностики.
  Возможно, этот вопрос следует оставить на выбор пользователя, сделав его параметром командной
строки.

  3. После загрузки промежуточного представления следует проверить выполнение условия 3 — совпаде-
ние истинного имени модуля с физическим. При несовпадении можно продолжать обработку, выставив флаг
ошибки. Такой модуль нельзя добавлять в дерево модулей, однако с контекстом интереснее.
  На ОС типа Windows поиск модулей осуществляется без учёта регистра, поэтому независимо от коррек-
тности входного имени (см. п.2) при дальнейшем анализе грозди и попытке проанализировать директиву
импорта с тем же именем без учёта регистра, мы снова наткнёмся на этот же модуль. Поэтому имеет
смысл сохранить этот модуль в контексте как ошибочный.
  На ОС типа UNIX при корректнмо входном имени модуль имеет смысл добавить в контекст по причине,
изложенной выше. При некорректном входном имени модуль в контекст добавлять не следует (если кон-
текст регистронезависим).

  4. При успешном выполнении п.3 следует проверить корректность истинного имени модуля в дереве —
здесь возможно только несовпадение регистра. Конфликт модуль/пакет исключается п.2 и п.3.
  Здесь рассуждения те же, что и в п.3.
  Несовпадение на ОС Windows возможно независимо от того, была ли ошибка регистра в п.2, т.к. из
условия 5 следует, что модуль найдётся. Также, поскольку физическое имя не чувствительно к регис-
тру, п.3 тут тоже роли не играет. Очевидно, такой модуль будет ошибочным, т.к. он не вписывается
в дерево, но выполнить проверку синтаксиса и даже проверку межмодульных связей для него можно.
  Из логики поиска модулей, при если при дальнейшем анализе грозди попадётся то же имя модуля в ди-
рективе импорта (без учёта регистра), то этот модуль будет найден повторно. Поэтому его имеет смысл
пометить в контексте как проанализированный и ошибочный, но в дерево не добавлять.
  Несовпадение регистра на ОС типа UNIX возможно только если мы решили продолжать обработку модуля
с некорректной директивой импорта, т.к. логика поиска модуля и п.3 сохраняют регистр символов. При
дальнейшей обработке грозди может встретиться директива импорта уже с корректным именем модуля.
  Тогда, если добавлять ошибочный модуль в контекст, при последующем корректном появлении, мы полу-
чим сообщение об ошибочном импорте, что неверно.

  5. При выполнении п.4 (т.е. когда внутреннее имя модуля совпадает с физическим и укладывается в
дерево), необходимо сравнить внутреннее имя с внешним — несовпадение будет уже ошибкой в источнике
внешнего имени, а не модуля. Такой модуль при отсутствии синтаксических и семантических ошибок под-
лежит генерации кода, при наличии ошибок добавляется в контекст как ошибочный.

  6. Из мутных рассуждений, связанных с контекстом, следует сделать вывод, что контекст непосредст-
венно связан с поиском модулей. Поэтому можно выработать две стратегии.
  А. Если в п.2 сразу же прекращать обработку при некорректном входном имени, то контекст можно ос-
тавить регистронезависимым.
  Б. Если после п.2 продолжать обработку модуля с этим именем, то контекст следует делать регистро-
зависимым на "регистрозависимых" ОС и регистронезависимым на остальных ОС. Т.е. имена модулей в
контексте следует приводить к "каноническому" виду вызовом соответствующей библиотечной функции.


[06.09.2010 - 18:03:12,45]
(Версия 0.1.979)

  [TODO: Переименование задач]
  В журнал проекта ввести синтаксис вида:

  \[RENAME: Bad name\]
  \[TODO: Cool name\]

позволяющий переименовать имя задачи и в дальнейшем использовать более точное имя. Необходимость
вызвана тем, что часто задачи в процессе эволюции меняют свой смысл и название уже перестаёт от-
ражать суть. Можно разрешить менять статус задачи с TODO на TOTHINK, чтобы имеющиеся задачи типа
TODO: Обдумать ... или TODO: Продумать ... преобразовать в TOTHINK-задачи.
  Приоритет задачи не определяю, потому что хотелось бы переименовать задачу ПИ:Хранить в контек-
сте также информацию о пакетах.


[07.09.2010 - 23:30:08,46]
(Версия 0.1.979)

  [DONE: Переименование задач]
  Сделано, причём сохранилась возможность перечислять задачи пачками:

  \[TODO: Foo\]
  \[RENAME: Bar\]
  \[TOTHINK: Baz\]
  \[ERROR: Xyzzy\]
  ...

  В случае пачек команда RENAME воспринимает только ближайшую последующую строчку. После RENAME мо-
гут располагаться только теги TODO, +TODO, TOTHINK, +TOTHINK, ERROR, +ERROR. В случае любых других
тегов выводится сообщение об ошибке.
  Кстати, тут есть лазейка: после тега TODO нельзя написать тег TOTHIHK, а через RENAME можно.
  Я воспользуюсь новым функционалом для переименования тегов, названных "Продумать..." или "Обду-
мать ...", а также TODO ПИ:Хранить в контексте также информацию о пакетах.
  Не смотря на то, что заголовок DONE, версия компилятора не поднята, т.к. изменение не касается
компилятора, а только набора утилит. А версия утилит увеличина со 120 до 121.

  [RENAME: Продумать упрощение структуры Lexer'а и Parser'а]
  [+TOTHINK: Упрощение структуры Lexer'а и Parser'а]
  [RENAME: Обдумать введение видов для квалифицированных имён]
  [+TOTHINK: Введение видов для квалифицированных имён]
  [RENAME: Продумать генераторы лексического и синтаксического анализаторов]
  [+TOTHINK: Генераторы лексического и синтаксического анализаторов]
  [RENAME: Продумать двухуровневую структуру синтаксического анализа]
  [+TOTHINK: Двухуровневая структура синтаксического анализатора]
  [RENAME: Продумать изменения в лексике и комментариях]
  [+TOTHINK: Изменения в лексике и комментариях]
  [RENAME: Продумать блоки $INIT и $FINAL]
  [+TOTHINK: Блоки $INIT и $FINAL]
  Удалено слово "продумать" ("обдумать") из заголовка, сменён тег с TODO на TOTHINK. (Переименова-
ние было проведено при первой возможности — сразу после того, как был введён тег RENAME.)

  [RENAME: ПИ:Хранить в контексте также информацию о пакетах]
  [+TODO: Контроль регистра символов в именах модулей и пакетов согласно спецификации]
  Заголовок переименован в более актуальный.


[08.09.2010 - 22:17:59,56]
(Версия 0.1.979)

  [+TODO: Контроль регистра символов в именах модулей и пакетов согласно спецификации]
  Чётко перечислю те действия, которые надо сделать.

  1. Контекст не должен контролировать регистр символов в имени (сейчас он возвращает MismatchCase
при отличии имени модуля на входе от действительного имени модуля).
  
  2. Регистрозависимость контекста должна определяться регистрозависимостью целевой платформы, т.е.
следует применять функцию MFileSystem::CanonicalName для преобразования ключа.

  Примечание. Основные задачи контекста:
  (а) по входному имени возвращать сведения о результатах предыдущих обработок модулей с этим име-
нем (сейчас обработка разделена на три уровня: Found, Cluster и Ready; среди возвращаемых сведений
присутствует уроветь, на котором обработка завершена) и
  (б) если имени соответствует модуль, то контекст должен сообщать сведения об этом модуле: физи-
ческое расположение (MP-каталог, пути к end'ам, время модификации), тип модуля, кэшированный список
импорта, целевой файл и т.д.
  Т.к. это две малосвязанные задачи, действовать следует очень аккуратно. Возможно, понадобится
разделить контекст на два компонента, каждый из которых решает по отдельности каждую задачу.

  3. Driver::MCaseTable при проверке входного имени должна возвращать один из трёх результатов: до-
пустимое имя, конфликт модуль/пакет и ошибка в регистре, причём если возможны два варианта ошибки,
конфликт модуль/пакет имеет приоритет. Возможно, модуль лучше переименовать в Driver::MModuleTree.

  4. Проверку соответствия внутреннего и внешнего имени следует проводить во время обработки модуля
в Driver::MCompiler, а не во время синтаксического анализа. Соответственно, не следует передавать
имя модуля внутрь синтаксического анализатора.

 (5. Возможно, следует переименовать модуль Driver::MModules в Driver::MModuleFinder, что больше
соответствует предназначению модуля. Также разумно было бы переименовать контекст, но во что — я не
знаю.)

  Кроме того, систематизирую (т.е. повторно перечислю без размышлений) этапы проверки корректности
имён модулей и дерева модулей:

  O. Проверка имени в контексте.
  Ситуации:
  1. Имя помечено как ошибочное — прекращение обработки. Сообщить об ошибке в источнике имени.
  2. Модуль с этим именем известен как ошибочный — сообщить о невозможности загрузки этого модуля.
  3. Модуль с этим именем успешно обработан — возвратить его интерфейс.
  4. Модуль с этим именем подлежит обработке — продолжить обработку.

  I. Проверка входного имени на допустимость в дереве модулей.
  Ситуации:
  1. Конфликт модуль/пакет — остановка обработки с занесением имени в контекст как ошибочного.
  2. Конфликт регистра — допустима как остановка обработки, так и её продолжение. В обоих случа-
ях входное имя должно быть запомнено как ошибочное. [1]
  3. Имя допустимо — продолжить обработку.

  II. Загрузка модуля. Здесь под загрузкой понимается как синтаксический анализ файла исходного
текста, так и загрузка файла интерфейса.
  Ситуации:
  1. Модуль загрузить не удалось — прекратить обработку, занести входное имя модуля в контекст как
ошибочное.
  2. Модуль загрузился с синтаксическими ошибками — продолжить обработку, но при этом модуль запо-
минается как ошибочный. [2]
  3. Модуль загрузился без ошибок — продолжение обработки.

  III. Проверка совпадения внутреннего имени с физическим.
  Ситуации:
  1. Имена не совпадают — обработка продолжается, но модуль запоминается как ошибочный. [2]
  2. Имена совпадают — обработка продолжается.

  IV. Проверка внутреннего имени на допустимость в дереве модулей. Выполняется только если проверка
III прошла успешно. Конфликт модуль/пакет здесь невозможен, т.к. на пути внешнее имя--физическое
имя--внутреннее имя при правильности последнего звена возможно только нарушение регистра (на ОС ти-
па Windows).
  Ситуации:
  1. Конфликт регистра — обработка продолжается, но модуль запоминается как ошибочный. [2]
  2. Имя допустимо — обработка продолжается.

  V. При успешном выполнении проверок III и IV внутреннему имени модуля можно доверять (модуль сам
по себе корректен — находится в правильном файле и имеет допустимое имя). Поэтому при успешном вы-
полнении упомянутых проверок следует продолжить обработку модуля: провести проверку импорта.
  Ситуации:
  1. Проверка импорта завершилась неуспешно — прекратить обработку, модуль помечается как ошибоч-
ный. [2]
  (Проверка импорта может завершиться неуспешно по двум причинам: ошибки в самом модуле или ошибки
при загрузке интерфейсов импортируемых модулей.)
  2. Проверка импорта завершилась успешно — продолжить обработку.

  VI. Если модуль не запоминался как ошибочный [2], выполнить генерацию выходных файлов для модуля.
  Ситуации:
  1. В процессе генерации back-end сформировал внутреннюю ошибку. Следует прервать работу компиля-
тора с выдачей сообщения об ошибке.
  2. Генерация кода завершилась успешно — завершить обработку.

  VII. Завершение обрабоки модуля.
  Ситуации:
  1. В процессе обработки модуль запоминался как ошибочный [2] — сохранить в контексте информацию
об этом модуле, как об ошибочном. Продолжить обработку имени.
  2. Модуль не запоминался как ошибочный — сформировать из промежуточного представления интерфейс
модуля.

  VIII. Если входное имя модуля не было запомнено как ошибочное [1] или модуль не запоминался как
ошибочный [2], то сравнить внешнее и внутреннее имена.
  Ситуации:
  1. Имена не совпадают — продолжить обработку имени, запомнить имя модуля как ошибочное. [1]
  2. Имена совпадают — продолжить обработку имени.

  IX. Завершить обработку имени.
  Ситуации:
  1. Если имя модуля запоминалось как ошибочное [1], то сохранить в контексте информацию об этом
имени, как о ошибочном. Если создавался интерфейс, то уничтожить интерфейс. Сообщить об ошибке в
источнике имени.
  2. Модуль с этим именем запоминался как ошибочный [2]. Если создавался интерфейс, то уничтожить
интерфейс. Сообщить о невозможности загрузки этого модуля.
  3. Если имя и модуль не запомнены как ошибочные, то возвратить интерфейс модуля.

  Примечания. Чтобы обратить внимание на внешне похожие, но принципиально разные виды ошибок, их
упоминания дополнительно помечены цифрами в квадратных скобках.
  Если загружался только интерфейс модуля (модуль обновлён или библиотечный), то стадии V и VI не
выполняются, на стадии VII интерфейс не формируется (т.к. вместо промежуточного представления мы
уже имеем интерфейс).
  Возможно, что чтобы реализовать этот алгоритм, придётся кардинально переработать Driver::MCompil\
er. Возможно, что контекст придётся заменить на две параллельные таблицы с разными задачами: одна
из них хранит имена и индексируется физическими именами, вторая хранит сведения о модулях и индек-
сируется без учёта регистра.
  Стадия IX по ситуациям напоминает стадию O, т.к. и та, и другая завершают обработку.
  Исходя из алгоритма, интерфейс не обязан иметь вид IModule.
  Разумно было бы оформить все эти рассуждения в отдельную спецификацию, регламентирующую алгоритм
обработки имени модуля: от командной строки до линковки или от импорта до интерфейса в зависимости
от ситуации.


[08.10.2010 - 12:07:21,56]
(Версия 0.1.980)

  [DONE: Контроль регистра символов в именах модулей и пакетов согласно спецификации]
  Задача реализована в полном объёме, но не совсем в той форме, которая была описана в предыдущем
сегменте задачи.
  Теперь осуществляется контроль того, что
  а) в наборе гроздей, обрабатывающихся за раз, не может присутствовать модуль и пакет с одинаковым
квалифицированным (уточнённым) именем;
  б) регистр имени модуля определяется из имени, указанного внутри модуля. Регистр имени пакета оп-
ределяется из регистров имён модулей, расположенных в этом пакете. Если регистр имени пакета в раз-
ных модулях различается, то за эталон принимается имя пакета, попавшееся впервые;
  в) сравнивается физическое имя модуля и внутреннее с учётом ограничений ОС — на Windows без учёта
регистра;
  г) ошибка, связанная с различием внутреннего и внешнего имён, позиционируется в источнике внешне-
го имени (а не в самом модуле).

  Что касается реализации, были введены следующие модули и структуры данных.
  1. Таблица результатов поиска t.hLookupTable. Расположена в Driver::Tables::MLookup. Хранит в се-
бе сведения о том, как до этого завершилась обработка данного имени. Варианты: успешно, с ошибкой
(причём разные виды ошибок различаются) или данное имя ещё не обрабатывалось.
  2. Дерево модулей t.hModuleTree, ранее упоминавшееся как CaseTable. Расположено в Driver::Tables
::MModuleTree. Хранит в себе построенное к текущему моменту дерево пространств имён.
  3. Таблица модулей, ранее называемая контекстом. Хранит в себе набор атрибутов каждого модуля.
Расположена (перенесена) в Driver::Tables::MModules. В программе известна как t.hModules
  4. Структура-агрегат t.hTables. Расположена в Driver::MTables. Хранит в себе три вышеупомянутые
таблицы и переадресует обращения к каждой из компонент. Пример:

    <MTables::Lookup
      t.hTables
      & MLookupTable.AddError-CantLoadModule t.ModuleName
    >

  В данном вызове агрегат извлекает из t.hTables таблицу t.hLookupTable и применяет к ней указан-
ную операцию (<MLookupTable::AddError-CantLoadModule t.hLookupTable t.ModuleName>), заворачиват
таблицу t.hLookupTable обратно в t.hTables и возвращает результат обращения.

  5. По-новому реализован интерфейс файлов. Вместо использования урезанного промежуточного пред-
ставления t.hSymIModule, теперь используется специальный тип данных t.ModuleIF, определённый в
Driver::MModuleIF, который семантически является типом-значением и его можно копировать.
  Соответственно, удалён модуль Driver::MSymModule, ставший ненужным.
  Интерфейсы уже загруженных модулей кэшируются в t.hModules, что позволяет загружать их, не счи-
тывая с диска.
  6. Был полностью переписан модуль Driver::MCompiler. Рефакторинг модуля, проведённый ранее, поз-
волил мне прояснить алгоритм, однако введение новых структур данных (см. выше) потребовало полной
переработки исходного текста.
  Логика работы модуля следующая.
  Точкой входа в модуль является функция Make, которая принимает на входе корень грозди модуля,
указанный в командной строке, выполняет для него рекурсивную перекомпиляцию (путём вызова функции
ExternalName), затем при осутствии ошибок компиляции выполняет компоновку грозди.
  Функция ExternalName является основной функцией по обработке модуля — она принимает на входе вне-
шнее имя и источник имени (t.SrcPos, для корней грозди — положение в командной строке) и возвращает
результат обработки данного имени (успешно или ошибочно, какие именно ошибки).
  Результаты обработки извлекаются из таблицы t.hLookupTable, если же имя в таблице осутствует, то
осуществляется обработка модуля (функцией OnUnknown), после которой имя запоминается в таблице.
  Функция OnUnknown осуществляет обработку модуля, чьё имя ранее не было известно (т.е. модуль не
обрабатывался). В процессе работы проверяется допустимость имени в таблице модулей, если имя допус-
тимо, вызывается функция компиляции модуля Compile.
  Функция Compile осуществляет синтаксический анализ модуля и его межмодульных связей, и, при от-
сутствии ошибок, генерацию объектного кода модуля.
  Для получения интерфейса импортируемых модулей функция Compile осуществляет вызов функции Extern\
alName, осуществляя таким образом рекурсивную обработку грозди.

  [DONE: \\== Вот список приоритетных TODO ==//]
  Всё необходимое для версии 0.2 выполнено.

  [DONE: //== Список приоритетных TODO ==\\]
  Все необходимые задачи по выпуску версии 0.2 выполнены (кроме документации, но она была необяза-
тельна).
  1. Компилятор реализует механизм модулей и пакетов в полном соответствии со спецификацией.
  2. Архитектура компилятора открыта: поддерживает расширение новыми front- и back-end'ами, front-
end осуществляет загрузку модуля из одиночного файла исходного текста с требуемым расширением (пары
файлов интерфейс/реализация, как в случае Модулы или Рефала Плюс), back-end осуществляет генерацию
промежуточного файла с заданным расширением в заданный подкаталог и компоновку промежуточных файлов
в целевой файл.
  Back-end'ы группируются в профили, объединённые общностью решаемых задач, в частности в профиль
всегда входит генератор промежуточных файлов с интерфейсом модуля, back-end, создающий целевые фай-
лы с исполнимым кодом (сейчас только через генерацию кода на других языках программирования) и, оп-
ционально, back-end, обобщающий информацию, полезную для программиста, такую как перекрёстные связи
и список нескомпонованных элементов (что облегчает поиск и удаление нерелевантного кода).
  3. Компилятор имеет интерфейс, адекватный модульной модели и архитектуре компилятора: позволяет
сконфигурировать end'ы, выбрать профиль компиляции и указать пути поиска модулей. Интерфейс пред-
ставляет собой интерфейс командной строки, поддерживающий загрузку списка опций из текстового фай-
ла, что удобно.
  4. Реализован один front-end — front-end языка Модульный Рефал, который по синтаксису похож на
Рефал 5, но при этом заимствует ряд идей у Оберона. Особенности синтаксиса:
  (А) В файле исходного текста указывается имя модуля: в начале после директивы $MODULE и в конце
после директивы $END. Под именем модуля здесь подразумевается уточнённое (квалифицированное) имя,
т.е. имя с указанием пакета, в котором модуль находится.
  (Б) Вместо списка внешних функций, как это сделано в Рефале 5, указывается список импортируемых
модулей, причём допустимо переименование модулей (например, чтобы указать короткие псевдонимы).
Как и пункт (А), эта особенность позаимствована из Оберона.
  (В) Из управляющих конструкций поддерживается только подмножество Базисного Рефала: все предоло-
жения имеют вид Образец = Результат;.
  (Г) Новшеством является введение в язык т.н. абстрактных типов данных — именованных скобок. Для
объявления абстрактного типа данных внутри модуля пишется директива $DATA, после которой следует
список имён. Термом АТД является значение t-переменной, записываемое как выражение (образцовое или
результатное в зависимости от места в предложении) в квадратных скобках, причём после открывающей
квадратной скобки должно находится имя, объявленное в директиве $DATA. Семантика данной конструкции
состоит в том, что такой терм, созданный в результатном выражении некоторого модуля, может быть со-
поставлен только в образцовом выражении того же модуля, т.е. способа получить доступ к содержимому
из других модулей не существует.
  (Д) Язык поддерживает указатели на функции, пока только глобальные. В дальнейшем планируется под-
держка и вложенных функций, как в Рефале 7 или Простом Рефале.
  (Е) Также язык поддерживает статические ящики по аналогии с Рефалом 2, однако, в отличии от пос-
леднего, они не могут экспортироваться модулем наружу (они всегда локальные функции).
  5. Реализация поддерживает 5 back-end'ов: генерация кода на Си++, совместимая с кодом, генериру-
емым Простым Рефалом (основной back-end), генерация кода на Простом Рефале, генерация кода на Рефа-
ле 5 (возник исторически первым, в дальнейшем планирую от него отказаться) и два служебных: генера-
ция кода интерфейсов модулей и построение таблиц перекрёстных ссылок (см. выше про профили).
  6. На данный момент компилятор имеет хоть и маленькую, но тем не менее достаточно удобную библио-
теку, реализованную под платформу Windows. Библиотека написана в кросс-платформенной манере, поэто-
му её относительно несложно будет переписать и под платформу POSIX.


[11.10.2010 - 12:25:32,57]
(Версия 0.2.981)

  [CHANGED: Обновлён номер версии до 0.2]
  Обновлён номер версии до 0.2.981.


[18.10.2010 - 16:14:47,28]
(Версия 0.2.981)
  [CHANGED: Оформление журнала проекта]
  Если ранее для написания текста я стремился использовать всё пространство строки, то теперь я бу-
ду по возможности избегать разрыва слов в конце строки и избегать висячих предлогов (или союза и).
  Максимальная длина строки по-прежнему равна 100 символам.

  [TODO: ВПВ: Написание документации (НД)]
  Выпуск публичной версии компилятора требует написания документации: описания языка и описания
конктретной реализации. Поскольку предполагается распространение Модульного и Простого Рефалов
в одном дистрибутиве, документация должна включать в себя сведения об обоих диалектах.
  Отсюда две подзадачи:
  1 Написание "контента";
  2 Выбор способа представления контента.


  [TODO: ВПВ: НД: Написание текста документации]
  Требуется написать документацию к компиляторам и языкам Модульного и Простого Рефалов в текущей
реализации. Документация должна включать в себя следующие пункты:
  1 Описание текущей версии языка Модульный Рефал без рассмотрения особенностей конкретной реали-
зации. Включает в себя синтаксис и семантику Рефала, концепцию модульности.
  2 Описание текущей версии компилятора Модульного Рефала: представление модулей в виде исходных
и промежуточных файлов, компиляция, компоновка, расположение файлов модулей.
  3 Описание текущей версии языка Простого Рефала, при этом следует акцентировать внимание на том,
что ряд возможностей (идентификаторы, статические ящики) добавлены для совместимости с Модульным
Рефалом. Поскольку семантика управляющих конструкций Модульного и Простого Рефалов во многом сход-
ны, то их можно рассмотреть бегло.
  4 Описание текущей реализации Простого Рефала в Си++, рассмотрение интерфейса с языком Си++.
  5 Рассмотрение back-end'ов реализации Модульного Рефала, написание библиотечных модулей для
back-end'ов C++/SR и SR.
  6 (Приложение) Установка реализации Модульного Рефала на компьютер.
  7 (Приложение) Установка реализации Простого Рефала на компьютер.


  [TOTHINK: ВПВ: НД: Выбор представления документации]
  Существует несколько способов написания документации. Среди них можно выделить:
  1 Написание в виде файлов простого текста;
  2 Использование текстовых процессоров с последующей конверсией в PDF;
  3 Использование различных языков разметки:
    а) Perl POD,
    б) TeX Info,
    в) TeX;
  4 Продолжить разработку собственноручно написанного велосипеда для конверсии текста с разметкой
в своеобразный html для блога на WordPress.
  5 Пользоваться web-инструментами, например сразу размещать текст на блоге с требуемым форматиро-
ванием, или же при размещении исходных текстов на репозиториях, можно использовать прилагающуюся
wiki-среду.

  Пункт 1 наиболее прост в реализации, не требует установки дополнительного программного обеспече-
ния на компьютер, но и предоставляет минимум возможностей.
  Пункт 2 позволяет создавать красивые PDF-файлы, однако могут быть проблемы с формированием кода
HTML (например, для вставки в блог).
  Варианты, перечисленные в п. 3 позволяют с различной сложностью и различным качеством создавать
документацию в форматах PDF, HTML, man, info, красиво отформатированных текстовых файлов. Однако,
код в HTML для вставки в блоги придётся дорабатывать или перерабатывать.
  Вариант в п. 4 не требует установки дополнительного ПО на компьютер, позволяет адаптироваться
под любой формат текста блогов, или же генерировать код для языков разметки, перечисленных в п. 3.
Однако, всё это требует лишних усилий (проще пользоваться готовым средством, чем писать своё),
которые могли бы быть направлены на работу непосредственно с самим компилятором.
  Вариант 5 затрудняет работу с текстом offline, а также преобразование текста в другие форматы
(например, PDF), хотя всё зависит от инструмента.
  Поскольку пока выбор оптимального варианта затруднён, пока буду придерживаться п. 1, поскольку
от него проще всего перейти к любому из вышеперечисленных вариантов.

  [TODO: ВПВ: Вложенные функции (ВФ)]
  Как показала практика работы с Простым Рефалом, вложенные функции существенным образом повышают
выразительность программы и производительность программиста, даже если они и безымянные.
  Кроме того, практика показала, что если синтаксический анализ написан методом рекурсивного спуска
достаточно регулярным образом, то добавить в него вложенные безымянные функции тоже достаточно
несложно.
  Используемый рантайм (общий для Простого Рефала и back-end'а C++/SR Модульного Рефала) поддержи-
вает замыкания (представление вложенных функций во время выполнения программы).
  Версия 0.2 завершена, поэтому ничего не мешает расширению синтаксиса (на который был ранее нало-
жен запрет, дабы сконцентрировать усилия на других задачах).
  Вышеперечисленных аргументов достаточно, чтобы внедрить в язык вложенные безымянные функции
(позже можно будет придумать и именованные). Однако, есть и сложность на этом пути.
  Дело в том, что относительно безболезненно внедрить замыкания только в два профиля из трёх. Ран-
тайм профиля Рефала 5, в отличие от рантайма профилей C++/SR и SR, не поддерживает имманентно замы-
каний и, как следствие, реализация вложенных функций потребует костылей.
  Замыкание представляет собой кортеж, включающий в себя указатель на глобальную функцию и набор
связанных переменных, представляющих собой контекст замыкания. Поэтому задача состоит в том, чтобы
каким-либо образом их хранить в поле зрения. Семантически не должно быть способа разделить замыка-
ние на элементы каким-либо сопоставлением с образцом, следовательно, замыкание должно быть атомом
и сопоставляться с s-переменной.
  Под контеНтом замыкания будем подразумевать кортеж из контеКСта и указателя (имени) глобальной
функции.
  Среди способов реализации замыканий в профиле Рефала 5 можно выделить две группы: надёжные
и ненадёжные.

  I. Простые ненадёжные методы.

  1 При каждом создании замыкания создавать новый уникальный атом (например, функцией Implode),
а контент замыкания помещается в копилку с ключом в виде уникального атома. Непрямой вызов функции
представляется как вызов специальной функции, которая осуществляет проверку наличия уникального
атома в копилке и вызов контента при помощи функции Mu. При отсутствии атома в копилке функцией
Mu вызывается сам атом на входе.
  Недостаток: контенты замыканий не освобождаются, поэтому память будет непрерывно утекать.
  Достоинство: простота.

  2 По аналогии с п. 1, но используется фиксированный пул уникальных атомов. Если же пул опустошён,
то разрушается какое-то замыкание и его атом используется для создания нового замыкания.
  Недостаток: метод невозможно применять на практике, т.к. программа, использующая замыкания,
становится абсолютно ненадёжной — любое замыкание может быть похерено в любой момент.
  Достоинство: относительная простота, отсутствие утечек памяти.
  Метод тут рассматривается только для полноты картины.

  3 По аналогии с п. 1, но с замыканием ассоциируется счётчик вызовов, после которого оно становит-
ся недействительным (соответственно, контент освобождается). Соответственно, при каждом вызове
замыкания счётчик декрементируется.
  Недостаток: необходимо при создании замыкания инициализировать счётчик или специальным синтакси-
сом, или специальной библиотечной функцией, или выбирать значение счётчика по умолчанию. Если при
создании значение счётчика оказалось заниженным, то при "избыточных" вызовах получим ошибку. Если
значение счётчика оказалось заниженным, то память не освободится.
  Достоинство: способ более надёжен, чем п. 2, также способен бороться с утечками памяти.

  4 По аналогии с предыдущим пунктом с замыканием ассоциируется счётчик вызовов, но пользователь
получает возможность управлять этим счётчиком. Например, при создании ассоциируется значение 1,
при копировании замыкания пользователь явно инкрементирует счётчик, при удалении замыкания поль-
зователь должен счётчик явно декрементировать. Фактически, ручной подсчёт ссылок.
  Достоинства: способен обеспечить надёжность программы, а также избежать утечек памяти. Способ
прост. Способ эффективен.
  Недостаток: человеческий фактор. Контроль программиста за копированием напоминает управление
памятью в языках без сборки мусора (например, Си), но здесь последствия не так пагубны. Также недо-
статком является загромождение кода вызовами функций, которые ничего не делают в других профилях.

  II. Сложные надёжные методы. Данные методы всегда обеспечивают надёжность программы и ликвидируют
утечки памяти.

  5 Поскольку циклических связей между замыканиями быть не должно, можно применить подсчёт ссылок.
Т.е. в каждом предложении следует сравнивать количество переменных слева и справа: при уничтожении
переменных следует рекурсивно просматривать удаляемые переменные и декрементировать счётчики, при
копировании — аналогичным способом инкрементировать.
  Достоинство: процесс автоматизирован, надёжен.
  Недостаток: резкое снижение быстродействия.

  6 Изменение формата поля зрения. Атомы можно представлять как (s.Тип e.Значение), скобочные термы
как ((s.Тип e.Значение)). Такой формат позволяет хранить внутри атомов любые объектные выражения,
в том числе и контент замыкания.
  Достоинства: нет нужды в подсчётах ссылок и сборках мусора, утечки памяти невозможны, приличное
быстродействие.
  Недостатки: сравнение одноимённых переменных не за постоянное время, переделка всей библиотеки,
нечитаемость дампов памяти.

  7 Сборка мусора. Идея аналогична п. 2, только при исчерпании пула вызывается сборщик мусора.
  Недостаток: сложность в поддержке корневого множества (не иначе как в п. 5).
  Достоинство: метод надёжный в отличие от п. 2.

  8 Генерация кода в виде CPS (continuation-passing style). В этом случае вместо поля зрения
используется "пассивная" структура данных, в каждый момент времени в реальном поле зрения присут-
ствует только одна скобка конкретизации, поэтому корневое множество поддерживается элементарно.
  Достоинство: корневое множество доступно напрямую.
  Недостаток: это фактически написание нового back-end'а, снижение быстродействия вдвое (на каждый
вызов функции требуется по две скобки конкретизации), сложность кодогенерации.

  9 Эмуляция абстрактной рефал-машины. Можно добиться сравнительно малыми изменениями в кодогене-
рации и в реализации библиотечных модулей.
  Достоинство: доступность корневого множества, простота переделок.
  Недостатки: снижение быстродействия, фактически, написание нового back-end'а.

  Из приемлемых вариантов можно назвать п. 1, п. 4 и п. 9.


[05.11.2010 - 21:36:08,97]
(Версия 0.2.981)

  [TODO: ВПВ: НД: Выбор представления документации]
  На данный момент выбрано и уже используется представление пользовательской документации в виде
блога на сервисе Blogger (Blogspot), т.е. используются web-инструменты. Данное TODO чисто
техническое.

  [DONE: ВПВ: НД: Выбор представления документации]
  В качестве способа представления выбрано использование web-инструментов, а именно блога
на сервисе Blogger (Blogspot). Адрес ресурса http://mrefal.blogspot.com. Текст вводится
преимущественно WYSIWIG-средствами сервиса, хотя при необходимости используется правка в режиме
html. Одной из проблем является то, что текст документации хранится не на жёстком диске вместе
с прочими файлами проекта, а в Интернете. Поэтому необходимо (в далёкой перспективе) разобраться,
существует ли API, позволяющий публиковать/обновлять записи в блоге без использования web-интерфейса
или сохранять записи из блога на жёсткий диск компьютера в автоматическом режиме.

  [TODO: Выпуск публичной версии (ВПВ)]
  Особенности публичной версии:
  * Исходный код соответствует текущей версии 0.2.981, синтаксических нововведений и улучшений
алгоритмов не планируется. Это не исключает исправлений обнаруженных ошибок.
  * Руководство пользователя по Модульному и Простому Рефалам.
  * Средство автоматической инсталляции на жёсткий диск компьютера.
  * Репозиторий исходного кода в Интернете.
  * Выбор opensource-лицензии

  Исходный код есть, руководство пишется. Осталась инсталляшка, репозиторий и лицензия.

  [RENAME: ВПВ: Вложенные функции (ВФ)]
  [TODO: Вложенные функции (ВФ)]
  Снят префикс ВПВ в связи с тем, что их реализация не входит в приоритеты публичной версии.
  В качестве варианта реализации замыканий для back-end'а Рефала 5 предполагается использовать
модифицированный п. 1, подразумевающий создание нового атома для каждого замыкания, но с явной
операцией уничтожения. Возможна разработка специального модуля аналога MLambda, который вызывает
функцию уничтожения после выполнения требуемой операции. Функция уничтожения замыкания на других
back-end'ах не будет делать ничего.

  [TOTHINK: ВПВ: Средство автоматической установки]
  Следует продумать способ установки компиляторов на диск компьютера. Возможные варианты для
платформы Windows:
  1. Использование make-файлов.
  2. Использование специализированных средств установки типа пакетов MSI.
  3. Написание кустарного инсталлятора на базе sfx-архивов WinRAR и пакетных файлов.

  [TOTHINK: ВПВ: Репозиторий исходного кода]
  Выбрать репозиторий исходного кода для хранения исходных текстов проекта. TOTHINK превратится
в TODO, когда будет выбран репозиторий.

  [TOTHINK: ВПВ: Opensource-лицензия]
  Следует выбрать opensource-лицензию. TOTHINK станет TODO когда лицензия будет выбрана. TODO
включит в себя задачу по внедрению лицензионного соглашения в исходные тексты программы.


[24.05.2011 - 21:35:38,66]
(Версия 0.2.981)

  [ERROR: После установки Momentix'а перестал работать пункт меню "Показать текущую конфигурацию"]
  Была установлена среда QNX Momentix, а вместе с ней и утилиты Cygwin, в результате чего перестал
работать упомянутый пункт меню. Создаётся пустое меню почему-то.


[27.11.2011 - 15:47:55,31]
(Версия 0.2.981)

  Проект застрял. Вероятно, сдох.


[28.11.2011 -  0:25:10,03]
(Версия 0.2.981)

  Проект не сдох. Сегодня прикрутил профилировку и отпрофилировал.

  [FIXED: После установки Momentix'а перестал работать пункт меню "Показать текущую конфигурацию"]
  Почему-то утилита uname.exe, входящая в состав Моментикса, операционную систему (Windows 7)
называла Workstation. В результате переменные типа ECHO или PRINTLINE не определялись. В Include/
platform.mk добавлен грязный хак: Workstation интерпретируется как Windows. Теперь работает.

  [CHANGED: Добавлен библиотечный модуль профилировщика]
  Добавлен модуль MProfiler, осуществляющий профилировку программы. Чтобы замерить время выполнения
вызова функции <Func args>, нужно вызвать <MProfiler::Quantify &Func args>. Функция Profiler::
PrintResults сохраняет таблицу профилировки в файле или выводит в stdout.

  [TODO: Ускорение компиляции]
  Сегодня был создан модуль профилирования на основе профилировщика, разрабатывавшегося для проекта
FindCopies. Модуль профилирования несовершенный, но благодаря нему практические результаты уже по-
лучены: львиная доля времени уходит на кодогенерацию и компоновку, а если конкретнее, то расклад
примерно следующий:
  * От четверти до трети времени уходит на построение таблицы перекрёстных связей (XLinx). Затраты
на кодогенерацию и компоновку примерно равны.
  * Не менее четверти времени уходит на компоновку в рамках основного back-end'а, причём для всех
трёх профилей.
  * Речь идёт о замерах в режиме BUILD (полной перекомпиляции), в случае режима MAKE (частичная
перекомпиляция) затраты на компиляцию меньше, следовательно, удельная доля компоновки больше.
  Таким образом, около половины времени уходит на компоновку.

  Выходы из этого положения следующие:
  1. Для back-end'ов C++/SR и SR выходными файлами считать не исходники на C++ и Простом Рефале
соответственно, а объектные файлы. Такой подход затруднит работу с библиотечными модулями: удобнее
и переносимее, когда их выходные файлы являются исходным текстом на C++ или Простом Рефале, соот-
ветственно. Как вариант, библиотечные файлы можно компилировать в объектники на стадии компоновки.
  2. На стадии компоновки отслеживать обновившиеся файлы и перекомпилировать только их. Кроме того,
что код компоновщиков от этого усложнится, других недостатков не видно.
  3. Заставить компоновщики генерировать make-файл, а затем вызывать make. Недостаток в том, что
необходимо иметь утилиту make, но большинство компиляторов, как правило поставляются вместе с этой
утилитой.
  4. (Требует серьёзного рассмотрения и существенной переработки кода.) Продумать интеграцию с ути-
той make с отслеживанием зависимостей.

  Перечисленные варианты справедливы для back-end'ов C++ и Простого Рефала. В случае back-end'ов
Рефала 5 и XLinx требуется изучение и оптимизация самого кода на Рефале, поскольку, в отличие
от предыдущих случаев, где время тратилось на вызовы внешних программ, здесь узким местом является
сам код на Рефале.

  В общем, всё грамотно делается: сначала профилировка, а затем оптимизация.


[28.11.2011 - 23:54:02,05]
(Версия 0.2.981)

  [TODO: Ускорение компиляции]
  Были реализованы выходы 2 и 3 для back-end'а C++/SR, т.е. компоновщик отслеживает обновившиеся
исходные файлы на Си++ и перекомпилирует только их и компоновщик генерирует make-файл и запускает
утилиту make, соответственно. Соответственно, они реализованы в модулях C-Link::MMake и C-Link::
MPartialLinker.
  Из результатов профилирования можно сделать следующие выводы:
  * Оба компоновщика при полной перекомпиляции выполняются примерно в 3 раза дольше, чем исходный.
  * Если проект обновлён (т.е. ни один из целевых файлов не перекомпилирован), то новые компоновщи-
ки выполняются за относительно очень малое время.
  Исследование проводилось только для компилятора и профиля C++/SR, в качестве компилятора языка
Си++ использовался BCC 5.5, запускаемый через батник.

  Компоновщик C-Link::PartialLinker объектные файлы помещает по соседству с исходными файлами на
языке Си++.
  (+) К достоинствам компоновщика можно отнести то, что он не требует использования внешней утили-
ты (make).
  (+) Если за раз компилируется несколько целевых файлов, то объектники между собой не конфликтуют.
  Недостатки же следующие:
  (-) Объектные файлы помещаются по соседству с модулями библиотеки и рантайма, эти папки могут
быть доступны только для чтения, что вызовет ошибку. Впрочем, текущий компоновщик Простого Рефала
обладает тем же недостатком.
  (-) При использовании профиля Рефала 5 компоновщик будет выполняться долго: запрос даты послед-
него изменения происходит посредством вызова внешней программы.
  (-) Изменения отслеживаются только для пар объектник/исходник, поэтому компоновка из объектников
выполняется всегда.

  Компоновщик C-Link::MMake объектные файлы помещает в отдельно указываемую папку (она указывается
в качестве параметра, можно передавать из командной строки или конфигурационных файлов), чтобы не
возникало конфликтов имён, объектники получают имена вида 1.obj, 2.obj и т.д. Чтобы сохранить пре-
емственность между запусками программ, компоновщик сначала загружает предыдущий make-файл (его фор-
мат предельно простой), считывает оттуда соответствия между исходными и объектными файлами и их
учитывает при генерации нового объектника. В связи с особенностями алгоритма часть старых объектных
файлов удаляется из этой папки (подробности алгоритма в самом модуле).
  Достоинства:
  (+) Для объектных модулей задаётся особая папка.
  (+) Быстрое выполнение на Рефале 5 (вместо тучи вызовов System, вызов только один).
  (+) Вызов компоновщика Си++ выполняется тоже только по необходимости.
  Недостатки:
  (-) Зависимость от внешней утилиты make. Недостаток несущественный, поскольку вместе с большинст-
вом компиляторов Си++ поставляется make. Структура make-файла намеренно простая (не используются
шаблонные правила и переменные, которые могут оказаться непереносимыми), поэтому, по идее, должна
работать с любой утилитой make (хотя пробовал только на GNU Make, надо попробовать и на make-ах
из состава BCC 5.5 и Visual Studio).
  (-) В связи с особенностями алгоритма, при каждой компоновке часть объектных файлов удаляется.
Компиляция с несколькими целями будет работать корректно, но неэффективно, поскольку объектные фай-
лы удаляются.

  После некоторой доработки оба модуля можно использовать и для этапа компоновки back-end'а Просто-
го Рефала. В данной ревизии (71) будут сохранены оба компоновщика, возможно, один из них постепенно
отомрёт (а может и останется рудиментом, как профиль в Рефал 5).

  Следует остановиться над вариантами решения проблемы 1 и 4, указанными в предыдущем звене.
  Выход 1: на первый взгляд считать выходными файлами объектники нецелесообразно, поскольку для
разных компиляторов нужны объектники разного формата, в то время, как можно обойтись одним исход-
ником. Однако этот недостаток можно нивелировать. При доработке библиотечных модулей или (а) необ-
ходимо каждый раз перекомпилировать целевые файлы (вручную или автоматически), или (б) переделать
движок модульной концепции, чтобы та обрабатывала .cpp-файлы как особого вида исходники, или
(в) переработать её же так, чтобы она для библиотечных модулей ожидала не полный набор выходных
файлов, а альтернативные. В таком случае уже на стадии компоновки для библиотечных файлов вызывать
компилятор.
  Вариант (а) трудоёмок, к тому же привязывает к тому или иному компилятору Си++. Как вариант, мож-
но задавать особый режим компилятора Модульного Рефала или особую утилиту, которая для всех библио-
течных модулей запускает компиляцию "сишников" в объектники.
  Вариант (б) интересен. Front-end Модульного Рефала в исходных текстах искать особые комментарии
или особые макросы препроцессора вида DECLARE_ENTRY(PacketP_ModuleP_Function), на основе которых
генерировать интерфейсный модуль. Компилятор back-end'а должен знать, какие из модулей построены
из исходных файлов Си++, и, соответственно, вместо генерации исходного кода и последующей компиля-
ции, вызывать только компиляцию. Поскольку, с точки зрения пользователя, для компилятора Модульного
Рефала задаются только профили, этот особый front-end будет подключаться только с соответствующим
back-end'ом. Вариант интересен также тем, что, с точки зрения движка, здесь не будет библиотечных
модулей - все модули, как правило, представлены набором исходников.
  Вариант (в) требует доработки движка, чтобы он в качестве одного из выходных файлов набора мог
выбирать или "сишник", или объектник. После такой доработки движок будет более гибок и будет поз-
волять шаманить даже более хитрые вещи.
  Выход 4: переработка компилятора Модульного Рефала таким образом, чтобы он более-менее бескос-
тыльно интегрировался с утилитой make (для конкретности можно нацелиться на GNU Make, поскольку
она умеет обновлять файлы зависимостей и я её знаю лучше всех других). Однако эта отдельная большая
задача, время которой ещё не пришло, поэтому здесь я её не буду описывать.

  В качестве прагматичного решения лучше продолжать разрабатывать варианты 2 и 3, поскольку они,
по сравнению с остальными, достаточно просты и уже частично сделаны. Вариант 1а выглядит слишком
костыльно, вариант 1б интересен и, возможно, когда-нибудь будет реализован, причём, возможно, не
только для C++/SR и SR. Варианты 1в и 4 я рассматриваю как далёкое будущее, время которым ещё не
пришло.

  Данное TODO будет закрыто, когда новые компоновщики будут работать с профилем Простого Рефала
(там относительно несложная доработка), будут конфигурируемы через пользовательский интерфейс
(командная строка + конфигурационные файлы) и их код будет более тщательно проработан (сейчас он
написан неаккуратно).


[29.11.2011 - 13:42:23,80]
(Версия 0.2.981)

  [TODO: Ускорение компиляции]
  Оказалось, что потери времени на компиляцию файлов Си++ связаны с работой антивируса (Kasperski
Internet Security 2011). В случае отключённого антивируса компиляция выполняется гораздо быстрее
и основными потерями времени оказываются генерация файлов на Си++ (функция BE-CppSR::MCompiler::
Generate) и дамп промежуточных файлов межмодульных связей (MXXIO::Save) в случае полной переком-
пиляции и компоновка таблиц межмодульных связей в случае только компоновки (замерялся только
back-end C++/SR).

  [TODO: Добавить в Простой Рефал возможность компиляции в заданный файл]
  У большинства компиляторов C++ есть возможность компилировать исходный файл в объектник с задан-
ным именем, что делается опциями -o или /Fo (MS VC++). Надо тем или иным способом добавить такую
возможность в Простой Рефал. Допустим вариант вывода не в файл, а на stdout.


[28.04.2012 - 21:28:55,48]
(Версия 0.2.981)

  [TODO: Ускорение компиляции]
  В дополнение к четырём вышеизложенным выходам из проблемы долгой компиляции, был найден ещё один.
Идея заключается в своеобразной совместной компиляции на уровне back-end'овского компилятора Си++.
Выходные файлы в этом случае представляют собой не самостоятельные раздельно компилируемые единицы
трансляции, а части единого файла. На стадии компоновки генерится файл исходного кода на Си следу-
ющего содержания:

#include "refalrts.h"

#include "../Libraries/all.all/~CppSR/MLambda.cpp-code"
#include "../Libraries/windows.cppsr-b/~CppSR/Core/FileIO.cpp-code"
#include "~CppSR/Compiler/MCompiler.cpp-code"
#include "~CppSR/MRefal.cpp-code"

  Этот вариант потребует минимальной модификации имеющегося back-end'а C++/SR, в частности, потре-
буется (1) удалить #include "refalrts.h" из сгенерированных файлов, (2) добавить стражи включения
вокруг определений меток, чтобы избежать ошибок переоределения.
  Модификацию можно выполнить как путём копирования и мелкой правки (не труЪ), так и параметризации
имеющего back-end'а. На логическом уровне можно как выделять новый back-end, так и ввести опцию,
меняющую поведение имеющегося.
  Преимуществом такого подхода было бы снижение накладных расходов по сравнению с исходным вариан-
том (компилируются только этот единый файл, а также всякие рантаймы и библиотеки). Недостаток:
по сравнению с двумя частичными, каждый раз компилируется очень большой объём кода.



[03.05.2012 -  8:09:57,74]
(Версия 0.2.981)

  [TODO: Профилировщик рантайма определяет время выполнения и образца, и результата]
  На данный момент профилировщик рантайма C++/SR измеряет общую продолжительность выполнения функ-
ций, написанных на Рефале. В начало каждой функции, сгенерированной транслятором, добавляется вызов
this_is_generated_function(), который фиксирует момент начала выполнения. За счёт этого мы можем
определить продолжительность выполнения функций на Рефале, отделяя их от вызовов API.
  Поскольку в сгенерированном коде построение результатного выражения всегда начинается с reset_al\
locator(), мы можем, не изменяя кодогенератора, фиксировать время выполнения образцов и результатов
отдельно.
  Раздельная фиксация времени выполнения левых и правых частей позволит расставить приоритеты в об-
ласти оптимизации, поскольку и в C++/SR, и в профиле Простого Рефала, обе стадии выполняются очень
прямолинейно и неоптимально (в противоположность Рефалу 5, где используется оптимизация сопоставле-
ния с образцом).

  [TOTHINK: Оптимизация совместного сопоставления с образцом]
  Оптимизация совместного сопоставления с образом состоит в том, что если левые части нескольких
предложений функции имеют много общего (на практике очень распространённый случай - т.н. формат
функции), то имеет смысл сначала сопоставить их общую часть, а затем анализировать только те части,
которыми они различаются. Таким образом можно избежать повторного выполнения одних и тех же опера-
ций: при ошибке сопоставления в общей части мы избегаем повторного анализа похожих образцов, кото-
рые заведомо будут ошибочными, при ошибке сопоставления в специфической части не потребуется пов-
торного анализа общей части.
  Идея эта не нова, поскольку такая оптимизация используется как минимум в Рефале 5 (сгенерирован-
ный код других диалектов я не изучал).
  Недавно (вчера вечером, если быть точным) у меня появилась идея, как можно генерировать подобный
оптимизированный код.
  Чтобы это TOTHINK стало TODO, нужно
  * написать спецификацию, описывающую алгоритм,
  * продумать: стоит ли вместе с этим начать писать новый рантайм для кодогенерации в императивные
языки (в частности, в Си или Си++), или модифицировать C++/SR.



[04.05.2012 -  0:00:28,55]
(Версия 0.2.981)

  [DONE: Профилировщик рантайма определяет время выполнения и образца, и результата]
  Сделано как описано. Результат: на образец и результат затрачивается поровну времени, с перевесом
со стороны результата - около 40 % времени уходит на сопоставление с образцом и, соответственно,
60 % на построение результата. Вывод: чтобы ускорить выполнение программ (и компилятора, в частнос-
ти), необходимо начинать оптимизацию с результатного выражения.

  [TOTHINK: Оптимизация построения результатного выражения]
  Как показало исследование (Simple Refal.006 OR), немалая доля времени в текущей версии кодогене-
ратора тратится на постоянные сплайсы отдельных элементов в поле зрения: отдельные элементы (атомы,
различные типы скобок) инициализируются внутри связного списка свободных узлов, а затем по одному
помещаются в поле зрения. Каждый сплайс требует модификации 6 слов (связей двусвязного списка),
поэтому есть идея на них сэкономить: формировать внутри списка свободных узлов результат вызова
функции без оригинальных t- и e-переменных, которые затем будут вставляться на нужные места. Следу-
ет ли переносить s-переменные, или же их лучше заново инициализировать - вопрос открытый, поскольку
не очевидно, где больше расходы - на перенос или копирование.
  На данный момент в рантайме не представлено эффективной операции копирования s-переменной: есть
общая функция copy_stvar(res, sample), которая с любыми переменными обходится одинаково - пытается
скопировать как цепочку, поскольку t-переменная в списковом представлении может быть протяжённой,
когда она представляет скобочный терм. Следует создать отдельную эффективную функцию для копирова-
ния s-переменной.


[07.05.2012 - 20:06:31,73]
(Версия 0.2.981)

  [TODO: Ускорение компиляции]
  Ускоритель, основанный на объединении всех выходных файлов в одну единицу трансляции, создан.
В процессе создания были решены следующие проблемы:
  * Некоторые самописные модули подключали <stdio.h>. Макрос EOF, предоставляемый этим заголовком,
конфликтовал с идентификатором EOF. Файл <stdio.h> подключался из refalapi.h, который использовался
для предоставления удобных макросов объявления функций и меток. Пришлось эти макросы выносить в от-
дельный файл refalmacros.h, а подключение refalapi.h из mr_common.h, mr_oslib.h и mr_profiler.h
убирать.
  * Глобальная функция Go, вызываемая из рантайма, конфликтовала с идентификатором Go. Пришлось из-
менять рантайм таким образом, чтобы тот для Модульного Рефала ссылался на Entry_Go.
  * Компоновщик BCC 5.5 падал с ошибкой, вероятно, из-за необычно большого объектного файла. Компи-
лятор был заменён на Microsoft Visual C++.
  Быстродействие, как ни странно, не сильно возросло. Для вышеупомянутого MSVC время компиляции без
ускорителей составляло порядка 25—30 секунд, с объединённой единицей трансляции — 19—20 секунд.
  Наверное, чтобы ускорить процесс компиляции back-end-компилятором, нужно как-то уменьшить размер
генерируемых файлов? Отступы, хоть и на первый взляд кажется, что их много, много места не занима-
ют. Возможно, стоит вернуться к интерпретации результатных выражений.

  Требования к закрытию этого TODO сохраняются.


[09.05.2012 - 12:53:45,23]
(Версия 0.2.981)

  [CHANGED: Рефакторинг кодогенераторов SR и C++/SR]
  Оба кодогенератора обладают общим свойством: целевые языки требуют предшествования описания (объ-
явления или определения) сущности (функции, идентификатора) до её использования. Промежуточное пред-
ставление такой информации не предоставляет, поэтому эта задача решается на стадии кодогенерации.
  Эта общая задача была вынесена в отдельный модуль MPredeclGenerator, функция которого Generate-G\
eneric параметризуется конкретными функциями генерации отдельных элементов (объявлений и определений
функций, определений меток, генерации entry-кода). В результате код кодогенераторов стал гораздо чи-
ще, поскольку отдельная задача (вычисление предобъявлений) вынесена вон, осталась сущность — генера-
ция кода, для целевого языка.

  [DONE: Ускорение компиляции]
  Компоновщики теперь параметризуются из командной строки/конфигурационных файлов. От объединения с
back-end'ом Простого Рефала я отказался, поскольку это потребует значительных изменений, а данный
back-end вспомогательный и не стоит того. Проблема состоит в том, что для компоновщика входными фай-
лами являются как файлы на Простом Рефале, так и библиотеки на Си++, т.е. нужно различать оба типа
входных файлов. Использовать C-Link::MPartialLinker и C-Link::MMake только для компиляции конечных
файлов на Си++ бессмысленно, поскольку компилятор Простого Рефала обновляет все файлы на Си++, а оба
этих ускорителя анализируют даты. Чтобы использовать совместную трансляцию, нужно или менять кодоге-
нерацию Простого Рефала, либо конкатенировать .sref-файлы, попутно удаляя повторные определения ме-
ток. И то, и другое достаточно трудоёмко при столь неприоритетной задаче.
  Одно замечание. Совместная трансляция крайне полезна при использовании режима полной перекомпиля-
ции, которая используется при отладке/модификации кодогенератора C++/SR (своего рода приёмочный
тест). Остальные ускорители в таких случаях наоборот существенно медленнее трансляции без ускорения.


[12.05.2012 - 13:22:21,26]
(Версия 0.2.981)

  [FIXED: Ошибка в библиотечном профилировщике]
  Библиотечный профилировщик нарушал поле зрения, если аргумент профилируемого вызова оказывался
пустым. Ошибка исправлена.


[13.05.2012 - 17:41:39,77]
(Версия 0.2.981)

  [TODO: Оптимизация построения результатного выражения]
  Черновик оптимизации сделан: теперь в процессе построения результатного выражения новые элементы
(атомы, скобки, скопированные переменные) последовательно распределяются в списке свободных узлов,
указанный кусок списка свободных узлов переносится в поле зрения после открывающей угловой скобки,
в него переносятся переменные из результатного выражения, после чего остатки вызова функции (то,
что располагалось между старыми угловыми скобками) в список свободных узлов (это было и раньше).
  В целях сравнения производительности модуль BE-CppSR.Algorithm содержит как старый код генерации
результатного выражения, так и новый — им соответствуют функции GenResult и GenResult1 соответствен-
но. В процессе оптимизации были внесены правки в рантайм, основная из которых — функция refalrts::
splice_from_freelist(pos), которая как раз и переносит инициализированный фрагмент из списка свобод-
ных узлов в указанное место в поле зрения.
  Оптимизация дала ощутимые результаты: время выполнения результатных выражений снизилось примерно
на четверть (23,36 %), время выполнения функций на Рефале снизилось на 13,47 %, объём сгенерирован-
ного кода на Си++ — на десятую часть (9,15 %), объём исполнимого файла на 15,2 %. Время, затрачива-
емое на компиляцию сгенерированного кода компилятором Си++ не измерялось, но можно предположить, что
оно также должно уменьшиться на сопоставимую величину (10—15 %). Измерения проведены на компьютере
с процессором Intel Core 2 Quad Q8300, 2,50 ГГц, в качестве испытываемого приложения использовался
сам компилятор Модульного Рефала, применявшийся для компиляции собственных исходных текстов. Было
проведено по 8 запусков компилятора, скомпилированного в обоих режимах. Не смотря на то, что в про-
цессе испытаний работали и другие приложения, разброс времён оказался небольшим по сравнению с раз-
ницей в производительности оптимизированного и неоптимизированного кода. Подробные результаты изме-
рений можно прочитать в файле Оптимизации/Оптимизация сплайсов.xlsx папки документации.
  Чтобы оптимизация превратилась из черновика в чистовик, нужно удалить старый код генерации (если
что, его можно будет восстановить из репозитория, текущая ревизия 82), а также провести оптимизации,
связанные с s-переменными (для копирования s-переменных вызывается функция refalrts::splice_stvar(),
которая применяет более общий алгоритм; затем следует проверить предположение, что рациональнее без-
условно копировать s-переменные в результатное выражение вместо их сплайсов).



[20.05.2012 -  0:58:15,75]
(Версия 0.2.981)

  [DONE: Оптимизация построения результатного выражения]
  Старый код генерации удалён, предположения, связанные с оптимизацией s-переменных, проверены. Как
и предполагалось, эти модификации действительно повысили производительность. Проблема в том, что
совсем незначительно. Первая (копирование s-переменных специализированной функцией) дала ускорение
около 1 % для результатных выражений и около 0,6 % для всего кода на Рефале. Со второй ещё более за-
бавная ситуация: безусловное копирование s-переменных действительно ускорило выполнение результатных
выражений (примерно на 1,75 %). Однако, продолжительность выполнения функции DoGenResult в результа-
те усложнения оной (перед проверками переменных на копирование вставлен перехват частного случая —
s-переменной) уменьшилась, что дало общее повышение продолжительности сопоставления с образцом на
1,5 % или 0,25 секунд (другой причины, приведшей к увеличению продолжительности сопоставления с об-
разцом, я не вижу). В результате общее ускорение выполнения оказалось ничтожным, гораздо меньшим
статистической погрешности (0,17 %).
  Возможно, стоит также рассмотреть оптимизации самого рантайма, такие как использование inline-фун-
кций C++, или же ручного встраивания кода инициализации узла вместо вызова функции, замены возврата
cNoMemory на генерацию исключения (в этом случае изчезают ветвления из построения результата).
  Но эти потенциальные оптимизации я отложу на потом, сейчас интереснее заняться оптимизацией образ-
цового выражения, поскольку потенциал ускорения там даже не исследован.


[20.05.2012 - 12:23:22,24]
(Версия 0.2.981)

  [TODO: Ускорение MXXIO::Save]
  В логе профилировщика второй функцией после вызова компилятора Си++ является вызов MXXIO::Save, на
который затрачивается около 13 % полного времени выполнения. Как я предполагаю, основные потери свя-
заны с сериализацией отдельных атомов: явной функции определения типа атома в Модульном Рефале до
сих пор нет, поэтому тип определяется путём конвертации неизвестного атома в число функцией Ord и
в character функцией Chr. В зависимости от того, какие функции изменили свой аргумент, определяется
тип атома. Если атом оказался character’ом, то средствами Рефала проверяется, можно ли его вывести
открытым текстом, или же надо преобразовать в escape-последовательность. Этот набор затратных опера-
ций можно выразить средствами языка Си++, что будет быстрее и выразительнее.
  TODO будет завершено, когда будет разработана такая внешняя функция и будет показано, что произ-
водительность выросла.



[20.05.2012 - 12:39:14,85]
(Версия 0.2.981)

  [FIXED: Ошибка в сериализации character’а '#']
  Символ '#' при сериализации в MXXIO::Save не экранировался. Ошибка не проявлялась из-за того, что
сериализация использовалась только для составления таблицы перекрёстных связей, где этот символ не
попадался.


[20.05.2012 - 17:16:35,12]
(Версия 0.2.981)

  [DONE: Ускорение MXXIO::Save]
  Написана функция MStrings::SerializeAtom, которая преобразует атом в символьное представление.
Формат следующий:
  <SerializeAtom s.Atom>
    == Char e.CharRep
    == Number e.StrNumber
    == IsntSerializable s.Atom
  e.CharRep ::= s.Atom | s.Digit1 s.Digit2 s.Digit3
  e.StrNumber — десятичная запись числа
  Внедрение этой функции в MXXIO::Save уменьшило время её выполнения вдвое: если раньше совокупное
время на дамп межмодульной информации требовалось около 8 секунд, то сейчас — менее 4-х. Задача вы-
полнена: MXXIO::Save теперь уже далеко не первая (вторая) в рейтинге профилировщика.



[20.05.2012 - 19:15:12,30]
(Версия 0.2.981)

  [TODO: Оптимизация совместного сопоставления с образцом]
  Спецификацию писать необязательно, поскольку идея крайне проста. Но сначала некоторые общие поло-
жения и некоторые очевидные мысли.
  1. В общую часть могут быть вынесены только жёсткие элементы, сопоставляемые до первой открытой
e-переменной.
  2. В общих частях могут быть связывания переменных со значениями. Поскольку в разных предложениях
на одних и тех же позициях могут быть переменные с разными именами, необходимо вводить сгенерирован-
ные имена, а в дальнейшем внутри самих предложений эти переменные переименовывать.
  3. Механизм "заморозки". В текущей версии кодогенератора много сил требуется на то, чтобы скоррек-
тировать указатели на подвыражения внутри открытых e-переменных: внутри цикла по e-переменной могут
появляться возможности для сопоставления внутри скобочных подвыражений, которые были ранее определе-
ны вне цикла по e-переменной. Если переменные границ скобочных выражений изменятся внутри цикла, но
сопоставление окажется неуспешным, к следующей итерации мы получим неверные указатели на эти грани-
ци. Данная проблема возникнет и при совместном сопоставлении: после сопоставления с общей частью со-
поставление с остатком первого предложения будет изменять указатели на границы, в то время как оста-
ток второго предложения (на который передастся управление в случае ошибки сопоставления в первом ос-
татке) на входе ожидает такие указатели на границы, которые были после сопоставления с общей частью.
  Альтернативой текущему подходу является введение понятия "заморозки". Перед генерацией кода, кото-
рому требуются локальные копии внешних переменных (кода внутри цикла по открытой переменной, остат-
ка предложения) внешние переменные-границы объявляются замороженными: для сопоставления с образцом
с одной из таких границ нужно сначала разморозить данную пару границ, т.е. выбрать новый номер гра-
ницы и присвоить переменным с этим номером значение соответствующих размороженных границ и в ходе
дальнейшего сопоставления использовать новый номер переменных-границ.

  А теперь основная идея, которая кажется очевидной, но когда она ко мне пришла, я почувствовал оза-
рение. В текущей версии генератора псевдокода команда создаётся сразу, как только она обнаруживает-
ся, а затем цикл повторяется. Для обнаружения общего кода алгоритм следует модифицировать следующим
образом:
  1. Рассматривается группа предложений, для которых генерируется алгоритм совместного сопоставле-
ния. Изначально этой группой являются все предложения данной функции.
  2. Если в группе только одно предложение, то генерация алгоритма осуществляется известным спосо-
бом. В противном случае следует выполнять нижеследующие шаги.
  3. Сначала обнаружить все возможные операции сопоставления, доступные в текущей конфигурации (кон-
фигурацию при этом не изменять) для каждого из предложений группы. Доступными являются сопоставления
с жёсткими элементами и определения закрытых e-переменных.
  4. Среди множеств доступных операций сопоставления выбрать ту, которая является общей для наиболь-
шего числа предложений.
  5. Если выбранная операция применима ко всем предложениям группы, то сформировать эту операцию как
команду сопоставления, общую для группы. Применить операцию к конфигурациям предложений группы. Про-
должить формировать команды сопоставления для группы, как описано в пункте 3.
  6. Если выбранная операция применима только к части предложений группы, то сформировать из этих
предложений новую группу, для которой генерировать код, заморозив все определённые ранее границы.
Выбранная операция будет применима ко всем предложениям новой группы, т.е. для этой группы будет
применим пункт 5. Из остальных предложений сформировать другую группу, которую следует обрабатывать
начиная с пунка 2. (Следует помнить, что как первая новая группа, так и вторая могут состоять един-
ственного предложения).

  Вторым пунктом TOTHINK было обдумывание вопроса: следует ли создавать новый рантайм для этой опти-
мизации. Ответ: не нужно, поскольку генерация оптимизированного кода достижима и в рамках текущего
рантайма, возможно, расширив его новыми командами.
  Например, для функции
  F {
    A t.X (e.Y) e.Z = X;
    B t.X (e.Y) e.Z = Y;
  }
при оперировании только имеющимися командами, не удастся выявить общий код, поскольку команды сопо-
ставления с именами A и B будут разными, после которых оба предложения попадут в разные группы. Ре-
шением данной проблемы будет генерация сопоставления с неявной s-переменной, значение которой срав-
нивается с именами A и B. Другой, более оптимальный, алгоритм — сопоставление с неизвестным иденти-
фикатором (сравнивается только тег типа), затем сравнивать только значение этого идентификатора,
вариант возможно потребует большего количества изменений рантайма.


[14.07.2012 - 11:51:13,55]
(Версия 0.2.981)
  [CHANGED: Журнал проекта без переносов]
  Буду вести журнал проекта таким образом, чтобы избегать переносов слов и висячих предлогов.
Раньше, ограничивая себя 100 символами, я пытался вписать туда максимум букв. Теперь буду
невлезающие слова переносить целиком, кроме тех случаев, когда строка оказывается короче 90
символов.

  [TODO: Оптимизация совместного сопоставления с образцом]
  Алгоритм в той форме, в которой он описан, не будет сохранять семантику исходной функции.
Например:
  F {
    X A e.X = R1;
    e.X Y = R2;
    X B e.X = R3;
    X e.X = R4;
  }
  В этом примере наиболее общей операцией будет отщепление элемента X слева, и, таким образом,
предложения 1, 3 и 4 попадут в одну группу, которая будет перехватывать все случаи, когда аргумент
начинается с X. Но семантика такой функции изменится: если аргумент начинается на X, после которого
не следует A, и заканчивается на Y будет перехвачен третьим или четвёртым предложением, в то время
как в неоптимизированной функции выполнилось бы второе предложение.
  Проблема в том, что группировка предложений по общей операции сопоставления меняет их относитель-
ный порядок, что, в случаях, когда один и тот же аргумент может соответствовать разным образцам,
способно привести к изменению семантики. Прямолинейная группировка возможна только для тех случаев,
когда образцы ортогональны.
  Допустимо, и вполне логично, рассматривать образцы как предикаты, возвращающие истину или ложь
для некоторого аргумента. Кроме того, их можно представить в виде конъюнкции более простых
предикатов, которые соответствуют т.н. линейным образцам — без открытых e-переменных и повторных
переменных (некий терм равен литералу, терм является скобочным, i-й терм слева или справа доступен,
т.е. возможно его отщепить, выражение содержит ровно n термов и т.д.), и сложных (два терма равны,
подвыражение справа/слева начинается с некоторого другого подвыражения, два подвыражения равны,
подвыражение где-то внутри содержит цепочку термов (сканирование по открытой e-переменной) и т.д.).
  Для ссылок на отдельные термы и подвыражения в скобках можно ввести понятие пути:
  — путь к выражению верхнего уровня есть пустая строка,
  — путь к подвыражению в скобках равен пути к скобочному терму,
  — путь к терму, находящемуся в i-й позиции подвыражения se слева или справа имеет вид, соответ-
ственно seLi и seRi.
  Например, для образца (t.1 (t.2) e t.3 (t.4 t.5)) e t.6 пути к термам t.1 t.2 t.3 t.4 t.5 t.6
имеют вид, соответственно, L1L1, L1L2L1 или L1L2R1, L1R2, L1R1L1 или L1R1R2, L1R1L2 или L1R1R1, R1.
  Предикаты, соответствующие элементарным операциям отсечения терма слева (сопоставления с t e)
и справа (сопоставления с e t), будем обозначать как ^…Li и ^…Ri, тогда сопоставление с пустым
выражением можно будет обозначить как !^…Li и как !^…Ri.
  Образцы фиксированной длины можно выразить несколькими разными логическими выражениями, что
означает возможность генерации алгоритма сопоставления с образцом разными способами. Для простоты
ниже такие случаи рассматривать не будем.
  Предикативное представление может быть полезным для различных теоретических изысканий. Например,
приведение набора образцов к ортогональной форме. Обозначим Pi — i-й образец. Условие ортогонально-
сти имеет вид Pi & Pj == false для i ≠ j. Можно показать, что если заменить предикаты Pi, соответ-
свующие i-м предложениям, на предикаты P'i = !P1 & !P2 & … & !Pi-1 & Pi, то семантика функции
не изменится, однако образцы (предикаты) станут ортогональными. Поскольку предикаты представляются
в конъюнктивной форме, то отрицание предиката будет представлять собой дизъюнкцию отрицаний
отдельных команд сопоставления. Перемножение этой суммы отрицаний на предикат Pi, возможно, приве-
дёт к его размножению, т.е. при переходе от предикативной записи обратно к образцовой (см. пример
ниже) мы получим набор предложений вместо одного исходного. Можно показать, что получившийся набор
образцов станет ортогональным. Действительно, пусть i > j. Тогда P'i & P'j = (!P1 & … & !Pj & …
… & Pi) & (!P1 & … & Pj) == false. Пусть P'i = (A | B), P'j = (C | D). Тогда (A | B) & (C | D) ==
== false → A & C | B & C | A & D | B & D == false → A & C == false, B & C == false, A & D == false,
B & D == false.
  Рассмотрим пример:
  G {
    X e.1 = R1;     → P1 = ^L1 & (L1 == X)
    e.1 Y = R2;     → P2 = ^R1 & (R1 == Y)
  }
  Образцы в ортогональной форме:
  P'1 = P1,
  P'2 = !P1 & P2 = !^L1 & ^R1 & (R1 == Y) | ^L1 & (L1 ≠ X) & ^R1 & (R1 == Y).
  После преобразования функция приобретает вид:
  G' {
    X e.1 = R1;
    Y = R2;
    ~X e.1 Y = R2;
  }
  Здесь ~X означает любой терм, не равный X. Очевидно, что преобразованная функция в отличие
от исходной, не чувствительна к перестановке предложений. Для аргумента X Y всегда будет выполнено
первое предложение.
  Также можно показать, что если одному из образцов предшествует более общий образец, то вычисление
ортогонального образца даст false, т.е. пустое множество набора ортогональных образцов. В таких
случаях разумнее всего давать предупреждение компилятора.
  Для вычисления набора ортогональных образцов можно не пользоваться напрямую предикативным
представлением, а осуществлять операции умножения на отрицание выражения, алгоритм будет в целом
похож на алгоритм вычисления объединения двух образцов — см. соответствующую «лабу».

  Недостаток подхода через ортогонализацию заключается в том, что количество образцов резко
увеличивается и каждый из них усложняется. Поэтому будем использовать другой подход, который
назовём частичной группировкой. Рассмотрим пример:
  H {
    X A e.X = R1;
    X B e.X = R2;
    e.X C = R3;
    X D e.X = R4;
    X F e.X = R5;
  }
  Исходный алгоритм здесь предложил бы сгруппировать все предложения, кроме третьего по признаку,
что все они начинаются на X. Однако, как уже было сказано, образцы неортогональны и это приведёт
к изменению семантики (два предложения снизу неявно ожидают, что последний терм не равен C).
  Поэтому группировать следует по общему признаку до тех пор, пока не встретим обобщение в данной
позиции. В данном случае обобщением будет e…, поскольку X… уже, чем e…. Группировать мы можем
только среди сопоставлений, имеющих одинаковую «ширину», т.е. среди тех сопоставлений, что никакое
из них не имеет более широкую область сопоставления, чем остальные.
  Введём дополнительные определения
  Ортогональным набором будем называть набор последовательных образцов, имеющих в некоторой позиции
только сопоставления одинаковой «ширины».
  Ортогональный набор определяется для некоторой позиции, в которой происходит сопоставление.
При выборе другой позиции мы можем получить другой ортогональный набор.
  Можно выделить следующие разновидности ортогональных наборов.
  1. Литеральные значения атомов + скобочные термы + сопоставления с пустыми выражениями. Такой
ортогональный набор завершается любой переменной, не важно, повторной или новой (последнее включает
также открытые и закрытые e-пермененные). Можно менять порядок любых образцов, различающихся
в данной позиции. Можно группировать термы, имеющие одинаковую операцию сопоставления в данной
позиции (разумеется, с сохранением относительного порядка внутри группы).
  2. Повторные s-переменные + скобочные термы + сопоставления с пустыми выражениями. Такой набор
завершается новой s-переменной, любой t- или e- переменной. Поскольку значения повторных
s-переменных нам не известны, мы не можем менять относительный порядок этих образцов. Таким
образом, группировка по операции сопоставления не должна учитывать то, что повторные переменные
могут быть равны разным переменным.
  3. Новые s-переменные + скобочные термы + сопоставления с пустыми выражениями. Такой набор
завершается любой t- или e- переменной. Группируются по виду операции сопоставления обычным образом.
  4. Любые атомарные значения (литералы, любые s-переменные) + скобочные термы + сопоставления
с пустыми выражениями. Завершается любой t- или e-переменной. Нельзя менять относительный порядок
образцов, различающихся любым атомарным значением.
  5. Известные термовые значения (атомарные литералы, повторные s- и t-переменные, скобочные
термы) + сопоставления с пустыми выражениями. Завершаются новой s- или t-переменной, любой
e-переменной. Относительный порядок сопоставления с термовыми значениями менять нельзя.
  6. Ограниченные термовые значения (атомарные литералы, любые s-переменные, повторные
t-переменные, скобочные термы) + сопоставления с пустыми выражениями. Завершаются новой
t-переменной, любой e-переменной. Относительный порядок сопоставления с ограниченными термовыми
значениями нельзя.
  7. Любые термовые значения (атомарные литералы, любые s- и t- переменные) + сопоставления
с пустыми выражениями. Завершаются любой e-переменной. Относительный порядок термовых значений
менять нельзя.
  (8.) Любые сложные образцы кроме закрытых e-переменных. Завершается закрытой e-переменной.
Добавлен здесь, разумеется, для полноты картины, практического смысла не имеет.
  Примечание. «Завершающие» команды сопоставления не входят в ортогональный набор, а следуют
непосредственно за ним. Элементы, разделённые знаком «+», могут быть объединены в группы
с общей операцией сопоставления.
  Примечание 2. В списке отстутствуют АТД-термы, но схему можно обобщить и на них.
  Некоторые виды ортогональных наборов могут включать в  себя несколько более мелких ортогональных
наборов. Например, несколько образцов, образующих первую разновидность, могут входить в более
длинный набор шестой разновидности.

  Очевидно, система оказалась слишком сложной, и связано это с тем, что элементарные команды
сами по себе сложны. Введём альтернативный набор команд — от поддиапазона будем отщеплять только
термы (условно, t-переменные), которые затем уже анализируются отдельно (терм есть атом, равный
данному литералу, просто атом (s-переменная), повторная переменная, скобочный (АТД) терм).
С одной стороны ортогональность команд существенно повышается (нет отдельных команд для
сопоставления с термом определённого вида слева/справа), с другой возможна потеря производи-
тельности — терм анализируется дважды — во время отсечения терма (для скобочного терма нужно
перепрыгнуть по скобке, для остальных просто сдвинуться), а затем проанализировать отсечённый
терм отдельно. Однако, есть надежда, что эффект от совместного сопоставления превысит вышеупомя-
нутые потери.
  Тогда можно будет ввести следующую классификацию ортогональных наборов.
  1. Ортогональные наборы для краёв подвыражений.
  1.1 Жёсткие элементы (термы и повторные e-переменные) и сопоставления с пустым выражением.
Ограничение — открытые и повторные e-переменные. Никакие команды тут переупорядочивать нельзя.
Данный вид введён лишь для полноты картины, практического интереса не представляет.
  1.2 Термы + сопоставления с пустым выражением. Ограничиваются любой e-переменной. Естественным
образом образцы разбиваются на две ортогональные группы: отсечение терма от непустого выражения
и выражение пустое. Если среди представленных образцов есть представители обоих групп, то код
можно генерировать в виде конструкции if-else.
  2. Ортогональные наборы для термов.
  2.1 Терм является известным (повторная переменная, литерал, скобочный или АТД-терм). Ограничение
— t-переменная. Как и для краёв подвыражений, это случай рассмотрен для полноты картины, применения
ему я пока не вижу.
  2.2 Литеральные атомарные значения + скобочные (АТД) термы. Ограничение — любая переменная.
Группировка, очевидно, по литеральным значениям, по виду и меткам скобок.
  2.3 Новые s-переменные + скобочные (АТД) термы. Ограничение — повторная s-переменная, любая
t-переменная. Группируются по атомарности, виду и меткам скобок.
  2.4 Атомарные термы (любые s-переменные и литеральные значения) + скобочные (АТД) термы.
Ограничение — любая t-переменная. Группируются по атомарности, виду и меткам скобок.
  3. Ортогональные наборы для атомарных термов.
  3.1 Терм является известным (повторная s-переменная, литерал). Ограничение — новая s-переменная.
  3.2 Терм является литеральным значением. Ограничение — любая s-переменная. Возможна группировка
по значениям: числа, идентификаторы, characters, указатели на функции и т.д.
  Для некоторых позиций группы образцов возможно найти различные разновидности ортогональных
наборов. Например, последовательность 2.2 может входить в последовательность 2.4. Задача алгоритма
оптимизации найти наибольший ортогональный набор. Тогда если одна и та же последовательность
является наибольшим ортогональным набором, подходящим под определения 2.2 и 2.4, то её следует
рассматривать как более узкий вариант 2.2, чем как 2.4, поскольку последний подразумевает лишний
уровень косвенности — дополнительную проверку на атомарность, чтобы отсечь все атомы к группе 3.
Если же последовательность, подходящая под 2.2 короче, чем под 2.4, то следует наоборот применять
последний.


[16.09.2012 - 11:13:49,96]
(Версия 0.2.981)

  [TODO:ВПВ: Написание документации (НД)]
  Сначала я предполагал размещать документацию на сайте blogspot, даже уже частично написал, однако,
к некоторому моменту я потерял интерес к этому процессу. В качестве представления этот способ
оказался не слишком удобен: данные хранятся на удалённом сервере, поэтому для редактирования надо
быть в онлайне, к тому же, необходимо логиниться на сайте.
  Недавно мне пришла в голову неплохая идея: можно писать документацию в формате docx/odt — с одной
стороны, это автоматически даёт возможность получить красиво отформатированный pdf, с другой —
формат представляет собой набор зазипованных xml’ек, который, при необходимости, относительно легко
распарсить, просто выбирая только теги с понятным содержимым, а остальные игнорируя.
  Преимущество формата docx — возможности форматирования Microsoft Word, которым я умею эффективно
пользоваться.
  Преимущество формата odt — кроссплатформенность и простота для парсинга (XML более ясный, чем
у Microsoft Word).


[06.11.2014 - 12:35:00,01]
(Версия 0.2.981)
  Проект долгое время был заморожен, и, возможно, таковым и останется.

  [TODO: Выпуск публичной версии (ВПВ)]
  Выпуск публичной версии откладывается, за долгое время простоя (два года) к этому аспекту
я потерял интерес. Закрывать это TODO я пока не буду, поскольку, возможно, когда-нибудь к нему
вернусь.

  [TODO: Вложенные функции (ВФ)]
  Предлагаемый выше вариант вполне работоспособен, однако есть один нюанс. Замыкания могут
содержать внутри себя другие замыкания (например операции MLambda::BindLeft или MLambda::Composite).
Следовательно, явная операция удаления должна удалять замыкания рекурсивно. Но, при этом только
программист знает, когда замыкания удалять нужно, а когда не нужно. В частности, возможен случай,
когда замыкание, после вызова подлежащее удалению, замыкает контекст, содержащий другое замыкание,
пока не подлежащее удалению. Т.е. нужно что-то вроде «деструктора» замыкания.
  Если делать деструктор в соответствии с идиомой ООП, то одно из предложений функции будет
представлять собой метод, левая часть которого должна принимать аргумент, который не могут принимать
другие предложения функции. Недостатки такого подхода:
  1 Невозможно написать замыкание, которое одинаково обрабатывает любой аргумент (частный случай —
деструктор должен будет обрабатываться по особому).
  2 Любое замыкание обязано содержать специальный образец, иначе при удалении замыкания будет
происходить ошибка сопоставления.
  3 В других back-end’ах это предложение не будет иметь смысла, но может (незначительно) снижать
быстродействие.
  Этих трёх проблем можно избежать, если предложение-деструктор сделать синтаксически отличным
от регулярных предложений, например, состоять из одного символа $DELETE. В результатных частях
тот же символ $DELETE может использоваться только как Callable, т.е. после левой скобки
конкретизации. Преимущества:
  1 Выполнить это предложение вызовом <s.Closure $DELETE> невозможно, поскольку синтаксически
некорректно. Единственный способ вызвать это предложение — уничтожить замыкание (вычислив
<$DELETE s.Closure>). Следовательно, данный образец никак не конфликтует с другими образцами.
Следствие: предложение-деструктор может идти любым по счёту: первым, последним…
  2 При отсутствии предложения оно неявно подразумевается с пустой правой частью, т.е. при удалении
замыкания ничего не должно выполняться.
  3 Специальный синтаксис допускает и особый способ компиляции. В других back-end’ах эти предложения
при трансляции будут игнорироваться, равно как будут игнорироваться вызовы <$DELETE …> в правых
частях. Следствие: переносимая программа в предложениях-деструкторах не должна ничего делать, кроме
уничтожения замыканий, захваченных контекстом. Также переносимая программа не должна вкладывать
в вызовы <$DELETE …> вызовы функций с побочным эффектом. Либо, вызовы <$DELETE …> должны
компилироваться в вызовы <NIL …> при наличии скобок конкретизации внутри вызова <$DELETE …>. Такое
поведение снизит быстродействие в корректной программе, но сделает переносимым поведение
в некорректной. Способ трансляции разумно сделать управляемым параметром конфигурации.
  4 Синтаксис Модульного Рефала допускает использование функций с пустым телом, а Рефал-5 — нет.
Приходится для пустых функций добавлять предложение NF = NF (в промежуточном представлении
не существует идентификаторов NF, поэтому такой метод корректен). Использование деструктора
устраняет этот костыль: любая сгенерированная функция будет содержать предложение-деструктор.

  Дополнительные замечания.
  Функция $DELETE соответствует идеологии Модульного Рефала — использование встроенных средств
только для встроенных в язык возможностей.
  Функция $DELETE может принимать не только s-переменную, но и вообще любое объектное выражение,
что имеет смысл, когда замыканий в контексте несколько. Разумеется, передавать литералы атомов
бессмысленно (их даже можно удалять во время компиляции или выдавать предупреждение), но для
унификации синтаксиса допустимо.
  Разрешать ли передачу в $DELETE скобок, как безымянных, так и абстрактных, я пока не определился.
  Конструкции &$DELETE и $DELETE не после левой скобки вызова в результатной части следует считать
ошибочными, равно как и использование $DELETE внутри образца, за исключением образца, состоящего
из единственного символа $DELETE.
  Допустимы два варианта написания $DELETE и $delete.

  [TODO: Оптимизация совместного сопоставления с образцом]
  На данный момент этим исследованием занимается студент ИУ-9 Батусов Павел в рамках своего
курсового проекта. По завершении проекта будет готова расчётно-пояснительная записка с обоснованием
корректности алгоритма, а также оптимизирующий компилятор Простого Рефала. Записка будет включена
в настоящий репозиторий, а алгоритм оптимизации внедрён в Модульный Рефал (что сделать несложно
ввиду сходства языков).

  [TOTHINK: Серьёзное расширение синтаксиса]
  Обоснование.
  1 Отсутствие вложенных функций приводит как к необходимости явного написания глобальных функций,
затем явно связываемых с контекстом, так и к сложночитаемым комбинациям функций при помощи средств
модуля MLambda ← таково краткое обоснование внедрения в язык хотя бы вложенных безымянных функций.
При этом внедрение в язык только вложенных безымянных функций может привести к похожему результату,
а именно к сложночитаемым комбинациям вложенных безымянных функций (при помощи комбинатора Y,
функций Composite и Fetch). Использование именованных функций полностью обесценивает комбинатор Y,
а соответствующие синтаксические средства снижают потребность в функциях Composite, Fetch и ряде
других. Таким образом, вложенные безымянные функции есть полумера.
  2 Во многих развитых диалектах Рефала есть механизм, позволяющий задавать дополнительные
ограничения на образец в левой части — условия в Рефале-5, неуспехи в других диалектах. Механизм,
очевидно, полезный, однако имитировать его при помощи одних лишь вложенных функций (не важно,
именованных или нет) достаточно трудно (без открытых e-переменных) или даже практически невозможно
(с открытыми e-переменными). Под трудностью и практической невозможностью подразумевается тот факт,
что код в результате получится чрезвычайно сложным и нечитаемым («овчина выделки не стоит»).

  Предлагается реализовать синтаксис, являющийся средним между Рефалом-5 и Рефалом-7: из Рефала-7
берём вложенные функции и действия ":", ",", "->", "::", "=", "=>", из Рефала-5 невозможность
возврата неуспеха из функции. Таким образом, неуспехи могут порождаться только действием ":"
(действие "::" при невозможности сопоставления аварийно останавливает программу), "," и "->"
прозрачны для неуспехов, "=" и "=>" непрозрачны для неуспехов (неперехваченный неуспех после
них приводит к аварийному останову программы), образец после ":" может перехватывать неуспех
(путём удлинения открытых e-переменных), образец после "::" не может перехватывать неуспех
(сопоставление однозначно).
  Вопрос об образцах после "::" (допустимы любые образцы, либо только жёсткие) требует
дополнительной проработки.
  Некоторые переменные могут помечаться как переопределяемые символом "^". Требуют проработки
следующие вопросы: символ "^" должен идти перед переменной или после, если переменная с крышкой
повторная в данном образце, все ли экземпляры должны быть помечены или не все, какие из них.

  В дальнейшем требуется:
  1 Подробнее сформулировать синтаксис и семантику
  2 Проработать указанные выше вопросы
  3 Продумать особенности реализации.
  4 Проанализировать плюсы и минусы возврата неуспехов из функций.


[27.12.2014 - 15:43:41,16]
(Версия 0.2.981)

  [TODO: Ускорение работы компилятора на слабых машинах]
  На слабых машинах (например, Pentium MMX, 64 Mb RAM) становится очевидным низкое быстродействие
быстродействие компилятора, связанное как с низким быстродействием сгенерированного кода, так и
с неоптимальными алгоритмами в самом компиляторе. К примеру, цикл раскрутки компилятора требует
нескольких десятков минут.
  На момент написания TODO часть работы по оптимизации была выполнена, а именно, были сделаны
следующие выводы и оптимизации.
  * Много времени уходит на создание статистической информации XLinx — около пяти с половиной
минут. Основная причина — отжор виртуальной памяти большей, чем физически установлено на машине.
Компилятор с профилем C++/SR потребляет более 80 Мбайт оперативной памяти, в то время как без свопа
в память влезает не более ≈35 Мбайт (остальное требуется операционной системе и фоновым программам).
Виртуальная память отжиралась по причине трёхкратного копирования перекрёстной информации при
порождении 4 файлов статистики. Двум файлам статистики требовался только список модулей — он стал
формироваться без потребления дополнительной памяти во время прохода по перекрёстной информации;
функция порождения таблицы перекрёстных связей стала прозрачной — в результате копирование
переменной стало ненужным.
  * Другой причиной низкого быстродействия был ассоциативный поиск среди всех записей при
построении инверсных сведений. Было применено хеширование — для каждого имени вычислялся хеш
(число от 0 до 37) и затем применялся двухуровневый ассоциативный поиск (среди имён с данным хешем
и внутри соответствующей корзины). Таким образом сложность была снижена с N² до N*sqrt(N), т.е.
на целый корень. Также хеширование ускорило поиск неслинкованных элементов.
  * Много времени отнимало построение деревьев модулей. Путей модификации логики самого алгоритма
я не обнаружил, а вот изменение структур данных ускорило этот этап примерно вдвое (с ≈40 до ≈20
секунд). Речь идёт о замене имён модулей (e-переменных) на числовые идентификаторы (s-переменнные).
Экономия времени связана со скоростью сравнения на равенство одноимённых переменных.
  * Суммарно эти две оптимизации снизили продолжительность построения статистической информации
до 2 минут.
  * Неплохо ускоряет работу back-end’а C++/SR использование компоновщика на make-файле. При
повторной перекомпиляции даже не запускается компоновщик Си++, т.к. make видит, что исполнимый файл
не обновлён по сравнению с объектными.
  * Перекомпиляция для back-end’а Простого Рефала занимает продолжительное время (порядка 4-5
минут), режимы, ускоряющие его работу, я пока не смотрел, т.к. часто им и не пользовался.
  * Back-end Рефала-5 ещё не оптимизирован, работает сильно медленно (несколько минут), возможно,
его также спасёт хеширование.
  * Профилировщик очень полезен в деле оптимизации.
  * Также полезно наблюдение за работой программы в диспетчере задач Windows XP, т.к. он показывает
не загрузку физической памяти (как в более поздних ОС), а загрузку виртуальной. Визуально по
графикам можно определять причины проблем:
    — если сильно выросло потребление памяти, а загрузка процессора не полная — проблема в свопе;
    — если загрузка процессора полная — проблема в вычислениях.
Сейчас на всём протяжении перекомпиляции имеем практически 100%-ную загрузку процессора.
  * Сейчас уже проблема находится не в свопе, а в затратах на вычисление.
  * Функция MOrder::Sort медленная и путей её ускорения я не вижу.

  Что предстоит сделать:
  * Сделать профилировщики более интеллектуальными. См. отдельное TODO.
  * Рассмотреть вопрос оптимизации кэша. На текущий момент звенья поля зрения в back-end’ах C++/SR
и Простого Рефала имеют размер 5 слов (20 и 40 байт на x86 и amd64 соответственно), что
не оптимально с точки зрения кэша процессора. Каждое звено включает в себя ссылки вперёд и назад
(по 1 слову), поле тега (из-за выравнивания — 1 слово, хотя хватило бы и байта), поле информации
(2 слова).
  Едиственная альтернатива в поле информации, занимающая два слова — ссылка на функцию, включающая
в себя указатель на функцию и указатель на её имя. Если в поле информации хранить не пару
указателей, а указатель на структуру, хранящую эту пару указателей, то звено уже будет кратно строке
кэша. Возможно снижение производительности, связанное с дополнительной косвенной адресацией, но оно
будет пренебрежимо мало по сравнению с затратами времени на всё остальное. Другим преимуществом
будет отход от генерации идентификаторов для представления имён функций в C++/SR.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  * Оптимизировать компоновщик back-end’а Рефала 5, возможно, путём хеширования.
  * Когда исследование совместного сопоставления с образцами будет завершено, внедрить этот механизм
оптимизации.
  
  [TODO: Добавить аналитики в профилировщики]
  Сделать профилировщики более интеллектуальными. Профилировщик, встроенный в рантайм, способен
отдельно оценивать затраты времени на код Рефала и на код внешних функций, отдельно мерять время
сопоставлений с образцом и построения результата. На последние две характеристики влияют два
фактора: низкое качество самого сгенерированного кода и выбор неоптимального алгоритма,
и в некоторой степени эти факторы можно измерять отдельно.
  Практика показала, что на время выполнения программы могут существенным образом влиять циклы
по открытым e-переменным, сопоставления с повторными e- и t-переменными и копирования переменных
в образце. Эти три параметра при незначительных модификациях рантайма и кодогенератора вполне можно
измерять.
  Библиотечный профилировщик измеряет только общее время выполнения, поэтому в результирующем отчёте
внешние функции (например запуск компилятора Си++ функцией MOS::System) и функции на Рефале
располагаются рядом. Его следует модифицировать таким образом, чтобы он также создавал отдельные
отчёты по разным видам затрат времени — таким образом можно не только определять функции,
подлежащие оптимизации, но и быстрее определять пути их оптимизации.


[20.10.2015 - 17:46:32,47]
(Версия 0.2.981)

  [CHANGED: Поддержка компиляторов Open Watcom и Clang]
  Теперь Модульный Рефал можно откомпилировать при помощи Open Watcom и Clang. Для того, чтобы
компиляция ими проходила без ошибок и предупреждений, потребовалось внести некоторые правки
в исходный код.
  Компилятор Open Watcom более требователен к пространствам имён. Другие компиляторы позволяют
вызывать функцию, определённую в пространстве имён, без квалификатора, если её аргументы имеют
типы, определённые в этом пространстве имён (например, refalrts::empty_seq(refalrts::Iter,
refalrts::Iter) можно вызвать empty_seq(begin, end)). Open Watcom такого не позволяет.
  Кроме того, обнаружен баг в реализации std::vector стандартной библиотеки Open Watcom. Чтобы
код, скомпилированный Модульным Рефалом, работал, пришлось в refalapi.cpp добавить обход этого
бага. Забавным оказалось то, что в компиляторе BCC 5.5 также присутствует баг, и обходы этих багов
текстуально находятся по-соседству в упомянутом refalapi.cpp.
  С компилятором Clang проблем не было за исключением того, что я не сразу разобрался, как запускать
сам компилятор. Оказалось, что необходимо сначала установить MinGW, добавить в PATH путь к каталогам
bin MinGW и Clang (LLVM), после чего можно использовать clang (clang++) точно также, как gcc (g++).
  Единственное, что обнаружил компилятор Clang — это неиспользуемая переменная g_end_list
в рантайме, о которой компилятор выдал предупреждение. Возможно, компилятор мог бы найти и больше,
но я пока не знаю всех его возможностей в плане диагностики.


[21.10.2015 - 11:41:49,72]
(Версия 0.2.981)

  [DONE: Добавить аналитики в профилировщики]
  Что было сделано:
  * Добавлено несколько новых метрик, измеряемых рантаймом, например, время сопоставления
с повторными t- и e-переменными (причём отдельно внути и вне циклов по удлинению открытых
e-переменных), время выполнения циклов по открытым e-переменным, время копирования переменных,
чистое время сопоставления с образцом и чистое время построения результата, а также некоторые
производные счётчики. Часть этих счётчиков выводится на stderr при завершении программы, как
и ранее, часть используется внутри библиотечного профилировщика.
  * Идеология библиотечного профилировщика осталась той же. Перед запуском профилируемой функции
создаётся объект профилировщика, делающий отсчёт измеряемых параметров, после её завершения
объект профилировщика разрушается, делается второй отсчёт измеряемых параметров, разность отсчётов
представляет собой потреблённые ресурсы в ходе выполнения функции, они запоминаются для дальнейшего
вывода в отсчёте. Вложенность функций при этом учитывается: из объемлющей функции вычитаются
ресурсы, потреблённые функцией дочерней.
  * Старый профилировщик измерял только общее время выполнения функции, причём само время получал
WinAPI-функцией GetSystemTimeAsFileTime, что непортабельно. Новый профилировщик замеряет целый
вектор параметров, включающий в себя различные метрики времени, а также число шагов и текущий объём
кучи. Параметры запрашиваются у рантайма соответствующей функцией. Вообще, профилировщик может
замерять любые параметры, единственное требование к ним — монотонное неубывание.
  * В результирующем отчёте отдельно выводятся как затраты ресурсов для каждой измеряемой функции,
так и сводные таблицы по каждому из ресурсов (в которых указывается, какой вклад в потребление
данного ресурса сделала каждая конкретная функция). Это, собственно, та аналитика, которую
требовалось сделать.
  * Расширился интерфейс библиотечного профилировщика. Появились функции:
  ** <SetOutputName e.Name> — устанавливает имя промежуточного отчёта программы. Запись в него
осуществляется каждый 500-й замер, либо при вызове <Flush>. Ранее это имя было захардкожено как
Profiler.log.
  ** <Flush> — формирует промежуточный отчёт о производительности программы.
  ** <Quantify-Flush s.FnProg e.Arg> — замеряет время выполнения функции, после чего формирует
промежуточный отчёт. Удобно для медленных функций, внутри которых <Quantify> не вызывается.

  [TODO: Ускорение работы компилятора на слабых машинах]
  Из того, что сделано.
  * Профилировщики сделаны интеллектуальными. Соответствующая задача закрыта.

  Из того, что предстоит сделать.
  * Рассмотреть вопрос по оптимизации кэша. Остаётся как есть, см. выше.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  Последние несколько месяцев проект Простого Рефала начал активно развиваться. Применительно
к текущей задаче — быстродействие компилятора заметно повысилось (приблизительно на 5…10 %). Имеет
смысл актуализировать версию Простого Рефала, входящую в проект Модульного Рефала как минимум
из соображений быстродействия.
  См. отдельное TODO.
  * Оптимизировать компоновщик back-end’а Рефала-5. Поиск путей оптимизации пока ведётся. Видятся
два варианта. Эволюционный: ищем в коде узкие места, оптимизируем их. Революционный: отказаться
от переименований функций и переменных на уровне компоновщика, вместо этого просто склеивать файлы.
Правильные имена функций и переменных давать сразу на этапе генерации «объектников».
  См. отдельное TODO.
  * Про совместное сопоставление с образцом. Ничего нового.

  [TODO: Актуализировать компилятор Простого Рефала и back-end C++/SR]
  Проект Простого Рефала последние несколько месяцев развивается независимо от Модульного Рефала
и, при этом, очень активно. В частности, повысилось быстродействие самого компилятора
и сгенерированного кода, исправлен ряд ошибок в генераторе кода и в рантайме.
  Поэтому имеет смысл сделать две вещи:
  * Актуализировать версию Простого Рефала, включённую в проект Модульного Рефала. Можно сделать
несколькими способами:
  ** Просто обновить файлы. Преимущество: быстро. Недостаток: при дальнейшем развитии Простого
Рефала процедуру обновления нужно будет делать заново каждый раз.
  ** Привязать репозиторий Простого Рефала к Модульному. Преимущество: упрощается синхронизация
с Простым Рефалом в дальнейшем. Недостаток: сложно, вследствие странной текущей ситуации
с репозиториями Модульного Рефала (используется и Git, и SVN).
  ** Выкинуть Простой Рефал из репозитория Модульного Рефала. Преимущество: нет дублирующихся
проектов, которые надо синхронизировать. Недостаток: Модульный Рефал будет требовать установленный
Простой Рефал на машине, причём той версии, с которой он сейчас совместим.
  Поэтому путь актуализации надо весьма чётко обдумать.
  * Переделать back-end C++/SR, внеся в него те же (или похожие) изменения, что произошли в Простом
Рефале: исправить ошибки, добавить быстродействия.

  [TODO: Оптимизация back-end’а РЕФАЛа-5]
  На данный момент этот back-end работает довольно медленно, особенно на слабых машинах.
Фундаментальная причина лежит в том, что компилятор РЕФАЛа-5 не может транслировать исходные тексты,
содержащие строки длиной более 200 символов. Ради этого код стал обфусцироваться: все
пользовательские имена (функции и индексы) стали переименовываться в более короткие, а также код
переформатировался в последовательность строк небольшой длины (образцовые и результатные выражения
склеиваются вместе и интеллектуально бьются на короткие строки). Пример одной из функций:

* Local::MRefal::CompileList
L1{t.i7 t.i8 W0(T W1 e.i9)=<L3 t.i7><EV t.i8><EW e.i9
>;t.i7 t.i8 W0 t.iA e.iB=<L4 t.iA t.i7 t.i8 e.iB>;t.i7 t.i8
W2=<L3 t.i7><EX t.i8>;}

  На уровне генератора кода довольно быстро и примитивно генерятся «рыхлые» файлы (почти дамп
промежуточного представления). А вот компоновщик затем эти файлы пережёвывает и сжимает в описанное
компактное представление.

  Пути оптимизации:
  * Профилирование и поиск узких мест, их оптимизация. Ничего больше не меняем.
  * Переименование переменных на уровне генератора кода (сквозные имена всех переменных в программе,
в отличие от функций, не нужны, можно их переименовывать независимо от функций).
  * Отказ от переименований вообще, генерация на уровне генератора файлов с правильными именами
и правильной длиной сток, на уровне компоновщика — простое склеивание. Преимущество: упрощение
и ускорение. Недостатки: переписывание всех библиотечных функций, сложность с созданием псевдонимов
для встроенных функций РЕФАЛа-5.
  Пока занимаемся первым пунктом, переходим к следующему, только если предыдущий не дал результата.


[06.11.2015 - 10:21:12,56]
(Версия 0.2.981)

  [DONE: Оптимизация back-end’а РЕФАЛа-5]
  Первого пути оптимизации хватило за глаза.
  Если кратко: продолжительность компоновки удалось снизить с 2 минут 23 секунд до 46 секунд
(включая вызов компилятора refc.exe требует порядка 10 секунд), т. е. ускорение составило примерно
3,1 раз.
  (Примечание. Замер производительности выполнялся на компьютере Pentium MMX 223 МГц, 64 Мбайт ОЗУ,
back-end C++/SR, компилятор Borland C++ 5.5 без опций оптимизации. Программа целиком влезала
в память, подкачки не производилось. Оценки времени по двум запускам — до оптимизации 2:22,9
и 2:22,6, после оптимизации — 46,1 и 46,6. Таким образом, затраты времени от запуска к запуску
меняются не сильно, можно не усреднять по серии измерений.)

  Подробнее. Как этого удалось достигнуть. Во-первых, активно применялось хеширование, уже
зарекомендовавшее себя при создании back-end’а XLinx. Внутри компоновщика неоднократно
использовались отображения, реализованные с помощью обычных ассоциативных списков: таблица
псевдонимов, отображающая идентификаторы в «объектных файлах» в короткие обфусцированные в целевом
файле (BE-Refal5::MLinkerAliasTable), список имён уже скомпонованных функций в BE-Refal5::MLinker::
UnitStorage (второй компонент) и список ещё не скомпонованных самих функций там же (третий
компонент). Поскольку среднее число элементов в каждой таблице составляет 2000—3000 (оценка делалась
по списку псевдонимов, в котором присутствуют только функции, число индексов переменных тоже
составляет порядка 1000), поиск в ней составляет ощутимую долю времени (счётчик * Open e-loop time
(total) отнимает 65 % времени от всего (total) времени выполнения функции BE-Refal5::MLinker::Link:
92…95 секунд).
  Использование хеш-функции, которая возвращает хеш в диапазоне от 0 до 42 снижает затраты времени
на поиск буквально на порядок (та же метрика — 16…18 %, 7,4…8,2 секунды). Причём, что любопытно,
затраты метрика + Open e-loop time (clear) отнимает больше времени, чем Repeated e-var time
(in e-loop), поскольку сравнение на равенство s-переменных отдельно не замеряется.
  В частности, использование хешей в BE-Refal5::MLinker::AddRequest для скомпонованных имён ускорило
её выполнение примерно в 20 раз: с 1,9 секунд до 0,1 секунды (замеры на современной машине). Функция
BE-Refal5::MLinker::GetNextUnit ускорилась с 0,486 секунд до 0,016 секунд, BE-Refal5::MLinker::
AddUnit (которая не могла быть не оптимизирована, поскольку использует ту же стурктуру данных, что
и GetNextUnit) до оптимизации требовала всего 0,015 секунд (0,2 % от всей программы), после
оптимизации изчезла из отчёта.

  Но ничто не даётся даром. Вычисление хешей — довольно затратная операция, тем более, реализованная
на Рефале (не хочу без серьёзной нужны добавлять в язык новые «встроенные» функции). Поскольку хеш
имени однозначно определяется самим именем (и алгоритмном хеширования), то при фиксированном
алгоритме, его вычисление можно перенести на более ранний этап: на генерацию промежуточных файлов.
Таким образом, продолжительность компиляции несколько замедлилась: до оптимизации составляла
14 секунд, после — 54 секунды. Однако, это не является большой проблемой, поскольку полная
перекомпиляция выполняется редко (а цифры даны именно по ней), а частичная затрагивает, как правило,
лишь небольшое число файлов.
  Соответственно, изменился формат промежуточных файлов. Имена, подлежащие замене (окружённые
знаками $ или находящиеся в строке 'b '), после своего имени могут содержать хеш, записанный
в формате #NN, где NN — его десятичное значение. Если символ решётки в имени присутствует,
то остаток строки за ним интерпретируется компоновщиком как уже вычисленный хеш, в противном случае
— хеш вычисляется компоновщиком. Благодаря этому подходу удалось избежать необходимости править
библиотечные модули, написанные вручную, а также мучаться, добавляя в них хеши имён.

  Помимо внедрения хешей, были сделаны другие мелкие ситуативные оптимизации, которые нет нужды
здесь описывать, попутно были сделаны рефакторинг и переписывание некоторых участков кода.

  Помимо оптимизации, списки псевдонимов и нескомпонованных элементов были перенесены
из фиксированных месторасположений (папка .Info в текущем каталоге, в ней файлы Aliases.als
и Not linked.txt). Теперь они создаются по соседству с целевым файлом с именами
%TARGET%-Aliases.txt и %TARGET%-Not linked.txt (например, MRefal.r5-Aliases.txt
и MRefal.r5-Not linked.txt). Соответствующим образом, частично адаптировано FarMenu.ini (пока
не адаптирован пункт "Декодировать файл дампа", поскольку под него надо обновлять соответствующую
утилиту, ибо она ожидает захардкоженный путь).

  [TODO: Ускорение работы компилятора на слабых машинах]
  Back-end РЕФАЛа-5 оптимизирован, остальные пункты не потеряли актуальности.


[06.11.2015 - 12:43:17,75]
(Версия 0.2.981)

  [ERROR: Ошибка в генерации циклов удлинения e-переменных]
  Следующая программа не работает:

    $PROGRAM Evar;
    
    WithE {
      (e.Prefix e.Suffix) e.Prefixes-B (e.Prefix) e.Suffix = ;
    }
    
    $ENTRY Go {
      =
        <WithE ('prefix') ('prefix')>
        <WithE () ()>;
    }
    
    $END Evar.

  Эта ошибка сначала была обнаружена и исправлена в Простом Рефале. Но, поскольку кодогенератор
Модульного Рефала представляет собой почти дословную копию Простого, ошибка проявляется и здесь.
Собственно, надо её исправить. Из лога репозитория Простого Рефала:

commit 10726e0659d13a8ab9eb713d9ddb8be7edfe3e03
Author: Mazdaywik <a.v.konovalov87@mail.ru>
Date:   Sun Jun 7 20:21:33 2015 +0300

    ﻿BUGFIX: Исправлены циклы удлинения открытых e-переменных.
    
    Чтобы рассказать, в чём была ошибка, надо сначала пояснить, как работает
    механизм удлинения e-переменных.
    
    В общем случае, образец (или часть образца), содержащий открытую e-переменную,
    имеет вид:
    
      e.переменная ОСТАЛЬНАЯ-ЧАСТЬ
    
    Здесь, как видно, левый конец переменной закреплён, правый не закреплён.
    Поэтому при сопоставлении с образцом делаются попытки сопоставлений остальной
    части с различными длинами e-переменной. Пусть длина всего сопоставляемого
    выражения равна L. Тогда e-переменная должна принимать длины от 0 до L
    включительно, и, соответственно, остальная часть — длины от L до 0, тоже
    включительно.
    
    Ошибка заключалась в том, что при итерации длина e-переменной менялась
    не от 0 до L, а от 0 до L-1 — цикл с предусловием завершался, когда длина
    остальной части становилась равной нулю. Ошибка ранее не проявлялась, поскольку
    во всех случаях использования компилятора (пока только компиляция самого
    Простого Рефала, компиляция Модульного Рефала в качестве back-end’а
    и в нескольких других программах) остальная часть семантически не могла быть
    пустым выражением. Открытые e-переменные использовались для поиска терма,
    соответствующего некоторым критериям, для чего остальная часть представляла
    собой терм и закрытую e-переменную:
    
      e.открытая-переменная      ОСТАЛЬНАЯ-ЧАСТЬ
                ↓                       ↓
      e.открытая-переменная ТЕРМ e.закрытая-переменная
    
    Для таких случаев исходный ошибочный вариант был приемлем.
    
    Однако, можно привести пример, который демонстрирует ошибочное поведение — этот
    пример находится по пути tests-and-stubs/Test6.sref — для корректной реализации
    он молча завершается, в некорректной приводит к дампу поля зрения.
    
    Исправление ошибки заключалось в замене цикла с предусловием на цикл
    с постусловием — на первой итерации он выполняется с пустой e-переменной,
    проверка условия имеет побочный эффект — удлинение e-переменной и сокращение
    диапазона для остальной части. Соответственно, на последней итерации диапазон
    для остальной части соответствует пустому выражению (что в ошибочной реализации
    было невозможно), удлинение переменной больше неосуществимо, проверка условия
    возвращает false.


  [ERROR: Некорректная обработка двойных кавычек в компоновщике back-end’а РЕФАЛа-5]
  Модуль BE-Refal5::MExeTyper, выполняющий формирование целевого файла, неправильно обрабатывает
двойные кавычки. Он не видит разницы между двойными и одинарными кавычками, поэтому может разбивать
текст в кавычках на отдельные строки, склеивать два последовательных закавыченных куска и т. д.
Однако, в современном диалекте РЕФАЛ-5 двойные кавычки не являются синонимом одинарных: они служат
для оформления составных символов.
  Нужно исправить обработку двойных кавычек.

  [TODO: Оптимизация совместного сопоставления с образцом]
  Исследование сопоставления, сделанное Батусовым, завершилось ничем с практической точки зрения.
Из несомненных результатов — была сформулирована теория обобщений образцов, но на практике её
проверить не удалось. Возмжно, в дальнейшем оно будет реализовано как положено.

  Лучшее — враг хорошего. Следует продумать вариант, используемый в компиляторе РЕФАЛ-5: оптимизация
на уровне промежуточного кода. Для каждого предложения промежуточный код генерируется независимо,
затем из последовательностей команд сопоставления отдельных предложений генерируем дерево. Этот
вариант не будет давать идеальный результат (который мог бы давать алгоритм, построенный
на вычислении обобщений образцов), но с практической точки зрения он будет давать вполне приемлемое
ускорение.

  На данный момент, при выполнении полной пересборки в профиль C++/SR с заглушкой rem в качестве
компилятора C++ 16 % времени выполнения программы тратится на линейную часть сопоставления
с образцами — это время без учёта повторных переменных и циклов по открытым переменным. Эта метрика
идёт третьей строчкой после внешних функций (29 %) и линейного времени построения результатных
выражений (22 %).
  Таким образом, данная оптимизация не сможет дать выигрыш в быстродействии более чем 16 % в силу
того, что остальное время занимают операции, не затрагиваемые оптимизацией.