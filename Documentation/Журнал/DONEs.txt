====================================================================================================
  [DONE] Реорганизация каталоговой структуры проекта
====================================================================================================

  [TODO] 05.02.2009 -  1:25:50,27

  На данном этапе в корне каталога проекта находятся: (а) исходники компилятора и "стандартных" биб-
лиотечных модулей, (б) сопутствующих им папок с выходными файлами (~Defs, ~ROut, ~SRout, ~XLinx),
(в) каталог внутренней документации Documentation, (г) каталог подпроекта -- утилиты mr-extent,
(д) каталог сопуствующих утилит и (е) каталог MR-Home, содержащий библиотечные модули, использовае-
мые для компиляции программ, находящихся вне проекта (используется в сценарии compile_mr как одна
из MODULEPATH-папок).
  Очевидно, что (а) из всех частей проекта только исходники не оформлены как отдельные подпапки в
папке проекта и (б) исходники самого компилятора и "стандартной" библиотеки к нему перемешаны.
  Поэтому имеет смысл выделить отдельные подкаталоги для стандартных модулей и исходных файлов са-
мого компилятора. Подобным образом организованы каталоги в проекта Простой Рефал (который станет
подпроектом Модульного Рефала) -- это очень удобно.
  Кроме того, при размещении модулей по отдельным пакетам, папки, соответствующие пакетам и папки,
соответствующие отдельным частям проекта, не будут сливаться. (Папки пакетов и папки выходных фай-
лов не будут сливаться по той простой причине, что первые должны начинаться с буквы, а вторые на-
чинаются (в текущей реализации) со знака тильда).
----------------------------------------------------------------------------------------------------
  [DONE] 11.02.2009 -  0:37:17,89

  Реорганизация завершена. Структура каталогов теперь такая (каталоги выходных файлов и тестовых
программ не отображены):
    +---Bin
    +---Documentation
    |   +---Журнал
    |   \---Спецификации
    +---Libraries
    |   +---all.all
    |   +---all.r5
    |   +---windows.all
    |   \---windows.r5
    +---Sources
    |   +---Compiler
    |   +---Libraries
    |   |   +---all.all
    |   |   +---all.r5-b
    |   |   +---all.r5-s
    |   |   +---Projects
    |   |   +---windows.all
    |   |   +---windows.r5-b
    |   |   \---windows.r5-s
    |   +---MR-Extent
    |   \---Utilities
    \---Tests
  В папке Bin находятся исполнимые файлы компилятора и утилит (экзешник mr-extent.exe, остальные --
это rsl-файлы).
  В папке Documentation находится внутренняя документация проекта. Её структура не претерпела ника-
ких изменений.
  В папке Libraries находятся откомпилированные модули библиотечных модулей. О каталоговой структуре
этой папки будет сказано позже.
  В папке Sources находятся исходные файлы самого компилятора, библиотек, вспомогательной программы
MR-Extent и утилит.
  Подкаталоги исходных текстов библиотек имеют следующий вид: оп-система.back-end[-b|-s]. Если опе-
рационная система указана как all, то указанные модули могут использоваться для всех операционных
систем. Если в качестве back-end'а указан all, то данные библиотечные модули представлены в виде
исходных текстов Модульного Рефала и не зависят от back-end'а. Для конкретных back-end'ов использу-
ется суффикс '-b' или '-s'. Суффикс '-b' означает, что библиотечные модули не имеют исходного тек-
ста на Модульном Рефале, написаны непосредственно на выходном языке соответствующего back-end'а.
Суффикс '-s' означает, что библиотечные модули написаны на Модульном Рефале, но в то же время, не
переносятся на другие back-end'ы.


====================================================================================================
  [DONE] Таблица перекрёстных ссылок
====================================================================================================

  [TODO] 04.02.2008 - 23:26:22,87

  Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
  Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
  В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.
----------------------------------------------------------------------------------------------------
  [DONE] 01.02.2009 - 21:42:25,09

  Сделано. Реализовано как отдельный back-end, который на данный момент включен всегда (т.е. его
нельзя отключить), при проработке командной строки этот недостаток будет устранён. Выходные файлы
помещаются в каталог ~XLinx, расширение .xlinx. Информация о перекрёстных ссылках помещается в
Info/%exename%.xlinx.txt. Из тех возможностей, которые хотелось бы реализовать, но не реализованы,
можно назвать получение списка нелинкованных элементов и обобщение перекрёстных ссылок при одновре-
менной компиляции нескольких "гроздей".


====================================================================================================
  [DONE] Переупорядочить список приоритетных задач
====================================================================================================

  [TODO] 01.02.2009 - 20:00:56,79

  Работа над таблицей перекрёстных ссылок завершена ещё в новогодние выходные. Поэтому, если я сей-
час завершу это TODO, то формально получится так, что необходимо повысить номер версии до 0.2 (т.к.
это -- последнее TODO между скобками). Однако, с тех пор, когда я составил список приоритетных за-
дач, ситуация сильно изменилась. Поэтому необходимо обновить этот список. Обновлять я его буду тем
же путём, что и раньше при создании списка. Теперь за счёт использования тегов со знаком '+' стало
возможным обновлять сведения о задаче, не перемещая её в списке. Этим и воспользуюсь.
----------------------------------------------------------------------------------------------------
  [DONE] 01.02.2009 - 21:42:25,09

  Этим я займусь ниже (см. в журнале проекта, в экстрактах этого не видно).


====================================================================================================
  [CHANGED] Добавлены теги +TODO, +ERROR, +TOTHINK
====================================================================================================

  [CHANGED] 01.02.2009 -  2:38:40,13

  Смысл этих тегов в том, что эти теги не перемещают записи в файлах TODOs.txt и LIST.txt при пов-
торении, в отличие от одноимённых тегов без знака плюс.


====================================================================================================
  [DONE] Пересмотреть/переписать mOutModuleStatus.mref
====================================================================================================

  [TODO] 09.02.2008 -  3:00:29,53

  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.
----------------------------------------------------------------------------------------------------
  [TODO] 09.12.2008 -  0:37:17,92

  Добавить также строчку вывода Recompiled, заменяющую последовательный вывод Compiling/Compiled для
одного и того же модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 05.01.2009 - 22:47:50,90

  Пересмотрел код вывода сообщений. Написан он достаточно прилично, поэтому переписывать необходи-
мости нет. Код обработки Recompiled также написал. Всё работает.


====================================================================================================
  [FIXED] Возможна ошибка при чтении папок
====================================================================================================

  [ERROR] 23.04.2008 - 20:49:40,97

  Команду dir можно заместить, добавив в текущую папку/в один из каталогов PATH файл с именем, нап-
ример dir.exe. Такая ситуация может возникнуть, если на комп установлен cygwin (команда dir имитирует
команду ls системы Linux) -- сам видел. А это значит, что программы становятся непереносимыми.
  Решить проблему можно, если разработать отдельную программу с некоторым редким именем типа
mr_extent.exe, которая может в том числе выводить и листинг папки в более удобном для распознавания
формате. Эта же программа может возвращать значения переменных среды, конвертировать бинарные файлы
в текстовые специального формата и наоборот (чтобы имитировать работу с бинарными файлами). Для под-
держки этой программы можно создать отдельный стандартный модуль, который в момент инициализации про-
веряет наличие программы и корректность её версии.
  Примерный внешний вид програмы.
    > mr_extent.exe VERSION
  MRefal Extensions version 0.1.123
  или (в виде XXIO)
  MR_extent#0 #1 #123
  > mr_extent.exe LIST DirName
  file1.ext
  file2.txt
  dir3
  или
  (file1.ext)(file2.exe)(dir3)
  > mr_extent.exe INFO file1.ext
  #2048 #2008 #5 #9 #23 #59 #59 file1.ext
  Размер,  дата, время, имя
  > mr_extent.exe INFO dir3
  D#2008 #5 #9 #23 #59 #59 dir3
  > mr_extent.exe INFO file3.lst
  N
для папок может возвращаться вместо размера буква D, для несуществующих файлов N.
  Это ERROR я удалю, когда реализую эту программку.
----------------------------------------------------------------------------------------------------
  [FIXED] 05.01.2009 - 18:08:30,74

  Данная ошибка исправлена -- реализована соответствующая программа. Работает в почти полном соот-
ветствии с описанием в ERROR, за тем исключением, что имя этой утилиты mr-extent.exe и она при не-
правильном аргументе на stdout выводит E. При запросах INFO и LIST первым термом вывода (вывод в
stdout осуществляется в формате XXIO) является символ S.


====================================================================================================
  [DONE] Стабильная версия и сценарии make
====================================================================================================

  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Данное TODO подразумевает, что надо создать новую стабильную версию (которая будет поддерживать
пакеты) и обновить файлы make, чтобы иметь возможность пересобрать проект, т.к. имеющиеся уже уста-
рели.
----------------------------------------------------------------------------------------------------
  [DONE] 04.01.2009 - 17:54:39,75

  После завершения работы над встроенной утилитой make я обновил стабильную версию и файлы make.bat
и make-s.bat. При этом номер весии был поднят до 0.1.959. Ранее я не мог поднять номер версии, т.к.
bat-файлы не были обновлены для поддержки новой командной строки, а обновлять "руки не доходили".


====================================================================================================
  [DONE] ПИ:Режимы "только связывание" и "полной перекомпиляции"
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Должна быть возможность выбора режима перекомпиляции (на начальном этапе -- опцией командной
строки): make (быстрая перекомпиляция), build (полная перекомпиляция), linkonly (только связывание).
----------------------------------------------------------------------------------------------------
  [DONE] 04.01.2009 - 17:54:39,75

  Появились соответсвующие режимы в полном соответствии со спецификацией "Поиск исходников02.txt" и
с текущим TODO. Командная строка имеет следущий синтаксис:

  refgo /* опции для refgo */ mrefal РЕЖИМ "=MP:MP-КАТАЛОГИ" ИМЕНА МОДУЛЕЙ

где РЕЖИМ -- одно из +make+, +build+, +linkonly+; MP-КАТАЛОГИ -- имена MP-каталогов, перечисленных
через точку с запятой; ИМЕНА МОДУЛЕЙ -- имена модулей, которые являются "корнями" "гроздей", подле-
жащих компиляции.

  О внутреней реализации.
  Изнутри в контектсте модуль характеризуются двумя параметрами: статусом (Status) и типом (Type).
Названия параметров не очень удачные, но на большее фантазии не хватило. Статус определяется уров-
нем, на котором уже обработан модуль (статусы Found, Raw, Ready устанавливаются в модулях MModules,
MClusters и MCompiler соответственно).

  (*) Модуль MModules для запроса состояния-типа (информация о статусе и типе) имеет функцию Lookup\
ImportModule. Данная функция для модуля с заданным квалифицированным именем возвращает его статус и
тип, причём если модуль был заранее известен (имелся в контексте), то возвращается его статус-тип.
Иначе, запускается процедура поиска модуля в соответствии со спецификацией. По завершении поиска
возвращается статус Found и соответствующий тип (см. ниже). Эти же статус-тип добавляются в кон-
текст. Для запроса статус-типа используется функция MContext::GetStatusType.
  (*) Модуль MClusters для запроса состояния-типа использует семейство функций CheckNeedCompile-??,
где ?? -- это Make, Build или LinkOnly. Именно на этом уровне происходит разделение режимов работы
компилятора. Для запроса статус-типа используется функция MModules::LookupImportModule. Если пос-
ледняя функция возвращает статус Found, то на уровне модуля MClusters производится обработка и ана-
лиз данного модуля, после которой модуль получает статус Raw. На уровне MClusters модули не подвер-
гаются компиляции, осуществляется только поиск модулей и анализ их типа.
  (*) Модуль MCompiler уже производит компиляцию модулей, если это необходимо. Для получения статус-
типа используется одна из трёх функций предыдущего уровня. На начальном уровне выбирается функция-
запросчик, которая затем по указателю передаётся во все функции обработки. После завершения обработ-
ки модуля (компиляция, подтверждение обновлённости или библиотечности, обнаружение ошибок), модуль
получает статус Ready.

  Тип определяет разновидность модуля по характеру его обработки:
  (*) Тип Errors устанавливается в случае, если при обработке модулей произошла ошибка (Found Errors
-- модуль не найден, Raw Errors -- был Found Errors или в данном режиме имел недопустимый Found-тип,
Ready Errors -- был Raw Errors или произошла ошибка в процессе обработки).
  (*) Тип Changed означает, что модуль должен быть перекомпилирован, т.к. изменялся после предыдущей
перекомпиляции.
  (*) Тип Updated означает, что модуль можно не перекомпилировать, т.к. модуль имеет полный набор
корреткных выходных файлов, которые не изменялись после предыдущей компиляции.
  (*) Тип Library означает, что модуль является библиотечным, т.е. отстутствует файл исходного текс-
та, но при этом все выходные файлы корректны.

  Стратегия обработки.
  (*) На уровне Found модуль только обнаруживается, тип Updated устанавливается для всех модулей, у
которых присутствуют все выходные файлы и присутствует файл исходного текста. Если отсутствует хотя
бы один из выходных файлов, устанавливается тип Changed, файл исходного текста -- тип Library. Если
модуль найти не удалось -- тип Errors.
  (*) На уровне Raw в зависимости от текущего режима уточняется тип модуля. Если модуль имел до это-
го тип Errors, то он и остаётся.
  В режиме полной перекомпиляции (когда должны быть перекомпилированы все модули), модули имевшие до
этого тип Updated, получают тип Changed. Типы Changed и Library сохраняются.
  В режиме только перекомпоновки все модули, входящие в проект, должны быть найдены и скомпонованы в
конечный .exe-шник. При этом перекомпиляция не требуется. В данном режиме тип Changed заменяется на
Errors, т.к. невозможно слинковать проект, в котором отсутствуют хотя бы один выходной файл. Осталь-
ные типы сохраняются.
  В режиме частичной перекомпиляции типы Errors, Changed и Library сохраняются без изменений. Для
модулей типа Updated производится сначала анализ времени последнего изменения самого модуля (его ис-
ходных и выходных файлов), затем производится анализ импортируемых модулей -- нет ли среди них моду-
лей, имеющих тип Changed (независимо от статуса это означает необходимость перекомпиляции) или тип
Errors. Т.к. в модуль MClusters t.hErrorList не спускается, то в случае импорта ошибочных модулей
возвращается (на всякий случай) режим Changed (чтобы при перекомпиляции на уровне Ready ошибка была)
обнаружена. Аналогично обрабатывается ошибка при рекурсивных зависимостях. Если же все импортируемые
модули являются Raw/Ready Updated/Library, то сравнивается время последнего изменения импортируемых
модулей и времени последнего изменения обрабатываемого модуля. На его основе выносится окончательный
вердикт.
  (*) На уровне Ready для модулей Raw Changed производится перекомпиляция и анализ зависимых модулей,
для модулей Raw Updated/Library просто анализируются зависимостей. При этом модуль Raw Changed может
зависеть только от модулей типа Changed/Updated/Library независимо от статуса (для модулей статуса
Raw производится анализ и установка статуса Ready), модуль типа Raw Updated может зависеть только от
модулей Updated/Library, библиотечный модуль может зависеть только от библиотечных. 


====================================================================================================
  [FIXED] Не определяется обновлённость импортированного модуля
====================================================================================================

  [ERROR] 25.11.2008 - 15:52:21,87

  Согласно спецификации, перекомпиляция модуля должна осуществляться в случае, если исходные тексты
импортируемых модулей или выходные файлы импортируемых библиотек обновлены позже рассматриваемого
модуля. Для исходных текстов это правило не выполняется, для библиотек -- ещё не проверял. Надо ис-
править.
----------------------------------------------------------------------------------------------------
  [FIXED] Џ­ 08.12.2008 - 19:19:37.31

  Теперь всё определяется. И для случая с библиотеками, и для случая с простыми модулями. И всё ра-
ботает в соответствии со спецификацией.


====================================================================================================
  [DONE] Подготовиться к переходу на пакеты
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Частично перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Додумать детали перевода IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 20:27:00,31

  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] ПИ:Полная поддержка parser'ом квалифицированных имён
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Одно из требований гласит:  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно
быть указано в файле исходного текста (синтаксис файла исходного текста должен позволять это делать)
и в файлах с информацией о межмодульных связях (структура хотя бы одного из этих файлов должна поз-
волять это делать).
  Таким образом, синтаксис файлов исходного текста (распознаётся в mParser.mref) и структура (она
же синтаксис) файлов символической информации (распознаётся там же) должна полностью поддерживать
квалифицированные имена.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Перевести Parser на квалифицированные имена
====================================================================================================

  [TODO] 23.02.2008 - 21:33:32,54

  Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Добавление категории "квалифицированное имя"
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Добавление этого является прямым следствием иерархии языка Java.

  [TODO] Номер версии независимо от компиляции
  [TODO] Вывод номера версии компилятора
  Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
  Не выделяем.

  [TODO] Удалить MRefalRTS::Put
  Идеологически не принципиально. Всё равно это деталь реализации.
  Не выделяем.

  [TODO] Исключение промежуточного представления модуля
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Иерархия в стиле Java
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Новая модель модулей
====================================================================================================

  [TODO] 27.10.2007 - 18:34:49,78

  Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
  Подробности задачи см. в файле "Module conception for Module Refal.txt".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.

  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Расширить утилиту TODO_list
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Для лучшей ориентации в недоделках надо научиться извлекать из журнала не только заголовки невы-
полненных TODO, но и сами описания TODO. Т.е. помимо краткого списка выводить подробный, в котором
будут выводиться сами тексты TODO. А также список выполненных TODO, в котором приводится сводка всех
выполненных TODO, причём описания TODO и DONE должны располагаться рядом.
----------------------------------------------------------------------------------------------------
  [DONE] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.


====================================================================================================
  [DONE] Продумать введение тега "Продумать"
====================================================================================================

  [TODO] 05.07.2008 - 13:29:02,69

  Очень много TODO в журнале проекта содержат в заголовке слова "продумать", "обдумать". Тег TODO
семантически предназначен для описания задач, которые в конце концов должны быть решены в виде исход-
ного кода. Тег ERROR предназначен для описания ошибок, требующих исправления. Однако, как уже было
сказано, теги TODO со словами в заголовке типа "продумать" предназначены не для описания тех задач,
которые следует закодировать, а для задач, для которых ещё надо найти форму для воплощения. Поэтому
имеет смысл ввести тег ПРОДУМАТЬ для тех задач, решение которых представляет собой проектное решение
или ответ на вопрос, а не написанный код. При чём если в результате обдумывания некоторой возможнос-
ти я приду к выводу, что реализовывать эту возможность совсем не нужно, я могу закрыть этот тег с
обоснованием ненужности. Тот же случай в теге TODO/DONE выглядит противоречиво: в теге "сделано" опи-
сывается то, что не сделано и не будет сделано никогда.
  Эту TODO легко реализовать в коде, но есть одно препятствие, которое надо преодолеть прежде, чем
закодировать. Это имена для указанных тегов. Вариант THINK/THINKED выглядит как-то не красиво.
  Другая мысль. Указанный тег можно было бы закрывать не только специальным закрывающим тегом, но и
тегом TODO, если в результате обдумывания появилось решение, которое можно воплотить в коде. Можно
ввести специально различные закрывающие теги для описания положительных и отрицательных резолюций по
поводу вносимых изменений, это позволит яснее определять те решения, которые в процессе работы были
отклонены.
  Возможно, не стоит ограничиваться только англоязычными тегами. Можно даже наоборот, для TODO/DONE
ERROR/FIXED CHANGED ввести синонимы СДЕЛАТЬ/ГОТОВО ОШИБКА/ИСПРАВЛЕНО ИЗМЕНЕНИЯ.
  В общем, надо продумать детали.
----------------------------------------------------------------------------------------------------
  [DONE] 07.12.2008 - 13:40:55,38

  Ограничимся пока введением пары тегов TOTHINK/THINKED, причём тег TOTHINK можно закрывать и одно-
имённым тегом TODO, когда результатом обдумывания является готовое задание.


====================================================================================================
  [DONE] Искать имя программы другим способом
====================================================================================================

  [TODO] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Перейти от модуля Context к модулю MContext
====================================================================================================

  [TODO] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Переписать драйвер
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.

  [TODO] Промежуточное представление как АТД
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] SymInfo как АТД
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.

  [TODO] Переписать драйвер
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Модуль-программа
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Использование нескольких front-end и back-end
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".

  [TODO] RASL и интерпретатор
  Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
  Не выделяем.

  [TODO] Доделать механизм переименования модулей
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Механизм поиска модулей
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.

  [TODO] Использование нескольких front-end и back-end
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] ПИ:Написать средства для оценки необходимости перекомпиляции
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Написать функцию для оценки необходимости перекомпиляции в соответствии со следующими требовани-
ями (дословно из спецификации):
  Компилятор может предоставлять режим "быстрой перекомпиляции", в котором некоторые компилируемые
модули могут исключаться из процесса компиляции при одновременном выполнении следующих условий:
  (*) Для данного модуля присутствуют ВСЕ выходные файлы.
  (*) Выходные файлы созданы/обновлены позже исходного файла данного модуля.
  (*) Модули, от которых зависит данный модуль, либо библиотечные, либо были исключены из процесса
компилирования, хотя были компилируемыми.
  (*) Исходные тексты компилируемых модули, от которых зависит данный модуль, созданы/обновлены
раньше, чем данный модуль.
  (*) Выходные файлы библиотечных модулей, от которых зависит даннный модуль, созданы/обновлены
раньше, чем данный модуль.
  Этот набор эвристических условий позволяет с высокой вероятностью гарантировать непротиворечи-
вость проекта.
  Если всё равно есть сомнения, то рекомендуется включать режим для полной перекомпиляции.
----------------------------------------------------------------------------------------------------
  [DONE] 18.11.2008 - 23:56:49,37

  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


====================================================================================================
  [DONE] Создать модуль для оценки необходимости перекомпиляции
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Т.е. создать модуль, основная функция которого получает имя модуля, ищет входные и выходные файлы
модуля, считывает sym-файл и проверяет необходимость в перекомпиляции рекурсивно. Возвращает функция
сведения о небходимости перекомпиляции или сообщение об ошибке. При этом собственно перекомпиляцию
этот модуль осуществлять не должен.
----------------------------------------------------------------------------------------------------
  [DONE] 18.11.2008 - 23:56:49,37

  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


====================================================================================================
  [DONE] Создать средство для поиска модулей, подлежащих линковке
====================================================================================================

  [TODO] 06.07.2008 - 13:15:05,41

  Нужно создать средство, которое по заданному имени корневого модуля находит все модули, от которых
зависит данный модуль, при чём в топологическом порядке от зависимых к зависящим.
----------------------------------------------------------------------------------------------------
  [DONE] 11.11.2008 - 13:18:37.09

  Такое средство создано -- это функция MClusters::ListForLinking. По заданному корневому имени она
находит все зависимые имена и сортирует их в топологическом порядке. Формат функции
  <MClusters::ListForLinking t.hContext t.RootModule>
    == t.hContext Success e.Modules
    == t.hContext Fails
  Функция завершается неуспешно если хотя бы один из модулей в "грозди", растущей из t.RootModule
не был откомпилирован или обновлён, а также если среди модулей каким-то чудом оказались циклические
зависимости. Теперь можно удалить из контекста функции LastModule и GetProgName.


====================================================================================================
  [DONE] Контекст индексируется по именам в нижнем регистре
====================================================================================================

  [TODO] 08.11.2008 - 19:37:27,98

  Мотивация. Согласно спецификации модули и пакеты, находящиеся в одном проекте (в принципе, это
правило можно распространить и на весь набор проектов, компилируемых за раз), не могут иметь имена,
различающиеся лишь регистром. Однако, полное квалифицированное имя того модуля, который импортиру-
ется, должно быть известно точно: имя в директиве $IMPORT и имя импортируемого модуля в директивах
$MODULE и $END (как в исходных, так и в sym-файлах) должны совпадать с учётом регистра. Поэтому
имеет смысл индексировать контекст именами без учёта регистра (например, приведя все имена в верх-
ний или нижний регистр), но при этом в контексте хранить сведения о настоящем имени модуля (если
таковое известно -- модуль компилировался или читался его sym-файл).
  Цель. Индексировать контекст именами в нижнем регистре, при этом храня информацию о дествитель-
ном имени модуля (если таковая имеется). При попытке индексировать квалифицированным именем кон-
текст должно проверяться соответствие имени на входе настоящему имени, если таковое известно.
  /* И опять список заданий и ошибок не влезает на один экран :-). */
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Указанная схема реализована, но только пока не используется: нигде в программе не устанавливается
атрибут RealName, поэтому теперь контекст индексируется только по неквалифицированным именам.


====================================================================================================
  [DONE] ПИ:Обработка командной строки
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Для модулей, перечисленных в командной строке, обработку выполнять в соответствии со специфика-
цией (см. "Поиск исходников.txt").
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] ПИ:Написать функцию для поиска модулей
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Поиск модулей должен осуществляться в соответствии со спецификацией. Здесь дословно её цитировать
не буду, а просто сошлюсь на файл "Поиск исходников.txt".
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] Разработать функцию поиска модуля из командной строки
====================================================================================================

  [TODO] 18.10.2008 - 21:53:30,07

  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] Разработать функцию поиска импортируемого модуля
====================================================================================================

  [TODO] 18.10.2008 - 21:53:30,07

  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [CHANGED] Организация файлов спецификаций
====================================================================================================

  [CHANGED] 09.11.2008 - 22:05:55,79

  Ранее я однажды редактировал спецификацию "Поиск исходников", старый текст при этом я "закомменти-
ровал", добавления и изменения я пометил "комментариями" (комментарии Си и Си++). Очевидно, что при
дальнейшей модификации спецификации, под навалом комментариев трудно будет почитать сам текст. Поэ-
тому я восстановил как предыдущий вариант, так и текущий, очистив их от комментариев и переименовав
их в соответственно "Поиск исходников.01.txt" и "Поиск исходников.02.txt". При дальнейшем развитии
спецификации я буду создавать файлы с номерами 03, 04 и так далее. Эволюцию спецификаций можно от-
следить программой fc.


====================================================================================================
  [FIXED] Плохо проверяется попытка переопределения
====================================================================================================

  [ERROR] 07.07.2008 -  2:08:58,93

  Внутри одного исходного файла можно определить две функции, два АТД, два импорта с одинаковым име-
нем, лишь бы их виды (Kinds) совпадали. Проверка на переопределение выполняется только для сущностей
разных видов.
----------------------------------------------------------------------------------------------------
  [FIXED] 18.10.2008 - 23:54:58,07

  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.


====================================================================================================
  [FIXED] Конфликт имён между псевдонимом модуля и функцией
====================================================================================================

  [ERROR] 06.07.2008 - 13:15:05,41

  Если в файле исходного текста одновременно присутствуют функция и псевдоним модуля с одинаковым
именем, то компилятор умирает с ошибкой. А на самом деле должна выскакивать ошибка переопределения
имени. Причина ошибки в том, что IModule индексируется по полным именам импортируемых модулей, а не
по их псевдонимам. Надо это исправить.
----------------------------------------------------------------------------------------------------
  [FIXED] 18.10.2008 - 23:54:58,07

  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.


====================================================================================================
  [CHANGED] ПИ: Конфликт между именами импортируемых модулей и модулей в командной строке
====================================================================================================

  [CHANGED] 17.10.2008 - 22:58:13,00

  Проблема такая. В спецификации указано, что модули, перечисленные в командной строке, являются как
бы "головными". Если в командной строке указан головной модуль, который компилируется в отдельный
exe-шник, то он образует проект. Если же указан не головной модуль, то подлежит компиляции он и все
зависимые от него модули. В любом случае каждый модуль в командной строке образует "гроздь" из зави-
симых модулей. В принципе, эти "гроздья" могут частично пересекаться или даже вкладываться друг в
друга. Для всех гроздей имеется одинаковая переменная MODULEPATH, одинаковый набор back- и front-
end'ов. Поэтому можно предположить (а я так для этого молчаливо и полагал, не отражая свои мысли в
журнале или спецификациях) что модули, одновременно присутсвующие в нескольких "гроздьях", должны
быть обработаны только однократно и при обработке последующей "грозди" можно воспользоваться обрабо-
танными модулями из предыдущих "гроздей".
  Но тут возникает проблема. Правила поиска модулей по квалифицированному имени (когда ищется импор-
тируемый модуль) и правила поиска модулей, указанных в командной строке различаются. Поэтому если
модуль импортируется, то он может быть найден по одному пути, если же он указан в командной строке,
то имея то же квалифицированное имя, может находиться по другому пути. Пример.
  compile_mr /* разные опции, MODULEPATH=".;D:\MyLib;C:\MR" */ MainModule.mref C:\MR\SubModule.mref

  $PROGRAM MainModule;
  
  $IMPORT SubModule;

  /* прочий код */;

  $END MainModule.

  В данном случае, если SubModule находится в текущей папке или папке D:\MyLib, то как импортируемый
модуль он не будет обнаружен в папке C:\MR, но по правилам поиска модуля, указанного в командной
строке, будет SubModule должен быть найден в папке C:\MR (должен быть, иначе произойдёт ошибка ком-
пиляции "Модуль не найден"). Возникает конфликт.

  Решение проблемы. Предполагается следующее решение. Сначала производится поиск (только поиск без
компиляции или анализа) модулей, перечисленных в командной строке. Их местоположения запоминаются.
В дальнейшем производится последовательная компиляция этих модулей. Теперь, если где-либо в списке
импорта будет указан тот же модуль, что и тот, который указан в командной строке, будет использо-
ваться модуль, указаннный в командной строке. Т.е. для примера выше модулем MainModule.mref будет
импотирован модуль C:\MR\SubModule.mref.


====================================================================================================
  [CHANGED] ПИ: Расширения в нижнем регистре
====================================================================================================

  [CHANGED] 15.10.2008 - 22:39:31,17

  Меняю спецификацию. Теперь расширения должны быть в нижнем регистре. Подробности в файле специфи-
кации "Поиск исходников.txt".
  Мотивация. Искать файлы с расширениями, различающимися регистром, неэффективно.


====================================================================================================
  [CHANGED] Устранены MRefalRTS::Lenw и MRefalRTS::ExistFile-T
====================================================================================================

  [CHANGED] 14.07.2008 - 20:42:05,95

  Из модуля поддержки времени выполнения удалены эти две функции, которые не используются в библио-
течных модулях. Когда-то я удалял Lenw, но, видимо или не до конца удалил. Или забыл всё-таки уда-
лить из самого MRefalRTS, или случайно когда-то потёр MRefalRTS и восстановил старую версию.


====================================================================================================
  [DONE] eXpression eXchange in/out
====================================================================================================

  [TODO] 19.10.2007 -  1:04:32,32

  В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).
----------------------------------------------------------------------------------------------------
  [DONE] 14.07.2008 - 20:42:05,95

  Написал модуль для средств обмена выражениями. Для XXIO формата принят следующий синтаксис:
  * Структурные скобки ( ) отображаются соответственно в '(' ')'.
  * Объектные скобки '(' ')' отображаются соответственно в '#(' '#)'
  * Символы табуляции и новой строки отображаются соответственно в '\t' и '\n'.
  * Символы с кодами от 33 до 127 отображаются как есть.
  * Остальные символы отображаются как '\dNNN', где NNN -- трёхзначный десятичный код символа.
  * Макроцифры отображаются в '#число ', где число -- десятичное представление числа.
  Если в исходном выражении были идентификаторы или АТД-термы, то функция сохранения MXXIO::Save
сохранения файла не выполняет, возвращает Fails.
  При обнаружении первой же ошибки во входном файле разбор файла прекращается, функция MXXIO::Load
возвращает Fails.
  При чтении файла не имеет значения разбиение исходного файла на строки, при записи файл разбива-
ется на строки длиной 63 символа.


====================================================================================================
  [CHANGED] Отступ в два пробела
====================================================================================================

  [CHANGED] 05.07.2008 - 23:58:33,14

  Недавно узнал, что у нас на кафедре при программировании на Си++ требуется делать отступы в два
пробела (при чём пробелами и ни в коем случае не табуляцией). Чтобы исследовать на себе этот стиль,
я установил в настройках Far'а табуляцию в два пробела, замена всех табуляций пробелом (заменяет при
сохранении файла), а также макрос Пробел-Backspace на кнопку табуляции. Привыкаю потихоньку.


====================================================================================================
  [DONE] Продумать детали перевода IModule на квалифицированные имена
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?
----------------------------------------------------------------------------------------------------
  [DONE] 05.07.2008 - 20:27:00,31

  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.


====================================================================================================
  [DONE] Разбить Parser на модули
====================================================================================================

  [TODO] 05.07.2008 - 13:29:02,69

  Кратко. Разбить модуль парсера на три модуля: mParser_Common.mref, mParser_Source.mref,
mParser_Sym.mref.
  Мотивация. Модуль MParser прямо или косвенно импортируется следующими модулями: MSymModule,
Compiler, MStartupSeqGenerator, MLinker_Refal5, MBackEnd_Refal5_init, MFrontEnd_MRefal. И при каждом
изменении парсера для всех этих модулей проходит каскадная перекомпиляция. Дело в том, что модуль
MParser выполняет две похожие задачи: анализ и распознавание файла исходного текста и файла символи-
ческой информации. Эти две задачи объединяет то, что код их реализации имеет очень много компонентов,
поэтому они реализуются в одном модуле.
  Поэтому надо разделить код из модуля MParser на три разных модуля: модуль для распознавания общих
нетерминалов, модули для распознавания исходного и символического файлов. В принципе, можно было бы
объединить модули с общими термами и распознавания символических файлов, т.к. для распознавания пос-
ледних нужно только две специализированные функции: тело модуля и объявление функции. Однако, это ре-
шение мне кажется непоследовательным, т.к. объединяются модули только по признаку объёма файла, а не
по смыслу.
  Вообще, решение об разделении одного модуля на три мне кажется больше техническим, нежели концеп-
туальным. Ведь после разделения связь между модулем с общими средствами и модулями распознавания фай-
лов будет большой (определяется количеством используемых entry-функций). Но, с другой стороны, сейчас
модуль парсера является самым большим среди всех исходных файлов проекта (45594 байта). Поэтому для
удобства работы с ним его надо разбить на несколько маленьких.
----------------------------------------------------------------------------------------------------
  [DONE] 05.07.2008 - 15:53:28,01

  Теперь в проекте вместо модуля MParser имеются три модуля MParser_Common, MParser_MRefal,
MParser_Sym. В принципе, сделано всё в соответствии с TODO.


====================================================================================================
  [DONE] Удалить поддержку FnPtr
====================================================================================================

  [TODO] 23.06.2008 - 21:36:49,43

  Закономерное следствие введения синтаксиса указателей на функции и поддержки этого синтаксиса.
Стабильная версия поддерживает оба варианта получения FnPtr, поэтому можно вызовы FnPtr постепенно
удалить и заменить на нормальный человеческий синтаксис.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 23:01:39,17

  Удалил из парсера поддержку FnPtr и парсер полегчал на 88 строк программного кода. Также заменил
все вызовы <FnPtr ... > в исходных кодах компилятора на конструкцию с амперсандом.


====================================================================================================
  [DONE] Переворошить Parser -- форматы функций
====================================================================================================

  [TODO] 20.06.2008 - 23:12:35,60

  Кратко. Надо поменять формат всех функций на
  <NFn
    [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  >
    == [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  В квадратных скобках показаны необязательные элементы.
  Мотивация. Параметр t.IModule присутствует во всех функциях-нетерминалах, но используется он
только в нетерминалах верхнего уровня. Аналогично в случае t.VarTable, которая тоже не везде исполь-
зуется. Однако, все функции принимают t.ErrorList t.Lexer и t.NextToken. Вышеназванные балластные
элементы находятся между t.ErrorList и t.Lexer, поэтому приходится балластные элементы передавать.
  Дело не в тех иллюзорных тактах процессора, требуемых на распознавание этих элементов, а в том,
что (а) удлиняется код -- на экране элементарно влезает меньше, (б) усложняется код -- необходимо
следить за правильной передачей тех данных, которые не используются.
  Проблема явила свою гадкую личину после того, как я написал универсальные функции для распозна-
вания квалифицированных имён. Формат этих функций не был приспособлен для работы с форматом, содер-
жащим таблицу локальных переменных. Поэтому для использования внутри выражений приходилось (не)ес-
тественным образом таблицу локальных переменных прятать в стек.
  Ожидаемые результаты. Новый формат позволит не передавать во внутренние функции балластные аргу-
менты. Например, если функция NFn1 принимает t.IModule, а функция NFn2 его не принимает, то можно
записать:
  t.IModule e.Stack t.ErrorList t.Lexer t.NextToken =
    <NFn1
      t.IModule
      e.ParentStack
      <NFn2
        e.LocalStack
        t.ErrorList t.Lexer t.NextToken
      >
    >
вместо
  t.ErrorList t.IModule (e.Stack) t.Lexer t.NextToken =
    <NFn1
      <NFn2
        t.ErrorList t.IModule
        (e.LocalStack (e.ParentStack))
        t.Lexer t.NextToken
      >
    >
  Вторым преимуществом является упрощение соглашения о вызовах функций. Стек в данном случае рас-
тёт справа, поэтому можно принять соглашение о том, что функция, распознающая нетерминал всегда нахо-
дится на вершине стека. Родительский стек автоматически конкатенируется с дочерним.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Форматы функций, распознающих нетерминалы, написаны в соответствии с TODO. Однако есть здесь два
варианта стека: тот, который описан в TODO, и оставшийся со старых времён стек в скобках для распоз-
навателей выражений.


====================================================================================================
  [DONE] Новая стабильная версия
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Введение новой стабильной версии позволит сейчас (пока указатели на функции целиком не завладели
исходными текстами) уже избавиться от позорной псевдофункции FnPtr. Уже соответствующий синтаксис
готов. Для себя ставлю веху: когда будет готов следующий синтаксис:
  ... = <MLambda.Reduce Math.Add 0 e.NumList>;
т.е. квалифицированное имя посреди выражения интерпретируется как указатель на функцию, я заменю ста-
бильную версию.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Стабильная версия написана. Стабильная версия поддерживает как указатели на функции в новом сти-
ле: с '&' и без '&' в случае явно написанного квалифицированного имени. Однако, как уже сказано выше,
стабильная версия не поддерживает синтаксис < & Module.Function ... >.
  Стабильная версия имеет номер версии 0.1.951.
  По сравнению с предыдущей стабильной версией, в этой стабильной версии полностью поддерживаются
АТД (разумеется, без спецификаций переменных, я их в версию 0.2 добавлять не планирую). Папка и рас-
ширение выходных файлов этой стабильной версии соответственно ROutS и .srout.


====================================================================================================
  [DONE] Пересмотреть Parser
====================================================================================================

  [TODO] 13.04.2008 - 22:05:09,47

  Необходимо разобраться с функциями, реализующими нетерминалы: унифицировать их интерфейс. Разоб-
раться, что должно быть в момент вызова нетерминалов на стеке и что должно оставаться на стеке после
их выполнения. Результат унификации должен быть закомментирован в шапке модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Parser пересмотрел, переворошил, интерфейс нетерминалов частично унифицировал. Однако, стек для
распознавателей выражений я не переделывал, т.к. он пока и так выполняет свои обязанности и допускает
расширение. Привожу шапку из Parser'а (в дальнейшем она может измениться).

/*------------------------------------------------------------------------------
  Функции синтаксического анализа делятся на три категории:
  (1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
  После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
  (2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
  (3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

  Формат функций-распознавателей работает в соответствии с TODO Переворошить Parser -- форматы фун-
кций.


====================================================================================================
  [DONE] Синтаксис для указателей на функции
====================================================================================================

  [TODO] 13.04.2008 - 22:05:09,47

  Диспетчеры предполагают регистрацию callback'ов. Для более красивой реализации этого лучше испо-
льзовать вместо FnPtr специальный синтаскис указателей. О том, какой синтаксис надо использовать,
я уже писал в DONE: Особым образом обрабатывать <FnPtr> от 19.03.2008. Тогда я хотел обождать, но
ждать уже хватит. Надо делать. Синтаксис.

  QualifiedName =
    IDENTIFIER | QuadQualified | DotQualified .
  QuadQualified =
    IDENTIFIER '::' IDENTIFIER | QuadQualified '::' IDENTIFIER .
  DotQualified =
    IDENTIFIER '.' IDENTIFIER | DotQualified '.' IDENTIFIER .
  FnPtr =
    '&' IDENTIFIER | ['&'] DotQualified .
  Callable =
    QualifiedName | FnPtr | S-VARIABLE .

  FnPtr может быть как результатным, так и образцовым термом.
  
  Таким образом, квалифицированное имя -- это или квалифицированное квадратиком '::' или квалифици-
рованное точкой имя. Или просто идентификатор. Там где был раньше допустим только квадратик, теперь
допустима и точка. В качестве вызываемой сущности может быть использован и указатель на функцию,
что вполне логично. Такой вызов семантически ничем не должен отличаться от обычного вызова.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Реализован в полном соответствии с TODO. Однако, нетерминал FnPtr распознаётся не отдельной цели-
ковой функцией, а по кусочкам -- кусочки в распознавателях выражений NPatternExpr и NResultExpr (на-
чинается с обнаружения амперсенда или идентификатора) и в NCallable.
  Про вариант синтаксиса < & Module.Function ... > я сначала забыл (поэтому он не определяется ста-
бильной версией), а потом всё-таки вспомнил.


====================================================================================================
  [DONE] Продумать квалификацию точкой
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Забавно то, что в комментарии к этому TODO я планировал решить этот вопрос только после выхода
версии 0.2. Уже давно продумано и даже реализовано. О том, как это было реализовано, написано в DONE
к Синтаксис указателей на функции. Вполне неплохо получилось.


====================================================================================================
  [DONE] Законспектировать спецификацию модели модулей
====================================================================================================

  [TODO] 13.06.2008 - 15:12:23,27

  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.
----------------------------------------------------------------------------------------------------
  [DONE] 14.06.2008 -  1:28:52,75

  Законспектировал. Теперь TODO очень много. Даже не умещаются на одной странице. Модули, относя-
щиеся к поиску модулей, содержат префикс ПИ. Некоторые подчинённые модули не имеют того же префикса.


====================================================================================================
  [DONE] Модуль имитации функций высших порядков
====================================================================================================

  [TODO] 13.06.2008 - 15:12:23,27

  Одно из совсем будущих изменений Модульного Рефала заключается во введении в него функций высших
порядков: возможность порождения (безымянных или с именем) локальных функций со связанными в них
локальными переменными, возврат этих функций (как возвращаемого значения) и т.д. Возможность передачи
объекта-функции (в виде указателя на функцию) внутрь функции и вызова этой функции есть уже сейчас
и реализована средстами FnPtr и <s.X ...>.
  Основными средствами, предоставляемыми этим модулем, должны быть функции Map и Reduce. У меня в
программе активно используются Map- и Reduce-подобные циклы (фактически, это можно рассматривать как
идиому). Но в некоторых случаях идиома скрывается под большим количеством строк, описывающих циклы.
(Интересно то, что здесь я, говоря о циклах, имел ввиду остаточную рекурсию. Циклов в Модульном Рефа-
ле нет. Я уже мыслю остаточную рекурсию в виде циклов). Использование явным образом функций Map и
Reduce сделает код более читабельным.
  Модуль я планирую назвать MLambda.mref. Если он докажет свою полезность, то станет библиотечным.
  Основные средства, предоставляемые модулем.

  Тип лямбда-функции:
    t.Lambda ::= s.FnPtr | [АТД, определённое внутри модуля]

  Вызов лямбда-фукции:
    <Apply t.Lambda e.Arg>
      == e.Result

  Создание лямбда-функции со связыванием слева:
  <BindLeft t.Lambda e.Left>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.Left e.ARG>;
  }

  Создание лямбда-функции со связыванием справа
  <BindRight t.Lambda e.Right>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.ARG e.Right>;
  }

  Функции семейства Map-Reduce
  <Map t.Lambda t.Src*>
    == e.Result*
  <Apply t.Lambda t.Src> == e.Result

  <Reduce t.Lambda t.Accum t.Src*>
    == t.Accum'
  <Apply t.Lambda t.Accum t.Src> == t.Accum'

  <MapReduce t.Lambda t.Accum t.Src*>
    == t.Accum' e.Result*
  <Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

  Функция MapReduce сочетает в себе действие функций Map и Reduce -- преобразует исходное выражение
в новое выражение вместе с передачей состояния. Для функций Reduce и MapReduce существуют парные им
фукнции Reduce-R и MapReduce-R, осуществляющие преобразование справа налево.
  Для АТД, представляющего собой лямбда-функцию, не предоставляется функция Destroy, т.к. объект
первого класса (которым и должен быть объект-функция) может беспрепятственно создаваться, копировать-
ся, возвращаться из функции и уничтожаться.
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 21:17:14,10

  Модуль написан в точности с описанием. Модуль компилируется нормально, но не протестирован. Ни-
чего, оттестируется в процессе использования.


====================================================================================================
  [DONE] Добавить к BE-Mgr поддержку линковщика
====================================================================================================

  [TODO] 01.06.2008 -  2:32:18,92

  Полная ортогональность не достигнута. Вперёд!
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 15:12:23,27

  Поддержка линковщика добавлена. Более того, теперь линковка выполняется также обобщённо, как и
генерация выходных файлов. Модуль mLinker.mref говорит диспетчеру "связывай" и диспетчер вызывает
функцию связывания для каждого из back-end'ов.


====================================================================================================
  [DONE] Абстрактные типы данных
====================================================================================================

  [TODO] 06.10.2007 - 18:35:07,82

  Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.

  [TODO] eXpression eXchange in/out
  Совсем не торопит. Не выделяем.

  [ERROR] Ошибка в MFileSystem при работе с кириллицей
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 15:12:23,27

  В сегодняшней версии (0.1.948) абстрактные типы данных по сути представляют собой надстройку над
идиомой АТД. И я считаю это вполне достаточным для версии 0.2. В дальнейших версиях, вероятно, будут
реализованы более сложные виды АТД: с некоторой внутренней структурой задаваемой образцом, с несколь-
кими конструкторами (как в Haskell). Также будут созданы ограничители на тип переменной, типа тех,
которые описаны в спецификации на АТД ("ATD support.txt"). Также будет возможность полного или час-
тичного экспорта АТД (т.к. если большая часть инварианта заключена в внутреннем формате АТД, то при
автоматической проверке формата инвариант будет сохраняться автоматически). Но это уже относится к
какой-нибудь версии 0.3 или больше. Сейчас надо сконцентрироваться на движке.


====================================================================================================
  [CHANGED] Создан файл спецификаций "Поиск исходников.txt"
====================================================================================================

  [CHANGED] 13.06.2008 - 15:12:23,27

  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.


====================================================================================================
  [FIXED] Ошибка в именах файлов с пробелами
====================================================================================================

  [ERROR] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.
----------------------------------------------------------------------------------------------------
  [FIXED] 12.06.2008 -  1:32:20,20

  Исправил. Вроде работает.


====================================================================================================
  [FIXED] Ошибка в MFileSystem::FilesInfo при работе с кириллицей
====================================================================================================

  [ERROR] 11.06.2008 - 22:03:06,42

  Выяснено: выскакивает ошибка при работе с кириллицей. Надо разбираться.
----------------------------------------------------------------------------------------------------
  [FIXED] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


====================================================================================================
  [FIXED] Ошибка при рекурсивном сканировании папок
====================================================================================================

  [ERROR] 08.06.2008 -  2:49:01,70

  При попытке использовать имя папки, возвращённое функцией MFileSystem::FilesInfo для рекурсивного
просмотра этой папки вылетает ошибка. Эту ошибку можно увидеть в папке Tests/DirSync.
----------------------------------------------------------------------------------------------------
  [FIXED] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


====================================================================================================
  [DONE] Примерное описание работы диспетчеров back- и front-end'ов
====================================================================================================

  [TODO] 18.04.2008 - 22:57:27,21

  Это TODO я удалю, когда дам точные спецификации для работы этих диспетчеров. Или когда эти диспет-
черы я реализую.
  Back-end manager должен позволять зарегистрировать в себе конкретные генераторы выходного кода.
Генератор характеризуется функцией для генерации файла из IModule, расширением выходного объектного
файла, расширением исполнимого файла, папкой для выходных файлов и др. Также может предоставлять фун-
кцию, создающую имя файла из квалифицированного имени.
  Front-end manager должен позволять также регистрировать front-end'ы. Front-end должен предостав-
лять расширение исходного текста, (возможно) имя папки, функцию для парсинга.
  Модуль компиляции и модуль проверки необходимости компиляции ничего не знают о конкретных front-
и back-end'ах, просто пользуются диспетчерами. Модуль компиляции посылает диспетчеру сообщение "гене-
рировать" и тот генерирует.
----------------------------------------------------------------------------------------------------
  [DONE] 01.06.2008 -  1:58:55,72

  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


====================================================================================================
  [DONE] Создать "диспетчеры" back-end'ов и front-end'ов
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Создать модули, хранящие списки зарегистрированных входных и выходных частей. При этом диспетчеры
должны сообщать о зарегистрированных расширениях, папках, в которых следует искать, должны осуществ-
лять вызов анализаторов и генераторов кода.
----------------------------------------------------------------------------------------------------
  [DONE] 01.06.2008 -  1:58:55,72

  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


====================================================================================================
  [DONE] Доделать механизм переименования модулей
====================================================================================================

  [TODO] 29.09.2007 - 22:22:40,36

  Доделать наполовину сделанный механизм переименования модулей.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.

  [TODO] Расширения .rout2 -> .rout
  Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
  Не выделяем.

  [TODO] Единица компоновки -- функция вместо модуля
----------------------------------------------------------------------------------------------------
  [DONE] 24.04.2008 -  0:14:07,31

  Давно у меня это TODO висело. Аж с 29.09.2007. Наконец то сделал. Теперь работает. Как только
я сделаю новый синтаксис для указателей на функции, я заменю стабильную версию и начну активно ис-
пользовать короткие псевдонимы для модулей.


====================================================================================================
  [FIXED] Ошибка в FnPtr
====================================================================================================

  [ERROR] 13.04.2008 - 21:06:47,07

  Реализация этой злополучной функции явила новый сюрприз. Если в качестве параметра указать вместо
имени функции имя АТД, то будет получен "указатель" на этот АТД, т.е. результат будет ошибочным. Нуж-
но на стадии компиляции проверять то, что аргумент FnPtr должен быть не только реально существующей
сущностью, но и должен быть именем функции.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.04.2008 - 22:49:01,30

  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.


====================================================================================================
  [FIXED] Ошибка при разрешении имени функции
====================================================================================================

  [ERROR] 23.04.2008 - 20:49:40,97

  Ранее была найдена ошибка в функции FnPtr. Оказывается ошибка не только в ней. Ошибка возникает
при разрешении любого вызова функции и при разрешении любого описания АТД. Имена функций и АТД разре-
шаются и затем компилируются абсолютно одинаковым образом: заменяется неквалифицированное имя на ква-
лифицированное с известной областью видимости. Причём место замены никак не контролируется: может
быть "правильно" разрешена функция после квадратной или АТД после угловой скобки.
  Слава богу, что синтаксис не позволяет записывать после квадратной скобки квалифицированное имя.
А то можно было бы делать "экспортируемые АТД", используя имя entry-функции после квадратной скобки.
  Кстати, эта ошибка нарушала один из негласных принципов компилятора: генерируемый код на входе
Рефал-5 должен быть абсолютно безошибочным или не генерироваться вообще. А так можно было сгенериро-
вать "вызов АТД" после угловой скобки. Рефал-5 в таких случаях справедливо ругается на необъявленную
функцию.
  Это ERROR я удалю тогда, когда исправлю ошибку. Вместе с ним я удалю упомянутое ERROR про FnPtr.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.04.2008 - 22:49:01,30

  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.


====================================================================================================
  [DONE] Обдумать замену FnPtr на что-то другое
====================================================================================================

  [TODO] 24.02.2008 - 23:49:32,95

  См. файл "Замена FnPtr на что-то другое.txt" (в каталоге спецификаций).
  Когда обдумаю, сделаю DONE для этого TODO и добавлю новое TODO: замена FnPtr на ... .
----------------------------------------------------------------------------------------------------
  [DONE] 23.04.2008 - 20:49:40,97

  Замену я обдумал ещё 13.04.2008 -- синтаксис и семантика для указателей на функции. Просто опять
по ошибке забыл удалить TODO.
  Первое время front- и back-end диспетчеры будут регистрироваться при помощи FnPtr, т.к. необходи-
мо обеспечить совместимость с текущей стабильной версией.


====================================================================================================
  [DONE] Исключение промежуточного представления модуля
====================================================================================================

  [TODO] 04.02.2008 - 16:08:22,32

  Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Продумать и исключить.

  [TODO] Таблица перекрёстных ссылок
----------------------------------------------------------------------------------------------------
  [DONE] 18.04.2008 - 22:57:27,21

  Это TODO я давно выполнил, когда реализовал IModule. Промежуточного представления в старом смысле
в программе нет. Просто по ошибке я забыл удалить это TODO. Вот так, не меняя ни строчки кода, я уст-
ранил одно TODO.


====================================================================================================
  [CHANGED] Изменена реализация контекста
====================================================================================================

  [CHANGED] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.


====================================================================================================
  [DONE] Промежуточное представление как АТД
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  См. комментарий к "SymInfo как АТД". Вопрос решать надо.

  [TODO] Добавление категории "квалифицированное имя"
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [DONE] Промежуточное представление модуля
====================================================================================================

  [TODO] 08.03.2008 - 20:17:27,04

  Атрибутная таблица символов (которая, по сути, лишь двухуровневый ассоциативный массив) -- сама
по себе очень гибкий инструмент: имя может иметь любой набор атрибутов, набор допустимых атрибутов
описывается в файле Attributes.txt, компилятором никак не проверяется. В дальнейшей работе можно про-
сто утонуть во всей этой гибкости. Поэтому нужна оболочка вокруг этой таблицы символов, которая конт-
ролировала бы доступ.
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [DONE] Интегрировать IModule
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Необходимо интегрировать структуру данных IModule в компилятор, т.е. заменить SymTable на неё
там, где надо.
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [CHANGED] Удалён модуль MSymInfo
====================================================================================================

  [CHANGED] 29.03.2008 - 19:33:03,08

  Предполагалось, что модуль MSymInfo будет предоставлять АТД для представления символической ин-
формации. Однако, этот модуль никак не развивался. В качестве промежуточного представления символи-
ческой информации можно использовать структуру IModule, удалив при этом из неё тела функций и инфор-
мацию об не-entry-функциях.
  Потом, когда я переведу компилятор целиком на IModule, я удалю TODO: SymInfo как АТД.


====================================================================================================
  [DONE] Отучить Resolver от старого представления модуля
====================================================================================================

  [TODO] 20.03.2008 -  0:08:54,21

  Модуль MResolver сначала преобразовывает таблицу символов в модуль в старом формате, его проверя-
ет и снова модуль превращает в таблицу символов. Решить этот вопрос. Можно решать этот вопрос в то же
время, когда и буду учить Resolver проверять образцовое выражение. Хотя, вероятно, Resolver придётся
приучать к промежуточному представлению модуля в виде АТД.
  При этом автоматически мы избавимся от MSymTable-Module.
----------------------------------------------------------------------------------------------------
  [DONE] 29.03.2008 - 19:33:03,08

  Теперь Resolver пользуется только таблицей символов. Хотя модуль, инкапсулирующий промежуточное
представление модуля MIModule, написан, он ещё в проекте не используется. Т.е. надо интегрировать.


====================================================================================================
  [FIXED] В таблице символов ошибка -- имя может оказаться без сорта
====================================================================================================

  [ERROR] 22.03.2008 - 21:17:30,11

  Если выполнить команду <MSymTable::RemoveAttrib t.SymTable e.Name Kind>, то в таблице символов
имя вообще окажется без атрибута.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.03.2008 - 20:27:33,79

  Ошибка исправлена. В функцию MSymTable::RemoveAttrib просто добавлен частный случай.


====================================================================================================
  [FIXED] Исправлена ошибка в Parser
====================================================================================================

  [FIXED] 23.03.2008 - 14:22:12,04

  Если при обработке тела модуля функцией MParser::NModuleBody встречался конец файла, функция воз-
вращала результат неправильного формата: t.ErrorList t.SymTable Error, хотя по завершению рекурсив-
ного анализа синтаксиса, должно возвращаться t.ErrorList t.SymTable. Происходила, в общем ошибка.
  Похожая ошибка была и в MParser::MSymModuleBody. Но в этом случае компилятор просто бы завис.


====================================================================================================
  [DONE] Несуррогатно реализовать АТД
====================================================================================================

  [TODO] 19.03.2008 - 23:38:04,78

  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.
----------------------------------------------------------------------------------------------------
  [DONE] 20.03.2008 - 23:03:24,42

  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


====================================================================================================
  [DONE] Научить Resolver проверять образцовое выражение
====================================================================================================

  [TODO] 19.03.2008 - 23:38:04,78

  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.
----------------------------------------------------------------------------------------------------
  [DONE] 20.03.2008 - 23:03:24,42

  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


====================================================================================================
  [DONE] Особым образом обрабатывать <FnPtr>
====================================================================================================

  [TODO] 08.03.2008 - 23:59:52,21

  Проблема FnPtr всё ещё актуальна. Пока я нового синтаксиса для указателей на функции не придумал,
хотя в промежуточном представлении они успешно существуют. Временное решение проблемы состоит в том,
чтобы вызовы <FnPtr ИДЕНТИФИКАТОР*> обрабатывать не как вызов функции, а особым образом -- сразу за-
менять их на указатель в промежуточном представлении.
----------------------------------------------------------------------------------------------------
  [DONE] 19.03.2008 - 23:24:46,88

  Казалось бы, за что боролся, на то и напоролся. Раньше функция FnPtr была автоматически генериру-
емой, то теперь она встроенная. При чём, эту функцию пользователь не может переопределить: если поль-
зователь объявит собственную функцию FnPtr, то она просто не будет вызвана. Вызов <FnPtr ИДЕНТИФИКА-
ТОР* > распознаётся на уровне синтаксического анализа (parser'ом).
  Относительно нового синтаксиса для указателей на функции я склоняюсь к следующему: вводится ква-
лификация точкой, указатель описывается так:
  FuncPointer = "&" IDENTIFIER | ["&"] NonEmptyDotQualifier .
  NonEmptyDotQualifier = IDENTIFIER "." IDENTIFIER | NonEmptyDotQualifier "." IDENTIFIER .
  Т.е. указатель на функцию состоит из "&" и следующим за ним квалифицированным точкой именем. Если
в квалификаторе более, чем два сегмента (т.е. есть хотя бы одна точка). Синтаксически это выражается
нетерминалом -- непустым квалификатором (см. выше). В приципе, можно использовать квалификацию точкой
и в вызовах функций -- ведь по смыслу вызов известным указателем это ведь непосредственный вызов фун-
кции. Но надо подумать, обождать. Хотя додумать надо до того, как я буду вводить в компилятор неско-
лько front- и back-end'ов.
  Кстати, текущая версия компилятора 888.


====================================================================================================
  [DONE] Реорганизация таблицы символов
====================================================================================================

  [TODO] 23.02.2008 - 19:20:11,82

  Модуль таблицы символов выполняет две мало связанные функции -- реализует АТД и выполняет конт-
роль ошибок. Все функции, использующие t.ErrorList, коих немного, желательно вынести из модуля. Одна
из них (AddCurrentModule) вынесется автоматически при выполнении предыдущего TODO. Остальные две
также вынести не сложно.
----------------------------------------------------------------------------------------------------
  [DONE] 08.03.2008 - 20:57:45,78

  Теперь контроль ошибок действий с таблицей символов осуществляется без списка ошибок из MError.
Контроль добавления имени в таблицу символов осуществляется функцией AddNewName, которая помимо таб-
лицы символов возвращает Success или Fails. Добавление ошибки в t.ErrorList осуществляется в модуле
MParser.
  Однако, я всё ещё в стороне от цели. Модуль MParser должен работать не напрямую с таблицей симво-
лов, а с промежуточным представлением модуля. Т.е. нужно создать дополнительный уровень абстракции.


====================================================================================================
  [DONE] Вынести проверку соответствия имени модуля имени файла из MSymTable
====================================================================================================

  [TODO] 23.02.2008 - 19:20:11,82

  Эта проверка происходит в модуле таблицы символов, что значительно усложняет модуль и реализова-
но неестественно (добавляется символ FsName как имя и ему назначается атрибут LowerName, затем эта
запись удаляется). Проще будет организовать эту проверку вне таблицы символов.
----------------------------------------------------------------------------------------------------
  [DONE] 28.02.2008 -  0:40:56,27

  Просто вынес. Теперь эта проверка в MParser. Надо ещё вынести добавление новой сущности и, самое
главное, сравнение имён модуля в начале и конце файла. TODO "Реорганизация таблицы символов" как раз
этому посвящено.


====================================================================================================
  [CHANGED] Реорганизован каталог документации
====================================================================================================

  [CHANGED] 24.02.2008 - 23:49:32,95

  Теперь в папке Documentation появились свои каталоги для журнала и спецификаций. В каталог специ-
фикаций я складываю все TODO, вынесенные в отдельные файлы по причине своего размера (про модульную
концепцию, абстрактные типы данных и атрибутную таблицу символов).


====================================================================================================
  [FIXED] Синтакс переименования модулей
====================================================================================================

  [FIXED] 23.02.2008 - 18:50:39,32

  При обработке консткукции переименования модулей, написанной первоначально, обнаружена ошибка,
позволяющая компилятору принять такие неверные конструкции, как $IMPORT A = B = C;. Когда синтакси-
ческий анализатор писался в первый раз, не планировалось реализовывать переименование модулей в бли-
жайшее время и код был написан небрежно. Теперь эта ошибка исправлена. При обработке конструкции
переименования модуля в атрибут Alias имени импорта (ImportName) добавляется имя псевдонима модуля,
если модуль импортируется без псевдонима, то в Alias добавляется действительное имя.


====================================================================================================
  [DONE] Атрибутная таблица символов
====================================================================================================

  [TODO] 21.02.2008 - 18:29:09,77

  Подробности в файле AttSymTable.txt
----------------------------------------------------------------------------------------------------
  [DONE] 23.02.2008 - 18:50:39,32

  Атрибутная таблица символов реализована, правда не в полном соответствии со спецификацией.
  Реализованы:
  (+) Добавление имени в таблицу символов. В случае, если такое имя уже присутствует, таблица сим-
волов изменяться не должна.
  (+) Получение заданного атрибута заданного имени. Возвращаемое значение должно предусматривать
возможность сообщить об отсутствии этого имени.
  (+) Получение списка всех имён в таблице.
  (+) Установка (обновление) значения заданного атрибута заданного имени. При отсутствии имени
оно должно создаваться с набором атрибутов по умолчанию (возможно, пустым).
  (+) Удаление имени из таблицы. Вопрос о том, что делать при отсутствии имени решится в процессе
кодирования.
  (+) На начальном этапе таблица символов должна предоставлять интерфейс старой таблицы символов.

  (?) Получение списка имён с заданным значением заданного атрибута.*
  Можно получить список имён, имеющих определённое значение атрибута Kind. Атрибут Kind определяет
сорт имени: имя модуля, функция, импорт или АТД, и за каждым сортом закреплён строго определённый
набор атрибутов.

  (-) Получение списка атрибутов, связанных с данным именем. Возвращаемое значение должно предус-
матривать возможность сообщить об отсутствии этого имени.
  Будет добавлено позже.
  (-) Удаление атрибута заданного имени из таблицы. Предусловие: имя должно присутствовать в таб-
лице.
  Будет добавлено позже.
  (-) Проверка существования заданного имени.*
  Вместо этого используется проверка существования атрибута Kind.
  (-) Получение списка имён с заданным атрибутом.*
  (-) Удаление заданного атрибута у всех имён.*
  Будет реализовано позже.

  Функции для работы с таблицей символов делятся на базовые -- реализующие сам АТД, производные,
дополняющие базовые для типичных операций (установка нескольких атрибутов, добавление нового имени
в таблицу, при этом имя в таблице должно отсутствовать, поиск имён по сорту) и специальные, оставлен-
ные в наследство предыдущей таблицей символов. Последний класс функций нужно постепенно удалять из
таблицы, сменяя их на базовые и производные. Уже таким образом устранена функция AddImportModule Так-
же, в процессе работы над проектом, будут добавляться те функции таблицы символов, которые "Будут
реализованы позже".


====================================================================================================
  [CHANGED] Новая стабильная версия!
====================================================================================================

  [CHANGED] 21.02.2008 - 15:51:11,21

  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.


====================================================================================================
  [DONE] Расширения .rout2 -> .rout
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).
----------------------------------------------------------------------------------------------------
  [DONE] 21.02.2008 - 15:51:11,21

  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.


====================================================================================================
  [DONE] Подготовить совместимый с АТД синтаксис
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Это значит, что необходимо подготовить синтаксис, совместимый с Модульным Рефалом версии 0.2+.
Т.е. надо подготовить директиву типа $DATA (см. ATD Support.txt) для обозначения имени абстрактного
типа данных. Квадратные скобки язык поддерживает.
  Просто я хочу заменить текущую стабильную версию (0.1.356) на более новую, в которой и приступить
к разработке АТД и прочей лабуды.
----------------------------------------------------------------------------------------------------
  [DONE] 21.02.2008 - 15:23:05,30

  Для объявления абстрактных типов данных используются директивы $DATA и $data, синтаксис тот же,
что и при объявлении статических ящиков. Действие директивы состоит в том, имя АТД резервируется в
таблице символов, а значит не может использоваться при объявлении функций, swap-ов и в именах моду-
лей. Т.к. синтаксис подготовлен и, хочется в это верить, программа работает довольно стабильно, то
можно заменить старую стабильную версию на новую. Вероятно, также имеет смысл заменить расширение
выходных файлов, например, снова на .rout.


====================================================================================================
  [FIXED] Ошибка с FnPtr
====================================================================================================

  [FIXED] 17.02.2008 - 12:32:34,15

  Возникала ошибка при работе с FnPtr: если пользователь определял собственную функцию FnPtr, то в
объектный файл заносятся два определения -- сначала пользовательская, потом сгенерированная. Счастье,
что линковщик линковал функции в прямом порядке и вторую таким образом игнорировал. А то при измене-
нии линковки и прочих изменениях могли бы возникать глюки. Правда, исправил криво: работоспособно, но
эстетически некрасиво. В любом случае надо переписывать Resolver и создавать атрибутную таблицу сим-
волов.


====================================================================================================
  [DONE] Вывод номера версии компилятора
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

  Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

  Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.
----------------------------------------------------------------------------------------------------
  [DONE] 13.02.2008 - 23:17:52,92

  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


====================================================================================================
  [DONE] Номер версии независимо от компиляции
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.
----------------------------------------------------------------------------------------------------
  [DONE] 13.02.2008 - 23:17:52,92

  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


====================================================================================================
  [CHANGED] Создана утилита для обновления номера версии
====================================================================================================

  [CHANGED] 13.02.2008 - 22:59:00,41

  Утилита называется VersionUpdater. Синтаксис вызова:
  refgo VersionUpdater /verfile:файл_с_номером_версии /srcfile:исходный_текст
  Параметр /srcfile может повторяться. Файл /verfile представляет собой файл того же формата, что
и Info/Version.txt. При запуске утилита считывает номер версии, инкрементирует его и записывает в
файлы, указанные в параметрах /srcfile. В исходном файле должны присутствовать специальные метки
  //{{GEN:VERSION
  //}}GEN
между которыми будет вставлен текст VerNumber = '1.2.3';, окружённый пустыми строками. Вместо 1.2.3
в файле находится инкрементированный номер версии. Если в файле имеется несколько вхождений пар ме-
ток, то текст будет вставлен несколько раз. Если в файле имеется неправильная метка (после GEN: нахо-
дится не VERSION) или будет лишняя //}}GEN без соответствующей открывающей метки, то будет выдано
сообщение об ошибке и файл изменён не будет. Генерируемый текст вставляется между этими двумя мет-
ками, предыдущий текст между ними удаляется. Если в файле отсутствует закрывающая метка //}}GEN, то
она подразумевается перед меткой //{{GEN:* или перед концом файла и при обновлении файла будет до-
бавлена.
  Всем утилитам был в начале присвоен номер компиляции 64 (от балды) и номер версии 0.1 (так же,
как и Модульному Рефалу).


====================================================================================================
  [FIXED] Ошибка в MFileSystem при работе с кириллицей
====================================================================================================

  [ERROR] 19.10.2007 -  1:04:32,32

  Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
  Возможные пути решения:
  (1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
  Преимущества. Подход обобщается на использования других команд консоли Windows.
  Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
  (2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
  Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
  Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

  Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

  Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
  Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.
----------------------------------------------------------------------------------------------------
  [ERROR] 05.02.2008 -  1:22:49,77

  Ошибку необходимо исправить. Даже не обсуждается.

  [TODO] Стандартные модули контейнеров и распространённых функций
  Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

  [TODO] Новая модель модулей
----------------------------------------------------------------------------------------------------
  [FIXED] 12.02.2008 - 19:48:21,36

  Исправлена эта ошибка путём введения функции перекодировщика Dos <--> Win (см. описание ошибки
и способов исправления в записи от 19.10.2007). Создавать приложение для вывода листинга папки я не
стал, т.к.
  (а) лень -- способ более трудоёмок, его преимущества не оправдывают усилий: листингом папки я ещё
ни разу не пользовался;
  (б) привязка Рефала к постороннему приложению -- не удобно;
  (в) перекодировщик полезен сам по себе.
  Помимо перекодировки вывода программы dir, перекодировщик используется в функциях ввода/вывода
модуля InOut, поэтому теперь изнутри программа работает в кодировке Windows. Можно в файлах исходного
текста использовать текстовые строки в кодировке Windows, которые затем будут успешно выводиться пра-
вильно на консоль.
  Недостатком данного подхода является то, что перекодировке подлежат только символы кириллицы, лю-
бые другие символы второй половины кодовой таблицы сохраняются на выходе как есть.
  В идеале Рефал должен использовать внутри себя Unicode.


====================================================================================================
  [DONE] Единица компоновки -- функция вместо модуля
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.

  [TODO] Абстрактные типы данных
----------------------------------------------------------------------------------------------------
  [DONE] 10.02.2008 - 23:17:42,34

  Правильная компоновка наконец реализована. Теперь идеологически .rout-файл представляет собой не
фрагмент генерируемого .ref-файла, в котором требуется только осуществить переименование элементов
и приклеить к .ref-файлу, а набор единиц компоновки (link unit), содержащих в себе ссылки на другие
единицы компоновки. Единицей компоновки может быть локальная или entry-функция или реализация стати-
ческого ящика. Задача линковщика теперь состоит в том, чтобы сгенерировать стартовую функцию Go для
Рефала-5 и прилинковать прямо или косвенно зависящие от неё единицы компоновки. При этом линковщик
производит переименование фукций, индексов и идентификаторов, давая им короткие имена.
  Также теперь .rout-файлы содержат в себе тег версии, который проверяется во время компоновки.


====================================================================================================
  [CHANGED] Изменился вывод сообщений о процессе компиляции
====================================================================================================

  [CHANGED] 09.02.2008 -  3:00:29,53

  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.


====================================================================================================
  [FIXED] Ошибка в MParser::NImportBlock-AfterName
====================================================================================================

  [FIXED] 09.02.2008 -  3:00:29,53

  Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $IMPORT. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.


====================================================================================================
  [FIXED] Ошибка в MOrder::Sort
====================================================================================================

  [FIXED] 09.02.2008 -  3:00:29,53

  Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.


====================================================================================================
  [CHANGED] Квадратные скобки
====================================================================================================

  [CHANGED] 08.02.2008 -  2:54:59,96

  Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


====================================================================================================
  [CHANGED] Директива $CLEARMODULE
====================================================================================================

  [CHANGED] 05.02.2008 -  2:46:46,28

  Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.


====================================================================================================
  [DONE] Составить список приоритетных TODO
====================================================================================================

  [TODO] 04.02.2008 - 23:26:22,87

  Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.
----------------------------------------------------------------------------------------------------
  [DONE] 05.02.2008 -  1:22:49,77

  Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.


====================================================================================================
  [DONE] TODO_list изменяет порядок TODO
====================================================================================================

  [TODO] 05.02.2008 -  1:09:32,10

  Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.
----------------------------------------------------------------------------------------------------
  [DONE] 05.02.2008 -  1:22:49,77

  Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).


====================================================================================================
  [DONE] Удалить прозрачные функции вывода из RTS
====================================================================================================

  [TODO] 02.02.2008 - 17:27:23,22

  Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.
----------------------------------------------------------------------------------------------------
  [DONE] 02.02.2008 - 17:55:52,95

  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.


====================================================================================================
  [DONE] Удалить MRefalRTS::Lenw
====================================================================================================

  [TODO] 02.02.2008 - 17:15:41,26

  Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.
----------------------------------------------------------------------------------------------------
  [DONE] 02.02.2008 - 17:55:52,95

  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.


====================================================================================================
  [DONE] Создание папок Defs и ROut по требованию
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 23:01:49,86

  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


====================================================================================================
  [DONE] Генерация Info/Log.txt по требованию
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 23:01:49,86

  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


====================================================================================================
  [DONE] Новая семантика идентификатора
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 21:21:01,49

  Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
  Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

  Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.


====================================================================================================
  [CHANGED] TODOs.txt -- сводка только TODO и ERROR
====================================================================================================

  [CHANGED] 20.10.2007 - 19:08:06,05

  Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.


====================================================================================================
  [DONE] Автоматизация списка TODO
====================================================================================================

  [TODO] 20.10.2007 - 16:06:51,06

  Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
  \[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).
----------------------------------------------------------------------------------------------------
  [DONE] 20.10.2007 - 17:59:43,10

  Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


====================================================================================================
  [DONE] Функция MOS::ArgList
====================================================================================================

  [TODO] 20.10.2007 - 16:06:51,06

  Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
  <MOS::ArgList> == e.Args
  e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
  t.ArgK ::= (e.ArgK)
----------------------------------------------------------------------------------------------------
  [DONE] 20.10.2007 - 17:59:43,10

  В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).


====================================================================================================
  [CHANGED] MFileSystem стал библиотечным
====================================================================================================

  [CHANGED] 19.10.2007 -  1:04:32,32

  Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


====================================================================================================
  [CHANGED] Удалена ROut
====================================================================================================

  [CHANGED] 16.10.2007 - 22:06:30,03

  Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


====================================================================================================
  [DONE] Исправить зависимую от MOS::Env MOS::EnvList
====================================================================================================

  [TODO] 16.10.2007 - 21:50:54,61

  Изменить соответствующим образом MOS::EnvList.
----------------------------------------------------------------------------------------------------
  [DONE] 16.10.2007 - 22:06:30,03

  Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.


====================================================================================================
  [FIXED] MOS::Env корректно работает с кириллицей
====================================================================================================

  [FIXED] 16.10.2007 - 21:50:54,61

  Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.


====================================================================================================
  [DONE] Переименовать модуль Refal5
====================================================================================================

  [TODO] 30.09.2007 -  0:37:49,72

  Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.
----------------------------------------------------------------------------------------------------
  [DONE] 12.10.2007 - 22:09:54,55

  Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


====================================================================================================
  [CHANGED] Папка ROut2
====================================================================================================

  [CHANGED] 12.10.2007 - 22:09:54,55

  По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.


====================================================================================================
  [DONE] Указатели на функции или функция Mu
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
  Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

  Mu {
    F e.Arg = <F e.Arg>;
    G e.Arg = <G e.Arg>;
    H e.Arg = <H e.Arg>;
    Mod1 A e.Arg = <Mod1::A e.Arg>;
    Mod1 B e.Arg = <Mod1::B e.Arg>;
    Mod1 C e.Arg = <Mod1::C e.Arg>;
    Mod2 A e.Arg = <Mod2::A e.Arg>;
    Mod2 C e.Arg = <Mod2::C e.Arg>;
    Mod2 D e.Arg = <Mod2::D e.Arg>;
  }

  Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
  Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.
----------------------------------------------------------------------------------------------------
  [DONE] 07.10.2007 -  0:23:54,89

  Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождественны
идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова ука-
зателей таков (см. Syntax.txt).
  
  FunctionCall = '<' Callable ResultExpr '>' .
  Callable = FunctionName | Qualifier '::' FunctionName
    | SwapName | S-VARIABLE .

  Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
  Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

  Context::FnPtr::Local {
    Create =
      $Context::Create::Entry$ ;
    UpdateModuleInfo =
      $Context::UpdateModuleInfo::Entry$ ;

    // Часть пропущена

    AppendError =
      $Context::AppendError::Entry$ ;
    FnPtr =
      $Context::FnPtr::Local$ ;
    MModulesList UpdateModuleInfo =
      $MModulesList::UpdateModuleInfo::Entry$ ;
    MModulesList LastModule =
      $MModulesList::LastModule::Entry$ ;
    MModulesList ExtractOption =
      $MModulesList::ExtractOption::Entry$ ;
    MModulesList GetProgName =
      $MModulesList::GetProgName::Entry$ ;
    MModulesList ExtractModulesList =
      $MModulesList::ExtractModulesList::Entry$ ;
  }

  В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
  Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

  Test::IndirectCall::Local {
    s.Function =
      <Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
  }

  Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
  $MODULE Indirect;

  /*
    <ForAll s.FnPtr t.Term*>
      == e.Result*
    где e.Result = <s.FnPtr t.Term>
  */
  $ENTRY ForAll {
    s.FnPtr t.Next e.Tail =
      <s.FnPtr t.Next>
      <ForAll s.FnPtr e.Tail>;

    s.FnPtr = ;
  }

  $END Indirect.

  Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

  $MODULE Convert;

  $IMPORT MStrings, Indirect;

  $ENTRY NumsToStrings
    e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

  ToStr s.Num = <MStrings::Symb s.Num> ' ';

  $END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
  Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


====================================================================================================
  [CHANGED] Компиляция структурных скобок по-новому
====================================================================================================

  [CHANGED] 06.10.2007 - 18:35:07,82

  Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.


====================================================================================================
  [DONE] FileIO-дескрипторы в статическом ящике
====================================================================================================

  [TODO] 30.09.2007 -  0:37:49,72

  Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.
----------------------------------------------------------------------------------------------------
  [DONE] 30.09.2007 -  0:57:58,78

  С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.


====================================================================================================
  [DONE] Статические ящики
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
  Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

  ModuleName::SomeHolder::Swap {
    e.NewValue =
      <Dg ('ModuleName::SomeHolder')>
      <Br ('ModuleName::SomeHolder') '=' e.NewValue>;
  }

  Синтаксически можно использовать конструкцию, похожую на список импорта:

  $SWAP SomeHolder, OtherSomeHolder;

  Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).
----------------------------------------------------------------------------------------------------
  [DONE] 30.09.2007 -  0:37:49,72

  Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
  Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
  Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.


====================================================================================================
  [DONE] Элемент (Module e.ModuleName)
====================================================================================================

  [TODO] 29.09.2007 - 22:22:40,36

  Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 29.09.2007 - 23:18:10,03

  Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
  
  Было:

  t.Module ::=
    (t.SymTable t.ModuleContent)

  t.ModuleContent ::=
    ( (ModuleName e.ModuleName)
      t.Element*
    )

  Стало:

  t.Module ::= (t.SymTable e.ModuleContent)

  e.ModuleContent ::= t.Element*


====================================================================================================
  [DONE] Резервное копирование
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

  Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.
----------------------------------------------------------------------------------------------------
  [DONE] 29.09.2007 - 21:53:16,11

  Реализовано резервное копирование.


