====================================================================================================
  [DONE] ИиПЦФ: Расширить структуру командной строки указаниями целевых файлов
====================================================================================================

  [TODO] 21.07.2010 -  0:44:01,39

  Т.е. добавить группы ( -target:targetname ) к именам файлов исходных текстов. Вполне возможно,
что группы могут содержать и ряд дополнительных опций, касаемых компоновки конкретных гроздей.
(т.к. обработка нескольких перекрывающихся гроздей не позволяет тонко управлять компиляцией каждой
грозди индивидуально).
  Рамки этого TODO ограничены лишь поддержкой групп командной строкой --- при указании группы, со-
держащей описание целевого файла, компилятор не должен выдавать синтаксических ошибок.
----------------------------------------------------------------------------------------------------
  [DONE] 23.07.2010 -  0:48:04,19

  Сделано в полном соответствии с TODO в заданных рамках.


====================================================================================================
  [DONE] ИиПЦФ: Имя целевого файла в Pt-формате
====================================================================================================

  [TODO] 21.07.2010 -  0:44:01,39

  Компоновщики back-end'ов, т.е. функции Link, которые вызываются для получения из горсти промежу-
точных файлов целевого файла, должны принимать имя целевого файла в Pt-формате.
  Рамки этого TODO ограничены изменением указанных функций для передачи путей в Pt-формате и под-
системы, вызывающей эти функции соответсвующим образом.
----------------------------------------------------------------------------------------------------
  [DONE] 23.07.2010 -  0:48:04,19

  Сделано в полном соответствии с TODO в заданных рамках.


====================================================================================================
  [DONE] Интегрировать Простой Рефал в общую структуру каталогов
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  На данный момент файлы, относящиеся к Простому Рефалу, находятся в каталоге /Simple Refal относи-
тельно корня проекта. Папка Simple Refal имеет ту же каталоговую структуру, что и подпапки лаб по
Простому Рефалу (т.к. представляет собой фактически копию лабы версии 004) и включает в себя давно
устаревший bootstrap-каталог (т.к. необходимости в его обновлении нет, скрипт автоматического обно-
вления не предусмотрен); исходные тексты компилятора, библиотеки и сопутствующих утилит: генератора
лексического анализатора и препроцессора Простого Рефала в Модульный; а также папка с набором уста-
ревших тестов и заготовок для написания внешних функций.
  В общем, схема неплохая. Но есть и недостатки, а именно
  1. Исходные тексты Простого Рефала находятся как-то поодаль относительно прочих исходных текстов,
входящих в проект, что идеологически усложняет общее дерево каталогов проекта.
  2. В каталогах bootstrap и "Тесты и заготовки" много уже давно нерелевантных файлов, так что, воз-
можно, их следует удалить.
  3. Обособленность исходных текстов затрудняет написание общего скрипта перекомпиляции и пересбор-
ки.
  4. Файлы библиотеки времени выполнения refalrts.h и refalrts.cpp присутствуют в двух разных ката-
логах, что усложняет их синхронизацию (на данный момент они не синхронизированы).
  Задачу считаю приоритетной (для версии 0.2), т.к. устраняет логическую ошибку, связанную с рассин-
хронизацией исходных текстов библиотеки времени выполнения.
----------------------------------------------------------------------------------------------------
  [TODO] 02.07.2010 - 12:59:05,15

  Есть мысль сконвертировать утилиты типа генератора лексического анализатора и srmake в Модульный
Рефал и поместить в общий каталог утилит. Хотя, сомнительно.
----------------------------------------------------------------------------------------------------
  [TODO] 10.07.2010 - 23:01:10,34

  Исходные тексты перенесены в каталог Sources/Compiler.sr, библиотечные модули --- в каталог Sour\
ces/Library.sr, рантайм refalrts.h/refalrts.cpp объёдинён с рантаймом Модульного Рефала. Тесты и
утилиты (LexGen, srmake и srprep) помещены в каталоги Sources/SRTests и Sources/SRUtils соответст-
венно, т.к. что с ними делать, я пока не знаю.
  Есть мысль организовать общий скрипт пересборки, который обновляет не только Модульный Рефал, но
и Простой. Т.к. Простой Рефал предполагается частью Модульного Рефала, то можно ему назначить тот
же номер версии, что и у Модульного Рефала.
  Как только я решу, что сделать с тестами и утилитами, а также разберусь с предыдущей мыслью (воп-
лощу или откажусь), я завершу это TODO.
----------------------------------------------------------------------------------------------------
  [DONE] 21.07.2010 -  0:44:01,39

  Утилиты, написанные на Простом Рефале (SRMake и LexGen) очень удачно интегрированы в структуру
каталога с остальными утилитами:
  1) команда Far-меню "Make it" умеет распознавать расширение файла и вызывать для исходника на
Простом Рефале соотвествующий компилятор. Более того, можно выделить несколько исходников и отком-
пилировать их единовременно, что целесообразно для Простого Рефала (т.к. он не может по одному ис-
ходному файлу найти все остальные, (когда я делал эту возможность, забыл о SRMake));
  2) аналогично пополнен скрипт make_all.bat, проводящий полную перекомпиляцию всех исходных текс-
тов;
  3) когда я переименовывал библиотечные модули (MFileIO, MInOut, MMath), я забыл поправить исход-
ные тексты утилит, поэтому поправлять их пришлось сейчас.
  Кроме того, был написан общий скрипт для сборки Простого и Модульного Рефала. При запуске Просто-
го Рефала теперь тоже отображается номер версии, который совпадает с версией Модульного Рефала. Как
гласит строка о номере версии (Simple Refal, part of Module Refal 0.1.973 (c) Mazdaywik 2008-2010),
Простой Рефал в текущей ипостаси рассматривается как часть Модульного Рефала.
  Тесты перенесены в подкаталог /Tests/Simple Refal.


====================================================================================================
  [DONE] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 17:52:48,14

  Относительно предыдущего TODO-звена сделано следующее.
  (1) Математическая библиотека только расширилась вышеупомянутыми функциями.
  (2) Что касается упрощения переносимости, то с этой точки зрения библиотека сильно изменилась. Во
многих случаях добавились дополнительные слои абстракции, выраженные пакетами CoreBE и CoreOS, хотя
внимание было больше сосредоточено на переносимости между back-end'ами в рамках платформы Windows.
  Для достижения более чёткой переносимости между различными операционными системами следует тща-
тельнее проанализировать модули MOS и MFileSystem, вынося из них код на Рефале, характерный для ОС
Windows.
  (3) Поскольку последние изменения библиотеки касались в большей степени внутренней структуры, чем
интерфейса, переносить модули библиотеки в пакет я не счёл нужным. Перенос модулей библиотеки в па-
кет логически относится к изменению интерфейса библиотеки, поэтому его следует отложить до того вре-
мени, когда нужно будет существенно переработать интерфейс. Последнее целесообразнее делать после
введения в язык вложенных функций --- в этом случае замыкания будут гораздо активнее применяться в
языке и, соответственно, интерфейс библиотеки надо будет адаптировать под изменение стилей програм-
мирования.
  Итог. Для завершения данного TODO следует грамотно переработать библиотеку с точки зрения перено-
симости между различными ОС.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, т.к. в круг задач входит получение стабиль-
ной и логически согласованной библиотеки.
----------------------------------------------------------------------------------------------------
  [DONE] 19.07.2010 - 22:17:22,22

  Библиотека версии 0.2 сделана. В её интерфейс входят следующие модули:

  * MFileIO --- чтение и запись текстовых файлов, как построчно, так и загрузка и сохранение цели-
ком;
  * MFileSystem --- функции файловой системы: атрибуты файлов, список файлов в каталоге, создание
каталогов, удаление файлов и каталогов;
  * MInOut --- консольный ввод-вывод;
  * MLambda --- поддержка функций высших порядков: списочные морфизмы (Map, Reduce, MapReduce),
комбинаторы, с которыми проще программировать в языке без вложенных функций;
  * MMath --- поддержка простых математических действий в Модульном Рефале;
  * MOS --- функции операционной системы: аргументы командной строки, переменные окружения, запуск
команды оболочки (функция System);
  * MOrder --- функции сравнения и упорядочивания (сортировки);
  * MSelfDiag --- диагностические функции: утверждения, диагностическая печать;
  * MStrings --- функции работы с объектными выражениями: определение длины, отсечение нужного ко-
личества термов, преобразования типов атомов, с недавнего времени в неё входит и простая классифи-
кация символов (заглавная и строчная буква, цифра);
  * MSwapSupport --- функции работы со статическими ящиками: копирование значения из ящика, добав-
ление с конкатенацией, извлечение первого или последнего терма, эмуляция копилки;
  * MXXIO --- ограниченная сериализация объектых выражений (eXpression eXchange In Out --- XXIO по
образцу Рефала 5).

  Текущее состояние библиотеки должно оставаться неизменным до выхода версии 0.2.


====================================================================================================
  [DONE] СМКиРФ: Префикс M для модулей
====================================================================================================

  [TOTHINK] 09.07.2010 - 21:50:39,95

  На данный момент в библиотеке насчитывается 22 модуля, из них 13 не входят в пакеты Core*, т.е.
представляют собой API языка. Вот они:

  * FileIO
  * InOut
  * Math
  * MDosWinRecoder
  * MFileSystem
  * MLambda
  * MOrder
  * MOS
  * MSelfDiag
  * MStrings
  * MSwapSupport
  * MXXIO
  * Types

  Как видно, 4 модуля, исторически появившиеся раньше других, не имеют префикса M, остальные имеют,
что демострирует неединообразие интерфейса библиотеки.
  Отсюда вопрос: следует ли ради единообразия добавить или удалить у всех модулей префикс M или же
оставить всё как есть?
  Строго говоря, по хорошему надо у некоторых модулей сменить имя (а не только добавлять/удалять
префикс), но это уже серьёзная переработка интерфейса.
  Вопрос отношу к приоритетным, т.к. отражается на эстетической целостности интерфейса. К тому же
это подзадача приоритетной задачи.
----------------------------------------------------------------------------------------------------
  [TODO] 17.07.2010 - 20:45:57,84

  На данный момент осталось всего три модуля без префикса M: FileIO, InOut и Math. Модуль Types был
объединён с модулем MStrings.
  Я решил остановиться на единообразии: поскольку большинство модулей библиотеки имеют префикс M,
то разумнее переименовать более малочисленные модули (хотя в библиотеке для совместимости можно ос-
тавить модули и без префиксов).
  Вывод. Надо переименовать модули.
----------------------------------------------------------------------------------------------------
  [DONE] 19.07.2010 - 22:17:22,22

  Указанные модули переименованы. Теперь в интерфейсе библиотеки не осталось ни одного модуля без
префикса M (есть модули без префикса M, но они запрятаны внутри реализации --- пакетов Core***).


====================================================================================================
  [DONE] СМКиРФ: Модуль Types объединить с MStrings
====================================================================================================

  [TODO] 10.07.2010 - 15:35:46,55

  Модуль содержит средства для определения типа, а точнее, класса символа (character): является ли
он буквой, цифрой или прочим символом. В модуле MStrings находятся функции для преобразования сим-
волов, среди которых есть и функции Upper и Lower, которые выполняют сходные задачи. Поскольку мо-
дуль --- это набор логически взаимосвязанных средств, то имеет смысл эти модули объединить.
  Задача приоритетная как подзадача приоритетной задачи.
----------------------------------------------------------------------------------------------------
  [DONE] 10.07.2010 - 23:01:10,34

  Объединил. Возникшие в модуле MRefal-FE::MLexer (это был единственный модуль, использующий этот
модуль библиотеки) синтаксические ошибки были тут же исправлены.


====================================================================================================
  [DONE] СМКиРФ: Нужен ли модуль MDosWinRecoder в интерфейсе библиотеки
====================================================================================================

  [TOTHINK] 09.07.2010 - 21:50:39,95

  На данный момент этот модуль используется только для преобразования кодировки в операциях консоль-
ного ввода-вывода (да и то не совсем корректно, т.к. преобразует только символы кириллицы). Раньше
он также применялся для преобразования кодировки переменных среды, получаемых из вывода команды
SET оболочки.
  Таким образом, вне библиотеки он нигде не используется (во всяком случае, я его не использовал).
На мысль спрятать модуль в один из Core-пакетов, меня натолкнул тот факт, что библиотеку следует
делать переносимой между различными платформами, в частности перенести под платформу POSIX, где
консольный ввод-вывод выполняется отнюдь не в кодировке CP866 (скорее всего, в UTF-8). Поэтому наз-
вание модуля MDosWinRecoder будет как минимум неадекватно выполняемой задаче.
  Кроме того, когда писался этот модуль, предполагалось, что файлы исходного текста будут написаны
преимущественно в кодировке CP1251. Сейчас часть модулей уже написана в кодировке UTF-8, что делает
запись выводимого текста кириллицей в надежде на корректный вывод на консоль бессмысленной.
  По-нормальному, следует разработать универсальные гибкие удобные средства локализации, позволяю-
щие работать со множеством различных кодировок, что подразумевает поддержку Юникода на уровне ран-
тайма и поддержку большого количества различных кодовых таблиц, а не использование только двух ва-
риантов.
  Модули исходного текста могут быть написаны скорее всего в трёх возможных кодировках: DOS (CP866),
т.к. она является дефолтовой в консольных текстовых редакторах, в частности в Far Manager'е старых
версий, ANSI (CP1251), т.к. её можно установить в качестве дефолтовой в Far Manager'е современных
версий и большом количестве редакторов под Windows, UTF-8, т.к. эта универсальная кодировка являет-
ся переносимой между различными платформами и скорее всего является дефолтовой в большинстве совре-
менных дистрибутивов Linux (основная реализация платформы POSIX; тщательно это утверждение не про-
верял).
  Дальнейшую разработку Модульного Рефала предполагается продолжать в Far Manager'е, хотя другие
продвинутые текстовые редакторы, такие как Vim и Emacs, тоже нельзя сбрасывать со счетов. При воз-
можном портировании под POSIX будет использован скорее всего Vim, т.к. в отличии от Emacs, я им умею
пользоваться.
  Из всего вышеизложенного можно сделать вывод, что предполагать внутренней кодировкой для символов
в Модульном Рефале CP1251 не следует, проще этот вопрос пока оставить открытым (Модульный Рефал ис-
пользует однобайтовую кодировку ASCII, а какую конкретно --- как повезёт). Точно также говорить о
кодовой странице консоли также не следует.
  Поэтому можно даже поставить вопрос таким образом: нужен ли этот модуль в библиотеке вообще?
  Наличие этого модуля как раз отражает факт использования внутренней кодировки Windows, внешней
(для ввода-вывода) --- DOS, что некорректно.

  Можно сказать, что этот вопрос для обдумывания является подзадачей подзадачи приоритетной задачи,
т.к. относится к переносимости библиотеки, а значит сам является приоритетным.
----------------------------------------------------------------------------------------------------
  [TODO] 10.07.2010 - 15:35:46,55

  Не нужен по приведённым выше соображениям.
  К соображениям выше также можно добавить, что функции MStrings::Upper и MStrings::Lower, а также
модуль Types, считают за буквы только символы латинского алфавита, следовательно, можно сказать о
компиляторе и библиотеке то, что используемая кодовая страница не определена.

  Вообще, этот модуль я уже удалил, но не хочу писать DONE, т.к. не хочу пока делать сбоку.
----------------------------------------------------------------------------------------------------
  [DONE] 10.07.2010 - 23:01:10,34

  Модуль удалён. Процитирую последний абзац из предыдущего DONE, т.к. он даёт исчерпывающий ответ
на вопрос.

|     Кроме того, был удалён модуль MDosWinRecoder, т.к. он не нужен в текущем варианте (или надо
|   делать полноценную библиотеку для работы с кодовыми страницами, или считать, что Модульный Ре-
|   фал работает в какой-то однобайтовой кодировке). Этот модуль был написан из предпосылки, что
|   исходные тексты будут писаться в кодировке ANSI, а консоль будет работать с OEM-кодировкой. Ра-
|   зумеется, под Линуксом эти утверждения перестают соответствовать истине. Более того, сейчас ряд
|   исходных текстов сохранён в кодировке UTF-8, поэтому без поддержки Юникода в рантайме говорить
|   о кодовой таблице бессмысленно.


====================================================================================================
  [DONE] СМКиРФ: Подготовка библиотеки к переносимости между различными ОС
====================================================================================================

  [TODO] 01.05.2010 - 17:52:48,14

  Суть в том, чтобы подготовить библиотеку к переносу на другие платформы, прежде всего, под плат-
форму POSIX. Выбор последней обусловлен тем, что это достаточно распространённая платформа (вклю-
чает в себя GNU/Linux, *BSD, QNX и даже MacOS X) и у меня есть опыт работы с двумя представителями:
QNX и GNU/Linux. DOS я не рассматриваю вследствие большого объёма исполнимого файла (несколько ме-
габайт) и больших потребностей в оперативной памяти, что затрудняет работу с ним. Мобильные платфор-
мы я не рассматриваю по двум причинам: у меня на данный момент нет смартфона и Рефал на них не так
уж и нужен.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, как подзадача требуемой задачи.
----------------------------------------------------------------------------------------------------
  [DONE] 10.07.2010 - 23:01:10,34

  Подготовка к переносимости состояла в локализации кода, который необходимо будет переписать при
переносе Модульного Рефала прежде всего под платформу POSIX. Код, который будет подвержен изменени-
ям, был максимально вынесен в отдельные файлы и отделён от кода, который оставался бы общим для
двух вариантов библиотеки.
  В результате были прежде всего проанализированы и переработаны модули MFileSystem и MOS, косвенно
обращающиеся к функциям Windows API, модуль реализации библиотеки baselib.h/baselib.cpp был разбит
на два модуля: mr_common.h/mr_common.cpp, содержащий общий код для обоих платформ и mr_oslib.h/
mr_oslib.cpp, содержащий специфический для ОС код.
  Кроме того, был удалён модуль MDosWinRecoder, т.к. он не нужен в текущем варианте (или надо делать
полноценную библиотеку для работы с кодовыми страницами, или считать, что Модульный Рефал работает
в какой-то однобайтовой кодировке). Этот модуль был написан из предпосылки, что исходные тексты бу-
дут писаться в кодировке ANSI, а консоль будет работать с OEM-кодировкой. Разумеется, под Линуксом
эти утверждения перестают соответствовать истине. Более того, сейчас ряд исходных текстов сохранён
в кодировке UTF-8, поэтому без поддержки Юникода в рантайме говорить о кодовой таблице бессмысленно.


====================================================================================================
  [FIXED] Компилятор на Рефале 5 падает на функции System
====================================================================================================

  [ERROR] 02.07.2010 - 12:59:05,15

  При достаточно длинных аргументах встроенной функции System Рефала 5, интерпретатор падает с ошиб-
кой нехватки памяти. Сначала я предполагал, что ошибка связана обычным переполнением изначально за-
данного фиксированного объёма памяти, но увеличив объём до 300 единиц кода и 200 поля зрения (т.е.
-c300 -l200 в командной строке), я от ошибки не избавился. Так что предположительно, длина команд=
ной строки, принимаемой функцией System, меньше приблизительно 3000 байт (примерно такую длину име-
ет командная строка при самомприменении компилятора с профилями Простого Рефала и C++/SR).
  При превышении этого лимита, функция, вместо стандартного нарушения формата встроенной функции,
возвращает недостаток памяти.
  Возможным путём решения является генерация bat-файла, который и содержит эту длинющую строку.
----------------------------------------------------------------------------------------------------
  [FIXED] 09.07.2010 - 20:34:59,06

  Ошибка исправлена так, как и предполагалось: создаётся временный файл-сценарий, который затем и
запускается. Вроде работает.


====================================================================================================
  [FIXED] В некоторых случаях падает профиль Простого Рефала
====================================================================================================

  [ERROR] 02.07.2010 - 12:59:05,15

  Ошибка возникает в back-end'е Простого Рефала, если .cpp-файл (в широком смысле), являющийся ре-
зультатом компиляции исходного текста на Простом Рефале, отсутствует (как правило, из-за ошибок
компиляции).
  Ошибка проявляется, если такой .cpp-файл предполагается копировать для избежания конфликта имён,
в результате возникает ошибка открытия файла.
----------------------------------------------------------------------------------------------------
  [FIXED] 09.07.2010 - 20:34:59,06

  Исправлено. Теперь компилятор Простого Рефала предоставляет ключ -e filename, который задаёт имя
файла, который создаётся при наличии синтаксических ошибок. При отсутствии ключа в командной строке
никакой файл не создаётся, т.к. никаких значений по умолчанию для данного поведения не предусмотре-
но. Создаваемый файл является пустым, т.к. предназначен исключительно для использования внутри ком-
поновщика back-end'а Простого Рефала --- наличие этого файла-флага сигнализирует о неудачной компи-
ляции.
  Интересно отметить, что для поддержки этого ключа в компиляторе Простого Рефала был использован
объектно-ориентированный подход (впервые в моей практике в реальном коде). Во-первых, парсером ко-
мандной строки возвращается объект, хранящий информацию о командной строке компилятора и имени фай-
ла-флага. Во-вторых, в самом парсере командной строки используется объект-состояние, который изме-
няется при обнаружении тех или иных опций (-c и -e). В результате у нас имеется 5 разновидностей
объекта-состояния: 4 для случая наличия-отсутствия каждой из двух опций и один для состояния ошиб-
ки, в которое переходит парсер при обнаружении дублирующихся опций. Очевидно, что хотя такой под-
ход с одной стороны инкапсулирует обработку аргументов (парсер при обнаружении опций выполняет ме-
тоды #CAddCompileCommand и #CAddErrorFile, которые возвращают новое состояние-объект), с другой
стороны требует экспоненциального роста числа состояний при расширении компилятора новыми опциями,
требующими уникального появления в командной строке. Более грамотный дизайн объектов-состояний спо-
собен решить эту проблему.
  Альтернативным способом исправления этой ошибки мог бы быть перебор всех ожидаемых скомпилирован-
ных файлов с проверкой существования (MFileSystem::ExistFile), который не потребовал бы переработки
компилятора Простого Рефала. В частности, для этой цели можно было бы использовать функцию поиска
файлов библиотеки времени выполнения C-Link::MLinker::LookupRuntimeFiles, передав которой только
расширение выходных файлов Простого Рефала (в случае компиляции в Си++ --- .cpp). Недостатком этого
способа является то, что проверка наличия файлов не сможет перехватить ошибку в модуле рантайма,
написанного на Простом Рефале, который был недавно изменён, но при этом осталась его старая "тень"
в виде скомпилированного файла. Недостаток устраняется путём принудительного удаления всех "теней",
что может быть проблематично, если библиотечные файлы защищены от записи (например, если они нахо-
дятся в папке %programfiles%, доступном для записи только администраторам; хотя, как тогда можно об-
новить файл рантайма на Простом Рефале (стирать это предложение ввиду глупости не буду, т.к. после-
дующие мысли интересные)). К слову сказать, Модульный Рефал не готов к случаю, если модули библио-
теки будут представлены файлами с исходным текстом, при этом располагающихся в подобных каталогах,
доступных только для чтения. Компиляторы Си++, такие как MS VC или BCC, имеют защиту от подобного
поворота событий, т.к. по умолчанию располагают объектные файлы в текущем каталоге (если, конечно,
текущий каталог доступен для записи), с чем я и борюсь путём копирования.
  Перекомпиляцию компилятором Простого Рефала можно было бы оптимизировать, введя сравнение времён
обновления условно .sref- и .cpp-файлов по принципу утилиты make. Двухкратное сравнение времён пар
.sref-файл--.cpp-файл до и после компиляции могло бы зафиксировать ошибки компиляции, т.к. соответ-
ствующий выходной файл не был бы найден. Однако это замедлит работу устаревшего, но в то же время
используемого профиля Рефала 5.


====================================================================================================
  [DONE] Добавить escape-последовательности в Модульный Рефал
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  Модифицировать лексический анализ таким образом, чтобы компилятор поддерживал больший набор esca-
pe-последовательностей, включая \xXX и \ooo.
  Не смотря на то, что это изменение синтаксиса (а точнее, лексики), я его отношу к приоритетным,
т.к. это имеет прямое отношение к юзабельности компилятора (программисты традиционно привыкли ис-
пользовать шестнадцатиричные или восьмеричные коды в противовес имеющимся десятичным).
----------------------------------------------------------------------------------------------------
  [DONE] 02.07.2010 - 12:59:05,15

  Лексический анализатор был пополнен как escape-последовательностями, позволяющими явно задать код
символа в виде восьмеричного или шестнадцатиричного числа, так и односимвольными последовательнос-
тями. Набор односимвольных последовательностей на данный момент включает в себя следующие:

  Символ     Код    Обозначение   Смысл
    \a       \x07       bel       сигнал
    \b       \x08       bs        возврат на шаг
    \f       \x0C       ff        перевод страницы
    \n       \x0A       lf        перевод строки
    \r       \x0D       cr        возврат каретки
    \t       \x09       ht        горизонтальная табуляция
    \v       \x0B       vt        вертикальная табуляция
    \\       \x5C       \         обратная косая черта
    \'       \x27       '         апостроф
    \"       \x22       "         двойная кавычка

  Последовательности для числовых кодов \xHHH...H и \OOO имеют те же особенности, что и в Си++: в
шестнадцатиричном представлении число шестнадцатиричных цифр неограничено, в восьмеричном --- не
больше 3 цифр. Это касается как Модульного, так и Простого Рефала.


====================================================================================================
  [DONE] Уйти от использования bat-файлов на стадии компоновки
====================================================================================================

  [TOTHINK] 17.04.2010 - 17:40:47,00

  На данный момент профили Простого Рефала и C++/SR используют генерацию bat-файлов для вызова сто-
ронних компиляторов. Это нежелательно по следующим причинам:
  (а) снижает переносимость, т.к. привязывает к платформе Windows;
  (б) засоряет каталог ненужными файлами;
  (в) требует использования в качестве компилятора строки вида 'call compile_cl.bat', что открывает
детали реализации (то, что генерится батник).
  В то же время, сгенерированный bat-файл позволяет лучше понять содержимое командной строки и в
ряде случаев упрощает отладку.
  В общем, это надо обдумать.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Если версия 0.2 будет кроссплатформенной, то этот пункт важен. В противном
случае bat-файлы можно оставить (разумеется, удаляя пакетные файлы сразу после их выполнения ---
сейчас эта возможность закомментирована).
----------------------------------------------------------------------------------------------------
  [TODO] 01.07.2010 - 20:39:07,96

  Опять я нарушил дисциплину и забыл во-время преобразовать TOTHINK в TODO. Поэтому отсюда это фор-
мальное TODO.
----------------------------------------------------------------------------------------------------
  [DONE] 01.07.2010 - 20:39:07,96

  Модуль компиляции исходных файлов на Си++ сам отвечает за копирование файлов и вызов компилятора
языка Си++, причём делает это без использования bat-файлов. Поэтому bat-файлы в тех местах, где они
использовались раньше, стали не нужны.


====================================================================================================
  [DONE] Модуль компиляции исходных файлов на Си++
====================================================================================================

  [TODO] 12.01.2010 - 12:46:39,51

  Идея этого задания в том, что компиляцию сгенерированных исходных текстов на Си++ локализовать в
одном модуле. В модуль войдёт кроме функции компиляции ещё и набор опций компилятора Си++. Данный
модуль позволит более тонко управлять компиляцией "сишных" файлов в профиле Простого Рефала, самому
же Простому Рефалу оставив только преобразование .sref в .cpp. При дальнейшей эволюции компилятора,
а именно, при разработке новых back-end'ов в Си++, данный модуль можно использовать повторно.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, т.к. имеет прямое отношение к юзабельности
компилятора.
----------------------------------------------------------------------------------------------------
  [DONE] 01.07.2010 - 20:39:07,96

  Сделано. Модуль C-Link::MLinker предоставляет две функции: C-Link, которая позволяет тонко выпол-
нять компиляцию набора файлов исходных текстов, включая переименование файлов для избежания конфлик-
тов имён объектных файлов (см. ниже) и функцию LookupRuntimeFiles, которая в наборе каталогов ищет
набор файлов поддержки времени выполнения и возвращает полные пути к ним.
  Функции модуля инвариантны к конкретному целевому языку и расширениям файлов исходного текста,
поэтому их можно использовать не только для работы с языками Си и Си++ (расширения .c, .cpp, .cc),
но и с другими языками, например, Си Шарп (.cs).
  Ряд компиляторов Си++ (MSVC, BCC) при вызове со списком файлов на Си++ сначала выполняют их ком-
пиляцию, размещая объектные файлы в текущей директории, а затем вызывают компоновщик по отношению
к этим объектным файлам. Проблема возникает в случае, если среди исходных файлов попадаются файлы
с одинаковым именем, но в разных каталогах. Тогда одноимённый файл, компилируемый последним, пере-
запишет своим объектным файлом объектный файл другого одноимённого файла, что приведёт в дальней-
шем к ошибке компоновки. Проблема решается копированием в текущую папку файлов, имеющих "использо-
ванные" имена с суффиксами вида @1, @2, например, Linker@1.cpp. 


====================================================================================================
  [CHANGED] Поддержка работы с бинарными файлами
====================================================================================================

  [CHANGED] 30.06.2010 - 14:48:51,43

  Появилась возможность читать и записывать бинарные файлы в профилях Простого Рефала, C++/SR и Ре-
фала 5, причём запись корректно реализована во всех трёх профилях, а чтение --- только в первых
двух. К сожалению, встроенная функция Рефала 5 Get, выполняющая построчное чтение файлов, при нали-
чии символа с кодом '\0' в прочитанной строке, обрезает считанную строку до этого символа, даже ес-
ли файл открыт с режимом "rb". Поэтому не рекомендуется читать двоичные файлы при использовании это-
го профиля.
  Для этой цели формат библиотечных функций FileIO::Open и Core::MFileIO::Open был модифицирован
следующим образом (у них формат одинаковый, поэтому квалификаторы опускаются):
  <Open 'b' s.Mode e.FileName> == s.Handle
  <Open s.Mode e.FileName> == s.Handle
  s.Mode ::= 'r' | 'w' | 'a'

  Файл по-прежнему построчно читается и пишется теми же самыми функциями: WriteLine, Write и Read\
Line модулей FileIO и Core::MFileIO.


====================================================================================================
  [FIXED] Ошибка при компиляции модуля типа $CLEARMODULE
====================================================================================================

  [FIXED] 27.06.2010 - 16:16:34,09

  Синтаксис языка позволяет начинать модуль с одной из трёх директив: $PROGRAM, $MODULE и $CLEARMO\
DULE. Первая директива соответствует головному модулю, который может содержать функцию Go и после
компиляции и компоновки даёт исполнимый файл. Два других варианта соответствуют простым (регулярным)
модулям, т.е. модулям, которые фактически просто группируют ресурсы (в данном случае функции) и ре-
зультатом их компиляции не может быть исполнимый файл (хотя не исключается вариант генерации стати-
ческой или динамической библиотеки). (Сомнительная) директива $CLEARMODULE добавлялась на будущее,
когда язык будет различать чистые функции или функции с побочными эффектами. На данный момент она не
используется, и не факт, что будет использоваться в дальнейшем, но в описании синтаксиса и синтакси-
ческом анализаторе присутствует.
  Ошибка была связана с тем, что упомянутые три директивы в синтаксическом анализаторе помечали мо-
дуль как Main, Regular и Clear соответственно. Но остальная часть программы оперировала только пер-
выми двумя типами модулей (т.к. к тому моменту я забыл о $CLEARMODULE), поэтому при компиляции син-
таксически корректного модуля, начинающегося с сомнительной директивы, компилятор падал с дампом па-
мяти.
  Решение: директива $CLEARMODULE интерпретируется также как и $MODULE, т.е. модуль получает тип
Regular.


====================================================================================================
  [FIXED] Множественная настройка back-end'ов
====================================================================================================

  [FIXED] 27.06.2010 - 16:16:34,09

  Ошибка происходила при задании в командной строке (или файле конфигурации) настроек back-end'ов
(опция -tune-be), не входящих в текущий профиль. В этом случае программа сваливалась с дампом памя-
ти.
  Исправлено.


====================================================================================================
  [DONE] Оптимизация MFileSystem::ExistFile для профиля Рефала 5
====================================================================================================

  [TODO] 27.06.2010 -  0:09:29,47

  На данный момент библиотеки всех профилей подведены под одну гребёнку. При этом функция MFileSys\
tem::ExistFile реализуется как запрос атрибутов файла и проверка на успешность запроса. Это эффек-
тивно для профилей C++/SR и Простого Рефала, но отвратительно по быстродействию для профиля Рефала
5, тем более, что последний предоставляет встроенную функция языка ExistFile.
----------------------------------------------------------------------------------------------------
  [DONE] 27.06.2010 - 16:16:34,09

  Как сказал классик, большинство проблем в кибернетике можно решить введением дополнительного уро-
вня абстракции. В данном случае был создан дополнительный модуль CoreBE::MExistFile, предоставляю-
щий функцию ExistFile. Модуль для профилей Простого Рефала и C++/SR является модулем с исходным те-
кстом (в нём реализована функция ExistFile также, как и раньше), для профиля Рефала 5 представляет
собой библиотечный модуль, вызывающий одноимённую встроенную функцию целевой платформы.
  Если до оптимизации полная перекомпиляция (с ключом -build) занимала порядка 20 минут, то после
оптимизации --- около 3 минут, что сравнимо (на нетбуке) со временем работы других профилей.


====================================================================================================
  [CHANGED] Номер версии в записях журнала
====================================================================================================

  [CHANGED] 27.06.2010 -  0:09:29,47

  Теперь помимо даты в записи журнала автоматически добавляется текущая версия компилятора.


====================================================================================================
  [DONE] Ограничения на MODULEPATH
====================================================================================================

  [TOTHINK] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  На уровне программы это никак не контролируется, записано лишь в спецификациях. При отрицательном
ответе на вопрос достаточно лишь поправить строчку текста.
----------------------------------------------------------------------------------------------------
  [TODO] 16.05.2010 -  0:35:57,09

  Задачу (обдумывание) я завершил, но это TODO здесь технически необходимо: невозможно закрыть тег
TOTHINK тегом DONE или CHANGED (хотя последние два здесь были бы более уместны). О сделанных изме-
нениях написано ниже в DONE.
----------------------------------------------------------------------------------------------------
  [DONE] 16.05.2010 -  0:35:57,09

  Спецификация была модифицирована, текущая версия находится в файле "Поиск исходников.03.txt".
  Модификации сводятся к следующему:
  1. Снят запрет на использование относительных ссылок ("." и "..") внутри путей MP-каталогов.
  2. Ограничение на вложенные MP-каталоги перешло из разряда запретов в разряд неопределённого по-
ведения.
  3. Более точно раскрыта тема вложенности MP-каталогов, а также приведено разъяснение причин тако-
го ограничения.
  4. Уточнено ограничение на псевдонимы каталогов.

  Так что теперь ссылки вверх разрешены и текущий способ использования компилятора (ссылки на библи-
отечные MP-каталоги реализовывались через "..") легализован.


====================================================================================================
  [DONE] Обновить стабильную версию и поднять версию компилятора
====================================================================================================

  [TODO] 20.05.2009 - 15:28:26,81

  Требуется выбрать из имеющихся реализаций стабильно работающую, т.к. предыдущая стабильная версия
уже морально устарела: не может компилировать новый синтаксис (лексика пополнена \r). Кроме того,
компилятор потрясли значительные изменения: появилось несколько новых back-end'ов, изменилась обра-
ботка командной строки. Это стоит отметить повышением номера версии.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2.
  Стабильные версии компиляторов обновлены. А вот поднять номер сборки надо. Давно надо. Т.к. я дав-
но не поднимал номер сборки, я сборку выполню от 20 до 40 раз. Столько, сколько потребуется для на-
ладки операции make к новому синтаксису командной строки.
  Следует организовать новый порядок инкремента номера сборок --- когда происходит завершение задачи
в журнале, выполняется новая сборка. Возможны и другие варианты, но они должны быть чётко привязаны
к конкретной деятельности.
----------------------------------------------------------------------------------------------------
  [DONE] 03.05.2010 - 23:21:46,12

  Пакетный файл, применяемый для выполнения сборки, сменил имя с make.bat на build.bat, что более
точно отражает его суть. Кроме того, внутренняя логика изменилась. Теперь сначала выполняется три
прохода компиляции тремя профилями и с соответствующими профилями --- чтобы определить наличие син-
таксических ошибок.
  Если проход оказался успешен, обновляется версия компилятора и производится 9 проходов: каждым
профилем (как результатом компиляции --- исполнимым файлом) с каждым профилем (как режимом компиля-
ции).
  После этого происходит обновление файлов стабильной версии компилятора.
  Утверждаю порядок выполнения сборок.
  1. Сборка должна выполняться, когда после сравнительно крупных изменений была получена устойчивая
версия.
  2. Сборка должна выполняться после завершения очередного TODO или ERROR (до занесения результатов
в отчёт).
  Следствие. После завершения очередного TODO или ERROR необходимо добиваться получения устойчивой
версии.


====================================================================================================
  [DONE] Ревизия задач
====================================================================================================

  [TODO] 07.01.2010 - 23:12:41,12

  Необходимо пересмотреть список приоритетных задач.
----------------------------------------------------------------------------------------------------
  [DONE] 01.05.2010 - 19:30:19,45

  Уже делаю (см. сегодняшнюю запись в журнале).


====================================================================================================
  [FIXED] Ошибка при циклическом импорте модулей
====================================================================================================

  [ERROR] 06.01.2010 - 22:15:43,19

  Обнаружена ошибка, приводящая к дампу поля зрения, возникающая, предположительно, при циклическом
импорте модуля, импортируемого с псевдонимом. Ошибка выскочила на файле с таким содержимым:

$MODULE CoreBE::MOrder;

...

$IMPORT Core = CoreBE::MOrder;

...

$END CoreBE::MOrder.
----------------------------------------------------------------------------------------------------
  [FIXED] 01.05.2010 - 17:52:48,14

  Как оказалось, ошибка была связана с нарушением инварианта внутри IModule. Дело в том, что импор-
тируемый модуль внутри промежуточного представления представляется двумя записями во внутренней таб-
лице символов: записью для самого модуля и записью для его псевдонима. Инвариант IModule предпола-
гал, что обе записи должны формироваться и изменяться согласованно, однако, это требование не выпол-
нялось. В приведённом выше примере для псевдонима Core запись создавалась, но для настоящего имени
CoreBE::MOrder запись создать не удавалось, т.к. возникал конфликт с записью для самого модуля.
  Программа падала на функции AnalyzeValidSubModule-AddError, её код и код её вызова приведены ниже:

  AnalyzeValidSubModule-AddError
    s.FnAddError t.hErrorList t.Alias
    t.hRawIModule Found t.SrcPos =
      (
        <s.FnAddError t.hErrorList t.SrcPos t.Alias>
        t.hRawIModule
        Errors
      );

    ...
      <AnalyzeValidSubModule-AddError
        & MError.AddBrokenImport
        t.hErrorList t.ImportName
        <MIModule::GetImportAttribute-RealName
          t.hRawIModule Position t.ImportName
        >
      >;
    ...

  Проблема заключалась в том, что список имён модулей подгружался функцией MIModule::GetImportList-\
Aliases, а атрибут (в данном случае --- позиция внутри модуля) брался у реального имени, которого не
было. В результате чего AnalyzeValidSubModule-AddError падала.
  Функция была исправлена путём контроля согласованности псевдонима и реального имени на уровне про-
межуточного представления и добавления контроля ошибок на уровне синтаксического анализа: перед до-
бавлением импорта в IModule теперь проверяется на переопределение не только псевдоним, но и реальное
имя (реальное имя не должно совпадать с именем модуля и именем импорта).


====================================================================================================
  [DONE] Устранить лишние вызовы функции MOS::System
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Устранить вызовы, используемые для создания папки, удаления файлов, получения списка переменных
среды. Реализовать эти средства или средствами языка Си, или средствами ОС.
----------------------------------------------------------------------------------------------------
  [TODO] 05.01.2010 -  1:45:39,45

  В текущей рабочей версии библиотеки back-end'а Си++ функции создания папки и удаления файла уже
реализованы как элементарные, в пишушейся версии библиотеки функции работы с переменными среды ис-
пользуются функции WinAPI, поэтому, отлажу новую версию библиотеки, это TODO можно будет считать
выполненным для профиля (тут всё-таки корректнее говорить о профиле) Си++.
  Относительно других профилей: устранить из профиля Рефала 5 подобные вызовы невозможно, т.к.
иначе (не меняя сами интерпретатор и компилятор Рефала 5) невозможно реализовать внешние функции;
профиль Простого Рефала даёт больший простор для надежды, т.к. можно написать вручную ещё один
модуль примитивных функций или даже расширить WinLib.cpp.
----------------------------------------------------------------------------------------------------
  [TODO] 07.01.2010 - 23:12:41,12

  В новой версии библиотеки профиля Си++ функция MOS::System больше не используется для реализации
посторонних операций, таких как получение списка переменных среды или файловые операции. Однако,
чрезмерное использование MOS::System (а если говорить шире, то командного интерпретатора Windows)
cохраняется как в профиле Простого Рефала, так и в самом компиляторе (в частности, в компоновщиках
порождаются командные файлы, которые тут же исполняются). Устранение лишних вызовов из профиля Про-
стого Рефала возможно только после реорганизации соотвествующей библиотеки (благо, процесс уже на-
чат). Улучшение структуры самого компилятора возможно только со стороны написания новых библиотеч-
ных функций для копирования или переименования файлов (отсутствие которых и вынуждает генерить па-
кетные файлы с командами копирования и переименования).
----------------------------------------------------------------------------------------------------
  [DONE] 17.04.2010 - 17:40:47,00

  "Неуместные" вызовы MOS::System устранены: теперь она используется только внутри компоновщиков,
которые её используют для запуска внеших компиляторов. Для выполнения посторонних утилитарных нужд
она больше не используется: т.к. такие действия, как создание папки и удаление файла или папки уже
выполняются библиотечными модулями, написанными на целевом языке, в том числе и в профиле Рефала 5.
В последнем, конечно, применяется вызов фукции System для выполнения внешних операций, но этот вы-
зов присутствует только в библиотечных модулях на самом низком уровне.
  Тот факт, что профили Простого Рефала и C++/SR активно используют командный интерпретатор, т.к.
генерят и тут же запускают bat-файлы, никак не влияет на завершение этого TODO. Во-первых, в заго-
ловке чётко говорится о том, что нужно устранить сами лишние вызовы MOS::System, а не изменять
способ компиляции. Во-вторых, для этого сейчас будет написано отдельное TOTHINK.


====================================================================================================
  [DONE] Удалить MRefalRTS::Put
====================================================================================================

  [TODO] 02.02.2008 - 17:55:52,95

  См. выше, почему это не особо критично.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Можно и удалить. Ведь, если необходимо, всегда можно добавить. На данный момент функцией MSelfDi\
ag::Log-T я пользуюсь довольно редко. Чаще я с целью трассировки функции Func пишу следующий код:

// До трассировки

Func {
  // Тело функции Func. Формат функции такой: <Func t.X e.Y (e.Z)> == ...
}

// После трассировки

Func
  t.X e.Y (e.Z) =
    <MSelfDiag::Log>
    <MSelfDiag::Log '<Func>'>
    <MSelfDiag::Log '  t.X = ' t.X>
    <MSelfDiag::Log '  e.Y = ' e.Y>
    <MSelfDiag::Log '  e.Z = ' e.Z>
    <?Func t.X e.Y (e.Z)>;

?Func {
  // Тело функции Func.
}

  Очевидно, что вместо этого лучше включить в язык/компилятор нормальное средство трассировки, но
я сейчас не буду описывать это как TODO. Т.к. (а) до выхода версии 0.2 я не собираюсь изменять син-
таксист, (б) запись прямо здесь этого как TODO сделает его приоритетным. Пункт (б) не критичен, т.к.
описать TODO можно и после закрывающей скобки.
----------------------------------------------------------------------------------------------------
  [DONE] 17.04.2010 - 17:40:47,00

  В результате реорганизации библиотеки был удалён и сам модуль MRefalRTS --- уже по-этому можно
считать это TODO нерелевантным. Ранее эту функцию (MRefalRTS::Put) использовал модуль MSelfDiag для
реализации функции Log-T. Теперь MSelfDiag для реализации функций Log и Log-T использует функции
CoreBE::MSelfDiag::Log и CoreBE::MSelfDiag::Log-T, написанные на целевом языке профиля. Вызовы функ-
ций Put и Putout внутри этих файлов выглядят вполне законченно и гармонично --- модули на целевом
языке могут использовать всю мощь целевой платформы, если это необходимо для реализации требуемого
интерфейса.


====================================================================================================
  [DONE] Реорганизация имеющейся библиотеки (РБ)
====================================================================================================

  [TODO] 07.01.2010 - 23:12:41,12

  Точно также, как сейчас была реорганизована библиотека профиля Си++, нужно реорганизовать профили
Простого Рефала и Рефала 5. В скобках указан префикс для подзадач.
----------------------------------------------------------------------------------------------------
  [DONE] 12.04.2010 -  1:05:18,48

  Библиотеки профилей Простого Рефала и Рефала 5 реорганизованы. Подробности в соответствующих DONE.


====================================================================================================
  [DONE] РБ: Реорганизация библиотеки профиля Рефала 5
====================================================================================================

  [TODO] 07.01.2010 - 23:12:41,12

  См. надзадачу. Реорганизация по аналогии с профилем Си++. Кроме того, желательно написать новые
библиотечные модули взамен модуля MRefalRTS. В частности, можно инкапсулировать факт конечного чис-
ла дескрипторов файлов взамен функций MRefalRTS::Open и сопуствующих. Неплохо было бы пересмотреть
утилиту mr-extent.exe.
----------------------------------------------------------------------------------------------------
  [DONE] 12.04.2010 -  1:05:18,48

  Все библиотечные модули Рефала 5 были сделаны по интерфейсу аналогичных библиотечных модулей объ-
динённого профиля Простого Рефала и C++/SR, что позволило .rout-файлы поместить в каталоги all.cpp\
01-b и windows.cppsr01-b, удалив при этом каталоги с суффиксами .r5-b и .r5-s. Сложностей с модуля-
ми Core::Math, Core::MFileIO, CoreBE::MOrder, CoreBE::MSelfDiag, CoreBE::MStrings не было, почти не
возникло проблем с модулем CoreOS::MOS, а вот с CoreOS::MFileSystem пришлось повозиться.
  Модули, с которыми проблем не было, как правило просто перенаправляли вызовы к аналогичным встро-
енным функциям Рефала 5 или реализованы очевидно. Некоторая возня возникла с модулем MOS в связи с
интерфейсами: наружу предоставляется функция CommandLine, возвращающая командную строку, которая
затем разбивается на аргументы, в то время как целевая платформа (Рефал 5) предоставляет уже разби-
тую на аргументы командную строку. Поэтому пришлось эти аргументы склеивать в одну командную стро-
ку, что на целевом языке (язык .rout-файлов на входе линковщика), делать сравнительно тоскливо.
  Столь же тоскливым по процессу (dx/dt), но более тоскливым по достижению конечного результата
(INT...dt) было написание модуля CoreOS::MFileSystem, т.к. функций целевой платформы, реализующих
требуемые возможности, просто нет. Поэтому пришлось как и раньше писать и вызывать функцией System
стороннюю программу, выполняющую требуемую работу, а значит сериализовывать и десериализовывать ар-
гументы и результаты функций. Т.к. библиотечные модули не могут использовать модули с исходным ко-
дом, а писать на Модульном Рефале, а затем тереть (или переименовывать) исходник мне западло ибо
неэлегантно, сериализацию и десериализацию я написал на целевом языке.
  Новшеством здесь было то, что сама внешняя программа была написана на Модульном Рефале, при этом
откомпилирована при помощи профиля C++/SR. Это позволяет:
  а) сохранить общую семантику функций для разных профилей;
  б) упростить сериализацию/десериализацию, т.к. её на Рефале писать несколько проще;
  в) несколько упростить отладку.
  Относительно отладки следует сказать отдельно. Новая программа (FS-Extent) разрабатывалась сов-
местно с другими т.н. утилитами, т.е. программами каталога Sources/Utilities дерева проекта. Утили-
ты компилируются в текущей конфигурации в двух режимах: сначала для профиля C++/SR, затем для про-
филя Рефала 5. Исходный текст программы непосредственно вызывает функции модуля CoreOS::FileSystem,
так что таким образом программа, откомпилированная профилем Рефала 5 должна была для работы вызывать
саму себя (точнее, C++/SR-версию). Это позволило проверить работу как самой внешней программы, так
и библиотечного модуля, написанного на целевом языке, т.к. позволяло сравнивать результаты .rsl- и
.cpp.exe-версий.
  В общем, не считая тягомотины с написанием на тоскливом целевом языке сериализации/десериализации
выражений, писать получилось весело.
  В качестве недостатка можно указать неиспользование возможностей Рефала 5. Для проверки существо-
вания файла используется запрос атрибутов файла --- если он успешен, то файл существует. С точки
зрения профиля Рефала 5 это означает вызов внешней программы, хотя в библиотеке встроенных функций
присутствует функция ExistFile, которая проверяет файл на существование за гораздо меньшее время.
Возможно, это следует исправить.
  В целом, результатом я доволен.


====================================================================================================
  [FIXED] Завершение программы и функция Exit
====================================================================================================

  [ERROR] 15.03.2010 - 22:26:57,71

  Согласно модульной модели языка (пардон за тавтологию), при завершении программы должны быть выз-
ваны финализаторы модулей, причём независимо от того, завершилась она естественным образом (выпол-
нение функции Go завершилось) или принудительно (вызывана MOS::Exit или MSelfDiag::ExitFailure в
текущей редакции библиотеки).
  Чтобы упростить себе работу, для профилей Простого Рефала и Рефала 5 функции финализаторов я ре-
гистрировал в соответствующих инициализаторов (аналогично atexit в Си), а затем в конце функции
Go вызывал функцию Exit для выполнения кода финализации. Код регистрации и завершения программы был
опрометчиво помещён в библиотеку, поэтому, если программа не использует модуль MOS::Exit, код этих
функций не подключается к программе и программа не компонуется.
  Данная проблема не коснулась профиля Cpp-SR, т.к. он использует свой (хоть и кривой) механизм
работы инициализаторов и финализаторов. Функция финализации Exit генерится одновременно с функцией
Go в одном файле и вызывает все требуемые финализаторы.
  Эту ошибку можно (и нужно) рассматривать как TODO, т.к. она требует проанализировать и переписать
имеющиеся механизмы инициализации и финализации.
  Напоследок, пример кода, где программа валится:

$PROGRAM Test;

$IMPORT InOut;

$ENTRY Go = <InOut::WriteLine 'Test'>;

$END Test.

  Ошибка вылезла в связи с переписыванием библиотеки профиля Рефала 5, т.к. раньше весь функционал
находился в модуле MRefalRTS, а теперь при переписывании библиотеки (на данный момент --- MSelfDiag
с функцией ExitFailure) пришлось продумывать механизм завершения программы.
----------------------------------------------------------------------------------------------------
  [FIXED] 18.03.2010 - 20:39:33,71

  Ошибка исправлена.
  В профил Простого Рефала внесены следующие изменения:
  1. Теперь инициализаторы модулей содержат только код инициализации и код регистрации финализато-
ров. Инициализаторы теперь имеют имя %полное имя модуля%P_EntryPointE_.
  2. Функция Main головного модуля теперь также вызывается из функции %полное имя головного модуля%
P_EntryPointE_.
  3. На стадии компоновки формируется модуль с именем %имя программы%.main.sref, в котором распола-
гаются следующие три функции:
    1) статический ящик G_Finalizers, хранящий стек функций финализации;
    2) функция RegisterE_, предназначенная для регистрации финализаторов;
    3) функция Go, содержащая последовательность вызовов функций ...EntryPointE_ в порядке от им-
портируемых модулей к импортирующим, которая завершается функцией ExitE_;
    4) функция ExitE_, вызывающая финализаторы модулей (из стека G_Finalizers) и функцию Exit биб-
лиотеки baselib.
  Профиля Рефала 5 изменения почти не коснулись: в генерируемый код была лишь добавлена функция
$Entry::__Exit$, которая вызывает финализаторы, закопанные под именем Finalizers.
  Кривой механизм финализации профиля Cpp-SR я не трогал, хотя следовало бы.


====================================================================================================
  [DONE] РБ: Реорганизация библиотеки профиля Простого Рефала
====================================================================================================

  [TODO] 07.01.2010 - 23:12:41,12

  Необходимо реорганизовать библиотеку профиля Простого Рефала по аналогии с профилем Си++, а имен-
но избавится от рудимента --- модуля MRefalRTS. Возможно задействие модуля baselib.h/baselib.cpp
профиля Си++.
----------------------------------------------------------------------------------------------------
  [DONE] 15.01.2010 - 23:43:58,82

  Т.к. рантаймы компилятора Простого Рефала и профиля C++/SR Модульного Рефала объединены, было ре-
шено использовать наработки профиля C++/SR в профиле Простого Рефала. Для этой цели написан файл
MR-BaseLib.cpp, представляющий собой библиотечный модуль Простого Рефала, подключаемый к нему на
этапе компоновки. Функции этого модуля осуществляют перенаправление к соответствующим (с точностью
до соглашений об именах одноимённым) функциям модуля baselib.h/baselib.cpp, что позволило написать
новую библиотеку для Простого Рефала, параллельную библиотеке профиля Си++.
  Т.к. небиблиотечные модули библиотеки для обоих профилей оказались одинаковыми, а библиотечные
модули имеют одинаковый интерфейс (т.к. они просто перенаправляют вызовы к функциям из baselib.*),
было решено объединить каталоги библиотек в общие подкаталоги с суффиксом srcpp: ***.srcpp01-?, где
вместо *** используется all и windows, ? замещает s и b.
  К сожалению, я не могу удалить старые версии файлов ***.cpp-? и ***.sr-?, т.к. их используют ста-
бильные версии компиляторов, которые не знают о существовании baselib.***.


====================================================================================================
  [DONE] Объединение рантаймов профиля C++/SR и компилятора Простого Рефала
====================================================================================================

  [TOTHINK] 12.01.2010 - 11:01:24,51

  В заголовке написано "компилятор Простого Рефала". Это означает, что речь идёт не о профиле ком-
пиляции в Простой Рефал, а именно о самом Простом Рефале. Под рантаймом тут подразумевается пара
файлов refalrts.h и refalrts.cpp.
  После появления самостоятельного профиля компиляции C++/SR оба рантайма развивались параллельно:
для Простого Рефала Вадимом Сухаревым был разработан режим интерпретации, позже были внедрены вло-
женные функции. Вложенные функции привели к распределению памяти в пуле, а не по одному узлу; в
рантайме профиля компиляции в Си++ для обозначения имён замыканий стали использоваться идентифика-
торы вместо константных C-строк.
  Из-за последней особенности рантаймы стали несовместимы. Несовместимость можно преодолеть, ис-
пользуя условную компиляцию и, например, на время компиляции в C++/SR определять макрос MREFAL или
MODULE_REFAL.
  Объединение рантаймов позволит использовать функции высших порядков в двух профилях Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 12.01.2010 - 11:52:13,25

  Ещё одна причина. Это упростит использование baselib.h/baselib.cpp и в библиотеке профиля Просто-
го Рефала.
----------------------------------------------------------------------------------------------------
  [DONE] 12.01.2010 - 12:46:39,51

  Объединил, всё теперь компилируется и работает (профиль C++/SR, профиль Простого Рефала, сам Про-
стой Рефал). Более того, внесены незачительные изменения в baselib.cpp, позволяющие компилировать
библиотеку как в режиме Простого, так и в режиме Модульного Рефала. Таким образом, можно применить
наработки для библиотеки профиля C++/SR и для библиотеки профиля Простого Рефала.


====================================================================================================
  [DONE] Размещение низкоуровневых функций в отдельном файле рантайма
====================================================================================================

  [TOTHINK] 30.12.2009 - 21:10:34,94

  На данный момент библиотечные модули (т.е. написанные вручную на целевом языке --- не путать с
модулями библиотеки --- модулями, входящими в библиотеку языка) пишутся вручную следующим способом:
пишется заготовка на Рефале, компилируется, файл исходного текста удаляется (или переименовывается),
в сгенерированном коде тело функций частично переписывается вручную. Метод хорош и применим на пра-
ктике, однако у него имеются и недостаток. Недостаток заключается в том, что для работы со структу-
рами поля зрения зачастую недостаточно элементарных операций одного только рантайма (точнее, ими
пользоваться можно, но неудобно): нужны более высокоуровневые средства, например для прочтения из
поля зрения текстовой строки переменной длины разработана функция считывания данных в вектор STL
переменного размера. На данный момент эта функция тупо скопирована в каждый из файлов реализаций
библиотечных модулей, что, очевидно, нарушает правила модульности и хорошего стиля программирования.
Кроме того, при подобной практике в библиотечных модулях помимо написанного вручную кода, присутст-
вуют и артефакты кодогенерации, такие как предобъявления функций, блоки инициализации-финализации и
закодированные полные квалифицированные имена функций, что затрудняет прочтение, понимание и после-
дующее сопровождение этих файлов.
  Для решения этих проблем предлагается код, реализующий низкоуровневые детали реализации, помещать
в отдельный файл исходного текста, который будет затем подключаться точно таким же образом, как сей-
час подключается файл refalrts.cpp. Этим функциям (реализующим, например, ввод-вывод, арифметику
или средства операционной системы) предлагается давать ясные имена, возможно, помещая их в специаль-
ное пространство имён (например, refal_lib::add). Затем, из кода собственно библиотечных модулей
непосредственно вызывать эти функции, например:

refalrts::FnResult StdP_MathP_Add(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  return refal_lib::add(arg_begin, arg_end);
}

  В примере предполагается, что функция refal_lib::add объявлена выше. Кроме того, файл реализации
низкоуровневых функций может содержать сразу несколько функций разных модулей библиотеки, что упро-
стит повторное использование кода, общего для нескольких функций.
  Данное TOTHINK вовсе не конфликтует с TODO "C++: Устранить Library.cpp и RefalRTS", а даже наобо-
рот, выполняет схожую задачу. Вместо имеющегося на данный момент объединения низкоуровневых функций
в уродливых полунаписанных-полусгенерированных модулях Library.cpp и RefalRTS, код, который непо-
средственно пишется вручную на целевом языке (Си++), будет находиться в файле, целиком (или почти
целиком) написанном вручную, в автоматически созданных заготовках будет минимум написанного вручную
кода.
  Кроме того, данная стратегия может быть полезна и для реализации низкоуровневых функций, совместно
используемых back-end'ами Си++ и Простого Рефала (хотя вопросы совмещения этих двух back-end'ов на-
до отдельно прорабатывать): библиотечные модули обоих языков могут ссылаться на функции, описанные
в отдельном файле исходного текста, подключаемом на этапе генерации целевого языка.
  Кроме того, организация низкоуровневых модулей таким образом облегчит дальнейшую реструктуризацию
стандартной библиотеки.
----------------------------------------------------------------------------------------------------
  [TODO] 05.01.2010 -  1:45:39,45

  Это TODO --- чистая формальность, т.к. к выполнению этой задачи я уже приступил и даже сделал не
менее трети работы. Как не трудно догадаться, процесс идёт параллельно с переписыванием библиотеки
back-end'а Си++. На данный момент уже переписаны модули Math, FileIO, MStrings, InOut, MOS. Модуль
MStrings был перемещён в каталог all.all с вызовом функций модуля CoreBE::MStrings, который в back-
end'е Си++ написан на Си++, в остальных back-end'ах --- на Модульном Рефале с вызовом функций моду-
ля MRefalRTS.
  Как положительный результат на этом этапе можно отметить написание ряда вспомогательных средств:
макросы REFAL_FUNC, DECL_REFAL_IDENT и REFAL_IDENT, вспомогательные классы CharArray и AllocArray,
первый представляет собой строковой класс, поддерживающий размещение данных в виде массивов языка
Си --- поверх класса std::vector<char> (класс std::string не даёт гарантий такого размещения), вто-
рой позволяет хранить неопределённое количество фрагментов распределённой памяти, которые затем
можно сконкатенировать и построить результат, а также функция string_from_seq (правда, написанная
давно), считывающая цепочку char'ов из рефал-выражения в массив CharArray.
  Впрочем, этот процесс имеет и один недостаток. Он заключается в том, что реализации всех функций
находятся в одном файле, в то время как идеологически предполагается разбиение функций, специфичных
для каждого back-end'а на платформенно-независимые функции и функции, специфичные для конкретной
операционной системы. Этот недостаток устраним: достаточно один файл разбить на два, в одном из ко-
торых будут находиться определения переносимых функций, в другом --- определения функций, специфич-
ных для Windows. Но этот недостаток я буду устранять не ранее, чем после того, как допишу и отлажу
текущую библиотеку.
  Написан большой массив кода, который компилируется (проверял), но ещё ни разу не запускался. Как
только допишу текущую версию библиотеки, буду развлекаться с отладкой. Чувствую, что получу немало
удовольствия.
----------------------------------------------------------------------------------------------------
  [DONE] 07.01.2010 - 23:12:41,12

  Данное TODO выполнено в полном соответствии с описанием. Разделять baselib.h/baselib.cpp на две
части: переносимую и непереносимую я пока не стал, т.к. задач переноса под другие платформы в обоз-
римом будущем пока не стоит.
  Отлаживал на на удивление быстро --- за один день компилятор уже смог компилировать свой исходный
текст. Возможно, есть и скрытые ошибки, которые находятся в неиспользуемых (в компиляторе) функциях
или проявляются в тех ситуациях, которые в исходных текстах компилятора не возникают, но задачи ком-
плексного тестирования я пока не ставил (возможно, поставлю позже).


====================================================================================================
  [DONE] Реализовать back-end C++
====================================================================================================

  [TODO] 26.04.2009 - 21:59:57,53

  Собственно, всё продумано, приступаем к реализации.
  Независимо от того, как будет осуществляться генерация кода на Си++ -- напрямую компилятором с
"пришитым" генератором от Простого Рефала (генератор Простого Рефала состоит из модуля создания "ал-
горитма" -- команд языка сборки промежуточного представления предложения и модуля собственно генера-
ции) или путём генерации исходных текстов Простого Рефала, в любом случае надо пополнить Простой Ре-
фал средствами, необходимыми для Модульного Рефала:
  1. Идентификаторы (имена, метки, compound-символы). Далее по тексту "идентификаторы". Идентифика-
торы представляют собой элементы глобального множества, смысл которых состоит только в возможности
сравнения на равенство/неравенство средствами сопоставления с образцом с известным идентификатором
или между собой.
  2. Квалифицированные имена Модульного Рефала, т.е. имена, составленные из сегментов. Сегмент под-
чиняется правилам Модульного Рефала. т.е. может содержать символы типа '!', '?', '_', '-', причём
последние два различаются.
  3. Абстрактные типы данных.
  4. Статические ящики.
  5. Инициализация и финализация.
  Все задачи, относящиеся к генерации C++-кода, будут иметь префикс C++.
----------------------------------------------------------------------------------------------------
  [TODO] 16.11.2009 -  8:48:44,69

  На данный момент back-end C++ уже работает, однако это TODO я не удаляю только по одной причине:
формально осталось одно TODO с префиксом C++, а именно "Устранить Library.cpp и MRefalRTS". Когда
это TODO будет устранено, будет закрыто и текущее TODO.
----------------------------------------------------------------------------------------------------
  [DONE] 07.01.2010 - 23:12:41,12

  Фактически, back-end (вернее, профиль) был реализован давно и давно уже успешно использовался.
Это TODO висело так долго только из-за того, что одна из задач, помеченная как подзадача, долго де-
лалась. TODO "C++: Устранить Library.cpp и MRefalRTS" закрыто, значит закрыто и текущее TODO.


====================================================================================================
  [DONE] C++: Устранить Library.cpp и RefalRTS
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Будем различать модули библиотеки -- модули, реализующие API для языка и поставляемые вместе с
компилятором и библиотечные модули -- модули, у которых отсутствует исходный текст.
  Генеральный план действий. Модули библиотеки содержат как низкоуровневые функции (реализуемые
ручным написанием библиотечных модулей), так и высокоуровневые, вполне реализуемые на самом Модуль-
ном Рефале (например, разбор пути к файлу в строковом представлении). Поэтому логично их разнести
в разные модули. Низкоуровневые модули, реализуемые на целевом языке, будут иметь то же имя, что
и модули-клиенты низкоуровневых функций, но будут находиться в пакете Core (как это сейчас сдела-
но для FileIO и MFileSystem, но с оговорками).
----------------------------------------------------------------------------------------------------
  [DONE] 07.01.2010 - 23:12:41,12

  Рукотворная часть библиотеки профиля Си++ (т.е. тот функционал, который реализуется примитивными
функциями, написанными на Си++) полностью переписана таким образом, что она не использует код, на-
писанный на Простом Рефале/для профиля Простого Рефала/для профиля Рефала 5. Хронологически профили
появлялись в следующем порядке: Рефал 5, Простой Рефал, C++/SR (такое официальное название профиля
Си++, т.к. он основан на рантайме и генераторе кода компилятора Простого Рефала). Поддержка времени
выполнения и базовая часть библиотеки Рефала 5 представляла (да и сейчас представляет) собой един-
ственный модуль MRefalRTS, написанный на целевом языке (своебразный фрагмент кода на Рефале 5) и
содержащий функции, одноимённые встроенным функциям Рефала 5 и вызыващих оные. В целях упрощения и
ускорения разработки базовые функции профиля Простого Рефала сначала представляли собой тот же мо-
дуль MRefalRTS, который впоследствии был дополнен другими модулями примитивных функций, в частности,
для работы с файловой системой и вводом-выводом, т.к. файловый ввод-вывод в стиле Рефала 5 крайне
неудобен. При появлении профиля C++/SR модули элементарных функций были позаимствованы от предыду-
щего профиля, т.к. на тот момент их рантаймы были совместимыми. Таким образом профиль Си++ был отя-
гощён рудиментами типа подключения библиотеки Library.cpp, функции которой косвенно вызывались из
библиотечных модулей библиотеки, т.к. базовые модули, целевой код которых должен был писаться вруч-
ную был фактически сконвертирован их Простого Рефала. Кроме того, немалая доля элементарных функций
была доступна из модуля MRefalRTS, что никак не соответствует исходному предназначению последнего
(редиректы к функциям Рефала 5).
  Выходом из этой ситуации, очевидно, является коренное переписывание библиотечных модулей библио-
теки профиля Си++ таким образом, чтобы не реализуемые средствами Рефала функции, вызываемые из поль-
зовательского кода, были или непосредственно написаны на целевом языке, или вызывались из других
библиотечных модулей с небольшой дополнительной обработкой (желательно не более двух уровней подоб-
ной косвенности). Что и было сделано для рассматриваемого профиля. Использовалась стратегия "Разме-
щение низкоуровневых функций в отдельном файле рантайма" (TOTHINK/TODO/DONE).
  Следующим шагом является такая же ревизия библиотек, относящимся к двум другим профилям компиля-
ции. Возможно, она будет выполнена к текущей структуре библиотеки, возможно параллельно с реструк-
туризацией.
  Положительным побочным эффектом этого этапа работы можно считать более тщательный анализ библио-
теки и её декомпозицию на переносимую и непереносимую часть. В структуре каталогов библиотеки ряд
модулей переместился в папки all.all и windows.all, непереносимый же код переместился в пакет
CoreBE как в библиотечные модули, так и в модули с исходным текстом.


====================================================================================================
  [CHANGED] Упрощён код генерации циклов по открытым e-переменным в back-end'е Си++
====================================================================================================

  [CHANGED] 05.01.2010 -  1:45:39,45

  Вместо использования переменных c суффиксом _stk и перекрытия имён функций во вложенных блоках
явным образом используются переменные с различными именами для представления диапазонах на различ-
ных уровнях вложенности. Цикл теперь выглядит примерно следующим образом:

    //Открытая e-переменная e.Set1_B
    for( 
      refalrts::Iter boe_1_0 = bb_1_0;
      ! empty_seq( boe_1_0, be_1_0 );
      refalrts::next_term( boe_1_0, be_1_0 )
    ) {
      refalrts::Iter bb_1_1 = bb_1_0;
      refalrts::Iter be_1_1 = be_1_0;
      refalrts::Iter bb_2_1 = bb_2_0;
      refalrts::Iter be_2_1 = be_2_0;
      bb_1_1 = boe_1_0;
      eSet1U_B_b_1 = bb_1_0;
      eSet1U_B_e_1 = boe_1_0;
      refalrts::move_right( eSet1U_B_b_1, eSet1U_B_e_1 );
      ...
      //Открытая e-переменная e.Set2_B
      for( 
        refalrts::Iter boe_2_1 = bb_2_1;
        ! empty_seq( boe_2_1, be_2_1 );
        refalrts::next_term( boe_2_1, be_2_1 )
      ) {
        refalrts::Iter bb_2_2 = bb_2_1;
        refalrts::Iter be_2_2 = be_2_1;
        bb_2_2 = boe_2_1;
        eSet2U_B_b_1 = bb_2_1;
        eSet2U_B_e_1 = boe_2_1;
        refalrts::move_right( eSet2U_B_b_1, eSet2U_B_e_1 );
        ...

  Теперь логикой работы цикла целиком управляет заголовок цикла for: начальное состояние инициали-
зируется как диапазон [boe_K_N, be_K_N], в точности соответствующий исходному диапазону, цикл про-
должается до тех пор, пока упомянутый диапазон не станет пустым, на каждой итерации этот диапазон
укорачивается.
  За циклом следует операция инициализации/восстановления границ тех диапазонов (со вторыми индек-
сами на единицу бОльшими), которые перемещаются в процессе сопоставления. После чего происходит
инициализация собственно открытой e-переменной, которая получает значение, представляющее диапазон
между исходной левой границей диапазона и перемещающейся границей-переменной цикла.
  Данная модификация генерации кода делает логику сопоставления с образцом более простой и понят-
ной, что упростит будущее внедрение в язык откатов (даже если потом придётся писать новый генера-
тор кода).


====================================================================================================
  [DONE] Устранить предупреждения компилятора BCC55
====================================================================================================

  [TODO] 24.12.2009 -  3:21:04,72

  При компиляции компилятором Borland C++ Compiler 5.5 (BCC55) выскакивает множество предупреждений.
Необходимо выяснить их причину и устранить её.
----------------------------------------------------------------------------------------------------
  [DONE] 24.12.2009 - 23:38:45,65

  БОльшая часть предупреждений устранена. Причины предупреждений и способы устранения оказались
следующими:
  1. Статическая переменная s_counter в инициализирующей функции в ряде случаев не использовалась.
Для подавления данного предупреждения уже был разработан механизм: переменная по ссылке передава-
лась в пустую функцию, как и в случае с "неиспользуемыми" итераторами. Однако, ряд модулей или
(а) не был после этого перекомпилирован (и, соответственно, в сгенерённом коде эти изменения отра-
жения не нашли), или (б) эти модули перекомпилировались предыдущими версиями (стабильными или уста-
ревшими версиями других back-end'ов). Полная перекомпиляция решила проблему.
  2. В низкоуровневых функциях библиотеки, написанных вручную, код был несколько небрежно написан,
но так как ранее использовались другие компиляторы, предупреждений это не вызывало. Решение: не-
брежности исправлены.
  3. При использовании std::vector<char> внутри написанных вручную функциях возникали предупрежде-
ния внутри самой стандартной библиотеки. Т.к. в стандартную библиотеку лезть нельзя (потому что
нельзя), эти предупреждения будем игнорировать. Переписывать иные функции без использования std::
vector'а трудоёмко и делает код более опасным (т.к. в случае стандартного вектора не приходится за-
ботиться о распределении памяти, в то время как использование realloc вынуждает контролировать па-
мять самостоятельно).
  4. Одно предупреждение (значение присваивалось переменной, но затем не использовалось) было выз-
вано несовершенством генерации кода сопоставления с образцом, содержащим открытые e-переменные. Как
оказалось, сгенерированный код для образцов вида e.Argument e.Tail (т.е. в случаях, когда открытая
e-переменная граничит с закрытой e-переменной) содержит подобное (лишнее) присваивание. Образцы та-
кого рода очень редки, поэтому не имеет смысл исправлять данный частный случай. В настоящий момент
во всём массиве исходных текстов компилятора Модульного Рефала такие образцы не используются, слу-
чай, приведший к предупреждению был всего лишь опиской, не влияющей на семантику программы.
Переменная e.Argument в образце жёсткая_часть e.Argument e.Tail была единственной открытой e-пере-
менной, в результате чего при сопоставлении она получала значение пустого выражения. В результатной
части она не использовалась. Т.е. здесь мы наблюдали забавный случай, заключающийся в том, что ком-
пилятор целевого языка (Си++) сумел обнаружить (совершенно некритичную) ошибку в исходном коде на
входном языке, выдав предупреждение :-).
  Данное конкретное предупреждение устранено путём исправления ошибки в исходном коде, первопричина
ошибки, заключающаяся в несовершенстве генерации кода для сопоставления с образцом устранена не бы-
ла, т.к. бороться с несовершенством надо глобально (переписывая генератор кода) и рано или поздно
это придётся сделать --- внедрение в язык неуспехов потребует отката и возврата к другому варианту
сопоставления, а значит, проектировать код циклов удлинения e-переменных придётся более тщательно.
  5. (Добавлено позже.) Одно из предупреждений компилятора было связано с тем, что пустые функции
компилировались в целевой код обычным образом, а именно, сначала генерировался заголовок, затем
последовательно код каждого предложения, после которых записывалась инструкция возврата refalrts::
cRecognitionImpossible и  закрывающая фигурная скобка. Таким образом, если функция не имела ни од-
ного предложения (как например, функция MSelfDiag::FailDown), генерировался только обычный заголо-
вок, после которого следовал возврат сигнала о неудачном распознавании. Таким образом формальные
параметры функции arg_begin и arg_end оказывались неиспользованными, о чём и сообщал бдительный
компилятор Borland C++. Решение: случай функций с пустым телом обрабатывался как специальный, такие
функции компилировались как $ENUM и $EENUM Простого Рефала (оказалось очень полезно не удалять этот
код из проекта).


====================================================================================================
  [DONE] Командная строка: параметризация компилятора Си++ опцией "имя исполнимого файла"
====================================================================================================

  [TODO] 14.12.2009 -  0:59:50,39

  Различные компиляторы используют различные опции для задания имени результирующего исполнимого
файла. А именно:
  --- компилятор g++ использует ключ командной строки -ofile или -o file;
  --- компилятор MS VC --- ключ /Fefile (также поддерживается и -ofile, но эта опция объявлена не-
желательной);
  --- компилятор BCC 6.0 --- ключ -efile.
  Как следствие, это необходимо параметризовать. На данный момент по соглашению используется опция
-o, для компиляции профилем C++/SR применяются только компиляторы g++ и MS VC.
----------------------------------------------------------------------------------------------------
  [DONE] 24.12.2009 -  3:21:04,72

  Добавлена дополнительная опция '-exec', задающая опцию "имя исполнимого файла". Как показала про-
верка, с её использованием можно откомпилировать проект всеми тремя вышеупомянутыми компиляторами.
  Преимущество использования разных компиляторов в том, что они выдают различную диагностику как в
случае ошибок (сравнивая различные сообщения об ошибках, легче понять в чём именно ошибка), так и в
случае предупреждений. В частности компиляция при помощи Borland C++ Compiler 5.5 привела к обнару-
жению погрешностей в коде, которые не обнаруживались двумя другими компиляторами. Об устранении
этих предупреждений будет отдельное TODO.


====================================================================================================
  [DONE] Командная строка: упорядочить метаданные -- список back-end'ов и зависимые перехватчики
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Хотя сейчас метаданные (дефолтовые расширения и папки вынесены) в отдельный файл, они там совер-
шенно не упорядочены -- одно и то же расширение упоминается несколько раз. Кроме того, компоновка
набора выходных файлов в единый back-end должна осуществляться также независимо от обработчика
командной строки. Кроме того, независимо от обработчика информация о выбранных опциях (в конкрет-
ном случае -- это командная строка вызова компилятора Си++) должна передаваться в функции генерато-
ра и компоновщика.
----------------------------------------------------------------------------------------------------
  [DONE] 12.12.2009 - 21:17:14,56

  Обработка командной строки и метаданные сейчас уже несколько более упорядочены:
  1. Обработка командной строки разделена на достаточно хороший DSL-движок, способный понимать раз-
личные свойства опций (необязательность/необходимость, однократность/многократность, наличие зави-
симых подопций, наличие опций-переключателей), а также поддерживать достаточно гибкий и мощный син-
таксис: опции с параметром и без, опции с группой подопций и без и т.д., и на собственно описание
конкретно командной строки средствами этого движка.
  2. Кроме того, в рамках описания командной строки средствами упомянутого DSL, сведения о каждом
из возможных парсеров и генераторов вынесены в функцию-таблицу BackEndsTable модуля Config.MLoad,
что также позволяет централизовано управлять метаданными.
  3. Сведения о дополнительных подопциях, соответствующих генераторам Си++ и Простого Рефала под-
гружаются из описания в специальном формате в функциях SRefal-BE.MInit.Extent и Cpp-SR-BE.MInit.\
Extent.
  4. Дополнительные опции, передаваемые в генераторы Си++ и Простого Рефала, на данный момент ис-
пользуются только внутри компоновщиков. Чтобы логически разделить опции командной строки и сам код
компоновщиков, создано средство т.н. "конфигурации" генератора --- абстрактный тип данных t.Config,
передаваемый в обработчик компоновки и представляющий собой ассоциативный массив, индексируемый
именем опции и возвращающий указанное значение (см. Config.MHelpers, функции Extent и Register
в модулях SRefal-BE.MInit и Cpp-SR-BE.MInit).


====================================================================================================
  [DONE] Командная строка: дополнительная параметризация back-end'ов
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Следует разрешить генераторам входных и выходных файлов (вместо ранее использованного термина
"внутреннее понятие back-end'а") параметризоваться дополнительными своими опциями (например, для
компилятора Си++ -- это путь к компилятору, дополнительные опции и др.). А если смотреть шире, то
помимо обработчика дефолтовых зависимых от самой опции команд группы, должен быть и обработчик
зависимых от значения опции команд группы.
----------------------------------------------------------------------------------------------------
  [TODO] 07.08.2009 - 21:04:53,72

  Написана спецификация нового движка командной строки и нового способа описания опций командной
строкиа, т.к. прежний движок был неудобен: не отслеживал такие характиристики опций как обязатель-
ность/опциональность, однократность/многократность и опции в режиме переключателей -- все эти ха-
рактеристики приходилось отслеживать вручную. Кроме того, новый движок позволяет иметь группу и
именам файлов в командной строке, что позволяет задавать имя и расположение целевого файла индиви-
дуально для каждого файла, например так: filename.mref ( -target:program -path:C:\Dir ).
----------------------------------------------------------------------------------------------------
  [TODO] 16.11.2009 -  8:48:44,69

  Новый движок реализован в полном соответствии со спецификацией. Кроме того, для унифицированной
обработки расширений конкретный back-end'ов и для инкапсуляции конкретных команд был реализован на-
бор функций-помощников (см. модуль Config::MHelpers). Инкапсуляция заключается в том, что конкрет-
ные списки команд скрыты внутри модулей-инициализаторов конфигурации конкретных back-end'ов (в фун-
кциях ...::MInit::Extent).
  Однако, функции-помощники имеют и один недостаток: расширяющие опции могут быть только опциональ-
ными, без группы и с параметром.
  Дополнительная параметризация на текущий момент реализована частично --- параметризуется только
выбор компилятора, опция компилятора Си++ include и каталог файлов поддержки времени выполнения.
В дополнение к этому желательно реализовать сам список файлов поддержки времени выполнения, опцию
компилятора define и опцию, означающую "дополнительные опции компилятора C++".
----------------------------------------------------------------------------------------------------
  [DONE] 12.12.2009 - 21:17:14,56

  Недостаток, заключающийся в том, что расширяющие опции могут быть только опциональными, однократ-
ными, с параметром и без группы, так и не исправлен, т.к. я его считаю несущественным.
  Дополнительные опции, перечисленные выше (список файлов времени выполнения, опция define и допол-
нительные опции компилятора Си++) добавлены. К сожалению, недостаток расширяющихся опций, заключаю-
щийся в их однократности, вынудил меня указывать файлы поддержки времени выполнения через запятую
в одной опции.
  Указанные опции расширения относятся только к генератору кода на Си++, т.к. генератор кода на
Простом Рефале параметризуется командной строкой запуска самого компилятора Простого Рефала, где
можно указать все эти дополнительные опции (список файлов времени выполнения, -DINTERPRET для режи-
ма интерпретации, а также любые другие опции компилятора Си++).


====================================================================================================
  [DONE] Научить XLinx выводить список нескомпонованных функций
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Как показала практика, вывод неиспользуемых функций -- весьма полезная вещь, упрощает поиск не-
ревантного кода, а также помогает найти некоторые ошибки. Однако, сейчас вывод подобного списка
привязан к back-end'у Рефала 5, от которого в ближайшей перспективе я планирую отказаться. Очевидно,
задача перекладывается на плечи XLinx, как средства как раз и нацеленного на анализ использований
функций.
----------------------------------------------------------------------------------------------------
  [DONE] 29.06.2009 - 22:16:48,85

  Выполнено в полном соответствии с TODO. Однако, в отличие от аналогичного инструмента back-end'а
Рефала 5, здесь отбрасывать библиотечные модули затруднительнее. Список выводится в виде дерева,
группируя функции по модулям и пакетам. Так сделано в надежде на то, что я перенесу, наконец, все
модули библиотеки в пространство имён Std и все неиспользуемые средства библиотек будут находиться
рядом.
  Фрагмент вывода показан ниже.

Not linked: 
Core::MFileSystem::DirList, ('..\Libraries\windows.sr-b\Core\MFileSystem.mref', 10)
Cpp-SR-BE::
  Generator::
    GenEEnum, ('Cpp-SR-BE\Generator.mref', 74)
    GenESwap, ('Cpp-SR-BE\Generator.mref', 102)
    PrintableName, ('Cpp-SR-BE\Generator.mref', 627)
    PrintableName-Aux, ('Cpp-SR-BE\Generator.mref', 630)
FileIO::
  G_Handles, ('..\Libraries\all.cpp-s\FileIO.mref', 7)
  WriteLine-T, ('..\Libraries\all.cpp-s\FileIO.mref', 28)


====================================================================================================
  [DONE] Научить XLinx выводить иерархический список использований модулей
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  XLinx должен уметь строить дерево зависимостей модулей как в прямом направлении (модуль исполь-
зует) с корнем в головном модуле, так и в обратном (модуль используется) -- несколько деревьев,
корнем каждого из которых является модуль, ничего не импортирующий, это как правило библиотечный
модуль реализации примитивов (теоретически, и библиотечный модуль может иметь зависимости от дру-
гих модулей, но это вырожденный случай).
----------------------------------------------------------------------------------------------------
  [DONE] 29.06.2009 - 22:16:48,85

  Выполнено в полном соответствии с TODO. В процессе работы возникла проблема: один и тот же модуль
может использоваться другими модулями и сам при этом иметь "развесистое" дерево зависимостей. Сие
развесистое дерево много раз включается в общее дерево, вследствие чего последнее разрастается, за-
туманивает структуру, которая из-за этого теряет свою информативность. Проблема была решена следу-
ющим образом: модули, упоминаемые впервые, обозначаются знаком '*' слева от имени и раскрываются
в дерево; модули, упоминаемые повторно, обозначаются знаком '@' и в дерево не разворачиваются.
  Однако, результат оказался не настолько интересен, как я преполагал заранее. Возможно, стоит что-
то переделать, например, скрыть @-записи и в качестве корней деревьев использовать каждый модуль,
а не модуль, не имеющий предков. В таком случае (а) мы будем наблюдать список прямо и косвенно за-
висящих (зависимых) модулей от данного, (б) отступы будут иллюстрировать примерный характер зави-
симостей -- будем знать путь (правда, только один) по которому импортирует(ся) искомый модуль.
  Сгенерированный результат имеет следующий вид (часть вывода):

MRefal =>
 * MCompiler, ('MRefal.mref', 5)
   * MClusters, ('MCompiler.mref', 3)
     * MContext, ('MClusters.mref', 10)
       * MQualifiedName, ('MContext.mref', 3)
         * MSelfDiag, ('MQualifiedName.mref', 14)
           * MRefalRTS, ('..\Libraries\all.cpp-s\MSelfDiag.mref', 3)
           * Core::MFileIO, ('..\Libraries\all.cpp-s\MSelfDiag.mref', 4)
         * MStrings, ('MQualifiedName.mref', 15)
           @ MRefalRTS, ('..\Libraries\all.cpp-s\MStrings.mref', 3)
           * Math, ('..\Libraries\all.cpp-s\MStrings.mref', 4)
             @ MRefalRTS, ('..\Libraries\all.cpp-s\Math.mref', 3)
           * MLambda, ('..\Libraries\all.cpp-s\MStrings.mref', 5)
       @ MStrings, ('MContext.mref', 4)
     * MFileSystem, ('MClusters.mref', 11)


====================================================================================================
  [DONE] C++: Имена функций -- идентификаторы вместо C-строк
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  В качестве имени функции внутри узла-указателя на функцию, необходимо использовать идентификатор
-- указатель на статическую функцию идентификатора. Тогда, соответственно, каждый вызов функции
будет требовать идентификатор. Но этот недостаток незначителен, т.к. лишние идентификаторы устра-
няются компоновщиком языка Си++.
----------------------------------------------------------------------------------------------------
  [DONE] 24.05.2009 - 16:26:52,40

  Сделано. Результат скромный -- исполнимый файл за счёт автоматической уборки лишних копий имён
функций полегчал менее чем 50 Кбайт.


====================================================================================================
  [DONE] C++: Реализовать генерацию кода на Си++ самим Модульным Рефалом
====================================================================================================

  [TODO] 07.05.2009 - 20:23:04,51

  Это существенно упростит пополнение Модульного Рефала низкоуровневым кодом, по сравнению с генера-
цией .sref-файлов. Кроме того, уйдёт лишний уровень косвенности (генерировать файлы исходного тек-
ста, затем проводить их синтаксический анализ), что приведёт к некоторому повышению быстродействия.
  Для этого необходимо сконвертить файлы Algorithm.sref и Generator.sref из Простого Рефала в Мо-
дульый, а для этого необходимо актуализировать srprep с учётом последних изменений синтаксиса
(в особенности касательно директивы $FORWARD).
----------------------------------------------------------------------------------------------------
  [DONE] 19.05.2009 - 22:23:09,31

  Back-end на основе Простого Рефала реализован. Даже с одной оптимизацией: оптимизация объёма сге-
нерированных файлов за счёт генерации цепочек char не по отдельности, а непрерывной последователь-
ностью (См. TODO C++: функции для преобразований между C-строкой и рефал-выражением), за счёт чего
удалось сократить объём исполнимого файла примерно на 15 %.
  Однако, back-end получился и не без недостатков. Помимо имманентных недостатков Простого Рефала
к ним добавились и следующие недостатки (многие из которых суть недоделки). А именно:
  (*) Непараметризуемость по компилятору (этим же страдает и back-end Простого Рефала) -- напрямую
в код зашит запуск программы compile_cl (которая есть пакетный файл compile_cl.bat, вызывающий ком-
пилятор MS Visual C++) с явно заданными некоторыми параметрами.
  (*) Кривая реализация низкоуровневых функций -- по прежнему используется Library.cpp. Необходимо
(а) реализовать самостоятельный рантайм применительно к Модульному Рефалу (слегка изменив
refalrts.h и refalrts.cpp) -- скорее, только косметические изменения); (б) перенести низкоуровневый
код в .cpp-файлы библиотеки.
  (*) Недостаток, сохранившийся из Простого Рефала, с тех времён, когда ещё не было идентификаторов,
но дамп поля зрения хотелось бы видеть в читабельном виде. А именно: имена функций для узлов-функций
задаются как C-строки. И эти c-строки слишком часто повторяются (приблизительный подсчёт показывает,
общий вес этих строк составляет 100 Кбайт). Следует имена функций в узлах хранить как ссылки на
идентификаторы.
  (*) Следует реализовать функции операционный и файловой систем, такие как создание папки, примити-
вами, а не вызовом функции System.


====================================================================================================
  [DONE] Запрос атрибутов файла написать на Си++
====================================================================================================

  [TODO] 07.05.2009 - 20:23:04,51

  Цель очевидна. Повышение быстродействия. Предполагается, что много времени уходит на проверку ан-
тивирусом каждого вызова функции System, поэтому получение атрибутов непосредственно в самом компи-
ляторе должно резко снизить затраты времени, ведь это всего лишь пара API-вызовов.
  Сама функция будет описана в библиотечном модуле MFileSystem::Core и будет называться GetFileAtt\
ribute, файл Core/MFileSystem.sref будет пустым, сишный код будет включён в файл Library.cpp.
----------------------------------------------------------------------------------------------------
  [DONE] 11.05.2009 - 14:03:21,79

  Выполнено в соответствии с TODO. Кроме того, на Си++ реализован запрос листинга папки. Однако зап-
рос листинга просто выводит имена файлов в указанной папке, а не их абсолютные имена. При переделке
библиотеки это надо доработать.


====================================================================================================
  [DONE] C++: Функции для преобразований между C-строкой и рефал-выражением
====================================================================================================

  [TODO] 07.05.2009 - 21:46:39,84

  Требуется добавить в refalrts функции, преобразующие char* <--> рефал-выражение. Возможные сигна-
туры:
  unsigned read_chars(char buffer[], unsigned buflen, Iter& first, Iter& last);
  void alloc_chars(Iter& first, Iter& last, const char buffer[], unsigned buflen);
  void alloc_string(Iter& first, Iter& last, const char *string);
При этом функции ***_chars работают не с C-строками, а с массивами символов, поэтому alloc_chars не
обращает внимания на нулевой байт.
  Поскольку распределение цепочек characters довольно распространено (по-другому генерацию файлов не
сделаешь), то использовать функцию alloc_chars целесообразно и в качестве оптимизации генерируемого
кода.
----------------------------------------------------------------------------------------------------
  [DONE] 10.05.2009 - 20:17:33,25

  Сделано в соответствии с TODO с тем отличием, что аргументы alloc_***, соответствующие началу и
концу рефал-выражения, называются res_b и res_e для единообразия стиля.


====================================================================================================
  [DONE] C++: Замер времени выполнения программы
====================================================================================================

  [TODO] 10.05.2009 - 14:21:13,26

  Было бы интересным добавить возможность замера времени выполнения программы. В принципе, можно
и осуществлять замер и чистого времени выполнения (для этого нужно слегка изменить кодогенерацию).
----------------------------------------------------------------------------------------------------
  [DONE] 10.05.2009 - 20:17:33,25

  Сделано в соответствии с TODO. Для сгенерированных функций пришлось добавить ещё один возвращаемый
результат: cExit, а также RTS-функция set_return_code. Указанные средства используются для реализа-
ции библиотечной функции Exit, которая как раз устанавливает код возврата и возвращает cExit. Ранее
она вызывала exit(), завершая тем самым выполнение программы. Такое поведение оказалось недопусти-
мым, т.к. требовалось после завершения работы рефал-машины выдавать сведения о быстродействии (до-
бавлять обработчик в at_exit мне не хотелось).


====================================================================================================
  [DONE] C++: Доработка srprep
====================================================================================================

  [TODO] 07.05.2009 - 20:23:04,51

  Необходимо доработать srprep таким образом, чтобы он поддерживал директиву $FORWARD. Остальными
возможностями типа идентификаторов или АДТ дорабатывать необязательно, т.к. эти возможности не ис-
пользуются в модулях Algorithm.sref и Generator.sref.
----------------------------------------------------------------------------------------------------
  [DONE] 10.05.2009 - 14:21:13,26

  Доработка коснулась лишь одного: директива $FORWARD сделана эквивалентной директиве $EXTERN. За-
бавным оказалось то, что директива $SWAP уже поддерживалась -- когда я писал srprep, я не подозре-
вал, что долгое время Simple Refal не будет поддерживать статические ящики.


====================================================================================================
  [DONE] Более прямая реализация файлов в FileIO
====================================================================================================

  [TODO] 07.05.2009 - 20:23:04,51

  На данный момент MRefalRTS эмулирует одноимённый модуль back-end'а Рефала 5 со всеми его косяками
и нелогичностями. Таким образом, не смотря на то, что функции работы с файлами (открытие, закрытие
построчное чтение и построчная запись) имеют идентичные интерфейсы, обмен осуществляется через не-
удобный интерфейс языка Рефал 5 с фиксированными числами-дескрипторами. Для отображения дескрипто-
ров Простого Рефала в чиселки используется таблица на уровне MRefalRTS, для контроля открытых дес-
крипторов-чиселок используется таблица на уровне FileIO.
  Очевидно, эту косвенность надо устранить.
----------------------------------------------------------------------------------------------------
  [DONE] 07.05.2009 - 23:17:35,42

  Создан библиотечный модуль Core::MFileIO, перенаправляющий вызовы функций Open, Close, WriteLine и
ReadLine к функциям на Простом Рефале.


====================================================================================================
  [DONE] C++: Собственно back-end
====================================================================================================

  [TODO] 02.05.2009 - 17:51:31,35

  Реализация back-end'а Модульного Рефала, генерящая sref-файлы.
----------------------------------------------------------------------------------------------------
  [DONE] 07.05.2009 - 17:44:20,12

  Реализован back-end, генерирующий .sref-файлы. У данного подхода, как выяснилось, есть существен-
ный недостаток, а именно неудобна реализация низкоуровневых средств на Си++. Самый низкоуровневый
код для данного back-end'а, очевидно, это Простой Рефал. Пополнение последнего низкоуровневыми сред-
ствами возможно только путём редактирования файлов refalrts.cpp и Library.cpp. Поэтому низкоуровне-
вые средства (см. RefalRTS.sref) выглядят примерно так:

  $EXTERN GetEnv;

  $ENTRY MRefalRTSP_Env {
    e.EnvName = <GetEnv e.EnvName>;
  }

т.е. практически та же ситуация, что и с Рефалом 5 с тем отличием, что можно пополнять набор "встро-
енных" функций. Так например, чтобы запрашивать атрибуты файла непосредственно, без mr-extent, пот-
ребуется или (а) написать функцию типа GetFileAttribute в Library.cpp и потом вызвать её из Core::
MFileSystem (как это сделано в MRefalRTS), или (б) создать библиотечный (в смысле, без исходника)
модуль типа Core::MFileSystem. Файл Core/MFileSystem.sref оставить пустым, в Core/MFileSystem.rsym
описать функцию GetFileAttribute, а функцию CoreP_MFileSystemP_GetFileAttribute описать в
Library.cpp.
  В случае же генерации кода на Си++ необходимости в файлах Library и LibraryEx уже быть не должно,
весь нативный сишный код должен быть представлен библиотечными модулями. Разумеется, это не касается
файла refalrts.cpp. Хотя и его можно сделать статической/динамической библиотекой.


====================================================================================================
  [DONE] C++: Инициализация и финализация в back-end'е Простого Рефала
====================================================================================================

  [TODO] 01.05.2009 - 14:46:30,01

  Реализация инициализации и финализации никак не затронет язык и компилятор Простого Рефала (за ис-
ключением того, что для этого статические ящики уже должны присутствовать в языке). IModule содержит
для каждого модуля стартовый код (инициализация+финализация или функция Go) и список всех импортиру-
емых модулей.
  Если в каждый сгенерированный файл Простого Рефала включить функцию ModuleNameP_InitE_, представ-
ляющая код инициализации соответствующего модуля (наличие суффикса E_ гарантирует несовпадение имени
с каким-либо сгенерированным именем), которая вызывает функции OtherModuleNameP_InitE_ импортируемых
модулей и затем вызовет стартовый код инициализации, который выполняется только один раз при первом
запуске, то стартовые коды инициализации будут вызваны в правильном порядке.
  Действительно, если модуль A импортирует модуль B, то код инициализации модуля A будет вызван пос-
ле вызова функции BP_InitE_, т.е. функция инициализации модуля B будет вызвана хотя бы один раз до
инициализации модуля A, а следовательно, модуль B будет проинициализироват до модуля A.
  Очевидно, что код финализации можно вынести в отдельную функцию, которую можно зарегистрировать
после завершения стартового кода инициализации. Сам факт регистрации финализатора можно использовать
для проверки того факта, что инициализирующий код выполнен.
  Схема реализации следующая:

  $EXTERN RegisterE_;
  $FORWARD ModuleNameP_InitializeE_, ModuleNameP_FinalizeE_;

  $EXTERN ImportModule1P_InitE_;
  $EXTERN ImportModule2P_InitE_;

  $ENTRY ModuleNameP_InitE_ { =
    <ImportModule1P_InitE_>
    <ImportModule2P_InitE_>
    <Register
      ModuleNameP_InitializeE_
      ModuleNameP_FinalizeE_
    >;
  }

  Очевидно, что можно применить и любую другую систему кодирования имён.
----------------------------------------------------------------------------------------------------
  [DONE] 07.05.2009 - 17:44:20,12

  Сделано в точном соответствии с TODO.


====================================================================================================
  [DONE] C++: Имена Модульного Рефала в Простом Рефале
====================================================================================================

  [TOTHINK] 27.04.2009 - 16:34:27,25

  Способ, которым можно представить имена (сегменты квалифицированного имени) в Простом Рефале,
прост: достаточно выбрать систему кодирования дополнительных символов. Наиболее подходящий способ
такой: символы '!', '?', '_', '-' заменяются соответственно на 'B_', 'Q_', 'U_', 'D_', остальные
символы остаются без изменений. Данное кодирование обладает следующими преимуществами:
  (+) Оно взаимно однозначно.
  (+) Кодированное имя не содержит двух соседних прочерков, не может начинаться на прочерк. Это яв-
ляется преимуществом, т.к. имена, начинающиеся на прочерк и содержащие два прочерка внутри являются
зарезервированными для Стандартной библиотеки Си++.
  (+) Имена, начинающиеся на '!' или '?', после кодирования будут начинаться с большой буквы -- имя
будет соответствовать правилам имён Простого Рефала.
  (+) По кодированному имени легко понять оригинал.
  Явных недостатков такой способ не имеет.
  Квалифицированные имена можно реализовать двумя способами: простым и сложным.
  Простой способ заключается в том, что вводится дополнительная управляющая последовательность,
представляющая собой разделитель квалификаторов, например 'P_'. Таким образом имя InOut::WriteLine
будет выглядеть как 'InOutP_WriteLine'.
  (+) Способ довольно простой.
  (+) Ничего не нужно менять в компиляторе Простого Рефала.
  (-) Слишком длинные имена таким способом кодировать нельзя слишком длинные имена (ограничение на
максимальную длину в Си++ составляет примерно 200 символов, дальше компилятор обрезает).
  Сложный способ заключается в том, что сущности, кодированные квалифицированными именами, будут
находиться в соответствующих пространствах имён. Таким образом, сгенерированный сишный код для имени
Std::InOut::WriteLine будет иметь вид:
  namespace Std {
  namespace InOut {
  refalrts::FnResult WriteLine( аргументы ) {
  }
  }
  }
  (+) Можно получить выигрыш в максимальной общей длине квалифицированного имени: на Visual Studio
2005 длинное квалифицированное имя не обрезается.
  (+) Пространства имён являются неотъемлемой возможностью Си++.
  (+) Такой способ интереснее
  (-) Необходимо изменять кодогенератор, формирователь конца функции должен знать имя функции, чтобы
поставить нужное число закрывающих фигурных скобок.
  (-) Не все компиляторы сохраняют в объектных файлах столь длинные имена. Borland C++ Builder 6,
например, имена в объектных файлах обрезает по 260-и символам.
  Надо заметить, что очень длинные квалифицированные имена мне встречались довольно редко (пока).
Однако, если в дальшейшем будет реализовываться синтаксис, основанный на действиях и с функциями
высших порядков, автоматически генерируемые промежуточные функции могут получать внутренние имена
вида ИмяРодительскойФункции::Какой-либоИдентификаторНапримерНомер. Конечно, в этом случае нужно по-
заботиться о том, чтобы имена автоматически генерируемых функций были короче.

  Синтаксис квалифицированных имён. Синтаксис в целом может быть похож на синтаксис квалифицирован-
ных имён в Модульном Рефале. В качестве разделителя имён можно использовать хоть точку, хоть двоето-
чие, хоть квадратик (два двоеточия).
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2009 - 14:46:30,01

  Простой способ лучше, т.к. (а) он более переносимый (Borland обрезает длинные имена в любом слу-
чае) и (б) он более прост, что в духе Простого Рефала (сделать всё максимально просто не заботясь
об эффективности.
  К тому же стоит рассмотреть и такой аспект: пополнять ли синтаксис Простого Рефала квалифициро-
ванными именами или нет: кодирование имени можно осуществлять как на уровне back-end'а Модульного
Рефала, так и на этапе генерации кода в Простом Рефале. Очевидно, что кодирование на уровне Модуль-
ного Рефала проще, т.к. не требует изменения синтаксиса Простого Рефала.
  Поэтому будем квалифицированные имена представлять простым способом, кодирование будем осуществ-
лять на уровне генерации .sref-файлов.
----------------------------------------------------------------------------------------------------
  [DONE] 07.05.2009 - 16:49:08,03

  Выполнено в полном соответствии с TODO. Имена функций, имеющих отношение к инициализации и финали-
зации, оканчиваются на 'E_', имена идентификаторов оканчиваются на 'I_'. В модуле может одновременно
упоминаться и идентификатор Name и функция с тем же имененм Name. Однако, компилятор Си++ (Visual
Studio) не позволяет использовать одновременно в одном файле шаблон класса и функцию с одним именем
(ругается). Поэтому все идентификаторы имеют суффикс 'I_'.


====================================================================================================
  [DONE] Статические ящики в back-end'е Простого Рефала
====================================================================================================

  [TOTHINK] 29.04.2009 - 17:40:52,94

  Статический ящик -- разновидность функции с побочным эффектом, возвращающей при вызове свой преды-
дущий аргумент. Возможная очевидная реализация:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter old_begin = 0;
    static refalrts::Iter old_end = 0;
    /*
      Присваиваем ссылкам old_begin и old_end текущий аргумент.
      В поле зрения вызов статического ящика заменяем на цепочку
      между old_begin и old_end.
    */
  }

обладает тем недостатком, что по завершении программы узлы между old_begin и old_end будут недоступ-
ны виртуальной машине, а значит не будут удалены. Хотя это для данной реализации некритично, но не-
красиво. В дальнейшем при возможной оптимизации выделения и освобождения памяти с простой схемой
сборки мусора это может стать проблемой. К тому же содержимое статических ящиков в данной реализации
не будет доступно для наблюдения в дампе памяти. Поэтому виртуальная рефал-машина должна иметь доступ
ко всем используемым статическим ящикам во время выполнения.
  Возникают следующие варианты.

  1. Использование копилки. Вводится копилка -- дополнительный двусвязный список, доступный рефал-
машине с операциями Br и Dg. В дальнейшем всё эквивалентно реализации статических ящиков Модульного
Рефала.

  Оценка.
  (+) Синтаксис Простого Рефала остаётся без изменений. Изменения касаются только рефал-машины (вво-
дится третий (после поля зрения и списка свободных блоков) список копилки -- фактически единственный
статический ящик, две библиотечные функции Простого Рефала Br и Dg (или одна Replace).
  (+) Удобство чтения дампа поля зрения.
  (-) Два уровня косвенности: копилка и статические ящик и как следствие снижение быстродействия.
  (-) Использование копилки. Копилку я не люблю.

  2. Хранение содержимого статических ящиков в специальном двусвязанном списке. Выглядит это так:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter begin = 0;
    static refalrts::Iter end = 0;
    if( (begin == 0) && (end == 0) && аргумент непустой ) {
      refalrts::Iter begin_swap = refalrts::get_begin_swap_list();
      вставить аргумент перед begin_swap
      присвоить begin и end начало и конец аргумента
      удалить вызов функции из поля зрения
    } else if( (begin == 0) && (end == 0) && аргумент пустой ) {
      удалить вызов функции из поля зрения
    } else if( (begin != 0) && (end != 0) && аргумент непустой ) {
      в двусвязанном списке вместо поддиапазона [begin, end] вставить аргумент
      и вызов функции в поле зрения заменить на поддиапазон [begin, end]
    } else if( (begin != 0) && (end != 0) && аргумент пустой ) {
      удалить поддиапазон [begin, end] из двусвязанного списка
      вставить поддиапазон [begin, end] вместо вызова в поле зрения
    }

    return refalrts::cSuccess;
  }

  Итераторы begin и end указывают на крайние узлы текущего содержимого статического ящика или оба
равны нулю (как это принято в Простом Рефале). Двусвязанный список статических ящиков представлен
точно также, как поле зрения и список свободных блоков -- парой глобальных переменных типа Node.
Функция get_begin_swap_list() возвращает g_begin_swap_list.next, в этом случае содержимое нового
статического ящика помещается в начало списка, или & g_end_swap_list, в этом случае содержимое но-
вого статического ящика помещается в конец списка (тогда функцию следует назвать get_end_swap_list).

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (-) В случае дампа памяти содержимое всех статических ящиков будет конкатенировано друг с другом
-- трудности понимания дампа памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  3. Хранение содержимого статических ящиков в специальном двусвязанном списке с головными узлами.
Отличие состоит в том, что содержимое каждого статического ящика в общем двусвязанном списке предва-
ряется головным узлом с именем этого ящика. Выглядит это так:

  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::Iter head = 0;
    static refalrts::Iter next_head = 0;

    if( head == 0 ) {
      // Первое использование
      assert( next_head == 0 );
      next_head = refalrts::get_begin_swap_list();
      head = refalrts::insert_head_node_before( next_head, "SomeSwap" );
    }

    /*
      Содержимое двусвязанного списка расположено между узлами head и next_head
    */
    обмен с аргументом операциями с двусвязанным списком
  }

  Головной узел -- специальный вид атома, содержащий имя статического ящика и при распечатке дампа
служащий разделителем между содержимыми статических ящиков.

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (+) Читабельный дамп памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  4. Статические ящики, связанные в однонаправленный список.
  Это выглядит так:
  // Файл refalrts.h
  namespace refalrts {

  struct SwapInfo {
    Iter begin;
    Iter end;
    SwapInfo *next;
    const char *name;
  };

  void link_swap( SwapInfo *swap_info );

  }

  // Файл refalrts.cpp

  refalrts::SwapInfo g_swap_top = 0;

  void refalrts::link_swap( SwapInfo *swap_info ) {
    swap_info->next = g_swap_top;
    g_swap_top = swap_info;
  }

  // сгенерированный код
  refalrts::FnResult SomeSwap( аргументы ) {
    static refalrts::SwapInfo info = { 0, 0, 0, "SomeSwap" };
    if( info.begin == 0 ) {
      refalrts::link_swap( & info );
    }
    дальше оперируем с диапазоном [info.begin, info.end] и аргументом
  }

  В этом случае рефал-машине доступны все статические ящики, задействованные в программе, по указа-
телю g_swap_top.

  Оценка.
  (+) Исключён лишний уровень косвенности.
  (+) Читабельный дамп памяти.
  (-) Необходимость изменения синтаксиса Простого Рефала.

  Если статические ящики будут добавлены в Простой Рефал, то будут иметь очевидный синтаксис: ди-
рективы $SWAP или $ESWAP и список имён через запятую.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 03.05.2009 - 14:56:57,84

  Способы № 1, № 2 и № 3 можно считать разновидностями одного и того же способа, только в случае ко-
пилки обработка единого двусвязанного списка для хранения содержимого ящиков пишется на Рефале, а в
двух других способах пишется на Си++, что несколько более эффективно.
  В первых трёх способах подразумевается, что содержимое статических ящиков принадлежит рефал-маши-
не, в четвёртом -- самим ящикам.
  Для всех упомянутых выше подхдов (включая очевидную реализацию) можно освобождать память, просто
вызывая статические ящики с пустым аргументом в коде финализации модуля. Однако при этом необходимо
или требовать от программиста на Простом Рефале, чтобы он опустошал ящики явно, или требовать, что-
бы Простой Рефал использовался только как back-end Модульного Рефала. Последнее можно гарантировать
встроив генератор кода Простого Рефала в Модульный (но это уже следующий шаг, сейчас ведётся разра-
ботка back-end'а, генерящего .sref-файлы).
  Способ № 2 неперспективен, т.к. потенциально затрудняет отладку программ, да и генерируемый код
мне кажется сложным.
  Одним из требований к статическим ящикам можно считать требование к беспровальности (nofail) их
работы: ошибки распознавания быть в принципе не может -- статический ящик должен быть способен при-
нять любой аргумент, ошибки распределения памяти тоже быть не должно (по крайней мере, для списко-
вой реализации) -- ящик лишь осуществляет обмен содержимого. Поэтому способ № 3 не может распреде-
лять элемент головы в списке свободных блоков -- это потенциальная (хотя и маловероятная) ошибка
распределения памяти. Поэтому ситуацию можно упростить тем, что при первом использовании ящика в
качестве маркера использовать или угловые скобки, или имя функции (после "<"). Имя функции предпоч-
тительнее, т.к. маркер головы всё равно должен содержать имя статического ящика, для превращения
узла-имени функции в маркер головы достаточно лишь изменить поле типа (Node::tag). Более того, мож-
но вообще отказаться от использования маркеров головы: в список статических ящиков при первом вызо-
ве ящика помещать его вызов вместе со скобками конкретизации, читабельность дампа памяти от этого
не пострадает. В таком случае можно даже ограничиться использованием одной статической переменной
-- открывающая скобка содержит указатель на закрывающую скобку конкретизации.
  Головные узлы не обязательно создавать из имени функции, их можно распределять статически внутри
самого ящика:
  Node head_node = { инициализация };
  При этом усложнится освобождение двусвязанного списка -- если раньше для каждого элемента просто
вызывалась функция free, то теперь нужно будет проверять, является ли элемент головным. Т.к. голов-
ных элементов в поле зрения должно быть существенно меньше, чем распределённых в динамической памя-
ти, то такая проверка будет неэффективна, т.к. почти для всех узлов будет выполняться и проверка, и
освобождение.
  Вместо использования отдельного двусвязанного списка для содержимого статических ящиков можно ис-
пользовать и само поле зрения (при этом надо будет ввести один указатель, отделяющий поле зрения
от памяти статических ящиков). Двусвязный список будет выглядеть так:
  [якорь] --- узлы поля зрения --- Голова1 --- Тело1 --- ... --- ГоловаN --- ТелоN --- [якорь]
                                   ^--- указатель на начало.
  Здесь якоря -- это глобальные переменные типа узел, которые двунаправленно связаны с полем зрения.
----------------------------------------------------------------------------------------------------
  [TODO] 03.05.2009 - 23:32:25,48

  Будем реализовывать статические ящики по способу № 3 с использованием поля зрения в качестве хра-
нилища. При первом использовании ящика головоной узел будет создаваться из узла имени функции. Но-
вые ящики будут добавляться слева от существующих.
  Головной элемент будет содержать два поля: поле имени типа char* и указатель на следующую голову.
Для инициализации головы будем использовать функцию refalrts::Iter refalrts::initialize_swap_head(
refalrts::Iter head_elem);, которая включает узел перед предыдущей крайне левой головой (при этом
узел исключается из предыдущего местоположения), инициализирует его как голову и сохраняет его мес-
тоположение как крайне левую голову. Таким образом удастся обойтись всего одной статической пере-
менной в функции ящика, что также упростит его инициализацию. Момент инициализации можно доверить
компилятору Си++, записав так:
  static refalrts::Iter s_head = refalrts::initialize_swap_head( func_name );
где func_name -- узел с именем функции.
----------------------------------------------------------------------------------------------------
  [DONE] 04.05.2009 -  1:36:05,40

  Выполнено в полном соответствии с TODO.
  В RefalRTS добавлены следующие функции.

  Iter initialize_swap_head( Iter head );

  Инициализирует головной узел (см. TODO).

  void swap_info_bounds( Iter& first, Iter& last, Iter head );

  По головному узлу находит содержимое статического ящика. Возвращает его как обычный диапазон Прос-
того Рефала ([first, last] или [0, 0] для пустого диапазона).

  void swap_save( Iter head, Iter first, Iter last );

  Сохраняет содержимое по элементу головы.


====================================================================================================
  [DONE] C++: Идентификаторы в Простом Рефале
====================================================================================================

  [TOTHINK] 27.04.2009 - 16:34:27,25

  Идентификаторы представляют собой элементы глобального множества, смысл которых состоит только в
возможности сравнения на равенство/неравенство средствами сопоставления с образцом с известным иден-
тификатором или между собой. Упорядочивание (сравнение на '<', '>', '==') иденификаторов не определе-
но, требуется лишь, чтобы выполнялись следующие законы:
  (1) Если s.A:s.B (отображается путём сопоставления с образцом), то s.A == s.B.
  (2) Выполняется только одно из трёх соотношений: s.A < s.B, s.A == s.B, s.A > s.B.
  (3) Если s.A < s.B и s.B < s.C, то s.A < s.C.
  Допустимо, если все идентификаторы будут считаться равными (как это сейчас сделано в back-end'е
Рефала 5). В идеале идентификаторы должны сравниваться по их текстовому представлению, т.к. подобное
поведение интуитивно понятно пользователю.
  Сравнение на равенство/неравенство средствами сопоставления с образцом должны выполняться эффек-
тивно, т.е. выполняться за постоянное время.

  Идентификаторы можно реализовать несколькими способами, их можно разделить на статические (пред-
ставления идентификаторов задаются на этапе компиляции) и динамические (представления задаются на
этапе выполнения), поддерживающие раздельную компиляцию (не требуют явного дополнительного прохода
на этапе компоновки) и не поддерживающие (требуют оного).

  1. Представление идентификаторов в виде функций заданного формата, размещаемых в специальной сек-
ции объектного файла. Статический, поддерживает раздельную компиляцию. Идея состоит в том, что су-
ществуют секции объектного файла, дублирующиеся элементы которых в разных единицах трансляции устра-
няются компоновщиком. В качестве типа можно выбрать функцию, не принимающую никаких аргументов и
возвращающую const char *. В качестве возвращаемого значения можно использовать текстовое представ-
ление идентификатора, что упростит вывод на экран.
  Пример.
  // Файл Module1.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F1( .... ) {
    .... & Success ....
  }

  // Файл Module2.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F2( .... ) {
    .... & Success ....
  }

  В итоге за счёт использования особой секции файла (секция указывается в директиве #pragma), компо-
новщик. видя в двух объектных файлах идентичные определения, одно из них устранит и в исполнимом
файле окажется только одно определение функции Success, на которое будут ссылаться функции F1 и F2.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы.
  (*) Указатели на функции можно сравнивать на равенство и неравенство.
  (*) Сравнение двух указателей выполняется за постоянное время.

  Оценка.
  (+) Способ статический -- не требуется динамических расходов во время выполнения программы.
  (+) Не требуется явного дополнительного прохода на стадии компоновки (неявный проход делает компо-
новщик Си++).
  (+) Способ работает как в Си, так и в Си++ (если понадобится написать генератор кода языка Си).
  (+) Доступно текствое представление на этапе времени выполнения: это облегчает отладку, позволяя
выводить идентификаторы на экран.
  (+) Возможность упорядочить по текстовому представлению.
  (-) Способ непереносим -- требуемая прагма зависит от компилятора, некоторые компиляторы могут та-
кую прагму не предоставлять.
  (-) Затруднена загрузка динамических библиотек: динамические библиотеки будут использовать свои
адреса к функциям-представлениям идентификаторов. В этом случае или интерфейс динамической библиоте-
ки не должен использовать идентификаторы (из-за чего пострадает или ясность программы -- обмен будет
осуществляться буквами либо цифрами, либо быстродействие -- обмен будет осуществляться целыми слова-
ми, либо удобство -- если в интерфейсе будут участвовать пустые функции -- по образцу $EENUM), или
идентификаторы должны будут сравниваться по текстовому представлению (что может снизить быстродей-
cтвие).
  Таким образом, при использовании динамической загрузки цель будет не достигнута.

  2. Представление идентификаторов в виде статических функций шаблонного класса. Статический, под-
держивает раздельную компиляцию. Аналогичен предыдущему, с тем отличием что идентификаторы представ-
ляются так:
  // Файл Module1.cpp
  template<typename T>
  class Success {
    static const char* name { return "Success"; }
  };
  refalrts::FnResult F1( .... ) {
    .... & Success<int>::name ....
  }

  Идея состоит в том, что шаблоны по умолчанию помещяются в секцию, описанную в первом способе.

  Цель достигнута -- см. способ №1.

  Оценка.
  Достоинства в целом те же, что и в способе №1, с тем исключением, что способ работает только в
Си++. На тех компиляторах, на которых я его проверял (g++ под Линукс, BCC 5.5 и Visual Studio 2005
под Windows) этот способ работает. Требует ли того Стандарт, я не знаю, т.к. в Стандарт не глядел.
  Недостатки в целом тоже те же, только с оговоркой на переносимость -- шаблоны являются неотъем-
лемым средством Си++, а вот объединяются ли они на любом компиляторе?..

  3. Создание перечисления идентификаторов. Статический, требует дополнительного прохода. Идея сос-
тоит в том, что идентификаторы представляются целыми числами, ссылки на идентификатор в сгенериро-
ванном тексте ссылки выглядят заметными для автоматического анализа, например как ident::Success,
в каждом сгенерированном файле присутствует ссылка на заголовок "idents.h", перед передачей сгене-
рированных файлов компилятору C++, выходные файлы будут сканироваться на предмет наличия идентифи-
каторов, после чего будет создаваться файл "idents.h" с таким содержимым:
  // Файл idents.h
  namespace ident {
    enum {
      ...
      Success,
      ...
    };
  }

  extern const char* textual(unsigned id);

и файл "idents.cpp" с таким содержанием
  // Файл idents.cpp

  const char* idents[] = {
    ...
    "Success",
    ...
  };

  const char* textual(unsigned id)
  {
    return idents[ id ];
  }

  Если текстовое представление идентификаторов на этапе выполнения не требуется, то на этапе компо-
новки будет подключаться не сгенерированный файл idents.cpp, а на заранее заготовленный файл
noidents.cpp:
  // Файл noidents.cpp
  const char* textual(unsigned id)
  {
    // Возврат например "?" или число id в текством представлении, например "42"
  }

  Очевидно, что имена в определении enum и в массиве должны следовать в одинаковом порядке. Если
идентификаторы располагать в enum в алфавитном порядке, то будет возможность упорядочивания иденти-
фикаторов по текстову представлению путём лишь сравнения числовых значений.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы -- файл idents.h един для всех единиц трансляции.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка:
  (+) Способ статический -- не требуется затрат во время выполнения программы.
  (+) Возможность отключать текстовое представление, когда этого не нужно.
  (+) Сравнение по текстовому представлению.
  (+) Способ работает как в Си, так и в Си++.
  (-) Требует дополнительного прохода на стадии компоновки.
  (-) Сложность с размещением файла "idents.h", если отдельные модули располагаются в разных папках.
Директива #include "idents.h" может по умолчанию искать файл idents.h в той же папке, что и файл ис-
ходного текста. Если файл idents.h присутствует в той же папке, что и исходник, то глобальный файл
может быть не найден.
  (-) Так же как и в способах №1 и №2, затруднена загрузка динамических библиотек. Если для динами-
ческих библиотек генерировать код тем же путём, что и для программы, совершенно разные идентификато-
ры будут получать одинаковые числовые представления, что потенциально способно привести к хаосу.
Если же изменить генерацию кода так, чтобы ссылки на идентификатор имели вид:
  refalrts::FnResult F(...) {
    ... ident::Success + g_offset ...
  }
где g_offset -- глобальная переменная, для основной программы равная нулю, при загрузке динамической
библиотеки наращиваемая на количество известных идентификаторов. В этом случае идентификаторы с оди-
наковым текстовым представлением в главной программе и библиотеке численно эквивалентны не будут.
  В этом случае недостатки способа по отношению к динамической загрузке будут те же, что и в спосо-
бах №1 и №2.
  Упорядочивание по численным значениям не будет эквивалентно упорядочиванию по текстовым представ-
лениям.
  При использовании динамической загрузки цель достигнута не будет.

  4. Динамическая таблица идентификаторов. Динамический, поддерживает раздельную компиляцию. Идея
следующая.
  // Функция, осуществляющая поиск в таблице и если необходимо добавление
  unsigned lookup( const char *name );

  // Некоторая сгенерированная функция
  refalrts::FnResult F(...) {
    const static unsigned Success = lookup("Success");
    const static unsigned Fails = lookup("Fails");
    ......
  }

  Идея заключается в том, что в Си++ инициализация статических переменных выполняется при первом
выполнении функции, на протяжении оставшегося времени программы переменные Success и Fails будут
хранить значения, соответствующие данным идентификаторам.
  В программе присутствует динамическая таблица, связывающая текстовое представление с числовым.
Функция lookup проверяет наличие отображения Текст <--> Число для данной текстовой строки, если
его нет, возвращается следующее числовое значение, которое ассоциируется с данным идентификато-
ром, если есть -- возвращается число.

  Цель достигнута:
  (*) Таблица глобальна для всей программы.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка
  (+) Не требуется прохода на стадии компоновки.
  (+) Работает как на Си, так и на Си++
  (+) Полностью совместим с динамическими библиотеками -- указатель на таблицу можно передать в ди-
намическую библиотеку, идентичные идентификаторы получат одинаковые числовые значения.
  (+) Текстовое представление доступно во время выполнения.
  (+) Есть возможность расширять множество идентификаторов, используемых в программе, пользователем
(точно также, как и в Рефал 5 -- фунцией типа Implode). Однако, для уничтожения неиспользованных
идентификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Затраты времени выполнения на инициализацию: каждая функция при первом вызове будет подторма-
живать, хотя и незначительно.
  (-) В каждой функции, использующией идентификатор, будет упоминаться текстовая строка, его пред-
ставляющая. Компиляторы могут не объединять дубликаты текстовых строк, отсюда возможно распухание
объёма исполнимого файла (хотя он и так распухает от кода).
  (-) Наиболее простой метод упорядочивания -- по числовым значениям, т.е. упорядочивает не в алфа-
витном порядке.

  Если отказаться от требования сравнения на равенство за постоянное время, то можно рассмотреть ещё
один способ. Самый простой и самый очевидный.

  (5.) Си-строки. Идея в том, что идентификаторы следует представлять в виде обычных Си-строк, т.е.
указателей на char. Выглядит это так:
  refalrts::FnResult F(...) {
    ..... "Success" ...
  }
  Сравнение на равенство осуществляется функцией strcmp языка Си.

  Цель не достигнута:
  (*) Текстовое представление инвариантно, т.к. представляет самого себя.
  (*) Текстовые строки можно сравнивать на равенство/неравенство.
  (!) Сравнение текстовых строк осуществляется за время O( min( length(s1, s2) ) ), т.е. пропорцио-
нально длине строк, причём максимальное время достигается при одинаковых идентификаторах. (Для опре-
деления неравенства идентификаторов Success и Fails требуется одно сравнение, для определения равен-
ства Success и Success требуется 7 сравнений (включая завершающий ноль.)

  Оценка.
  (+) Способ статический -- не требуется затрат на время выполнения.
  (+) Не требует прохода на стадии компоновки.
  (+) Полностью совместим с динамической загрузкой библиотек.
  (+) Чрезвычайная простота реализации.
  (+) Возможность расширения пользователем набора идентификаторов на стадии выполнения. Для этого
достаточно распределить в динамической памяти новую строку. Однако для удаления неиспользуемых иден-
тификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Расход памяти на используемые идентификаторы -- на каждое упоминание идентификатора требуется
одна Си-строка, В Простом Рефале, как показывает внутренний осмотр исполнимого файла, достаточно
много места занимают имена функций, Си-строки, которые используются для инициализации атомов-функ-
ций. Атомы-функции содержат строковое представление для удобства отладки -- для того, что бы можно
было проанализировать дамп поля зрения. Хотя, надо заметить, расход памяти на нерациональную гене-
рацию кода гораздо больше.
  (-) Как уже было сказано, требуется расход времени на сравнение двух строк. На самом деле сравне-
ние иногда можно оптимизировать, сравнивая сначала указатели на равенство, а затем уже сравнивая
содержимое.

  Синтаксис идентификаторов. Чтобы отличать идентификаторы от имён функций, можно идентификаторы об-
рамлять двойными кавычками (тогда потенциально можно разрешить в идентификаторах использовать многие
другие символы, а значит и расширить их систему кодирования) -- "Name", можно обрамлять слешами --
/Name/ как в Рефале 2, можно начинать с какого-либо символа, например, с # -- #Name, как это сделано
в Smalltalk.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2009 - 14:46:30,01

  Дополнение по поводу синтаксиса. Я склоняюсь к использованию синтаксиса типа #Name, причём '#' и
'Name' будут двумя отдельными лексемами. (точно также, как и в Модульном Рефале, где & -- отдельная
лексема). Связывание # и Name в один элемент будет осуществляться на отдельном проходе по лексемам.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 02.05.2009 -  0:53:33,64

  Компилятор Простого Рефала осуществляет синтаксический разбор и генерацию кода в один проход на
на уровне всего файла: сразу же после разбора таких элементов, как объявление функции, определения
перечисления (пустых функций), в ближайшем будущем статических ящиков, начала функции, предложения,
конца функции происходит их генерация.
  При генерации идентификаторов способами № 1 и № 2 требуется дополнительный проход по всей функции
для того, чтобы определить список используемых идентификаторов и определить их перед функцией. А до-
полнительный проход по функции потребует изменение структуры синтаксического анализатора. Для спосо-
ба № 1 можно было бы в самой функции обнаруживать идентификаторы, их объявлять непосредственно внут-
ри функции, заносить их в таблицу символов, а при генерации конца функции, определять вновь объяв-
ленные идентификаторы.
  В качестве альтернативы можно было бы перед использованием идентификатора, их явно объявлять как
функцию типа:

  $NAME Name, OtherName;

  F { # Name = # OtherName; }

но это несколько усложнит генерацию на уровне Модульного Рефала (хотя было бы в духе Простого Рефа-
ла -- объявление сущностей перед их использованием).
  От способов, требующих дополнительного прохода на этапе компоновки, я планирую отказаться, т.к.
они, собственно, требуют дополнительного прохода, а значит усложняют генерации кода, поэтому от спо-
соба № 3 я отказываюсь.
  Способ № 4 требует разработки специального ассоциативного массива для идентификаторов (использова-
ние стандартных классов Си++ не соответствует духу RTS Простого Рефала -- он построен практически
как подмножество Си языка Си++, поэтому std::map сюда не вписывается), т.е. требует довольно нетри-
виальной RTS. Поэтому я от него отказываюсь.
  Способ № 5, хотя и не достигает цели с точки зрения быстродействия (линейная сложность сравнения),
но больше соответствует духу Простого Рефала (задача должна быть решена наиболее просто, пусть и да-
же в ущерб быстродействию.
  Хотя, если быть честным, первые три способа не достигают цели при использовании динамических биб-
лиотек.

  P.S. К моменту написания этого TOTHINK уже реализована поддержка генератора кода для способа № 5,
хотя в принципе не сложно и перейти к способам № 1 и № 2, добавив возможность предобъявления.
----------------------------------------------------------------------------------------------------
  [TODO] 02.05.2009 - 16:11:55,89

  Идентификаторы реализованы в точности по схеме № 2, RTS идентификаторы полностью поддерживаются.
Также добавлен соответствующий тип узла cDataIdentifier и, соответственно, поле информации
ident_info.
  На данный момент требуется расширить библиотеку примитивов поддержкой идентификаторов (вывод, упо-
рядочивание, запрос типа).
----------------------------------------------------------------------------------------------------
  [DONE] 02.05.2009 - 17:51:31,35

  Идентификаторы полностью реализованы. Порядок сортировки (функцией-примитивом SymbCompare): чис-
ло > character > функция > идентификатор > дескриптор файла. Функции сравниваются сначала по тексто-
вому представлению, затем по указателю. Идентификаторы всегда сравниваются по текстовому представле-
нию.


====================================================================================================
  [DONE] C++: Абстрактные типы данных в Простом Рефале
====================================================================================================

  [TODO] 27.04.2009 - 16:34:27,25

  Абстрактные типы данных сравнительно несложно реализовать. Синтаксис можно позаимствовать из Мо-
дульного Рефала, в качестве метки АТД можно использовать имя $ENUM или даже $EENUM (для экспортиру-
емых АТД в перспективе). Синтаксис:
  PatternAbstractTerm ::= '[' Name Pattern']' .
  ResultAbstractTerm ::= '[' Name Result ']' .
  Проверку "приклеенности" имён функций к квадратным скобкам можно проводить за отдельный проход
после проверки парности скобок или в одном проходе с оной парности.
----------------------------------------------------------------------------------------------------
  [DONE] 02.05.2009 - 16:11:55,89

  Реализовано в соответствии с TODO.
  Добавлено два новых типа узлов (теги cDataOpenADT и cDataCloseADT), которые устроены в точности
также, как и обычные скобки. На уровне синтаксического анализа гарантируется, что после "[" следу-
ет имя функции. Также добавнены в алгоритм команды распознавания АТД (примитивы распознавания
adt_left и adt_right обнаруживают обе АТД-скобки и требуемое имя функции после открывающей скобки),
генерации АДТ-скобок (примитивы alloc_open_adt и alloc_close_adt просто распределяют узлы, проини-
циализированные как "[" и "]" соответственно, распределение имени после "[" выполняется отдельным
примитивом).


====================================================================================================
  [DONE] Продумать back-end C++
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Если я буду представлять версию 0.2 широкой общественности (списку рассылки Рефала), то реализо-
вать генерацию сишного кода необходимо. Удобнее, конечно, вариант с генерацией самим компилятором
Модульного Рефала Си++-файлов, но вариант с генерацией файлов Простого Рефала проще в реализации
(хотя для этого придётся расширять Простой Рефал аналогом квалифицированных имён, АТД, статическими
ящиками). Как обычно, ничто не мешает совмещать оба подхода в разных back-end'ах.
  Поэтому надо продумать необходимость этого средства в версии 0.2.
----------------------------------------------------------------------------------------------------
  [DONE] 26.04.2009 - 21:59:57,53

  Собственно, всё продумано, приступаем к реализации.
  Независимо от того, как будет осуществляться генерация кода на Си++ -- напрямую компилятором с
"пришитым" генератором от Простого Рефала (генератор Простого Рефала состоит из модуля создания "ал-
горитма" -- команд языка сборки промежуточного представления предложения и модуля собственно генера-
ции) или путём генерации исходных текстов Простого Рефала, в любом случае надо пополнить Простой Ре-
фал средствами, необходимыми для Модульного Рефала:
  1. Идентификаторы (имена, метки, compound-символы). Далее по тексту "идентификаторы". Идентифика-
торы представляют собой элементы глобального множества, смысл которых состоит только в возможности
сравнения на равенство/неравенство средствами сопоставления с образцом с известным идентификатором
или между собой.
  2. Квалифицированные имена Модульного Рефала, т.е. имена, составленные из сегментов. Сегмент под-
чиняется правилам Модульного Рефала. т.е. может содержать символы типа '!', '?', '_', '-', причём
последние два различаются.
  3. Абстрактные типы данных.
  4. Статические ящики.
  5. Инициализация и финализация.
  Все задачи, относящиеся к генерации C++-кода, будут иметь префикс C++.


====================================================================================================
  [DONE] ПИ:Поддержка переменной MODULEPATH с проверкой корректности
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Надо осуществлять проверку того, что никакой каталог в переменной MODULEPATH не является подка-
талогом другого MP-каталога. А также проверять существование данного каталога.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.
----------------------------------------------------------------------------------------------------
  [DONE] 26.04.2009 - 12:56:39,09

  Проверка корректности (ссылки вверх и вложенность) вынесены в другое задание (на данный момент в
TOTHINK), а проверка на существование каталога излишняя, т.к. в любом случае требуется наличие фай-
лов в этой папке (файла исходного текста для компилируемого модуля или всех выходных файлов для
библиотечного). Выдавать сообщение об ошибке я считаю нерациональным, т.к. на компьютер может быть
установлена неполная версия библиотеки, а список MP-каталогов подгружается из единого cfg-файла.
В этом случае компиляция будет невозможна. Поэтому при отсутствии MP-каталога надо выдавать макси-
мум предупреждение.


====================================================================================================
  [DONE] ПИ:Проверять корректность имени модуля/пакета
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.
----------------------------------------------------------------------------------------------------
  [DONE] 26.04.2009 - 12:56:39,09

  Проверка осуществляется только на отсутствие знака '?' внутри квалифицированного имени модуля.
Анализ длины имени модуля пока не выполняется.
  Реализован многоуровый контроль корректности имени модуля/пакета, хотя и неполный. Контроль осу-
ществляется на двух (для Windows на трёх уровнях):
  1. На стадии поиска модуля (в модуле MModules) среди всех гипотез (front-end + место расположе-
ния) отбрасываются те, квалифицированное имя модуля которых содержит знак '?'. Таким образом, при
поиске модуля командной строки модуль с некорректным именем найден не будет. Аналогичная проверка
потенциально выполняется для импортируемого модуля, но (см. ниже) функция LookupImportModule не дол-
жна вызываться с некорректным именем.
  2. На стадии компиляции (в модуле MCompiler) при анализе импортируемых модулей некорректные имена
отбрасываются, а информация о них помещается в список ошибок.
 (3.) Для Windows-приложений отсев некорректных имён модулей, заданных в командной строке происхо-
дит ещё на стадии анализа командной строки: при преобразовании имени модуля в специальный формат
пути производится проверка имени файла на корректность.
  Проверка не полна, т.к. можно было бы проверять корректность и на стадии синтаксического анализа:
требовать, чтобы имена, указанные после директив $MODULE ($PROGRAM) и $END, а также действительные
имена импортируемых модулей (в отличие от псевдонимов) являлись корректными именами.


====================================================================================================
  [DONE] Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Необходимо добавить следующие функции:
  (*) Функция, которая склеивает имя папки с относительным именем.
  (*) Функция, которая унифицирует имя папки -- т.к. в Windows одни и те же пути к файлам могут
выглядеть по-разному (прямой и обратный слеш, регистр символов).
  (*) Функция, возвращающая абсолютное имя для относительного. Такая функция может проверять также
наличие данного файла/папки. А может и не проверять.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Помимо этого необходима функция, способная распарсить имя папки на сегменты вида t.RootMode
(e.NameSegment), где t.RootMode ::= (Relative) | (Relative-Disk s.Disk) | (Absolut) | (Absolut-Disk
s.Disk) | (Absolut-Net e.Server), соответственно для 'Dir/File', 'C:Dir/File', '/Dir/File', 'C:/Dir'
'/File', '//SERVER/Dir/File'. Очевидно, поведение этой функциии будет зависеть от используемой опе-
рационной системы, т.к. в POSIX-системах имя папки может содержать любые символы, кроме 0x00 и пря-
мого слеша.
----------------------------------------------------------------------------------------------------
  [DONE] 26.04.2009 - 12:56:39,09

  Набор указанных возможностей реализован. Реализованы следующие средства:
  (*) Поддержка структуры данных (не АТД) "Путь к файлу" в полном соответствии с TODO: выражение,
начинающееся с типа корня и содержащее элементы пути (подпапки и собственно имя файла) в скобках.
  (*) Функция конкатенации путей, указанных выше.
  (*) Для получения полного имени папки необходимо запросить у файла атрибут LongName при помощи
функции FileAttribute. Кроме того, фукция FileAttribute проверяет наличие файла.
  (*) Для унификации имени папки используются функции CanonicalPath-Str и CanonicalPath-Pt, уни-
фицирующие соответственно путь заданный обычным (s.Char*) образом или как вышеупомянутый тип.


====================================================================================================
  [DONE] Ввести особый тип компоновки для особых функций
====================================================================================================

  [TODO] 13.04.2008 - 21:06:47,07

  Было бы красиво, на мой взгляд, для функций Init и Final обычных модулей и функции Go головного
модуля иметь специальный тип компоновки.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [DONE] ‚в 21.04.2009 - 13:02:07.17

  В этом уже нет необходимости, т.к. структура компилятора изменена таким образом, что стартовый
код, код инициализации и код финализации уже не зависит от имён соответствующих функций (ранее
Go, Init и Final), а стало лишь особенностью синтаксического анализа. Так что теперь можно разрабо-
тать ситнаксис, использующий другие имена для этой цели или даже не использующий их вовсе (например,
используя директивы $START, $INIT и $FINAL, после которых следует результатное выражение.


====================================================================================================
  [FIXED] Функция MOS::Exit и финализаторы
====================================================================================================

  [ERROR] 05.01.2009 - 21:31:08,54

  На данный момент функция MOS::Exit перенаправляет вызов к одноимённой функции модуля MRefalRTS,
которая в свою очередь, перенаправляет вызов к функции Exit Рефала 5. Поэтому, если в программе име-
ются модули с нетривиальной инициализацией (которая устанавливает некоторый инвариант) и нетривиаль-
ной финализацией (которая разрушает этот инвариант), финализаторы при вызове функции Exit не вызыва-
ются.
  Необходимо продумать пути исправления и исправить данную ошибку.
  Возможен такой вариант. Линковщик собирает все вызовы функций финализации в некоторую с заранее
известным именем. Далее, эту же функцию вызывает функция MRefalRTS::Exit. Недостаток этого варианта
в том, что при вызове функции Exit из финализатора поведение программы будет неопределено (хотя фак-
тически она зависнет). К тому же, при вызове функции Exit из инициализатора будут вызваны финализа-
торы ещё не инициализированных модулей.
  Другой вариант состоит в том, что список функций-финализаторов заносится в копилку Рефала 5 под
некоторым именем, каждый из финализаторов заносится в момент выполнения функции инициализации соот-
ветствующего модуля (стековая архитектура копилки для этого подходит чрезвычайно хорошо). Затем,
после выполнения функции Go происходит вызов <MRefalRTS::Exit s.RetCode> с s.RetCode == 0, который,
если стек финализаторов в копилке не пуст, вызывает финализатор с верхушки и за тем себя же
(<MRefalRTS::Exit s.RetCode>), если же стек пуст -- вызывается <Exit s.RetCode>. Данный метод хорош
тем, что позволяет безопасно вызвать Exit в инициализаторах и финализаторах. Недостаток в том, что
обработка инициализаторов усложняется (нужно определённым образом вставлять в них код сохранения фи-
нализатора).
----------------------------------------------------------------------------------------------------
  [ERROR] 01.02.2009 - 21:42:25,09

  Для выпуска версии 0.2 ошибку надо исправлять безусловно.
----------------------------------------------------------------------------------------------------
  [FIXED] ‚в 21.04.2009 - 13:02:07.17

  Одновременно с разработкой кода точек входа модуля (стартовой для головного модуля, точек инициа-
лизации и финализации для регулярного модуля) была исправлена и эта ошибка. Ошибка была исправлена
следующим путём: в объектных файлах back-end'а Рефала 5 было создано место для точек запуска моду-
лей. В объектный файл головного модуля в точку запуска помещается стартовый код, в объектный файл
регулярного модуля в точку запуска помещается код инициализации, при наличии кода финализации в объ-
ектный файл помещается функция __Finalizer, вызывающая оный код, а в точку запуска помещается после
кода инициализации код регистрации финализатора. Последняя осуществляется путём добавления указате-
ля на функцию __Finalizer в копилку под именем 'Finalizers'.
  Код функции $ENTRY Go в выходном файле Рефала 5 собирается линковщиком из кода точек запуска моду-
лей проекта в порядке от импортируемых к импортирующим и вызова функции <RefalRTS::Exit 0>.
  Функция RefalRTS::Exit если копилка с именем 'Finalizers' не пустая, вызывает самый верхний фина-
лизатор и затем рекурсивно себя, до тех пор, пока копилка не опустошится. При опустошении копилки
вызывается функция Exit Рефала 5.


====================================================================================================
  [DONE] При компоновке заменять самые примитивные функции на функции Рефала-5
====================================================================================================

  [TODO] 23.04.2008 - 22:49:01,30

  Т.е. идея в том, что нужно будет заменять вызовы функций типа MRefalRTS::Card сразу на <Card...>.
Причём это можно реализовать так, что в линковщик явно не будут встраиваться эти функции. Примитивные
функции будут описаны как псевдонимы в файле MRefalRTS особыми директивами линковщика. Можно, напри-
мер, ввести тег 'p ' с таким синтаксисом
  p Entry::MRefalRTS::Prout Prout
или
  b Entry::MRefalRTS::Prout
  p Prout.
  В этом случае в таблицу MLinkerAliasTable вместо сгенерированного псевдонима вида X123 будет до-
бавлен псевдоним Prout.
  Способ этот ортогонален компилятору, т.к. позволяет легко изменять набор встроенных функций не
меняя ни строчки кода самого компилятора. Файл MRefalRTS всё равно пишется вручную.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Сейчас, когда были достигнуты определённые успехи в генерации кода на Си++, выглядит уже малоперс-
пективным развитие back-end'а Рефала 5. Поэтому дальнейшие усилия на этом пути не кажутся необходи-
мыми и приоритетными. Поэтому данное TODO я к приоритетным не отношу.
----------------------------------------------------------------------------------------------------
  [DONE] ‚в 21.04.2009 - 13:02:07.17

  Не смотря на то, что дальнейшее развитие back-end'а Рефала-5 я считаю не перспективным, это TODO
было выполнено. Дело в том, что параллельно с этим TODO исправлялась ошибка, связанная с инициали-
заторами и финализаторами, так что я за одно и изменил этот аспект компоновки. Сделано в полном со-
ответствии со вторым вариантом:
  b Entry::MRefalRTS::Prout
  p Prout
(точка в конце не стоит в отличие от TODO).


====================================================================================================
  [DONE] Обновить спецификацию "Поиск исходников" новым пониманием back-end'ов
====================================================================================================

  [TODO] 09.03.2009 - 13:30:36,79

  Как было упомянуто в предыдущем TODO (Изменить обработку командной строки), существует понятие
back-end'а для пользователя и внутреннее понятие back-end'а. Для пользователя под back-end'ом под-
разумевается режим работы компилятора, при котором исполнимый файл создаётся тем или иным средст-
вом. Внутреннее понятие back-end'а включает в себя информацию о выходном расширении, выходной пап-
ке и функциях генерации и компоновки. Эти понятия нужно подробно раскрыть в спецификации.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 20.04.2009 - 16:00:13.96

  В обновлении спецификации нет никакой необходимости, т.к. собственно, понятия back-end'а в ней не
фигурирует. Спецификация описывает лишь физическое представление модулей как файлов файловой систе-
мы и их взаимное расположение. Низкоуровневое понятие back-end'а в ней соответствует понятию выход-
ного языка или файла межмодульных связей. Высокоуровневое понятие back-end'а в ней не фигурирует,
т.к. спецификация не касается того, как формируется набор выходных языков или файлов межмодульных
связей. Поэтому, данное TODO не относится к указанной спецификации (возможно, касается какой-то дру-
гой, на данный момент не написанной).


====================================================================================================
  [DONE] Вынести из компилятора метаданные
====================================================================================================

  [TODO] 21.02.2008 - 15:51:11,21

  Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
  Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Данная задача будет частично (а может даже и полностью) выполнена при выполнении TODO АТД "Конфи-
гурация". Данное АТД будет создаваться после анализа командной строки, но до того, как будет прово-
диться анализ модулей; АТД как раз и будет содержать то, что здесь названо как "метаданные".
----------------------------------------------------------------------------------------------------
  [DONE] 15.04.2009 - 19:27:08,40

  Теперь компилятор поддерживает возможность тонкой настройки back- и front-end'ов. Эта возможность
реализуется параметрами командной строки -tune-be и -tune-fe. Данные опции имеют параметр -- имя
back-end'а или front-end'а соответственно, а также группу. В состав групп входит опция -ext:ext,
определяющая расширение выходного файла (для обоих видов end'ов) и опция -dir:subdir (только для
выходной части). На данный момент поддерживаются имена: Refal5, XLinx, SymInfo и MRefal.


====================================================================================================
  [CHANGED] Командная строка
====================================================================================================

  [CHANGED] 15.04.2009 - 19:27:08,40

  Появились следующие возможности командной строки:
  (1) Префиксы '-' и '+'. В качестве префиксов опций командной строки можно использовать как символ
плюса, так и символ минуса. На данный момент, пока используется back-end Рефал 5, опции командной
строки, начинающиеся с минуса, недоступны. Но при подгрузке опций из файла (см. ниже) и в дальнейшем
при развитии компилятора (появлении других back-end'ов) опции с префиксом '-' (будут) доступны.
  (2) Опции с группой. Синтаксис
  -option ( -subopt1 -subopt2:value filename -file:finename -subopt4 ... )
для опций без параметра и
  -option:value ( ... )
для опций с параметром. Скобки должны являться отдельными аргументами командной строки -- должны
отбиваться пробелами (в случае загрузки из файла -- в отдельных строчках (см. ниже)).
  (3) Опция -file:filename.ext. Данная опция позволяет в командной строке задавать имена файлов,
начинающихся с '+' или '-'. Хотя в Модульном Рефале имена модулей не могут начинаться на знаки
препинания, имя модуля может быть указано относительным путём начиная с папки. А у папки имя мо-
жет начинаться и с '+', и с '-'.
  (4) Подгрузка опций из файла. Задаётся опцией -cfg:filename.ext. В этом случае каждая строка
соответствует аргументу командной строки, пустые строки и строки комментариев игнорируются. Коммен-
тариями являются строки, начинающиеся со знака '#', перед которым может следовать любое количество
пробельных символов.


====================================================================================================
  [DONE] Изменить обработку командной строки
====================================================================================================

  [TODO] 18.04.2008 - 22:57:27,21

  Сейчас (в текущей версии 0.1.904) модули/файлы в командной строке мыслятся как модули/файлы, вхо-
дящие в проект. "Лишние" файлы, которые компилируются и прилинковываются, могут иметь свои функции
инициализации, что позволяет осуществить гамак. Сие не есть хорошо. Надо изменить смысл командной
строки следующим образом.
  (1) Если некоторый аргумент командной строки является головным модулем, то он рекурсивно компи-
лируется и линкуется в .exe-шник. Если аргумент явяляется обычным модулем, то он рекурсивно компили-
руется, но не линкуется.
  (2) В командной строке можно указать несколько имён файлов/модулей. Каждый из них обрабатывается
согласно пункту (1). Таким образом, можно одновременно компилировать и собирать несколько проектов
одновременно. Если эти проекты имеют общие модули, то общее время компиляции должно снизиться.
  (3) Если расширение файла не указано, то поиск модуля выполняется по всем доступным front-end'ам.
Если расширение указано, то компиляция осуществляется указанным front-end'ом.
  (4) В командной строке могут быть опции, позволяющие выбрать необходимые back-end'ы.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Практически все вышеперечисленные пункты поддерживаются, кроме последнего (пока нет необходимости
выбирать back-end -- выбор сильно ограничен :-)), но поддерживаются они криво. В случае неверной ко-
мандной строки компилятор просто рушится с выдачей дампа. За образец можно взять обработку командной
строки из утилиты TODO_list, которую я недавно переписал с нуля.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Безусловно необходимо для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 09.03.2009 - 13:30:36,79

  В связи с тем, что на данный момент компилятор ориентируется генерацию кода на Рефале 5, а функ-
ция Arg при возврате аргумента командной строки игнорирует параметры, начинающиеся с дефиса ('-'),
для обозначения опций будем использовать знак '+'. Конфликта с именами модулей, подлежащих компиля-
ции в этом случае произойти не должно: имена модулей могут начинаться только на буквы латинского
алфавита или знак '!'. Будут поддерживаться следующие опции:
  '+MP' MP-каталог -- указывает каталог поиска модулей, данная опция может встречаться в командной
строке неограниченное количество раз, при этом каталоги в переменную MODULEPATH добавляются в по-
рядке перечисления.
  '+make', '+build', '+linkonly' -- определяет режим компиляции. Если ни одна из этих опций не ука-
зана, то по умолчанию предполагается режим частичной сборки. В командной строке может присутство-
вать только одна из перечисленных опций.
  '+be' имя-back-end -- определяет набор back-end'ов, используемых для генерации исполнимого файла.
Дело в том, что по низкоуровневым библиотечным файлам различные back-end'ы несовместимы (например,
если используется списковое представление объектных выражений, то функцию Length, вычисляющую дли-
ну выражения, можно описать на Рефале, в то время как для векторного представления такую функцию
целесообразнее реализовать как примитив). К тому же может так оказаться, что внешнее понимание back-
end'а может соовтествовать нескольким внутренним back-end'ам, например при генерации C++-кода .cpp-
и .h-файлам могут соответствовать два back-end'а, которые всегда должны активизироваться одновре-
менно.
  На данный момент из имён back-end'ов будет поддерживаться только 'R5' (очевидно, Рефал 5). В даль-
нейшем появится поддержка и Простого Рефала.
  Данная опция должна быть указана однократно.
  '+xlinx' -- включает генерацию таблицы перекрёстных связей. Может присутствовать не более одного
раза.
  Кроме этих опций в командной строке указываются головные имена модулей.
----------------------------------------------------------------------------------------------------
  [DONE] 09.03.2009 - 22:04:18,02

  Реализована командная строка с семантикой, указанной в TODO, но с несколько отличным синтаксисом.
В частности, используются следующие опции: +MP:Каталог, +make, +build, +linkonly, +be:Back-end,
+xlinx. В качестве имени back-end'а можно использовать R5 или Refal5 с одним и тем же смыслом.


====================================================================================================
  [DONE] АТД "Конфигурация"
====================================================================================================

  [TODO] 05.01.2009 - 21:31:08,54

  Предполагается ввести абстрактный тип данных (по аналогии с контекстом), хранящий текущую конфигу-
рацию программы, т.е. сведения о front- и back-end'ах (расширения, подпапки, callback-функции), све-
дения об окружении (MP-каталоги, режим работы: полная перекомпиляция, частичная перекомпиляция, то-
лько сборка). Данный АТД дескриптором считать не будем, чтобы после инициализации его можно было ко-
пировать и удалять нужное число раз -- т.к. после создания необходимости в его пополнении/модифика-
ции быть не должно. Конфигурация должна инициализироваться в парсере командной строки (который тоже
должен быть написан) и в дальнейшем оставаться неизменной.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо для выпуска версии 0.2, т.к. это является частью поддержки модулей и "мультикомпиляции"
(несколько front- и back-end'ов).
----------------------------------------------------------------------------------------------------
  [DONE] 08.03.2009 - 12:30:50,10

  АТД "Конфиругация" реализовано в полном соответствии с TODO. На данный момент в Конфиругацию вклю-
чаются (а) список MP-каталогов, (б) информация о back- и front-end'ах и (в) режим сборки (полная пе-
рекомпиляци, частичная перекомпиляция или только компоновка). Однако, до сих пор не реализован дос-
тойный парсер командной строки.


====================================================================================================
  [DONE] Сделать Простой Рефал частью проекта
====================================================================================================

  [TODO] 05.02.2009 -  1:25:50,27

  Т.к. я в том и/или ином виде буду объединять Простой и Модульный Рефалы, необходимо будет "слить"
оба проекта. В данном TODO под слиянием подразумевается следующее: перенос исходников Простого Ре-
фала в подкаталог Модульного Рефала, файлов note00?.txt -- в подпапку "Простой Рефал" каталога спе-
цификаций, использование настоящего журнала также для развития Простого Рефала.
----------------------------------------------------------------------------------------------------
  [DONE] 28.02.2009 - 13:05:34,27

  Сделано в полном соответствии с TODO.


====================================================================================================
  [DONE] Реорганизация каталоговой структуры проекта
====================================================================================================

  [TODO] 05.02.2009 -  1:25:50,27

  На данном этапе в корне каталога проекта находятся: (а) исходники компилятора и "стандартных" биб-
лиотечных модулей, (б) сопутствующих им папок с выходными файлами (~Defs, ~ROut, ~SRout, ~XLinx),
(в) каталог внутренней документации Documentation, (г) каталог подпроекта -- утилиты mr-extent,
(д) каталог сопуствующих утилит и (е) каталог MR-Home, содержащий библиотечные модули, использовае-
мые для компиляции программ, находящихся вне проекта (используется в сценарии compile_mr как одна
из MODULEPATH-папок).
  Очевидно, что (а) из всех частей проекта только исходники не оформлены как отдельные подпапки в
папке проекта и (б) исходники самого компилятора и "стандартной" библиотеки к нему перемешаны.
  Поэтому имеет смысл выделить отдельные подкаталоги для стандартных модулей и исходных файлов са-
мого компилятора. Подобным образом организованы каталоги в проекта Простой Рефал (который станет
подпроектом Модульного Рефала) -- это очень удобно.
  Кроме того, при размещении модулей по отдельным пакетам, папки, соответствующие пакетам и папки,
соответствующие отдельным частям проекта, не будут сливаться. (Папки пакетов и папки выходных фай-
лов не будут сливаться по той простой причине, что первые должны начинаться с буквы, а вторые на-
чинаются (в текущей реализации) со знака тильда).
----------------------------------------------------------------------------------------------------
  [DONE] 11.02.2009 -  0:37:17,89

  Реорганизация завершена. Структура каталогов теперь такая (каталоги выходных файлов и тестовых
программ не отображены):
    +---Bin
    +---Documentation
    |   +---Журнал
    |   \---Спецификации
    +---Libraries
    |   +---all.all
    |   +---all.r5
    |   +---windows.all
    |   \---windows.r5
    +---Sources
    |   +---Compiler
    |   +---Libraries
    |   |   +---all.all
    |   |   +---all.r5-b
    |   |   +---all.r5-s
    |   |   +---Projects
    |   |   +---windows.all
    |   |   +---windows.r5-b
    |   |   \---windows.r5-s
    |   +---MR-Extent
    |   \---Utilities
    \---Tests
  В папке Bin находятся исполнимые файлы компилятора и утилит (экзешник mr-extent.exe, остальные --
это rsl-файлы).
  В папке Documentation находится внутренняя документация проекта. Её структура не претерпела ника-
ких изменений.
  В папке Libraries находятся откомпилированные модули библиотечных модулей. О каталоговой структуре
этой папки будет сказано позже.
  В папке Sources находятся исходные файлы самого компилятора, библиотек, вспомогательной программы
MR-Extent и утилит.
  Подкаталоги исходных текстов библиотек имеют следующий вид: оп-система.back-end[-b|-s]. Если опе-
рационная система указана как all, то указанные модули могут использоваться для всех операционных
систем. Если в качестве back-end'а указан all, то данные библиотечные модули представлены в виде
исходных текстов Модульного Рефала и не зависят от back-end'а. Для конкретных back-end'ов использу-
ется суффикс '-b' или '-s'. Суффикс '-b' означает, что библиотечные модули не имеют исходного тек-
ста на Модульном Рефале, написаны непосредственно на выходном языке соответствующего back-end'а.
Суффикс '-s' означает, что библиотечные модули написаны на Модульном Рефале, но в то же время, не
переносятся на другие back-end'ы.


====================================================================================================
  [DONE] Таблица перекрёстных ссылок
====================================================================================================

  [TODO] 04.02.2008 - 23:26:22,87

  Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
  Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
  В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.
----------------------------------------------------------------------------------------------------
  [DONE] 01.02.2009 - 21:42:25,09

  Сделано. Реализовано как отдельный back-end, который на данный момент включен всегда (т.е. его
нельзя отключить), при проработке командной строки этот недостаток будет устранён. Выходные файлы
помещаются в каталог ~XLinx, расширение .xlinx. Информация о перекрёстных ссылках помещается в
Info/%exename%.xlinx.txt. Из тех возможностей, которые хотелось бы реализовать, но не реализованы,
можно назвать получение списка нелинкованных элементов и обобщение перекрёстных ссылок при одновре-
менной компиляции нескольких "гроздей".


====================================================================================================
  [DONE] Переупорядочить список приоритетных задач
====================================================================================================

  [TODO] 01.02.2009 - 20:00:56,79

  Работа над таблицей перекрёстных ссылок завершена ещё в новогодние выходные. Поэтому, если я сей-
час завершу это TODO, то формально получится так, что необходимо повысить номер версии до 0.2 (т.к.
это -- последнее TODO между скобками). Однако, с тех пор, когда я составил список приоритетных за-
дач, ситуация сильно изменилась. Поэтому необходимо обновить этот список. Обновлять я его буду тем
же путём, что и раньше при создании списка. Теперь за счёт использования тегов со знаком '+' стало
возможным обновлять сведения о задаче, не перемещая её в списке. Этим и воспользуюсь.
----------------------------------------------------------------------------------------------------
  [DONE] 01.02.2009 - 21:42:25,09

  Этим я займусь ниже (см. в журнале проекта, в экстрактах этого не видно).


====================================================================================================
  [CHANGED] Добавлены теги +TODO, +ERROR, +TOTHINK
====================================================================================================

  [CHANGED] 01.02.2009 -  2:38:40,13

  Смысл этих тегов в том, что эти теги не перемещают записи в файлах TODOs.txt и LIST.txt при пов-
торении, в отличие от одноимённых тегов без знака плюс.


====================================================================================================
  [DONE] Пересмотреть/переписать mOutModuleStatus.mref
====================================================================================================

  [TODO] 09.02.2008 -  3:00:29,53

  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.
----------------------------------------------------------------------------------------------------
  [TODO] 09.12.2008 -  0:37:17,92

  Добавить также строчку вывода Recompiled, заменяющую последовательный вывод Compiling/Compiled для
одного и того же модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 05.01.2009 - 22:47:50,90

  Пересмотрел код вывода сообщений. Написан он достаточно прилично, поэтому переписывать необходи-
мости нет. Код обработки Recompiled также написал. Всё работает.


====================================================================================================
  [FIXED] Возможна ошибка при чтении папок
====================================================================================================

  [ERROR] 23.04.2008 - 20:49:40,97

  Команду dir можно заместить, добавив в текущую папку/в один из каталогов PATH файл с именем, нап-
ример dir.exe. Такая ситуация может возникнуть, если на комп установлен cygwin (команда dir имитирует
команду ls системы Linux) -- сам видел. А это значит, что программы становятся непереносимыми.
  Решить проблему можно, если разработать отдельную программу с некоторым редким именем типа
mr_extent.exe, которая может в том числе выводить и листинг папки в более удобном для распознавания
формате. Эта же программа может возвращать значения переменных среды, конвертировать бинарные файлы
в текстовые специального формата и наоборот (чтобы имитировать работу с бинарными файлами). Для под-
держки этой программы можно создать отдельный стандартный модуль, который в момент инициализации про-
веряет наличие программы и корректность её версии.
  Примерный внешний вид програмы.
    > mr_extent.exe VERSION
  MRefal Extensions version 0.1.123
  или (в виде XXIO)
  MR_extent#0 #1 #123
  > mr_extent.exe LIST DirName
  file1.ext
  file2.txt
  dir3
  или
  (file1.ext)(file2.exe)(dir3)
  > mr_extent.exe INFO file1.ext
  #2048 #2008 #5 #9 #23 #59 #59 file1.ext
  Размер,  дата, время, имя
  > mr_extent.exe INFO dir3
  D#2008 #5 #9 #23 #59 #59 dir3
  > mr_extent.exe INFO file3.lst
  N
для папок может возвращаться вместо размера буква D, для несуществующих файлов N.
  Это ERROR я удалю, когда реализую эту программку.
----------------------------------------------------------------------------------------------------
  [FIXED] 05.01.2009 - 18:08:30,74

  Данная ошибка исправлена -- реализована соответствующая программа. Работает в почти полном соот-
ветствии с описанием в ERROR, за тем исключением, что имя этой утилиты mr-extent.exe и она при не-
правильном аргументе на stdout выводит E. При запросах INFO и LIST первым термом вывода (вывод в
stdout осуществляется в формате XXIO) является символ S.


====================================================================================================
  [DONE] Стабильная версия и сценарии make
====================================================================================================

  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Данное TODO подразумевает, что надо создать новую стабильную версию (которая будет поддерживать
пакеты) и обновить файлы make, чтобы иметь возможность пересобрать проект, т.к. имеющиеся уже уста-
рели.
----------------------------------------------------------------------------------------------------
  [DONE] 04.01.2009 - 17:54:39,75

  После завершения работы над встроенной утилитой make я обновил стабильную версию и файлы make.bat
и make-s.bat. При этом номер весии был поднят до 0.1.959. Ранее я не мог поднять номер версии, т.к.
bat-файлы не были обновлены для поддержки новой командной строки, а обновлять "руки не доходили".


====================================================================================================
  [DONE] ПИ:Режимы "только связывание" и "полной перекомпиляции"
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Должна быть возможность выбора режима перекомпиляции (на начальном этапе -- опцией командной
строки): make (быстрая перекомпиляция), build (полная перекомпиляция), linkonly (только связывание).
----------------------------------------------------------------------------------------------------
  [DONE] 04.01.2009 - 17:54:39,75

  Появились соответсвующие режимы в полном соответствии со спецификацией "Поиск исходников02.txt" и
с текущим TODO. Командная строка имеет следущий синтаксис:

  refgo /* опции для refgo */ mrefal РЕЖИМ "=MP:MP-КАТАЛОГИ" ИМЕНА МОДУЛЕЙ

где РЕЖИМ -- одно из +make+, +build+, +linkonly+; MP-КАТАЛОГИ -- имена MP-каталогов, перечисленных
через точку с запятой; ИМЕНА МОДУЛЕЙ -- имена модулей, которые являются "корнями" "гроздей", подле-
жащих компиляции.

  О внутреней реализации.
  Изнутри в контектсте модуль характеризуются двумя параметрами: статусом (Status) и типом (Type).
Названия параметров не очень удачные, но на большее фантазии не хватило. Статус определяется уров-
нем, на котором уже обработан модуль (статусы Found, Raw, Ready устанавливаются в модулях MModules,
MClusters и MCompiler соответственно).

  (*) Модуль MModules для запроса состояния-типа (информация о статусе и типе) имеет функцию Lookup\
ImportModule. Данная функция для модуля с заданным квалифицированным именем возвращает его статус и
тип, причём если модуль был заранее известен (имелся в контексте), то возвращается его статус-тип.
Иначе, запускается процедура поиска модуля в соответствии со спецификацией. По завершении поиска
возвращается статус Found и соответствующий тип (см. ниже). Эти же статус-тип добавляются в кон-
текст. Для запроса статус-типа используется функция MContext::GetStatusType.
  (*) Модуль MClusters для запроса состояния-типа использует семейство функций CheckNeedCompile-??,
где ?? -- это Make, Build или LinkOnly. Именно на этом уровне происходит разделение режимов работы
компилятора. Для запроса статус-типа используется функция MModules::LookupImportModule. Если пос-
ледняя функция возвращает статус Found, то на уровне модуля MClusters производится обработка и ана-
лиз данного модуля, после которой модуль получает статус Raw. На уровне MClusters модули не подвер-
гаются компиляции, осуществляется только поиск модулей и анализ их типа.
  (*) Модуль MCompiler уже производит компиляцию модулей, если это необходимо. Для получения статус-
типа используется одна из трёх функций предыдущего уровня. На начальном уровне выбирается функция-
запросчик, которая затем по указателю передаётся во все функции обработки. После завершения обработ-
ки модуля (компиляция, подтверждение обновлённости или библиотечности, обнаружение ошибок), модуль
получает статус Ready.

  Тип определяет разновидность модуля по характеру его обработки:
  (*) Тип Errors устанавливается в случае, если при обработке модулей произошла ошибка (Found Errors
-- модуль не найден, Raw Errors -- был Found Errors или в данном режиме имел недопустимый Found-тип,
Ready Errors -- был Raw Errors или произошла ошибка в процессе обработки).
  (*) Тип Changed означает, что модуль должен быть перекомпилирован, т.к. изменялся после предыдущей
перекомпиляции.
  (*) Тип Updated означает, что модуль можно не перекомпилировать, т.к. модуль имеет полный набор
корреткных выходных файлов, которые не изменялись после предыдущей компиляции.
  (*) Тип Library означает, что модуль является библиотечным, т.е. отстутствует файл исходного текс-
та, но при этом все выходные файлы корректны.

  Стратегия обработки.
  (*) На уровне Found модуль только обнаруживается, тип Updated устанавливается для всех модулей, у
которых присутствуют все выходные файлы и присутствует файл исходного текста. Если отсутствует хотя
бы один из выходных файлов, устанавливается тип Changed, файл исходного текста -- тип Library. Если
модуль найти не удалось -- тип Errors.
  (*) На уровне Raw в зависимости от текущего режима уточняется тип модуля. Если модуль имел до это-
го тип Errors, то он и остаётся.
  В режиме полной перекомпиляции (когда должны быть перекомпилированы все модули), модули имевшие до
этого тип Updated, получают тип Changed. Типы Changed и Library сохраняются.
  В режиме только перекомпоновки все модули, входящие в проект, должны быть найдены и скомпонованы в
конечный .exe-шник. При этом перекомпиляция не требуется. В данном режиме тип Changed заменяется на
Errors, т.к. невозможно слинковать проект, в котором отсутствуют хотя бы один выходной файл. Осталь-
ные типы сохраняются.
  В режиме частичной перекомпиляции типы Errors, Changed и Library сохраняются без изменений. Для
модулей типа Updated производится сначала анализ времени последнего изменения самого модуля (его ис-
ходных и выходных файлов), затем производится анализ импортируемых модулей -- нет ли среди них моду-
лей, имеющих тип Changed (независимо от статуса это означает необходимость перекомпиляции) или тип
Errors. Т.к. в модуль MClusters t.hErrorList не спускается, то в случае импорта ошибочных модулей
возвращается (на всякий случай) режим Changed, чтобы при перекомпиляции на уровне Ready ошибка была
обнаружена. Аналогично обрабатывается ошибка при рекурсивных зависимостях. Если же все импортируемые
модули являются Raw/Ready Updated/Library, то сравнивается время последнего изменения импортируемых
модулей и времени последнего изменения обрабатываемого модуля. На его основе выносится окончательный
вердикт.
  (*) На уровне Ready для модулей Raw Changed производится перекомпиляция и анализ зависимых модулей,
для модулей Raw Updated/Library просто анализируются зависимостей. При этом модуль Raw Changed может
зависеть только от модулей типа Changed/Updated/Library независимо от статуса (для модулей статуса
Raw производится анализ и установка статуса Ready), модуль типа Raw Updated может зависеть только от
модулей Updated/Library, библиотечный модуль может зависеть только от библиотечных. 


====================================================================================================
  [FIXED] Не определяется обновлённость импортированного модуля
====================================================================================================

  [ERROR] 25.11.2008 - 15:52:21,87

  Согласно спецификации, перекомпиляция модуля должна осуществляться в случае, если исходные тексты
импортируемых модулей или выходные файлы импортируемых библиотек обновлены позже рассматриваемого
модуля. Для исходных текстов это правило не выполняется, для библиотек -- ещё не проверял. Надо ис-
править.
----------------------------------------------------------------------------------------------------
  [FIXED] Џ­ 08.12.2008 - 19:19:37.31

  Теперь всё определяется. И для случая с библиотеками, и для случая с простыми модулями. И всё ра-
ботает в соответствии со спецификацией.


====================================================================================================
  [DONE] Подготовиться к переходу на пакеты
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Частично перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Додумать детали перевода IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 20:27:00,31

  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] ПИ:Полная поддержка parser'ом квалифицированных имён
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Одно из требований гласит:  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно
быть указано в файле исходного текста (синтаксис файла исходного текста должен позволять это делать)
и в файлах с информацией о межмодульных связях (структура хотя бы одного из этих файлов должна поз-
волять это делать).
  Таким образом, синтаксис файлов исходного текста (распознаётся в mParser.mref) и структура (она
же синтаксис) файлов символической информации (распознаётся там же) должна полностью поддерживать
квалифицированные имена.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Перевести Parser на квалифицированные имена
====================================================================================================

  [TODO] 23.02.2008 - 21:33:32,54

  Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Добавление категории "квалифицированное имя"
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Добавление этого является прямым следствием иерархии языка Java.

  [TODO] Номер версии независимо от компиляции
  [TODO] Вывод номера версии компилятора
  Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
  Не выделяем.

  [TODO] Удалить MRefalRTS::Put
  Идеологически не принципиально. Всё равно это деталь реализации.
  Не выделяем.

  [TODO] Исключение промежуточного представления модуля
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Иерархия в стиле Java
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Новая модель модулей
====================================================================================================

  [TODO] 27.10.2007 - 18:34:49,78

  Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
  Подробности задачи см. в файле "Module conception for Module Refal.txt".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.

  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
----------------------------------------------------------------------------------------------------
  [DONE] Џ­ 08.12.2008 - 19:19:37.31

  Сделана новая модель модулей в полном соответствии со спецификацией. Файлы модулей можно помещать
в папки-пакеты, затем их импортировать. И всё это будет работать (по крайней мере работает на тесто-
вом примере). Квалифицированные имена окончательно интегрированы во все заинтересованные модули ком-
пилятора, модуль-переходник MQualifiedSupport удалён.
  Промежуточное представление IModule теперь индексируется по квалифицированным именам. Квалифициро-
ванные имена промежуточного представления делятся на абсолютные (включающие квалифицированное имя
модуля) и относительные (без оного). Функции и АТД индексируются по относительным именам, с импорти-
руемыми модулями поинтереснее.
  В контексте информация об импорте хранится в виде двух сущностей: как псевдоним импорта (абсолют-
ное имя = имя текущего модуля + собственно псевдоним как квалифицированное имя) и как абсолютное
имя импортируемого модуля (просто как имя модуля, который импортируется, независимо от того, какое
имя имеет импортирующий модуль). Обе сущности имеют одинаковые атрибуты Position, RealName и Alias\
Name. Создаются эти две сущности одновременно функцией UpdateImport-X, которая на входе получает
именно эти три атрибута, причём атрибут AliasName представляет собой относительное имя.
  Для псевдонимов импорта и собственно импортов используются два разных набора функций-акцессоров.
  Однако, функция UpdateImport-X может некоректно работать при повторном вызове: она расчитана на
то, что будет вызываться только однократно для данного импорта или для данного псевдонима. В случае,
если придётся обновить импорт, присвоив ему другой псевдоним, t.hIModule перейдёт в некорректное
состояние.
  Такое разделение было создано с двумя целями: гарантировать, что (а) имя импорта без пакета не
совпадёт с именем функции/АТД и (б) модуль не сможет импортировать самого себя. Однако теперь имя
функции/АТД внутри модуля может иметь то же имя, что и сам модуль. Последнее очень удобно для "одно-
дневных" утилит, основная функция которых совпадает с именем (например, утилита Find и функция Find
в ней) -- не приходится ломать голову из-за этого ограничения.


====================================================================================================
  [DONE] Расширить утилиту TODO_list
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Для лучшей ориентации в недоделках надо научиться извлекать из журнала не только заголовки невы-
полненных TODO, но и сами описания TODO. Т.е. помимо краткого списка выводить подробный, в котором
будут выводиться сами тексты TODO. А также список выполненных TODO, в котором приводится сводка всех
выполненных TODO, причём описания TODO и DONE должны располагаться рядом.
----------------------------------------------------------------------------------------------------
  [DONE] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.


====================================================================================================
  [DONE] Продумать введение тега "Продумать"
====================================================================================================

  [TODO] 05.07.2008 - 13:29:02,69

  Очень много TODO в журнале проекта содержат в заголовке слова "продумать", "обдумать". Тег TODO
семантически предназначен для описания задач, которые в конце концов должны быть решены в виде исход-
ного кода. Тег ERROR предназначен для описания ошибок, требующих исправления. Однако, как уже было
сказано, теги TODO со словами в заголовке типа "продумать" предназначены не для описания тех задач,
которые следует закодировать, а для задач, для которых ещё надо найти форму для воплощения. Поэтому
имеет смысл ввести тег ПРОДУМАТЬ для тех задач, решение которых представляет собой проектное решение
или ответ на вопрос, а не написанный код. При чём если в результате обдумывания некоторой возможнос-
ти я приду к выводу, что реализовывать эту возможность совсем не нужно, я могу закрыть этот тег с
обоснованием ненужности. Тот же случай в теге TODO/DONE выглядит противоречиво: в теге "сделано" опи-
сывается то, что не сделано и не будет сделано никогда.
  Эту TODO легко реализовать в коде, но есть одно препятствие, которое надо преодолеть прежде, чем
закодировать. Это имена для указанных тегов. Вариант THINK/THINKED выглядит как-то не красиво.
  Другая мысль. Указанный тег можно было бы закрывать не только специальным закрывающим тегом, но и
тегом TODO, если в результате обдумывания появилось решение, которое можно воплотить в коде. Можно
ввести специально различные закрывающие теги для описания положительных и отрицательных резолюций по
поводу вносимых изменений, это позволит яснее определять те решения, которые в процессе работы были
отклонены.
  Возможно, не стоит ограничиваться только англоязычными тегами. Можно даже наоборот, для TODO/DONE
ERROR/FIXED CHANGED ввести синонимы СДЕЛАТЬ/ГОТОВО ОШИБКА/ИСПРАВЛЕНО ИЗМЕНЕНИЯ.
  В общем, надо продумать детали.
----------------------------------------------------------------------------------------------------
  [DONE] 07.12.2008 - 13:40:55,38

  Ограничимся пока введением пары тегов TOTHINK/THINKED, причём тег TOTHINK можно закрывать и одно-
имённым тегом TODO, когда результатом обдумывания является готовое задание.


====================================================================================================
  [DONE] Искать имя программы другим способом
====================================================================================================

  [TODO] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Перейти от модуля Context к модулю MContext
====================================================================================================

  [TODO] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Переписать драйвер
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.

  [TODO] Промежуточное представление как АТД
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] SymInfo как АТД
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Возможно, это и не понадобится, т.к. если будет реализована атрибутная таблица символов, то роль
SymInfo будет выполнять роль обычная таблица символов. Но этот вопрос надо решить до выхода 0.2.

  [TODO] Переписать драйвер
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Модуль-программа
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Использование нескольких front-end и back-end
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Реализовать возможность работы с несколькими различными front-end и back-end частями,
причём таким образом, чтобы драйвер программы (который должен быть переписан -- см. TODO выше)
не зависел от выбранного входного и выходного языка. Для этого, как мне кажется, надо реализовать...
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Да, хотя бы на уровне поддержки таблицы перекрёстных ссылок как back-end и потенциальная поддер-
жка нескольких front-end. Хотя разрабатывать новый front-end для нового диалекта Рефала я в версии
0.2 пока не планирую. Следующий front-end вероятно будет вариантом Рефала-2 как наиболее близкого
идеологически к Модульному Рефалу. Файлы .rsym можно рассматривать как один из видов одновременно
входных и выходных файлов. Если удастся сделать таблицу символов, основанную на атрибутах, то
загрузка из .rsym файла эквивалентна компиляции модуля без заполнения атрибута "тело функции".

  [TODO] RASL и интерпретатор
  Пока не торопит. Можно обходиться пока Рефалом-5. Однако, желательно (но не обязательно для сле-
дующей версии) создать независимую от Рефала-5 версию компилятора, например, основанную на Рефале-2
(создаёт .exe-шники) или на JScript (работает во всех современных версиях Windows).
  Не выделяем.

  [TODO] Доделать механизм переименования модулей
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] Механизм поиска модулей
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Переделать механизм поиска модулей. Для этого необходимо проанализировать реализации
механизма модулей в других языках программирования, таких как потомки Паскаля, Явы и других.
Для этого начата соответствующая лаба "Module Conception".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Безусловно. В этот же раздел входит использование нескольких front-end и back-end, новая модель
модулей, головной модуль (ранее -- модуль-программа), переписывание драйвера.

  [TODO] Использование нескольких front-end и back-end
----------------------------------------------------------------------------------------------------
  [DONE] 25.11.2008 - 15:52:21,87

  Движок полностью переписан, хотя и не без ошибок (см. ERROR: Не определяется обновлённость импор-
тированного модуля). Теперь он поддерживает новую модель модулей (с несколькими front-end'ами и
несколькими back-end'ами; параметр MODULEPATH и квалифицированные имена). Делать эту версию стабиль-
ной я пока не хочу, т.к. (а) есть неисправленная ошибка (см. выше) и (б) остальная часть компилятора
ещё не полностью поддерживает квалифицированные имена. TODO про командную строку я пока не убиваю,
поскольку оно требует выбора back-end'ов из командной строки, а эта возможность пока не реализована.
Всё равно приятно убить 7 TODO.


====================================================================================================
  [DONE] ПИ:Написать средства для оценки необходимости перекомпиляции
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Написать функцию для оценки необходимости перекомпиляции в соответствии со следующими требовани-
ями (дословно из спецификации):
  Компилятор может предоставлять режим "быстрой перекомпиляции", в котором некоторые компилируемые
модули могут исключаться из процесса компиляции при одновременном выполнении следующих условий:
  (*) Для данного модуля присутствуют ВСЕ выходные файлы.
  (*) Выходные файлы созданы/обновлены позже исходного файла данного модуля.
  (*) Модули, от которых зависит данный модуль, либо библиотечные, либо были исключены из процесса
компилирования, хотя были компилируемыми.
  (*) Исходные тексты компилируемых модули, от которых зависит данный модуль, созданы/обновлены
раньше, чем данный модуль.
  (*) Выходные файлы библиотечных модулей, от которых зависит даннный модуль, созданы/обновлены
раньше, чем данный модуль.
  Этот набор эвристических условий позволяет с высокой вероятностью гарантировать непротиворечи-
вость проекта.
  Если всё равно есть сомнения, то рекомендуется включать режим для полной перекомпиляции.
----------------------------------------------------------------------------------------------------
  [DONE] 18.11.2008 - 23:56:49,37

  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


====================================================================================================
  [DONE] Создать модуль для оценки необходимости перекомпиляции
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Т.е. создать модуль, основная функция которого получает имя модуля, ищет входные и выходные файлы
модуля, считывает sym-файл и проверяет необходимость в перекомпиляции рекурсивно. Возвращает функция
сведения о небходимости перекомпиляции или сообщение об ошибке. При этом собственно перекомпиляцию
этот модуль осуществлять не должен.
----------------------------------------------------------------------------------------------------
  [DONE] 18.11.2008 - 23:56:49,37

  Это средство создано как функция MClusters::CheckNeedCompile, одна из двух основных функций моду-
ля MClusters для работы с "гроздьями". Формат её следующий:
  <CheckNeedCompile
    t.hContext (e.ModulePath) t.ModuleName
  >
    == t.hContext t.ModuleName s.Result

  s.Result ::=
    NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

  В принципе, можно было бы обойтись и без возвращения обратно имени модуля, но я чувствую, что этот
аргумент пригодится в дальнейшем.
  Функция производит рекурсивную проверку только для модулей-исходников, для библиотечных модулей
рекурсивный анализ не производится. Подобный анализ я не стал здесь проводить, т.к. в этом случае
необходимо сообщать об ошибке зависимости библиотеки от исходника, а для подобного сообщения необ-
ходимо иметь t.hErrorList. В случае рекурсивных зависимостей сообщается о необходимости перекомпи-
ляции. Это связано с двумя причинами:
  (1) Второстепенная. Если два модуля действительно рекурсивно зависят, то о подобной ошибке надо
сообщать (необходим t.hErrorList).
  (2) Основная. Анализ на зацикливание производится до анализа импортируемых модулей на необходи-
мость перекомпиляции (иначе произойдёт зацикливание ;-)). Поэтому может так оказаться, что раньше
модуль ModA импортировал модуль ModB, а после модификации ModB он наоборот стал зависеть от ModA,
а ModA -- перестал. Хотя в таких случаях ModA должен быть модифицирован и определён как перекомпили-
руемый, но на всякий случай лишний контроль не помешает.


====================================================================================================
  [DONE] Создать средство для поиска модулей, подлежащих линковке
====================================================================================================

  [TODO] 06.07.2008 - 13:15:05,41

  Нужно создать средство, которое по заданному имени корневого модуля находит все модули, от которых
зависит данный модуль, при чём в топологическом порядке от зависимых к зависящим.
----------------------------------------------------------------------------------------------------
  [DONE] 11.11.2008 - 13:18:37.09

  Такое средство создано -- это функция MClusters::ListForLinking. По заданному корневому имени она
находит все зависимые имена и сортирует их в топологическом порядке. Формат функции
  <MClusters::ListForLinking t.hContext t.RootModule>
    == t.hContext Success e.Modules
    == t.hContext Fails
  Функция завершается неуспешно если хотя бы один из модулей в "грозди", растущей из t.RootModule
не был откомпилирован или обновлён, а также если среди модулей каким-то чудом оказались циклические
зависимости. Теперь можно удалить из контекста функции LastModule и GetProgName.


====================================================================================================
  [DONE] Контекст индексируется по именам в нижнем регистре
====================================================================================================

  [TODO] 08.11.2008 - 19:37:27,98

  Мотивация. Согласно спецификации модули и пакеты, находящиеся в одном проекте (в принципе, это
правило можно распространить и на весь набор проектов, компилируемых за раз), не могут иметь имена,
различающиеся лишь регистром. Однако, полное квалифицированное имя того модуля, который импортиру-
ется, должно быть известно точно: имя в директиве $IMPORT и имя импортируемого модуля в директивах
$MODULE и $END (как в исходных, так и в sym-файлах) должны совпадать с учётом регистра. Поэтому
имеет смысл индексировать контекст именами без учёта регистра (например, приведя все имена в верх-
ний или нижний регистр), но при этом в контексте хранить сведения о настоящем имени модуля (если
таковое известно -- модуль компилировался или читался его sym-файл).
  Цель. Индексировать контекст именами в нижнем регистре, при этом храня информацию о дествитель-
ном имени модуля (если таковая имеется). При попытке индексировать квалифицированным именем кон-
текст должно проверяться соответствие имени на входе настоящему имени, если таковое известно.
  /* И опять список заданий и ошибок не влезает на один экран :-). */
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Указанная схема реализована, но только пока не используется: нигде в программе не устанавливается
атрибут RealName, поэтому теперь контекст индексируется только по неквалифицированным именам.


====================================================================================================
  [DONE] ПИ:Обработка командной строки
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Для модулей, перечисленных в командной строке, обработку выполнять в соответствии со специфика-
цией (см. "Поиск исходников.txt").
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] ПИ:Написать функцию для поиска модулей
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Поиск модулей должен осуществляться в соответствии со спецификацией. Здесь дословно её цитировать
не буду, а просто сошлюсь на файл "Поиск исходников.txt".
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] Разработать функцию поиска модуля из командной строки
====================================================================================================

  [TODO] 18.10.2008 - 21:53:30,07

  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [DONE] Разработать функцию поиска импортируемого модуля
====================================================================================================

  [TODO] 18.10.2008 - 21:53:30,07

  Как сказано в спецификации, алгоритмы поиска импортируемого модуля и модуля, указанного в команд-
ной строке, различны. И для их реализации нужны две различные функции. Соответственно, надо их обе
реализовать.
----------------------------------------------------------------------------------------------------
  [DONE] 09.11.2008 - 22:05:55,79

  Написаны две функции, LookupCmdLineModule и LookupImportModule, которые осуществляют поиск моду-
ля, указанного соответственно в командной строке или в списке импорта. Данные функции только нахо-
дят сами файлы модуля или сообщают, что они не найдены. Проверку на обновлённость исходника по срав-
нению с объектниками функции не проверяют, это должен делать другой модуль. Модули они ищут в полном
соответствии со спецификацией (версия 02).
  Поддержка командной строки нового типа реализована только в минимальном состоянии, используется
следующий синтаксис:

  refgo mrefal +new+ =MP:перечисление-каталогов модуль1 модуль2 модуль3 ...
  refgo mrefal +old+ список модулей в старом стиле

  Здесь перечисление-каталогов -- это перечисление путей к папкам через точку с запятой, модульN --
абсолютный или относительный путь к модулю (см. спецификацию).
  Полностью переходить на новый стиль пока рано: ещё не подготовлена та часть программы, которая
должна проводить сборку каждой грозди, растущей от модуляN.


====================================================================================================
  [CHANGED] Организация файлов спецификаций
====================================================================================================

  [CHANGED] 09.11.2008 - 22:05:55,79

  Ранее я однажды редактировал спецификацию "Поиск исходников", старый текст при этом я "закомменти-
ровал", добавления и изменения я пометил "комментариями" (комментарии Си и Си++). Очевидно, что при
дальнейшей модификации спецификации, под навалом комментариев трудно будет почитать сам текст. Поэ-
тому я восстановил как предыдущий вариант, так и текущий, очистив их от комментариев и переименовав
их в соответственно "Поиск исходников.01.txt" и "Поиск исходников.02.txt". При дальнейшем развитии
спецификации я буду создавать файлы с номерами 03, 04 и так далее. Эволюцию спецификаций можно от-
следить программой fc.


====================================================================================================
  [FIXED] Плохо проверяется попытка переопределения
====================================================================================================

  [ERROR] 07.07.2008 -  2:08:58,93

  Внутри одного исходного файла можно определить две функции, два АТД, два импорта с одинаковым име-
нем, лишь бы их виды (Kinds) совпадали. Проверка на переопределение выполняется только для сущностей
разных видов.
----------------------------------------------------------------------------------------------------
  [FIXED] 18.10.2008 - 23:54:58,07

  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.


====================================================================================================
  [FIXED] Конфликт имён между псевдонимом модуля и функцией
====================================================================================================

  [ERROR] 06.07.2008 - 13:15:05,41

  Если в файле исходного текста одновременно присутствуют функция и псевдоним модуля с одинаковым
именем, то компилятор умирает с ошибкой. А на самом деле должна выскакивать ошибка переопределения
имени. Причина ошибки в том, что IModule индексируется по полным именам импортируемых модулей, а не
по их псевдонимам. Надо это исправить.
----------------------------------------------------------------------------------------------------
  [FIXED] 18.10.2008 - 23:54:58,07

  Проблема конфликта имён псевдонима модуля и функции была исправлена раньше. IModule индексируется
по псевдониму модуля, а не по самому квалифицированному имени.
  Теперь попытка переопределения проверяется качетвенно: сначала определяется список всех имён, уже
определённых в модуле и которые уже не могут использоваться, а затем проверятся добавляемое имя на
предмет совпадения с одним из них. В случае совпадения выбрасывается ошибка, в случае несовпадения
имя добавляется.


====================================================================================================
  [CHANGED] ПИ: Конфликт между именами импортируемых модулей и модулей в командной строке
====================================================================================================

  [CHANGED] 17.10.2008 - 22:58:13,00

  Проблема такая. В спецификации указано, что модули, перечисленные в командной строке, являются как
бы "головными". Если в командной строке указан головной модуль, который компилируется в отдельный
exe-шник, то он образует проект. Если же указан не головной модуль, то подлежит компиляции он и все
зависимые от него модули. В любом случае каждый модуль в командной строке образует "гроздь" из зави-
симых модулей. В принципе, эти "гроздья" могут частично пересекаться или даже вкладываться друг в
друга. Для всех гроздей имеется одинаковая переменная MODULEPATH, одинаковый набор back- и front-
end'ов. Поэтому можно предположить (а я так для этого молчаливо и полагал, не отражая свои мысли в
журнале или спецификациях) что модули, одновременно присутсвующие в нескольких "гроздьях", должны
быть обработаны только однократно и при обработке последующей "грозди" можно воспользоваться обрабо-
танными модулями из предыдущих "гроздей".
  Но тут возникает проблема. Правила поиска модулей по квалифицированному имени (когда ищется импор-
тируемый модуль) и правила поиска модулей, указанных в командной строке различаются. Поэтому если
модуль импортируется, то он может быть найден по одному пути, если же он указан в командной строке,
то имея то же квалифицированное имя, может находиться по другому пути. Пример.
  compile_mr /* разные опции, MODULEPATH=".;D:\MyLib;C:\MR" */ MainModule.mref C:\MR\SubModule.mref

  $PROGRAM MainModule;
  
  $IMPORT SubModule;

  /* прочий код */;

  $END MainModule.

  В данном случае, если SubModule находится в текущей папке или папке D:\MyLib, то как импортируемый
модуль он не будет обнаружен в папке C:\MR, но по правилам поиска модуля, указанного в командной
строке, будет SubModule должен быть найден в папке C:\MR (должен быть, иначе произойдёт ошибка ком-
пиляции "Модуль не найден"). Возникает конфликт.

  Решение проблемы. Предполагается следующее решение. Сначала производится поиск (только поиск без
компиляции или анализа) модулей, перечисленных в командной строке. Их местоположения запоминаются.
В дальнейшем производится последовательная компиляция этих модулей. Теперь, если где-либо в списке
импорта будет указан тот же модуль, что и тот, который указан в командной строке, будет использо-
ваться модуль, указаннный в командной строке. Т.е. для примера выше модулем MainModule.mref будет
импотирован модуль C:\MR\SubModule.mref.


====================================================================================================
  [CHANGED] ПИ: Расширения в нижнем регистре
====================================================================================================

  [CHANGED] 15.10.2008 - 22:39:31,17

  Меняю спецификацию. Теперь расширения должны быть в нижнем регистре. Подробности в файле специфи-
кации "Поиск исходников.txt".
  Мотивация. Искать файлы с расширениями, различающимися регистром, неэффективно.


====================================================================================================
  [CHANGED] Устранены MRefalRTS::Lenw и MRefalRTS::ExistFile-T
====================================================================================================

  [CHANGED] 14.07.2008 - 20:42:05,95

  Из модуля поддержки времени выполнения удалены эти две функции, которые не используются в библио-
течных модулях. Когда-то я удалял Lenw, но, видимо или не до конца удалил. Или забыл всё-таки уда-
лить из самого MRefalRTS, или случайно когда-то потёр MRefalRTS и восстановил старую версию.


====================================================================================================
  [DONE] eXpression eXchange in/out
====================================================================================================

  [TODO] 19.10.2007 -  1:04:32,32

  В целях упрощения новой будущей компоновки (по функциям) имеет смысл реализовать обмен выраже-
ниями XXIO, подобный тому, который есть в Рефал-5. Однако, данный формат, скорее всего не будет под-
держивать идентификаторы (т.к. семантика у них должна быть другая).
----------------------------------------------------------------------------------------------------
  [DONE] 14.07.2008 - 20:42:05,95

  Написал модуль для средств обмена выражениями. Для XXIO формата принят следующий синтаксис:
  * Структурные скобки ( ) отображаются соответственно в '(' ')'.
  * Объектные скобки '(' ')' отображаются соответственно в '#(' '#)'
  * Символы табуляции и новой строки отображаются соответственно в '\t' и '\n'.
  * Символы с кодами от 33 до 127 отображаются как есть.
  * Остальные символы отображаются как '\dNNN', где NNN -- трёхзначный десятичный код символа.
  * Макроцифры отображаются в '#число ', где число -- десятичное представление числа.
  Если в исходном выражении были идентификаторы или АТД-термы, то функция сохранения MXXIO::Save
сохранения файла не выполняет, возвращает Fails.
  При обнаружении первой же ошибки во входном файле разбор файла прекращается, функция MXXIO::Load
возвращает Fails.
  При чтении файла не имеет значения разбиение исходного файла на строки, при записи файл разбива-
ется на строки длиной 63 символа.


====================================================================================================
  [CHANGED] Отступ в два пробела
====================================================================================================

  [CHANGED] 05.07.2008 - 23:58:33,14

  Недавно узнал, что у нас на кафедре при программировании на Си++ требуется делать отступы в два
пробела (при чём пробелами и ни в коем случае не табуляцией). Чтобы исследовать на себе этот стиль,
я установил в настройках Far'а табуляцию в два пробела, замена всех табуляций пробелом (заменяет при
сохранении файла), а также макрос Пробел-Backspace на кнопку табуляции. Привыкаю потихоньку.


====================================================================================================
  [DONE] Продумать детали перевода IModule на квалифицированные имена
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?
----------------------------------------------------------------------------------------------------
  [DONE] 05.07.2008 - 20:27:00,31

  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.


====================================================================================================
  [DONE] Разбить Parser на модули
====================================================================================================

  [TODO] 05.07.2008 - 13:29:02,69

  Кратко. Разбить модуль парсера на три модуля: mParser_Common.mref, mParser_Source.mref,
mParser_Sym.mref.
  Мотивация. Модуль MParser прямо или косвенно импортируется следующими модулями: MSymModule,
Compiler, MStartupSeqGenerator, MLinker_Refal5, MBackEnd_Refal5_init, MFrontEnd_MRefal. И при каждом
изменении парсера для всех этих модулей проходит каскадная перекомпиляция. Дело в том, что модуль
MParser выполняет две похожие задачи: анализ и распознавание файла исходного текста и файла символи-
ческой информации. Эти две задачи объединяет то, что код их реализации имеет очень много компонентов,
поэтому они реализуются в одном модуле.
  Поэтому надо разделить код из модуля MParser на три разных модуля: модуль для распознавания общих
нетерминалов, модули для распознавания исходного и символического файлов. В принципе, можно было бы
объединить модули с общими термами и распознавания символических файлов, т.к. для распознавания пос-
ледних нужно только две специализированные функции: тело модуля и объявление функции. Однако, это ре-
шение мне кажется непоследовательным, т.к. объединяются модули только по признаку объёма файла, а не
по смыслу.
  Вообще, решение об разделении одного модуля на три мне кажется больше техническим, нежели концеп-
туальным. Ведь после разделения связь между модулем с общими средствами и модулями распознавания фай-
лов будет большой (определяется количеством используемых entry-функций). Но, с другой стороны, сейчас
модуль парсера является самым большим среди всех исходных файлов проекта (45594 байта). Поэтому для
удобства работы с ним его надо разбить на несколько маленьких.
----------------------------------------------------------------------------------------------------
  [DONE] 05.07.2008 - 15:53:28,01

  Теперь в проекте вместо модуля MParser имеются три модуля MParser_Common, MParser_MRefal,
MParser_Sym. В принципе, сделано всё в соответствии с TODO.


====================================================================================================
  [DONE] Удалить поддержку FnPtr
====================================================================================================

  [TODO] 23.06.2008 - 21:36:49,43

  Закономерное следствие введения синтаксиса указателей на функции и поддержки этого синтаксиса.
Стабильная версия поддерживает оба варианта получения FnPtr, поэтому можно вызовы FnPtr постепенно
удалить и заменить на нормальный человеческий синтаксис.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 23:01:39,17

  Удалил из парсера поддержку FnPtr и парсер полегчал на 88 строк программного кода. Также заменил
все вызовы <FnPtr ... > в исходных кодах компилятора на конструкцию с амперсандом.


====================================================================================================
  [DONE] Переворошить Parser -- форматы функций
====================================================================================================

  [TODO] 20.06.2008 - 23:12:35,60

  Кратко. Надо поменять формат всех функций на
  <NFn
    [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  >
    == [ t.IModule ] [ t.VarTable ]
    [ e.Stack ]
    t.ErrorList t.Lexer t.NextToken
  В квадратных скобках показаны необязательные элементы.
  Мотивация. Параметр t.IModule присутствует во всех функциях-нетерминалах, но используется он
только в нетерминалах верхнего уровня. Аналогично в случае t.VarTable, которая тоже не везде исполь-
зуется. Однако, все функции принимают t.ErrorList t.Lexer и t.NextToken. Вышеназванные балластные
элементы находятся между t.ErrorList и t.Lexer, поэтому приходится балластные элементы передавать.
  Дело не в тех иллюзорных тактах процессора, требуемых на распознавание этих элементов, а в том,
что (а) удлиняется код -- на экране элементарно влезает меньше, (б) усложняется код -- необходимо
следить за правильной передачей тех данных, которые не используются.
  Проблема явила свою гадкую личину после того, как я написал универсальные функции для распозна-
вания квалифицированных имён. Формат этих функций не был приспособлен для работы с форматом, содер-
жащим таблицу локальных переменных. Поэтому для использования внутри выражений приходилось (не)ес-
тественным образом таблицу локальных переменных прятать в стек.
  Ожидаемые результаты. Новый формат позволит не передавать во внутренние функции балластные аргу-
менты. Например, если функция NFn1 принимает t.IModule, а функция NFn2 его не принимает, то можно
записать:
  t.IModule e.Stack t.ErrorList t.Lexer t.NextToken =
    <NFn1
      t.IModule
      e.ParentStack
      <NFn2
        e.LocalStack
        t.ErrorList t.Lexer t.NextToken
      >
    >
вместо
  t.ErrorList t.IModule (e.Stack) t.Lexer t.NextToken =
    <NFn1
      <NFn2
        t.ErrorList t.IModule
        (e.LocalStack (e.ParentStack))
        t.Lexer t.NextToken
      >
    >
  Вторым преимуществом является упрощение соглашения о вызовах функций. Стек в данном случае рас-
тёт справа, поэтому можно принять соглашение о том, что функция, распознающая нетерминал всегда нахо-
дится на вершине стека. Родительский стек автоматически конкатенируется с дочерним.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Форматы функций, распознающих нетерминалы, написаны в соответствии с TODO. Однако есть здесь два
варианта стека: тот, который описан в TODO, и оставшийся со старых времён стек в скобках для распоз-
навателей выражений.


====================================================================================================
  [DONE] Новая стабильная версия
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Введение новой стабильной версии позволит сейчас (пока указатели на функции целиком не завладели
исходными текстами) уже избавиться от позорной псевдофункции FnPtr. Уже соответствующий синтаксис
готов. Для себя ставлю веху: когда будет готов следующий синтаксис:
  ... = <MLambda.Reduce Math.Add 0 e.NumList>;
т.е. квалифицированное имя посреди выражения интерпретируется как указатель на функцию, я заменю ста-
бильную версию.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Стабильная версия написана. Стабильная версия поддерживает как указатели на функции в новом сти-
ле: с '&' и без '&' в случае явно написанного квалифицированного имени. Однако, как уже сказано выше,
стабильная версия не поддерживает синтаксис < & Module.Function ... >.
  Стабильная версия имеет номер версии 0.1.951.
  По сравнению с предыдущей стабильной версией, в этой стабильной версии полностью поддерживаются
АТД (разумеется, без спецификаций переменных, я их в версию 0.2 добавлять не планирую). Папка и рас-
ширение выходных файлов этой стабильной версии соответственно ROutS и .srout.


====================================================================================================
  [DONE] Пересмотреть Parser
====================================================================================================

  [TODO] 13.04.2008 - 22:05:09,47

  Необходимо разобраться с функциями, реализующими нетерминалы: унифицировать их интерфейс. Разоб-
раться, что должно быть в момент вызова нетерминалов на стеке и что должно оставаться на стеке после
их выполнения. Результат унификации должен быть закомментирован в шапке модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Parser пересмотрел, переворошил, интерфейс нетерминалов частично унифицировал. Однако, стек для
распознавателей выражений я не переделывал, т.к. он пока и так выполняет свои обязанности и допускает
расширение. Привожу шапку из Parser'а (в дальнейшем она может измениться).

/*------------------------------------------------------------------------------
  Функции синтаксического анализа делятся на три категории:
  (1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
  После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
  (2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
  (3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

  Формат функций-распознавателей работает в соответствии с TODO Переворошить Parser -- форматы фун-
кций.


====================================================================================================
  [DONE] Синтаксис для указателей на функции
====================================================================================================

  [TODO] 13.04.2008 - 22:05:09,47

  Диспетчеры предполагают регистрацию callback'ов. Для более красивой реализации этого лучше испо-
льзовать вместо FnPtr специальный синтаскис указателей. О том, какой синтаксис надо использовать,
я уже писал в DONE: Особым образом обрабатывать <FnPtr> от 19.03.2008. Тогда я хотел обождать, но
ждать уже хватит. Надо делать. Синтаксис.

  QualifiedName =
    IDENTIFIER | QuadQualified | DotQualified .
  QuadQualified =
    IDENTIFIER '::' IDENTIFIER | QuadQualified '::' IDENTIFIER .
  DotQualified =
    IDENTIFIER '.' IDENTIFIER | DotQualified '.' IDENTIFIER .
  FnPtr =
    '&' IDENTIFIER | ['&'] DotQualified .
  Callable =
    QualifiedName | FnPtr | S-VARIABLE .

  FnPtr может быть как результатным, так и образцовым термом.
  
  Таким образом, квалифицированное имя -- это или квалифицированное квадратиком '::' или квалифици-
рованное точкой имя. Или просто идентификатор. Там где был раньше допустим только квадратик, теперь
допустима и точка. В качестве вызываемой сущности может быть использован и указатель на функцию,
что вполне логично. Такой вызов семантически ничем не должен отличаться от обычного вызова.
----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Реализован в полном соответствии с TODO. Однако, нетерминал FnPtr распознаётся не отдельной цели-
ковой функцией, а по кусочкам -- кусочки в распознавателях выражений NPatternExpr и NResultExpr (на-
чинается с обнаружения амперсенда или идентификатора) и в NCallable.
  Про вариант синтаксиса < & Module.Function ... > я сначала забыл (поэтому он не определяется ста-
бильной версией), а потом всё-таки вспомнил.


====================================================================================================
  [DONE] Продумать квалификацию точкой
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [DONE] 23.06.2008 - 21:36:49,43

  Забавно то, что в комментарии к этому TODO я планировал решить этот вопрос только после выхода
версии 0.2. Уже давно продумано и даже реализовано. О том, как это было реализовано, написано в DONE
к Синтаксис указателей на функции. Вполне неплохо получилось.


====================================================================================================
  [DONE] Законспектировать спецификацию модели модулей
====================================================================================================

  [TODO] 13.06.2008 - 15:12:23,27

  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.
----------------------------------------------------------------------------------------------------
  [DONE] 14.06.2008 -  1:28:52,75

  Законспектировал. Теперь TODO очень много. Даже не умещаются на одной странице. Модули, относя-
щиеся к поиску модулей, содержат префикс ПИ. Некоторые подчинённые модули не имеют того же префикса.


====================================================================================================
  [DONE] Модуль имитации функций высших порядков
====================================================================================================

  [TODO] 13.06.2008 - 15:12:23,27

  Одно из совсем будущих изменений Модульного Рефала заключается во введении в него функций высших
порядков: возможность порождения (безымянных или с именем) локальных функций со связанными в них
локальными переменными, возврат этих функций (как возвращаемого значения) и т.д. Возможность передачи
объекта-функции (в виде указателя на функцию) внутрь функции и вызова этой функции есть уже сейчас
и реализована средстами FnPtr и <s.X ...>.
  Основными средствами, предоставляемыми этим модулем, должны быть функции Map и Reduce. У меня в
программе активно используются Map- и Reduce-подобные циклы (фактически, это можно рассматривать как
идиому). Но в некоторых случаях идиома скрывается под большим количеством строк, описывающих циклы.
(Интересно то, что здесь я, говоря о циклах, имел ввиду остаточную рекурсию. Циклов в Модульном Рефа-
ле нет. Я уже мыслю остаточную рекурсию в виде циклов). Использование явным образом функций Map и
Reduce сделает код более читабельным.
  Модуль я планирую назвать MLambda.mref. Если он докажет свою полезность, то станет библиотечным.
  Основные средства, предоставляемые модулем.

  Тип лямбда-функции:
    t.Lambda ::= s.FnPtr | [АТД, определённое внутри модуля]

  Вызов лямбда-фукции:
    <Apply t.Lambda e.Arg>
      == e.Result

  Создание лямбда-функции со связыванием слева:
  <BindLeft t.Lambda e.Left>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.Left e.ARG>;
  }

  Создание лямбда-функции со связыванием справа
  <BindRight t.Lambda e.Right>
    == t.Lambda
  t.Lambda ::= {
    e.ARG = <Apply t.Lambda e.ARG e.Right>;
  }

  Функции семейства Map-Reduce
  <Map t.Lambda t.Src*>
    == e.Result*
  <Apply t.Lambda t.Src> == e.Result

  <Reduce t.Lambda t.Accum t.Src*>
    == t.Accum'
  <Apply t.Lambda t.Accum t.Src> == t.Accum'

  <MapReduce t.Lambda t.Accum t.Src*>
    == t.Accum' e.Result*
  <Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

  Функция MapReduce сочетает в себе действие функций Map и Reduce -- преобразует исходное выражение
в новое выражение вместе с передачей состояния. Для функций Reduce и MapReduce существуют парные им
фукнции Reduce-R и MapReduce-R, осуществляющие преобразование справа налево.
  Для АТД, представляющего собой лямбда-функцию, не предоставляется функция Destroy, т.к. объект
первого класса (которым и должен быть объект-функция) может беспрепятственно создаваться, копировать-
ся, возвращаться из функции и уничтожаться.
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 21:17:14,10

  Модуль написан в точности с описанием. Модуль компилируется нормально, но не протестирован. Ни-
чего, оттестируется в процессе использования.


====================================================================================================
  [DONE] Добавить к BE-Mgr поддержку линковщика
====================================================================================================

  [TODO] 01.06.2008 -  2:32:18,92

  Полная ортогональность не достигнута. Вперёд!
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 15:12:23,27

  Поддержка линковщика добавлена. Более того, теперь линковка выполняется также обобщённо, как и
генерация выходных файлов. Модуль mLinker.mref говорит диспетчеру "связывай" и диспетчер вызывает
функцию связывания для каждого из back-end'ов.


====================================================================================================
  [DONE] Абстрактные типы данных
====================================================================================================

  [TODO] 06.10.2007 - 18:35:07,82

  Реализовать языковую поддержку АТД. Подробности в файле "ATD support.txt".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Если не обязательно, то очень желательно. Примитивную поддержку обеспечить можно.

  [TODO] eXpression eXchange in/out
  Совсем не торопит. Не выделяем.

  [ERROR] Ошибка в MFileSystem при работе с кириллицей
----------------------------------------------------------------------------------------------------
  [DONE] 13.06.2008 - 15:12:23,27

  В сегодняшней версии (0.1.948) абстрактные типы данных по сути представляют собой надстройку над
идиомой АТД. И я считаю это вполне достаточным для версии 0.2. В дальнейших версиях, вероятно, будут
реализованы более сложные виды АТД: с некоторой внутренней структурой задаваемой образцом, с несколь-
кими конструкторами (как в Haskell). Также будут созданы ограничители на тип переменной, типа тех,
которые описаны в спецификации на АТД ("ATD support.txt"). Также будет возможность полного или час-
тичного экспорта АТД (т.к. если большая часть инварианта заключена в внутреннем формате АТД, то при
автоматической проверке формата инвариант будет сохраняться автоматически). Но это уже относится к
какой-нибудь версии 0.3 или больше. Сейчас надо сконцентрироваться на движке.


====================================================================================================
  [CHANGED] Создан файл спецификаций "Поиск исходников.txt"
====================================================================================================

  [CHANGED] 13.06.2008 - 15:12:23,27

  В файле "Поиск исходников.txt" подробно описана концепция иерархической структуры модулей и паке-
тов, а также реализация её на компиляторе. Данная спецификация не касается аспектов синтаксиса и
внутренней структуры выходных файлов, она даже допускает различные форматы сведений о межмодульных
связях. Описываются только данные о представлении модулей в виде набора файлов и пакетов в виде ката-
логов и аспекты их физического расположения.
  Однако описана она аморфно: просто в виде коротких безымянных разделов, разделённых пустой стро-
кой. Необходимо упорядочить эти сведения и организовать их в виде списка чётких TODO.
  Реализация всех параграфов этой спецификации идеологически связана со следующими TODO:

  [TODO] Механизм поиска модулей
  [TODO] Использование нескольких front-end и back-end
  [TODO] Новая модель модулей
  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java
  [TODO] Переписать драйвер
  [TODO] Добавление категории "квалифицированное имя"
  [TODO] Перевести Parser на квалифицированные имена
  [TODO] Создать модуль для оценки необходимости перекомпиляции
  [TODO] Искать имя программы другим способом
  [TODO] Изменить обработку командной строки

  В процессе работы будут уничтожаться как вышеперечисленные TODO, так и те, которые появятся после
написания специализации.


====================================================================================================
  [FIXED] Ошибка в именах файлов с пробелами
====================================================================================================

  [ERROR] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.
----------------------------------------------------------------------------------------------------
  [FIXED] 12.06.2008 -  1:32:20,20

  Исправил. Вроде работает.


====================================================================================================
  [FIXED] Ошибка в MFileSystem::FilesInfo при работе с кириллицей
====================================================================================================

  [ERROR] 11.06.2008 - 22:03:06,42

  Выяснено: выскакивает ошибка при работе с кириллицей. Надо разбираться.
----------------------------------------------------------------------------------------------------
  [FIXED] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


====================================================================================================
  [FIXED] Ошибка при рекурсивном сканировании папок
====================================================================================================

  [ERROR] 08.06.2008 -  2:49:01,70

  При попытке использовать имя папки, возвращённое функцией MFileSystem::FilesInfo для рекурсивного
просмотра этой папки вылетает ошибка. Эту ошибку можно увидеть в папке Tests/DirSync.
----------------------------------------------------------------------------------------------------
  [FIXED] 11.06.2008 - 22:26:35,36

  Кириллица тут оказалась не при чём. Ошибка заключалась в том, при рекурсивном просмотре в тесто-
вой программе исходное имя задавалось относительным путём в текущей папке. Дело в том, что команда
dir вызывалась таким образом:

  'dir ' e.FileMask '>...'

  Таким образом, если внутри e.FileMask имелись пробелы, команда оказывалась неверна. Одним из ва-
риантов решения проблемы могло быть автоматическое введенение кавычек внутри MFileSystem::FilesInfo.
При этом необходимо запретить кавычки внутри аргумента вышеупомянутой функции.


====================================================================================================
  [DONE] Примерное описание работы диспетчеров back- и front-end'ов
====================================================================================================

  [TODO] 18.04.2008 - 22:57:27,21

  Это TODO я удалю, когда дам точные спецификации для работы этих диспетчеров. Или когда эти диспет-
черы я реализую.
  Back-end manager должен позволять зарегистрировать в себе конкретные генераторы выходного кода.
Генератор характеризуется функцией для генерации файла из IModule, расширением выходного объектного
файла, расширением исполнимого файла, папкой для выходных файлов и др. Также может предоставлять фун-
кцию, создающую имя файла из квалифицированного имени.
  Front-end manager должен позволять также регистрировать front-end'ы. Front-end должен предостав-
лять расширение исходного текста, (возможно) имя папки, функцию для парсинга.
  Модуль компиляции и модуль проверки необходимости компиляции ничего не знают о конкретных front-
и back-end'ах, просто пользуются диспетчерами. Модуль компиляции посылает диспетчеру сообщение "гене-
рировать" и тот генерирует.
----------------------------------------------------------------------------------------------------
  [DONE] 01.06.2008 -  1:58:55,72

  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


====================================================================================================
  [DONE] Создать "диспетчеры" back-end'ов и front-end'ов
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Создать модули, хранящие списки зарегистрированных входных и выходных частей. При этом диспетчеры
должны сообщать о зарегистрированных расширениях, папках, в которых следует искать, должны осуществ-
лять вызов анализаторов и генераторов кода.
----------------------------------------------------------------------------------------------------
  [DONE] 01.06.2008 -  1:58:55,72

  Оба диспетчера уже сделаны. Диспетчер back-end'ов уже успешно выполняет свою функцию (мы ему го-
ворим: откомпилировать всеми back-end'ами и он компилирует). Для полноценной работы FE-Mgr'а нужно
переписать весь алгоритм определения необходимости перекомпиляции.


====================================================================================================
  [DONE] Доделать механизм переименования модулей
====================================================================================================

  [TODO] 29.09.2007 - 22:22:40,36

  Доделать наполовину сделанный механизм переименования модулей.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обязательно. Если будет добавлена иерархия в стиле Java, то писать Std::InOut::WriteLine будет
затруднительно. Использование $IMPORT IO = Std::InOut; а затем <IO::WriteLine e.Line> будет гораздо
удобнее.

  [TODO] Расширения .rout2 -> .rout
  Некритично. Чтобы обеспечить совместимость со стабильной версией, придётся часто менять расшире-
ния. Хотя и с этим можно справиться. Но всё же для выпуска публичной версии лучше поменять расшире-
ние.
  Не выделяем.

  [TODO] Единица компоновки -- функция вместо модуля
----------------------------------------------------------------------------------------------------
  [DONE] 24.04.2008 -  0:14:07,31

  Давно у меня это TODO висело. Аж с 29.09.2007. Наконец то сделал. Теперь работает. Как только
я сделаю новый синтаксис для указателей на функции, я заменю стабильную версию и начну активно ис-
пользовать короткие псевдонимы для модулей.


====================================================================================================
  [FIXED] Ошибка в FnPtr
====================================================================================================

  [ERROR] 13.04.2008 - 21:06:47,07

  Реализация этой злополучной функции явила новый сюрприз. Если в качестве параметра указать вместо
имени функции имя АТД, то будет получен "указатель" на этот АТД, т.е. результат будет ошибочным. Нуж-
но на стадии компиляции проверять то, что аргумент FnPtr должен быть не только реально существующей
сущностью, но и должен быть именем функции.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.04.2008 - 22:49:01,30

  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.


====================================================================================================
  [FIXED] Ошибка при разрешении имени функции
====================================================================================================

  [ERROR] 23.04.2008 - 20:49:40,97

  Ранее была найдена ошибка в функции FnPtr. Оказывается ошибка не только в ней. Ошибка возникает
при разрешении любого вызова функции и при разрешении любого описания АТД. Имена функций и АТД разре-
шаются и затем компилируются абсолютно одинаковым образом: заменяется неквалифицированное имя на ква-
лифицированное с известной областью видимости. Причём место замены никак не контролируется: может
быть "правильно" разрешена функция после квадратной или АТД после угловой скобки.
  Слава богу, что синтаксис не позволяет записывать после квадратной скобки квалифицированное имя.
А то можно было бы делать "экспортируемые АТД", используя имя entry-функции после квадратной скобки.
  Кстати, эта ошибка нарушала один из негласных принципов компилятора: генерируемый код на входе
Рефал-5 должен быть абсолютно безошибочным или не генерироваться вообще. А так можно было сгенериро-
вать "вызов АТД" после угловой скобки. Рефал-5 в таких случаях справедливо ругается на необъявленную
функцию.
  Это ERROR я удалю тогда, когда исправлю ошибку. Вместе с ним я удалю упомянутое ERROR про FnPtr.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.04.2008 - 22:49:01,30

  Теперь функция MResolveTable::Lookup принимает ещё один аргумент -- набор допустимых способов вы-
зова (ScopeClass). Если имя в таблице существует, но имеет ScopeClass, не входящий в набор, то функ-
ция возвращает ту же ошибку, что и просто при отсутствии имени.


====================================================================================================
  [DONE] Обдумать замену FnPtr на что-то другое
====================================================================================================

  [TODO] 24.02.2008 - 23:49:32,95

  См. файл "Замена FnPtr на что-то другое.txt" (в каталоге спецификаций).
  Когда обдумаю, сделаю DONE для этого TODO и добавлю новое TODO: замена FnPtr на ... .
----------------------------------------------------------------------------------------------------
  [DONE] 23.04.2008 - 20:49:40,97

  Замену я обдумал ещё 13.04.2008 -- синтаксис и семантика для указателей на функции. Просто опять
по ошибке забыл удалить TODO.
  Первое время front- и back-end диспетчеры будут регистрироваться при помощи FnPtr, т.к. необходи-
мо обеспечить совместимость с текущей стабильной версией.


====================================================================================================
  [DONE] Исключение промежуточного представления модуля
====================================================================================================

  [TODO] 04.02.2008 - 16:08:22,32

  Есть такая мысль: тело функции можно вполне рассматривать как один из атрибутов имени функции в
таблице символов. Поэтому можно исключить из компилятора такое понятие, как структура "Модуль -- про-
межуточно представление". Внутреннее представление структуры имеет вид t.Module ::= (t.SymTable
t.ModuleElement*), где t.ModuleElement ::= (Function e.FunctionInfo). e.FunctionInfo содержит в себе
информацию об классе видимости, квалифицированном имени функции и само тело функции. Если изменить
таблицу символов таким образом, чтобы она могла индексироваться по квалифицированному имени, то все
эти сведения можно сохранять как атрибуты. Для этого можно, например, создать функцию <AddAttribute
t.SymTable (e.Name) s.Attribute e.Value> или вместо (e.Name) использовать t.QualifiedName.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Продумать и исключить.

  [TODO] Таблица перекрёстных ссылок
----------------------------------------------------------------------------------------------------
  [DONE] 18.04.2008 - 22:57:27,21

  Это TODO я давно выполнил, когда реализовал IModule. Промежуточного представления в старом смысле
в программе нет. Просто по ошибке я забыл удалить это TODO. Вот так, не меняя ни строчки кода, я уст-
ранил одно TODO.


====================================================================================================
  [CHANGED] Изменена реализация контекста
====================================================================================================

  [CHANGED] 13.04.2008 -  2:04:35,41

  Теперь контекст реализован как настоящий абстрактный тип данных. До этого контекст был реализован
как псевдоАТД t.Context ::= (t.ModulesList t.CachedSyms t.ErrorList). Из этих трёх компонентов реаль-
но использовалась только первый, ко второму даже не было методов доступа. К третьему методы доступа
были, но они ни разу не использовались. Методы доступа к первому компоненту лишь перенаправляли вызов
к аналогичным функциям внутри модуля MModulesList.
  Вместо этого был разработан новый модуль MContext, который имеет более совершенные функции для
работы с контекстом (использование квалифицированных имён, все функции "чистые"). Модуль Context так-
же перенаправляет вызовы, при необходимости конструируя и разрушая квалифицированные имена.
  В дальнейшем предполагается постепенно избегать использования модуля Context, используя вместо
этого MContext. В процессе переработки управляющей программы, я думаю, это удастся осуществить и пос-
тепенно необходимость в модуле Context отпадёт сама собой.
  После завершения компиляции отдельного модуля, информация об этом модуле в контексте перемещается
в конец (ведь изнутри контекст реализует простой ассоциативный поиск по имени). Таким образом после
анализа головного модуля в конце списка оказывается головной модуль. Функция GetProgName как раз воз-
вращает это имя, которое затем используется в линковщике. Этот метод хотя и прост и эффективен, но
и имеет ряд недостатков. Основным недостатком является то, что определить "главность" модуля можно
и без контекста -- головным модулем может быть только модуль из командной строки, при этом начинаю-
щийся с директивы $PROGRAM. Поэтому в процессе переписывания движка нужно будет на это обратить вни-
мание.


====================================================================================================
  [DONE] Промежуточное представление как АТД
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  См. комментарий к "SymInfo как АТД". Вопрос решать надо.

  [TODO] Добавление категории "квалифицированное имя"
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [DONE] Промежуточное представление модуля
====================================================================================================

  [TODO] 08.03.2008 - 20:17:27,04

  Атрибутная таблица символов (которая, по сути, лишь двухуровневый ассоциативный массив) -- сама
по себе очень гибкий инструмент: имя может иметь любой набор атрибутов, набор допустимых атрибутов
описывается в файле Attributes.txt, компилятором никак не проверяется. В дальнейшей работе можно про-
сто утонуть во всей этой гибкости. Поэтому нужна оболочка вокруг этой таблицы символов, которая конт-
ролировала бы доступ.
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [DONE] Интегрировать IModule
====================================================================================================

  [TODO] 29.03.2008 - 19:33:03,08

  Необходимо интегрировать структуру данных IModule в компилятор, т.е. заменить SymTable на неё
там, где надо.
----------------------------------------------------------------------------------------------------
  [DONE] 30.03.2008 - 22:57:12,84

  Создано промежуточное представление модуля. И оно интегрировано: там, где раньше использовалась
голая таблица символов, сейчас используется промежуточное представление. Однако, ещё я не заменил
символьную информацию на промежуточное представление. Буду заменять, когда буду реализовывать TODO
"Создать модуль для оценки необходимости перекомпиляции". Вроде работает.
  Т.к. перекомпилировал много раз используя стабильную версию, номер сборки вырос. Теперь это 903.


====================================================================================================
  [CHANGED] Удалён модуль MSymInfo
====================================================================================================

  [CHANGED] 29.03.2008 - 19:33:03,08

  Предполагалось, что модуль MSymInfo будет предоставлять АТД для представления символической ин-
формации. Однако, этот модуль никак не развивался. В качестве промежуточного представления символи-
ческой информации можно использовать структуру IModule, удалив при этом из неё тела функций и инфор-
мацию об не-entry-функциях.
  Потом, когда я переведу компилятор целиком на IModule, я удалю TODO: SymInfo как АТД.


====================================================================================================
  [DONE] Отучить Resolver от старого представления модуля
====================================================================================================

  [TODO] 20.03.2008 -  0:08:54,21

  Модуль MResolver сначала преобразовывает таблицу символов в модуль в старом формате, его проверя-
ет и снова модуль превращает в таблицу символов. Решить этот вопрос. Можно решать этот вопрос в то же
время, когда и буду учить Resolver проверять образцовое выражение. Хотя, вероятно, Resolver придётся
приучать к промежуточному представлению модуля в виде АТД.
  При этом автоматически мы избавимся от MSymTable-Module.
----------------------------------------------------------------------------------------------------
  [DONE] 29.03.2008 - 19:33:03,08

  Теперь Resolver пользуется только таблицей символов. Хотя модуль, инкапсулирующий промежуточное
представление модуля MIModule, написан, он ещё в проекте не используется. Т.е. надо интегрировать.


====================================================================================================
  [FIXED] В таблице символов ошибка -- имя может оказаться без сорта
====================================================================================================

  [ERROR] 22.03.2008 - 21:17:30,11

  Если выполнить команду <MSymTable::RemoveAttrib t.SymTable e.Name Kind>, то в таблице символов
имя вообще окажется без атрибута.
----------------------------------------------------------------------------------------------------
  [FIXED] 23.03.2008 - 20:27:33,79

  Ошибка исправлена. В функцию MSymTable::RemoveAttrib просто добавлен частный случай.


====================================================================================================
  [FIXED] Исправлена ошибка в Parser
====================================================================================================

  [FIXED] 23.03.2008 - 14:22:12,04

  Если при обработке тела модуля функцией MParser::NModuleBody встречался конец файла, функция воз-
вращала результат неправильного формата: t.ErrorList t.SymTable Error, хотя по завершению рекурсив-
ного анализа синтаксиса, должно возвращаться t.ErrorList t.SymTable. Происходила, в общем ошибка.
  Похожая ошибка была и в MParser::MSymModuleBody. Но в этом случае компилятор просто бы завис.


====================================================================================================
  [DONE] Несуррогатно реализовать АТД
====================================================================================================

  [TODO] 19.03.2008 - 23:38:04,78

  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.
----------------------------------------------------------------------------------------------------
  [DONE] 20.03.2008 - 23:03:24,42

  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


====================================================================================================
  [DONE] Научить Resolver проверять образцовое выражение
====================================================================================================

  [TODO] 19.03.2008 - 23:38:04,78

  Два взаимосвязанных TODO. Короче, надо реализовать часть спецификаций АТД, а именно: осуществить
полноценную поддержку [ИДЕНТИФИКАТОР e.Содержимое] в образцовом и результатном выражении, т.е. прове-
рять, что имя АТД правильное. Поддержку этой конструкции легко осуществить в результатном выражении,
т.к. это похоже на проверку вызова функции. Нужно то же самое осуществлять и в образце. Возможно,
придётся изменить и промежуточное представление.
  Часть спецификации, а именно, проверять соответствие терма абстрактному типу данных из других мо-
дулей я пока не знаю как сделать -- с синтаксисом ещё не определился.
----------------------------------------------------------------------------------------------------
  [DONE] 20.03.2008 - 23:03:24,42

  Теперь есть более полная поддержка АТД: не поддерживается только соответствие переменной типу:
над синтаксисом надо думать. Resolver проверяет образцовое выражение. Промежуточное представление
также оказалось изменено. Теперь t.Sentence ::= (t.Pattern t.Result), t.Pattern ::= (Pattern t.Pat-
ternTerm*), t.Result ::= (Result t.ResultTerm*).
  Однако, Resolver по-прежнему использует MSymTable-Module.


====================================================================================================
  [DONE] Особым образом обрабатывать <FnPtr>
====================================================================================================

  [TODO] 08.03.2008 - 23:59:52,21

  Проблема FnPtr всё ещё актуальна. Пока я нового синтаксиса для указателей на функции не придумал,
хотя в промежуточном представлении они успешно существуют. Временное решение проблемы состоит в том,
чтобы вызовы <FnPtr ИДЕНТИФИКАТОР*> обрабатывать не как вызов функции, а особым образом -- сразу за-
менять их на указатель в промежуточном представлении.
----------------------------------------------------------------------------------------------------
  [DONE] 19.03.2008 - 23:24:46,88

  Казалось бы, за что боролся, на то и напоролся. Раньше функция FnPtr была автоматически генериру-
емой, то теперь она встроенная. При чём, эту функцию пользователь не может переопределить: если поль-
зователь объявит собственную функцию FnPtr, то она просто не будет вызвана. Вызов <FnPtr ИДЕНТИФИКА-
ТОР* > распознаётся на уровне синтаксического анализа (parser'ом).
  Относительно нового синтаксиса для указателей на функции я склоняюсь к следующему: вводится ква-
лификация точкой, указатель описывается так:
  FuncPointer = "&" IDENTIFIER | ["&"] NonEmptyDotQualifier .
  NonEmptyDotQualifier = IDENTIFIER "." IDENTIFIER | NonEmptyDotQualifier "." IDENTIFIER .
  Т.е. указатель на функцию состоит из "&" и следующим за ним квалифицированным точкой именем. Если
в квалификаторе более, чем два сегмента (т.е. есть хотя бы одна точка). Синтаксически это выражается
нетерминалом -- непустым квалификатором (см. выше). В приципе, можно использовать квалификацию точкой
и в вызовах функций -- ведь по смыслу вызов известным указателем это ведь непосредственный вызов фун-
кции. Но надо подумать, обождать. Хотя додумать надо до того, как я буду вводить в компилятор неско-
лько front- и back-end'ов.
  Кстати, текущая версия компилятора 888.


====================================================================================================
  [DONE] Реорганизация таблицы символов
====================================================================================================

  [TODO] 23.02.2008 - 19:20:11,82

  Модуль таблицы символов выполняет две мало связанные функции -- реализует АТД и выполняет конт-
роль ошибок. Все функции, использующие t.ErrorList, коих немного, желательно вынести из модуля. Одна
из них (AddCurrentModule) вынесется автоматически при выполнении предыдущего TODO. Остальные две
также вынести не сложно.
----------------------------------------------------------------------------------------------------
  [DONE] 08.03.2008 - 20:57:45,78

  Теперь контроль ошибок действий с таблицей символов осуществляется без списка ошибок из MError.
Контроль добавления имени в таблицу символов осуществляется функцией AddNewName, которая помимо таб-
лицы символов возвращает Success или Fails. Добавление ошибки в t.ErrorList осуществляется в модуле
MParser.
  Однако, я всё ещё в стороне от цели. Модуль MParser должен работать не напрямую с таблицей симво-
лов, а с промежуточным представлением модуля. Т.е. нужно создать дополнительный уровень абстракции.


====================================================================================================
  [DONE] Вынести проверку соответствия имени модуля имени файла из MSymTable
====================================================================================================

  [TODO] 23.02.2008 - 19:20:11,82

  Эта проверка происходит в модуле таблицы символов, что значительно усложняет модуль и реализова-
но неестественно (добавляется символ FsName как имя и ему назначается атрибут LowerName, затем эта
запись удаляется). Проще будет организовать эту проверку вне таблицы символов.
----------------------------------------------------------------------------------------------------
  [DONE] 28.02.2008 -  0:40:56,27

  Просто вынес. Теперь эта проверка в MParser. Надо ещё вынести добавление новой сущности и, самое
главное, сравнение имён модуля в начале и конце файла. TODO "Реорганизация таблицы символов" как раз
этому посвящено.


====================================================================================================
  [CHANGED] Реорганизован каталог документации
====================================================================================================

  [CHANGED] 24.02.2008 - 23:49:32,95

  Теперь в папке Documentation появились свои каталоги для журнала и спецификаций. В каталог специ-
фикаций я складываю все TODO, вынесенные в отдельные файлы по причине своего размера (про модульную
концепцию, абстрактные типы данных и атрибутную таблицу символов).


====================================================================================================
  [FIXED] Синтакс переименования модулей
====================================================================================================

  [FIXED] 23.02.2008 - 18:50:39,32

  При обработке консткукции переименования модулей, написанной первоначально, обнаружена ошибка,
позволяющая компилятору принять такие неверные конструкции, как $IMPORT A = B = C;. Когда синтакси-
ческий анализатор писался в первый раз, не планировалось реализовывать переименование модулей в бли-
жайшее время и код был написан небрежно. Теперь эта ошибка исправлена. При обработке конструкции
переименования модуля в атрибут Alias имени импорта (ImportName) добавляется имя псевдонима модуля,
если модуль импортируется без псевдонима, то в Alias добавляется действительное имя.


====================================================================================================
  [DONE] Атрибутная таблица символов
====================================================================================================

  [TODO] 21.02.2008 - 18:29:09,77

  Подробности в файле AttSymTable.txt
----------------------------------------------------------------------------------------------------
  [DONE] 23.02.2008 - 18:50:39,32

  Атрибутная таблица символов реализована, правда не в полном соответствии со спецификацией.
  Реализованы:
  (+) Добавление имени в таблицу символов. В случае, если такое имя уже присутствует, таблица сим-
волов изменяться не должна.
  (+) Получение заданного атрибута заданного имени. Возвращаемое значение должно предусматривать
возможность сообщить об отсутствии этого имени.
  (+) Получение списка всех имён в таблице.
  (+) Установка (обновление) значения заданного атрибута заданного имени. При отсутствии имени
оно должно создаваться с набором атрибутов по умолчанию (возможно, пустым).
  (+) Удаление имени из таблицы. Вопрос о том, что делать при отсутствии имени решится в процессе
кодирования.
  (+) На начальном этапе таблица символов должна предоставлять интерфейс старой таблицы символов.

  (?) Получение списка имён с заданным значением заданного атрибута.*
  Можно получить список имён, имеющих определённое значение атрибута Kind. Атрибут Kind определяет
сорт имени: имя модуля, функция, импорт или АТД, и за каждым сортом закреплён строго определённый
набор атрибутов.

  (-) Получение списка атрибутов, связанных с данным именем. Возвращаемое значение должно предус-
матривать возможность сообщить об отсутствии этого имени.
  Будет добавлено позже.
  (-) Удаление атрибута заданного имени из таблицы. Предусловие: имя должно присутствовать в таб-
лице.
  Будет добавлено позже.
  (-) Проверка существования заданного имени.*
  Вместо этого используется проверка существования атрибута Kind.
  (-) Получение списка имён с заданным атрибутом.*
  (-) Удаление заданного атрибута у всех имён.*
  Будет реализовано позже.

  Функции для работы с таблицей символов делятся на базовые -- реализующие сам АТД, производные,
дополняющие базовые для типичных операций (установка нескольких атрибутов, добавление нового имени
в таблицу, при этом имя в таблице должно отсутствовать, поиск имён по сорту) и специальные, оставлен-
ные в наследство предыдущей таблицей символов. Последний класс функций нужно постепенно удалять из
таблицы, сменяя их на базовые и производные. Уже таким образом устранена функция AddImportModule Так-
же, в процессе работы над проектом, будут добавляться те функции таблицы символов, которые "Будут
реализованы позже".


====================================================================================================
  [CHANGED] Новая стабильная версия!
====================================================================================================

  [CHANGED] 21.02.2008 - 15:51:11,21

  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.


====================================================================================================
  [DONE] Расширения .rout2 -> .rout
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  Заменить расширения выходных файлов с .rout2 на .rout. Расширения .rout2 использовались
для совместимости с одной из старых стабильных версий. Но это мы сделаем, когда добавим ещё одно не-
совмесимое изменение языка (это, скорее всего, будет другой тип линковки).
----------------------------------------------------------------------------------------------------
  [DONE] 21.02.2008 - 15:51:11,21

  Создана новая стабильная версия. Эта версия всё ещё АТД не поддерживает, но поддерживает код, ко-
торый использует АТД (см. выше). Другой особенностью версии является то, что она использует расшире-
ние .routS и папку ROutS\ для выходных файлов. Расширения и папка выходных файлов рабочей версии те-
перь .rout и ROut\ соответственно. Вообще, желательно всю информацию о расширениях и месторасположе-
ниях файлов вынести вон из компилятора и задавать их или в конфигурационном файле, или в качестве па-
раметра командной строки.
  Новая стабильная версия имеет версию 0.1.790.


====================================================================================================
  [DONE] Подготовить совместимый с АТД синтаксис
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Это значит, что необходимо подготовить синтаксис, совместимый с Модульным Рефалом версии 0.2+.
Т.е. надо подготовить директиву типа $DATA (см. ATD Support.txt) для обозначения имени абстрактного
типа данных. Квадратные скобки язык поддерживает.
  Просто я хочу заменить текущую стабильную версию (0.1.356) на более новую, в которой и приступить
к разработке АТД и прочей лабуды.
----------------------------------------------------------------------------------------------------
  [DONE] 21.02.2008 - 15:23:05,30

  Для объявления абстрактных типов данных используются директивы $DATA и $data, синтаксис тот же,
что и при объявлении статических ящиков. Действие директивы состоит в том, имя АТД резервируется в
таблице символов, а значит не может использоваться при объявлении функций, swap-ов и в именах моду-
лей. Т.к. синтаксис подготовлен и, хочется в это верить, программа работает довольно стабильно, то
можно заменить старую стабильную версию на новую. Вероятно, также имеет смысл заменить расширение
выходных файлов, например, снова на .rout.


====================================================================================================
  [FIXED] Ошибка с FnPtr
====================================================================================================

  [FIXED] 17.02.2008 - 12:32:34,15

  Возникала ошибка при работе с FnPtr: если пользователь определял собственную функцию FnPtr, то в
объектный файл заносятся два определения -- сначала пользовательская, потом сгенерированная. Счастье,
что линковщик линковал функции в прямом порядке и вторую таким образом игнорировал. А то при измене-
нии линковки и прочих изменениях могли бы возникать глюки. Правда, исправил криво: работоспособно, но
эстетически некрасиво. В любом случае надо переписывать Resolver и создавать атрибутную таблицу сим-
волов.


====================================================================================================
  [DONE] Вывод номера версии компилятора
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Пока компилятор я пишу для себя, я могу не выводить информацию об имени компилятора, версии и
авторских правах. Однако, если я захочу представить программу другим лицам, но необходимо при каждом
запуске компиллятора выводить информацию о компиляторе и авторских правах, типа

  Module Refal 0.1.xxx (c) Mazdaywik 2007-2008

  Если инкремент версии отделить от процесса компиляции, то модуль, выводящий эту строчку можно
каждый раз генерировать автоматически.
----------------------------------------------------------------------------------------------------
  [DONE] 13.02.2008 - 23:17:52,92

  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


====================================================================================================
  [DONE] Номер версии независимо от компиляции
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Номер версии инкрементируется при каждом запуске компилятора. Имеет смысл распараллелить эти опе-
рации, т.е. для инкремента номера создать отдельное приложение.
----------------------------------------------------------------------------------------------------
  [DONE] 13.02.2008 - 23:17:52,92

  Эта версия войдёт в историю как версия "три топора". Номер текущей версии 777. Просьба это запом-
нить. Стабильной эта версия становиться ещё не будет, но всё таки. На версию теперь я буду обращать
внимание, т.к. теперь номер отображается при компиляции.
  Теперь версия обновляется утилитой VersionUpdater (см.выше) и отображается при загрузке. Компиля-
тор теперь не отвечает за версию и не создаёт файл Info/Version.txt.
  Модуль mBuildNumber.mref будет официально удалён. Прямо сейчас.


====================================================================================================
  [CHANGED] Создана утилита для обновления номера версии
====================================================================================================

  [CHANGED] 13.02.2008 - 22:59:00,41

  Утилита называется VersionUpdater. Синтаксис вызова:
  refgo VersionUpdater /verfile:файл_с_номером_версии /srcfile:исходный_текст
  Параметр /srcfile может повторяться. Файл /verfile представляет собой файл того же формата, что
и Info/Version.txt. При запуске утилита считывает номер версии, инкрементирует его и записывает в
файлы, указанные в параметрах /srcfile. В исходном файле должны присутствовать специальные метки
  //{{GEN:VERSION
  //}}GEN
между которыми будет вставлен текст VerNumber = '1.2.3';, окружённый пустыми строками. Вместо 1.2.3
в файле находится инкрементированный номер версии. Если в файле имеется несколько вхождений пар ме-
ток, то текст будет вставлен несколько раз. Если в файле имеется неправильная метка (после GEN: нахо-
дится не VERSION) или будет лишняя //}}GEN без соответствующей открывающей метки, то будет выдано
сообщение об ошибке и файл изменён не будет. Генерируемый текст вставляется между этими двумя мет-
ками, предыдущий текст между ними удаляется. Если в файле отсутствует закрывающая метка //}}GEN, то
она подразумевается перед меткой //{{GEN:* или перед концом файла и при обновлении файла будет до-
бавлена.
  Всем утилитам был в начале присвоен номер компиляции 64 (от балды) и номер версии 0.1 (так же,
как и Модульному Рефалу).


====================================================================================================
  [FIXED] Ошибка в MFileSystem при работе с кириллицей
====================================================================================================

  [ERROR] 19.10.2007 -  1:04:32,32

  Функции модуля MFileSystem возвращают некорректное имя файла, если в имени или пути присутствуют
символы кирилицы. Это связано с тем, что данные функции реализованы с использованием консольной
команды dir (аналогичным образом была реализована функция MOS::Env).
  Возможные пути решения:
  (1) Реализовать функцию перекодировки DOS->Windows и по-прежнему использовать команду DIR.
  Преимущества. Подход обобщается на использования других команд консоли Windows.
  Недостатки. Низкая эффективность при использовании консольных команд. Зависимость от системы.
Низкая информативность: может отображаться только одно поле времени (выбор осуществляется ключём /T),
точность отображения до минуты. Для отображения атрибутов необходимо использовать отдельно команду
attrib. При указании в качестве аргумента директории, выводится листинг этой директории. Эта проблема
на данный момент никак не решена.
  (2) Реализовать отдельное приложние для получения списка файлов в кодировке Windows (вывод можно
сразу осуществлять в формате XXIO из соображений эффективности).
  Преимущества. Высокая эффективность. Возможна реализация высокой информативности (вплоть до вла-
дельцев файлов, атрибутов и т.д.). Одинаковое отношение как к файлам, так и к каталогам (можно от-
дельно реализовать возможность подгрузки листинга папки и получения информации об отдельном файле).
  Недостатки. Необходимость создавать отдельную программу. Зависимость программ, написанных на
Модульном Рефале от отдельной программы (необходимость в дополнение к самой программе "поставлять"
дополнительную утилиту).

  Хотя текущей реализации это никак не мешает. (а) Рефал не позволяет в именах модулей использовать
символы кирилицы и (б) компилятор пользуется этой функцией только для получения даты модификации.

  Выводы. Если бы было произведено полное тестирование модуля MFileSystem, то эта ошибка была бы
выявлена гораздо раньше. Поскольку возвращаемые функцией листинга данные -- имена файлов -- должны
соответствовать реально существующим в файловой системе файлам. Это можно было бы проверить, просто
заставив открыть и записать что-либо в файлы, получаемые из листинга.
  Лучше не проектировать в надежде на будущее. Для компилятора достаточно было бы реализовать
функцию, получающую дату модификации файла.
----------------------------------------------------------------------------------------------------
  [ERROR] 05.02.2008 -  1:22:49,77

  Ошибку необходимо исправить. Даже не обсуждается.

  [TODO] Стандартные модули контейнеров и распространённых функций
  Желательно. Но не выделяем. Всегда библиотеки можно поставлять отдельно.

  [TODO] Новая модель модулей
----------------------------------------------------------------------------------------------------
  [FIXED] 12.02.2008 - 19:48:21,36

  Исправлена эта ошибка путём введения функции перекодировщика Dos <--> Win (см. описание ошибки
и способов исправления в записи от 19.10.2007). Создавать приложение для вывода листинга папки я не
стал, т.к.
  (а) лень -- способ более трудоёмок, его преимущества не оправдывают усилий: листингом папки я ещё
ни разу не пользовался;
  (б) привязка Рефала к постороннему приложению -- не удобно;
  (в) перекодировщик полезен сам по себе.
  Помимо перекодировки вывода программы dir, перекодировщик используется в функциях ввода/вывода
модуля InOut, поэтому теперь изнутри программа работает в кодировке Windows. Можно в файлах исходного
текста использовать текстовые строки в кодировке Windows, которые затем будут успешно выводиться пра-
вильно на консоль.
  Недостатком данного подхода является то, что перекодировке подлежат только символы кириллицы, лю-
бые другие символы второй половины кодовой таблицы сохраняются на выходе как есть.
  В идеале Рефал должен использовать внутри себя Unicode.


====================================================================================================
  [DONE] Единица компоновки -- функция вместо модуля
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  На сегодняшний день в процессе линковки просто конкатенируются выходные файлы с сравни-
тельно несложной заменой вызываемых функций на более короткие имена. Необходимо изменить линковку
таким образом, чтобы единицей компоновки была функция, а не весь объектник.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обязательно. Иначе размер сгенерированных файлов получается неприлично большим.

  [TODO] Абстрактные типы данных
----------------------------------------------------------------------------------------------------
  [DONE] 10.02.2008 - 23:17:42,34

  Правильная компоновка наконец реализована. Теперь идеологически .rout-файл представляет собой не
фрагмент генерируемого .ref-файла, в котором требуется только осуществить переименование элементов
и приклеить к .ref-файлу, а набор единиц компоновки (link unit), содержащих в себе ссылки на другие
единицы компоновки. Единицей компоновки может быть локальная или entry-функция или реализация стати-
ческого ящика. Задача линковщика теперь состоит в том, чтобы сгенерировать стартовую функцию Go для
Рефала-5 и прилинковать прямо или косвенно зависящие от неё единицы компоновки. При этом линковщик
производит переименование фукций, индексов и идентификаторов, давая им короткие имена.
  Также теперь .rout-файлы содержат в себе тег версии, который проверяется во время компоновки.


====================================================================================================
  [CHANGED] Изменился вывод сообщений о процессе компиляции
====================================================================================================

  [CHANGED] 09.02.2008 -  3:00:29,53

  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.


====================================================================================================
  [FIXED] Ошибка в MParser::NImportBlock-AfterName
====================================================================================================

  [FIXED] 09.02.2008 -  3:00:29,53

  Функции ExpectEndSent передавалась вместо неожиданной лексемы таблица символов. Ошибка возникала
при отсутствии точки с запятой после имени модуля в директиве $IMPORT. Ошибка достаточно редкая, по-
этому раньше не обнаруживалась.


====================================================================================================
  [FIXED] Ошибка в MOrder::Sort
====================================================================================================

  [FIXED] 09.02.2008 -  3:00:29,53

  Ошибка возникала при попытке отсортировать функцией Sort пустой список. Теперь ошибка исправлена.


====================================================================================================
  [CHANGED] Квадратные скобки
====================================================================================================

  [CHANGED] 08.02.2008 -  2:54:59,96

  Абстрактные типы данных медленно, но неуклонно наступают. Теперь появились квадратные скобки.
Квадратные скобки имеют тот же смысл, что и круглые (в поле зрения Рефал-машины и те и другие пред-
ставляются абсолютно одинаково), но компилятор требует наличия сбалансированности круглых и квадрат-
ных скобок. Уже сейчас их можно использовать для оформления АТД в программах. Однако в самом компиля-
торе я их использовать пока не буду, т.к. имеющаяся стабильная версия их не поддерживает.


====================================================================================================
  [CHANGED] Директива $CLEARMODULE
====================================================================================================

  [CHANGED] 05.02.2008 -  2:46:46,28

  Добавлена директива $CLEARMODULE ($clearmodule). Ранее была добавлена директива $PROGRAM
($program), однако я об этом забыл написать в журнале проекта. В текущей версии компилятора эти две
директивы обрабатываются точно также, как и директива $MODULE, однако в дальнейшем они приобретут
различный смысл: для головного модуля необходимо будет использовать директиву $PROGRAM, для модулей
без побочных эффектов -- $CLEARMODULE, для остальных -- $MODULE. Уже сейчас можно использовать дирек-
тиву $PROGRAM для стартового модуля с функцией Go, чтобы обеспечить совместимость со следующей вер-
сией. Однако до "чистых" модулей и директивы $CLEARMODULE пока ещё далеко и употреблять её не стоит.


====================================================================================================
  [DONE] Составить список приоритетных TODO
====================================================================================================

  [TODO] 04.02.2008 - 23:26:22,87

  Нужно составить список приоритетных TODO, выполнение которых позволит перейти к версии 0.2.
----------------------------------------------------------------------------------------------------
  [DONE] 05.02.2008 -  1:22:49,77

  Будем составлять его следующим макаром. Проанализируем содержимое файла TODOs.txt последователь-
но. Поехали.


====================================================================================================
  [DONE] TODO_list изменяет порядок TODO
====================================================================================================

  [TODO] 05.02.2008 -  1:09:32,10

  Изменить утилиту TODO_list таким образом, чтобы игнорировались повторные вхождения TODO не кроме
первого, а кроме последнего.
----------------------------------------------------------------------------------------------------
  [DONE] 05.02.2008 -  1:22:49,77

  Изменили утилиту. Теперь TODO и ERROR переносятся в конец. Мне это было нужно, чтобы составить
список приоритетных TODO (см. ниже).


====================================================================================================
  [DONE] Удалить прозрачные функции вывода из RTS
====================================================================================================

  [TODO] 02.02.2008 - 17:27:23,22

  Прозрачные фукции вывода InOut::WriteLine-T и FileIO::WriteLine-T практически не используются,
по крайней мере, в компиляторе. Остальные программы на Модульном Рефале я исключаю из рассмотрения,
т.к. большей частью они не настолько объёмные как компилятор и являются в основном лабами. Анализ
количества вызовов делался визуальной оценкой количества строк в файле MRefal.ref (использовалась
утилита поиска строк find). Прозрачные функции вывода встречались или в объявлении, или в таблицах
FnPtr. Поэтому соответствующие им RTS-функции MRefalRTS::Print и MRefalRTS::Put решено удалить.
----------------------------------------------------------------------------------------------------
  [DONE] 02.02.2008 - 17:55:52,95

  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.


====================================================================================================
  [DONE] Удалить MRefalRTS::Lenw
====================================================================================================

  [TODO] 02.02.2008 - 17:15:41,26

  Теперь функции MStrings::Length(-T) реализованы обычными средствами Рефала. Конечно, использова-
ние подобных функций не так эффективно, как встроенных, но зато позволяет сделать компилятор более
независимым от RTS.
----------------------------------------------------------------------------------------------------
  [DONE] 02.02.2008 - 17:55:52,95

  Удалили MRefalRTS::Lenw и MRefalRTS::Print. Функция MRefalRTS::Put пока решено оставить, т.к.
она используется в весьма полезной для отладки функции MSelfDiag::Log-T. Поэтому, до тех пор, пока
я не буду переходить с Рефала-5 на новую платформу (самостоятельно разработаннный RASL или генерация
кода для императивного языка типа C++), я эту функцию удалять не буду. Поэтому следующее TODO будет
долго висеть.


====================================================================================================
  [DONE] Создание папок Defs и ROut по требованию
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Дело в том, что даже при ошибочных запусках (без параметров или с ошибками в тексте программе)
создаются папки Defs, Info и ROut, что представляет неудобство. Разобраться с этим.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 23:01:49,86

  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


====================================================================================================
  [DONE] Генерация Info/Log.txt по требованию
====================================================================================================

  [TODO] 27.01.2008 - 21:21:01,49

  Любая программа, прямо или косвенно использующая mSelfDiag.mref, при выполнении создаёт папку
Info и в ней открывает файл Log.txt, даже если он не нужен. Раздражает.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 23:01:49,86

  Добавлен модуль mCreateDirIfNeed.mref, Функция CreateDir принимает имя папки. При первом вызове
с данным аргументом создаёт соответствующую папку и возвращает её имя. При последующих вызовах с этим
именем функция папки уже не создаёт. Данная функция вызывается из Modules.mref для создания папок
Defs и ROut. Папка Info может создаваться двумя способами. (1) При вызове функции MSelfDiag::Log
(используются низкоуровневые функции RTL) и (2) при вызове MCreateDirIfNeed::InfoDir. Последняя фун-
кция просто вызывает <CreateDir 'Info'>. Таким образом, раздражающий фактор уничтожен.


====================================================================================================
  [DONE] Новая семантика идентификатора
====================================================================================================

  [TODO] 30.09.2007 -  0:57:58,78

  Изменить семантику идентификаторов. Текстовое представление идентификатора должно быть доступно
только на момент компиляции и компоновки. На момент времени выполнения значения идентификаторов
должны быть недоступны. Это можно сделать во время компоновки, переименовывая идентификаторы во что-то
вроде W123, как это делается на данный момент с функциями.
----------------------------------------------------------------------------------------------------
  [DONE] 27.01.2008 - 21:21:01,49

  Частично изменена компоновка. Теперь переименовываемые сущности (имена функций, индексы перемен-
ных, идентификаторы и тег скобок) выделяются с обоих сторон знаком доллара, тип сущности определяет-
ся префиксом (Index:: для индексов, Local:: и Entry:: для функций, Index:: для индексов, Swap:: для
статических ящиков, Ident:: для идентификаторов и ATD:: для абстрактных типов данных). Структурные
скобки интерпретируются как АТД типа __StructureBrackets (в файлах .rout3 имеют вид $ATD::
__StructureBrackets$).
  Эти имена теперь заменяются на LNNN, где L -- литера типа (i, L, E, S, W, T), NNN -- номер, сос-
тоящий из цифр и букв в разном регистре.

  Проблема правильной линковки стала более актуальна в связи с введением указателей на функции в
сегодняшней реализации. Функции-таблицы FnPtr имеют довольно большой объём, что отрицательно сказыва-
ется на размере сгенерированной программы.


====================================================================================================
  [CHANGED] TODOs.txt -- сводка только TODO и ERROR
====================================================================================================

  [CHANGED] 20.10.2007 - 19:08:06,05

  Теперь в сводку выносятся только TODO и ERROR. В будущем возможно создание другой сводки -- всех
изменений, к примеру. Архитектура программы TODO_list это позволяет несложно реализовать.


====================================================================================================
  [DONE] Автоматизация списка TODO
====================================================================================================

  [TODO] 20.10.2007 - 16:06:51,06

  Не мешало бы автоматизировать процесс составления списка актуальных TODO в файле TODOs.txt.
Это можно осуществить, вводя в Changes.txt специальные теги, типа
  \[TODO\:Автоматизация списка TODO\]
(экранировано, чтобы анализатор тегов в дальнейшем их не замечал).
----------------------------------------------------------------------------------------------------
  [DONE] 20.10.2007 - 17:59:43,10

  Создана программа TODO_list, лежащая в текущем каталоге, которая делает сводку по всем неисправ-
ленным TODO и ERROR (ищет для них соответствующие DONE и FIXED). Тег представляет собой строку следу-
ющего вида '[' e.TagName ':' e.Description ']', записанную в отдельной строчке. Пробелы перед и после
'[', ':' и ']' игнорируются. В файл сводки TODOs.txt выносятся незакрытые TODO и ERROR, "лишние" FIXED
и любые CHANGED. Повторные TODO, ERROR, FIXED и CHANGED игнорируются. При наличии "лишнего" DONE
и неопознанного тега любого другого типа в сводку добавляется пункт [BAD-TAG].


====================================================================================================
  [DONE] Функция MOS::ArgList
====================================================================================================

  [TODO] 20.10.2007 - 16:06:51,06

  Добавить в модуль MOS функцию ArgList, возвращающая аргументы командной строки (начиная с
нулевого) в виде последовательности скобочных термов:
  <MOS::ArgList> == e.Args
  e.Args ::= t.Arg0 t.Arg1 ... t.ArgN
  t.ArgK ::= (e.ArgK)
----------------------------------------------------------------------------------------------------
  [DONE] 20.10.2007 - 17:59:43,10

  В модуль MOS добавлены функции ArgList (см. выше) и ProgName. ProgName возвращает имя выполняемой
программы (нулевой аргумент <Arg 0>). Функция ArgList также возвращает имя программы в качестве пер-
вого терма. При реализации через Рефал-5 <Arg 0> возвращает список .rsl-файлов, выполняемых в данный
момент, разделённых знаком '+' (т.е. первый аргумент программы refgo не считая ключей).


====================================================================================================
  [CHANGED] MFileSystem стал библиотечным
====================================================================================================

  [CHANGED] 19.10.2007 -  1:04:32,32

  Теперь в список общих библиотек добавлен модуль MFileSystem. Тот самый, который не
работает (см. выше).


====================================================================================================
  [CHANGED] Удалена ROut
====================================================================================================

  [CHANGED] 16.10.2007 - 22:06:30,03

  Удалена папка ROut, т.к. текущие версии (рабочая и стабильная) ею уже не пользуются. 


====================================================================================================
  [DONE] Исправить зависимую от MOS::Env MOS::EnvList
====================================================================================================

  [TODO] 16.10.2007 - 21:50:54,61

  Изменить соответствующим образом MOS::EnvList.
----------------------------------------------------------------------------------------------------
  [DONE] 16.10.2007 - 22:06:30,03

  Соответствующим образом MOS::EnvList изменена. Поскольку переменная окружения MR_Home использует-
ся теперь по-другому, предыдущая стабильная версия работать перестала. Новой стабильной версией будет
0.1.356.


====================================================================================================
  [FIXED] MOS::Env корректно работает с кириллицей
====================================================================================================

  [FIXED] 16.10.2007 - 21:50:54,61

  Исправлена реализация функции MOS::Env. Если до этого функция для подгрузки переменной среды
использовала <System 'set > временный файл'>, то теперь она пользуется встроенной функцией Рефала-5.
До этого нужно было извратным образом устанавливать переменную окружения MR_Home (Так, чтобы при
перекодировке Windows->Dos она содержала путь к папке MR_Home в кодировке Windows). Теперь переменная
среды используется естественным образом. Это достигнуто ценой добавления ещё одной встроенной (RTS)
функции MRefalRTS::Env.


====================================================================================================
  [DONE] Переименовать модуль Refal5
====================================================================================================

  [TODO] 30.09.2007 -  0:37:49,72

  Переименовать Refal5 в MRefalRTL или MRefalRTS или ещё что-нибудь в этом роде.
----------------------------------------------------------------------------------------------------
  [DONE] 12.10.2007 - 22:09:54,55

  Переименован Refal5 в MRefalRTS. Теперь некоторые старые программы (предыдущие версии ком-
пилятора и некоторые другие) не удастся откомпилировать.


====================================================================================================
  [CHANGED] Папка ROut2
====================================================================================================

  [CHANGED] 12.10.2007 - 22:09:54,55

  По аналогии с расширением .rout2, папка для выходных файлов переименована в ROut2. Но
предыдущая папка ROut сохранена для совместимости с предыдущими стабильными версиями.


====================================================================================================
  [DONE] Указатели на функции или функция Mu
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  ... указатели на функции и/или функцию Mu. Поскольку я принципиально не хочу добавлять в
язык встроенные функции (все функции определяются внутри модулей, элементарные операции осуществля-
ются вызовом функций из библиотечных модулей), функция Mu будет носить статус автоматически генери-
руемой. Функция Mu локальна для рассматриваемого модуля и может быть реализованна следующим образом.
  Допустим в модуле определены функции F, G, H и из модулей Mod1 и Mod2 импортировались бы функции
Mod1::A, Mod1::B, Mod::C, Mod2::A, Mod2::C, Mod2::D. Тогда автоматически генерируемая функция Mu
работала бы так, как если бы в модуль был бы добавлен следующий код:

  Mu {
    F e.Arg = <F e.Arg>;
    G e.Arg = <G e.Arg>;
    H e.Arg = <H e.Arg>;
    Mod1 A e.Arg = <Mod1::A e.Arg>;
    Mod1 B e.Arg = <Mod1::B e.Arg>;
    Mod1 C e.Arg = <Mod1::C e.Arg>;
    Mod2 A e.Arg = <Mod2::A e.Arg>;
    Mod2 C e.Arg = <Mod2::C e.Arg>;
    Mod2 D e.Arg = <Mod2::D e.Arg>;
  }

  Это полностью соответствует семантике функции Mu Рефала-5, как она описана в документации.
В Рефале-5 эта функция носит статус встроенной специальной (в отличие от встроенных регулярных)
статической функции, т.е. переадресовывает вызов только функциям, определённым в текущем модуле.
В случае, если пользователь сам определит функцию Mu можно выдавать ошибку повторного определения,
предупреждения или не генерировать автоматически.
  Хотя в перспективе нужно реализовать косвенный вызов функции не по имени (идентификатор), а по
указателю на функцию.
----------------------------------------------------------------------------------------------------
  [DONE] 07.10.2007 -  0:23:54,89

  Реализованы указатели на функции. Надо признать, пока криво. Указатели на функции тождественны
идентификаторам, являющимся именами функций после линковки (Ennn, Lnnn). Новый синтаксис вызова ука-
зателей таков (см. Syntax.txt).
  
  FunctionCall = '<' Callable ResultExpr '>' .
  Callable = FunctionName | Qualifier '::' FunctionName
    | SwapName | S-VARIABLE .

  Т.е. после открывающей скобки вызова функции может следовать или идентификатор, или квалифициро-
ванное имя, или s-переменная.
  Получение указателя осуществляется вызовом автоматически генерируемой функцией FnPtr. В результа-
те компиляции функция FnPtr принимает примерно следующий вид:

  Context::FnPtr::Local {
    Create =
      $Context::Create::Entry$ ;
    UpdateModuleInfo =
      $Context::UpdateModuleInfo::Entry$ ;

    // Часть пропущена

    AppendError =
      $Context::AppendError::Entry$ ;
    FnPtr =
      $Context::FnPtr::Local$ ;
    MModulesList UpdateModuleInfo =
      $MModulesList::UpdateModuleInfo::Entry$ ;
    MModulesList LastModule =
      $MModulesList::LastModule::Entry$ ;
    MModulesList ExtractOption =
      $MModulesList::ExtractOption::Entry$ ;
    MModulesList GetProgName =
      $MModulesList::GetProgName::Entry$ ;
    MModulesList ExtractModulesList =
      $MModulesList::ExtractModulesList::Entry$ ;
  }

  В результате компоновки имена внутри знаков '$' заменяются на имена функций типа Lnnn или Ennn.
  Вызов <s.FnPtr e.Arg> компилируется в вызов встроенной функции Mu Рефала-5:

  Test::IndirectCall::Local {
    s.Function =
      <Mu s.Function 'Argument = ' <InOut::ReadLine::Entry > > ;
  }

  Функцию Mu я решил не реализовывать, т.к. она обладает меньшей гибкостью, чем указатели на функ-
ции. В частности, чтобы косвенно вызвать функцию из другого модуля, необходимо явно импортировать
этот модуль. В случае использования указателей для вызова функции другого модуля необходимо иметь
указатель на эту функцию, который может быть получен из третьего модуля или передан модулем-хозяином:
  $MODULE Indirect;

  /*
    <ForAll s.FnPtr t.Term*>
      == e.Result*
    где e.Result = <s.FnPtr t.Term>
  */
  $ENTRY ForAll {
    s.FnPtr t.Next e.Tail =
      <s.FnPtr t.Next>
      <ForAll s.FnPtr e.Tail>;

    s.FnPtr = ;
  }

  $END Indirect.

  Функция ForAll принимает выражение и указатель на функцию, который она применяет последовательно
к каждому терму. Пример использования: преобразуем последовательность чисел в строку символов, где
числа представлены в виде строк и разделены пробелами.

  $MODULE Convert;

  $IMPORT MStrings, Indirect;

  $ENTRY NumsToStrings
    e.Nums = <Indirect <FnPtr ToStr> e.Nums>;

  ToStr s.Num = <MStrings::Symb s.Num> ' ';

  $END Convert.

Вызов: <Convert::NumsToStrings 10 11 12 13 14>. Подобная гибкость недоступна для функции Mu, т.к. она
может обращаться только к тем функциям, которые видны из точки вызова.
  Однако использование функции FnPtr вызывает трудности в данной версии Модульного Рефала, посколь-
ку она занимает достаточно большой объём. При текущем способе компоновки это резко увеличивает размер
выходного файла. Поэтому надо заняться компоновкой.


====================================================================================================
  [CHANGED] Компиляция структурных скобок по-новому
====================================================================================================

  [CHANGED] 06.10.2007 - 18:35:07,82

  Теперь структурные скобки теперь компилируются как '( Structure ' e.Content ') '. Это
является первым шагом к реализации языковой поддержки АТД.


====================================================================================================
  [DONE] FileIO-дескрипторы в статическом ящике
====================================================================================================

  [TODO] 30.09.2007 -  0:37:49,72

  Изменить FileIO таким образом, чтобы он для хранения свободных дескрипторов использовал стати-
ческий ящик вместо копилки.
----------------------------------------------------------------------------------------------------
  [DONE] 30.09.2007 -  0:57:58,78

  С копилкой распрощались. При необходимости можно копилку реализовать поверх статических ящиков.
В связи с тем, что прошлые стабильные версии не поддерживали статических ящиков, а в реализации
текущей версии компилятора статические ящики используются, эти версии были удалены. При необходи-
мости их можно восстановить из архива. Следующей стабильной версией будет сегодняшняя версия 0.1.286.


====================================================================================================
  [DONE] Статические ящики
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Реализовать статические (просто, в первую очередь) и динамические (сложно при Рефал-5 back
end, во вторую очередь) ящики (swaps), как в Рефале-2. Хотя при программировании с использованием
функциональной парадигмы не рекомендуется использовать глобальные переменные, использование ассоциа-
тивных массивов (Дескриптор, значение) может улучшить инкапсуляцию при использовании идиомы АТД.
  Статические ящики могут быть реализованы с использованием копилки Рефала-5 сопоставив каждому
ящику функцию следующего вида:

  ModuleName::SomeHolder::Swap {
    e.NewValue =
      <Dg ('ModuleName::SomeHolder')>
      <Br ('ModuleName::SomeHolder') '=' e.NewValue>;
  }

  Синтаксически можно использовать конструкцию, похожую на список импорта:

  $SWAP SomeHolder, OtherSomeHolder;

  Обмен ящика осуществляется также как и вызов фунции (как и в Рефале-2).
----------------------------------------------------------------------------------------------------
  [DONE] 30.09.2007 -  0:37:49,72

  Реализованы статические ящики, хотя и криво. Информация о статических ящиках хранится только в
таблице символов. Поэтому приходится отдельно просматривать таблицу символов в процессе генерации
кода. Но по-другому реализация могла бы быть ещё кривее.
  Особенность. При текущем синтаксисе ящики недоступны извне модуля, т.к. они не могут быть entry.
И это хорошо, т.к. скрывает реализацию, тем более, с помощью глобальных переменных. Вообще функции
делятся на три типа (по способу вызова): Entry, Local и Swap. Выносятся в sym-файлы только Entry-
функции.
  Появилась возможность избавиться от единственного использования копилки -- в модуле FileIO как
хранилище свободных дескрипторов. А это значит, что функции Br и Dg также будут удалены из системного
модуля поддержки времени выполнения Refal5. Отсюда два новых TODO.


====================================================================================================
  [DONE] Элемент (Module e.ModuleName)
====================================================================================================

  [TODO] 29.09.2007 - 22:22:40,36

  Удалить элемент (Module e.ModuleName) из промежуточного представления модуля.
----------------------------------------------------------------------------------------------------
  [DONE] 29.09.2007 - 23:18:10,03

  Удалён элемент (Module e.ModuleName). Изменено промежуточное представление.
  
  Было:

  t.Module ::=
    (t.SymTable t.ModuleContent)

  t.ModuleContent ::=
    ( (ModuleName e.ModuleName)
      t.Element*
    )

  Стало:

  t.Module ::= (t.SymTable e.ModuleContent)

  e.ModuleContent ::= t.Element*


====================================================================================================
  [DONE] Резервное копирование
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Сделать возможность такого же резервного копирования, как и было сделано для FindCopies.

  Некоторые планируемые изменения зависят от других, а к некоторым можно приступать прямо сейчас.
Доступны на данный момент (1) функция Mu, (2) статические ящики и (3) резервное копирование.
----------------------------------------------------------------------------------------------------
  [DONE] 29.09.2007 - 21:53:16,11

  Реализовано резервное копирование.


