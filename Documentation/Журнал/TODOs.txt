====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  Недавно я написал прототип дизассемблера для .rsl-файлов Рефала 5, соответственно, изучил внут-
ренний формат и набор команд этих файлов интерпретируемого кода. В принципе, при разработке собст-
венного RASL'а можно не изобретать велосипед, а расширить имеющийся формат.
  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Целесообразность такой функции сомнительна, но как интересную идею оставлю.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Есть задумка использовать не генератор синтаксического анализа, а интерпретируемый DSL. Задумка
уже есть (Documentation/Перспективы и тупики/Синтаксический анализатор.txt).
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Мне хочется, чтобы версия 0.2 была совместима с синтаксисом языка версии 0.1, т.е. чтобы можно
было откомпилировать исходники выпуска 0.1 выпущенной версией 0.2. Поэтому комментарии со звёздоч-
кой я убирать пока не буду, а только назову их deprecated.
  Комментарии со звёздочкой удалю при первой же переработке синтаксиса языка. А имена со строчной
буквы не нужны, т.к. никаких принципиально новых возможностей дать пока не могут.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  Вообще, мне бы хотелось, чтобы компилятор версии N мог бы компилировать исходный код версии N-1,
изменение лексики сделало бы это невозможным.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [TODO] ‚в 21.04.2009 - 13:02:07.17

  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Синтаксис менять я не собираюсь, поэтому оставляю этот пункт в копилку идей.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Как уже сказано, выпуск версии не подразумевает переработки синтаксиса отно-
сительно текущего состояния. Поэтому эти конструкции я сейчас внедрять не буду. Но сделаю их при
первой же существенной переделке синтаксиса.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  По хорошему, надо писать не только тесты (некоторый небольшой набор тестов у меня есть), но и
средства автоматического тестирования (например, скриптом) и эти средства периодически обновлять.
  Некоторым подобием автоматического теста у меня является большой скрипт пересборки: он пересоби-
рает весь компилятор каждым исполнимым файлом, созданным некоторым профилем, с каждым профилем, что
в некоторой степени гарантирует его корректность.


====================================================================================================
  [TODO] "Подчистить" Простой Рефал
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  Задача состоит в том, чтобы проработать следующие мелкие недостатки Простого Рефала:
  1. Т.к. Простой Рефал поддерживает идентификаторы, заменить в большинстве мест (если не во всех)
использование функций-перечислений ($EENUM) на метки ($LABEL). Недостаток пустых функций в том, что
они должны быть определены только в одном файле, а в остальных --- только объявлены, что создаёт
лишние зависимости между модулями.
  2. Добавить поддержку escape-последовательностей вида \xXX или \ooo, как и в языках семейства Си.
Ранее, Модульный Рефал не поддерживал операций умножения, деления и взятия остатка (глупое ограни-
чение библиотеки), поэтому не поддерживались такого рода escape-последовательности. Возможно добав-
ление и других escape-последовательностей, традиционных для Си.
  3. Удаление интерпретируемого кода. Преимуществ по быстродействию интерпретация не даёт, размер
исполняемого файла в наше время некритичен, а вот структуру кода запутывает.
  Изменение отношу к неприоритетным (для версии 0.2), т.к. не вижу причин делать его приоритетным.
----------------------------------------------------------------------------------------------------
  [TODO] 02.07.2010 - 12:59:05,15

  Т.к. требовалось обеспечить поддержку escape-последовательностей в Модульном Рефале, а Простой
Рефал является одним из целевых языков компиляции, то необходимо было релизовать поддержку escape-
последовательностей и в нём.
  Реализована поддержка тех же escape-последовательностей, что и в Модульном Рефале (см. ниже).
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Для версии 0.2. не приоритетно, т.к. не относится к основным целям версии.
Однако, для выпуска публичной версии эта задача важна.


====================================================================================================
  [TOTHINK] Грамотная реализация библиотеки
====================================================================================================

  [TOTHINK] 10.07.2010 - 15:35:46,55

  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2, т.к. текущая версия библиотеки уже не-
плоха и вполне соответствует возможностям синтаксиса языка.
  С точки зрения грамотной реализации, текущая библиотека соответствует варианту пакета Std, но без
префикса Std и без альтернатив (Platform и BackEnd).
  Для выпуска публичной версии также не требуется, т.к. публичную версию вполне можно выпустить и с
текущей реализацией библиотеки.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия версии сохраняются.
  Идея версии 0.2 в том, чтобы получить стабильную реализацию языка Модульный Рефал, включающую в
себя компилятор, библиотеку и, возможно, документацию.
  Компилятор должен прежде всего стабильно работать, иметь удобный интерфейс (что уже почти достиг-
нуто) и быть логически законченным --- не иметь каких-либо недоделок и незавершённых начинаний.
  Библиотека тоже должна стабильно работать и предоставлять достаточно юзабельный и кроссплатфор-
менный интерфейс.
  Поскольку добавление ряда фич (например, расширение синтаксиса) не повлияет или слабо повлияет
на упомянутые выше цели, но сильно замедлит разработку, не собираюсь внедрять новые фичи в язык
или компилятор.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010). Цели и задачи сохраняются.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Вообще, надо разобраться, как поведёт себя компилятор, если это требование будет нарушено.
  На данный момент в полных квалифицированных именах функций модули всегда являются предпоследними
сегментами в именах, а пакеты --- перед ними. Так что конфликтов быть не должно. Но при появлении
вложенных именованных функций возможны проблемы с этим. Так что надо обдумать это дело.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Приоритетно.
  Требуется контролировать ограничения, наложенные в спецификации: что ни в каком пакете не может
находиться два модуля, два пакета или модуль и пакет с разными регистрами символов. И, разумеется,
при попытке добавить в контекст модуль, квалифицированное имя которого нарушает эти ограничения,
должно выдаваться внятное сообщение об ошибке.
----------------------------------------------------------------------------------------------------
  [TODO] 03.08.2010 - 21:38:05,23

  Контролировать корректность регистра символов в модулях (требование, что в одном пакете не могут
существовать два модуля, имена которых различаются только регистром) на платформе Windows бессмыс-
ленно, т.к. независимо от регистра символов в имени файла, представляющего собой модуль, файл будет
найден и открыт. Корректность имени с точностью до регистра осуществляется путём сравнения внешнего
(как на модуль ссылаются извне: из другого модуля или командной строки) и внутреннего (записано в
самом модуле) имён, при несовпадении уже давно определяется ошибка. Однако, при переносе на другие
платформы, чувствительные к регистру символов, возможно возникновение ошибки.
  Следует определиться (а) со способом хранения сведений о именах и их регистрах, (б) о местах этих
проверок. А далее уже хранить и проверять.
----------------------------------------------------------------------------------------------------
  [TODO] 05.09.2010 - 21:20:32,46

  Приостановлен рефакторинг модуля Driver::MCompiler. В поисках идеальной структуры программы ре-
факторинг можно выполнять бесконечно, поэтому нужно остановиться на том этапе, когда состояние
исходного текста становится достаточно понятным и приемлемым для внесения изменений в код. Поэтому
рефакторинг не завершён, а приостановлен.
  Модуль Driver::MCompiler предоставляет функцию Make, которая рекурсивно обрабатывает модули, вхо-
дящие в гроздь, с корнем в модуле, указанном в аргументе функции Make. Если корень оказывается го-
ловным модулем программы, выполняется компоновка грозди в исполнимый файл.
  Рекурсивная обработка модуля начинается с вызова функции ScanSubModule, получающей на входе имя
модуля и возвращающей в случае успешной обработки усечённое промежуточное представление. Логика об-
работки представлена в комментарии к модулю, который я здесь приведу.

/*
  На блок-схеме показаны основные этапы обработки модулей.

  Make --> ScanSubModule (определение состояния модуля)
                               |
                               V
                 Compile (загрузка IModule) [1]
                               |
                               V
      Compile-Aux (загрузка и анализ импортируемых модулей)
                               |
                               V
           Рекурсивный анализ импортируемых модулей
           (путём вызова ScanSubModule для каждого)
                               |
                               V
               Synthesis (анализ вызовов функций
          из импортируемых модулей и генерация кода) [2]
                               |
                               V
          Compile-Cache (кэширование списка импорта)
                               |
                               V
         UpdateContext (сохранение финального состояния)

  [1] В зависимости от состояния модуля (s.Type) выполняется загрузка
  промежуточного представления представления или по файлу исходного текста,
  или по файлу интерфейса модуля ("символическая информация").

  [2] В зависимости от состояния модуля (s.Type) или выполняется анализ
  импортируемых функций и генерация кода, или ничего не делается.
*/

  Задача состоит в том, чтобы в обработку модуля внедрить проверки корректности дерева модулей, об-
разованного пакетами и модулями проектов в соответствии со спецификацией, а также отсутствие ошибок
в межмодульных связях и физической организации модулей проекта. Для начала определим, что считать
корректностью дерева модулей.
  В последующем тексте речь будет идти о квалифицированных именах, для краткости прилагательное
"квалифицированный" опустим.
  При обработке модуля фигурируют 3 имени модуля:
  1) входное имя — имя модуля, который надо обработать. Это имя берётся из командной строки или ди-
рективы импорта; является аргументом функции ScanSubModule;
  2) "физическое" имя (в дальнейшем без кавычек) — путь к модулю относительно MP-каталога, в кото-
ром находится модуль. На ОС, не различающих регистр символов в именах файлов (семейство 32- или 64-
разрядных Windows) в физическом имени регистр символов не учитывается. На ОС, различающих регистр
символов (семейство POSIX) в физическом имени регистр учитывается;
  3) внутреннее (истинное) имя модуля — имя модуля, указанное в файле исходного текста или в файле
межмодульных связей, если файл исходного текста отсутствует. В спецификации оно считается основным
— по нему определяются истинные имена пакетов, в которых этот модуль (прямо или косвенно) находит-
ся.
  Модули, входящие в совместно обрабатываемые грозди (за один акт вызова компилятора) образуют кор-
ректное дерево модулей, если среди набора квалифицированных имён модулей и пакетов (из каждого ква-
лифицированного имени модуля формируются квалифицированные имена пакетов путём последовательного
усечения последних сегментов имени)
  1) не существует двух имён, различающихся только регистром символов и
  2) никакое имя не может быть одновременно именем какого-либо модуля и какого-либо пакета.

  Под отсутствием ошибок в межмодульных связях и физической организации модулей проекта ЗДЕСЬ будем
подразумевать следующее.
  1. Истинное имя модуля должно соответствовать его физическому имени с учётом ограничений ОС. Не-
совпадение этих имён должно рассматриваться как ошибка в самом модуле — имя, указанное внутри моду-
ля не соответствует его физическому расположению.
  2. Входное имя должно соответствовать истинному модулю с учётом регистра. Несовпадение означает
ошибку в источнике входного имени — в командной строке или в директиве импорта, т.к. внутреннее имя
(при выполнении условия 1) принимается за эталон.
  3. Входное имя должно соответствовать физическому имени с учётом ограничений ОС. Выполнение этого
условия на данный момент осуществляется механизмом поиска модулей — проверка наличия файлов модуля
в данном MP-каталоге осуществляется функцией MFileSystem::ExistFile, реализующей эти ограничения,
т.к. реализуется поверх API используемой платформы.
  Необходимо сформулировать, каким образом проверять указанные выше 5 условий и что делать при их
нарушении, а также определиться с местами проверок в блок-схеме модуля Driver::MCompiler.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия номера версии сохраняются.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010). Цели и задачи сохраняются.


====================================================================================================
  [TOTHINK] Выпуск публичной версии (ВПВ)
====================================================================================================

  [TOTHINK] 24.07.2010 - 22:57:01,29

  Под публичной версией я подразумеваю версию, которую можно представить другим пользователям, нап-
ример, выложить у себя на сайте/блоге, в рефал-рассылке или рефал-семинаре (на который я, возможно,
поеду).
  Нужно продумать, что требуется для выпуска публичной версии Модульного Рефала, в частности способ
установки (setup.exe, make install и др.), выполнение под POSIX, документация, мелочи в виде дефол-
тового конфигурационного файла (загружаемого, скажем, из %USERPROFILE% и содержащего MP-пути) и др.
  А также нужно продумать, должна ли публичная версия совпадать с ожидаемой версией 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Приоритетна, т.к. требуется прежде всего решить, должна ли публичная версия
совпадать одной из первых сборок версии 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 03.08.2010 - 21:38:05,23

  Выпуск публичной версии не будет совпадать с выпуском версии 0.2, т.к. задачи выпуска версии 0.2
не совпадают с задачами выпуска публичной версии. Версия 0.2 задумывалась как версия, в которой бу-
дет полностью и отлаженно работать концепция модулей, а также модульная архитектура компилятора.
  Публичная версия подразумевает дружественность к пользователю, а именно, удобную процедуру уста-
новки, удобную процедуру компиляции (практически достигнуто, недостаток в явном указании списка
MP-каталогов, но ведь у многих компиляторов Си++ нужно указывать пути include и library) и понятную
документацию. Основные возможности компилятора (модульность, надёжность, логичная концепция в осно-
ве, библиотека) подразумеваются как само собой разумещееся.
  Поэтому надо или расширять приоритеты версии 0.2, или выпускать публичную версию позже. Выбираю
второй вариант, т.к. во-первых, приоритеты версии 0.2 входят в приоритеты публичной версии, во-вто-
рых, лучше концентрироваться на более узкой задачей, т.к. лучше раньше завершить работу над модуль-
ностью (осталось фактически одно TODO), чем сделать это позже.
  После выпуска версии 0.2 приоритетом будет выпуск публичной версии. Конкретнее определюсь с прио-
ритетами после завершения версии 0.2.


