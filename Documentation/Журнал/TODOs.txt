====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.


====================================================================================================
  [TODO] Удалить MRefalRTS::Put
====================================================================================================

  [TODO] 02.02.2008 - 17:55:52,95

  См. выше, почему это не особо критично.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Можно и удалить. Ведь, если необходимо, всегда можно добавить. На данный момент функцией MSelfDi\
ag::Log-T я пользуюсь довольно редко. Чаще я с целью трассировки функции Func пишу следующий код:

// До трассировки

Func {
  // Тело функции Func. Формат функции такой: <Func t.X e.Y (e.Z)> == ...
}

// После трассировки

Func
  t.X e.Y (e.Z) =
    <MSelfDiag::Log>
    <MSelfDiag::Log '<Func>'>
    <MSelfDiag::Log '  t.X = ' t.X>
    <MSelfDiag::Log '  e.Y = ' e.Y>
    <MSelfDiag::Log '  e.Z = ' e.Z>
    <?Func t.X e.Y (e.Z)>;

?Func {
  // Тело функции Func.
}

  Очевидно, что вместо этого лучше включить в язык/компилятор нормальное средство трассировки, но
я сейчас не буду описывать это как TODO. Т.к. (а) до выхода версии 0.2 я не собираюсь изменять син-
таксист, (б) запись прямо здесь этого как TODO сделает его приоритетным. Пункт (б) не критичен, т.к.
описать TODO можно и после закрывающей скобки.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] При компоновке заменять самые примитивные функции на функции Рефала-5
====================================================================================================

  [TODO] 23.04.2008 - 22:49:01,30

  Т.е. идея в том, что нужно будет заменять вызовы функций типа MRefalRTS::Card сразу на <Card...>.
Причём это можно реализовать так, что в линковщик явно не будут встраиваться эти функции. Примитивные
функции будут описаны как псевдоними в файле MRefalRTS особыми директивами линковщика. Можно, напри-
мер, ввести тег 'p ' с таким синтаксисом
  p Entry::MRefalRTS::Prout Prout
или
  b Entry::MRefalRTS::Prout
  p Prout.
  В этом случае в таблицу MLinkerAliasTable вместо сгенерированного псевдонима вида X123 будет до-
бавлен псевдоним Prout.
  Способ этот ортогонален компилятору, т.к. позволяет легко изменять набор встроенных функций не
меняя ни строчки кода самого компилятора. Файл MRefalRTS всё равно пишется вручную.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Сейчас, когда были достигнуты определённые успехи в генерации кода на Си++, выглядит уже малоперс-
пективным развитие back-end'а Рефала 5. Поэтому дальнейшие усилия на этом пути не кажутся необходи-
мыми и приоритетными. Поэтому данное TODO я к приоритетным не отношу.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках в журнале проекта
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.02.2009 - 21:42:25,09

  К версии 0.2 непосредстенно не относится.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.


====================================================================================================
  [TODO] Вынести из компилятора метаданные
====================================================================================================

  [TODO] 21.02.2008 - 15:51:11,21

  Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
  Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Данная задача будет частично (а может даже и полностью) выполнена при выполнении TODO АТД "Конфи-
гурация". Данное АТД будет создаваться после анализа командной строки, но до того, как будет прово-
диться анализ модулей; АТД как раз и будет содержать то, что здесь названо как "метаданные".


====================================================================================================
  [TODO] Ввести особый тип компоновки для особых функций
====================================================================================================

  [TODO] 13.04.2008 - 21:06:47,07

  Было бы красиво, на мой взгляд, для функций Init и Final обычных модулей и функции Go головного
модуля иметь специальный тип компоновки.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).


====================================================================================================
  [TODO] ПИ:Проверять корректность имени модуля/пакета
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.


====================================================================================================
  [TODO] ПИ:Поддержка переменной MODULEPATH с проверкой корректности
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Надо осуществлять проверку того, что никакой каталог в переменной MODULEPATH не является подка-
талогом другого MP-каталога. А также проверять существование данного каталога.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.


====================================================================================================
  [TOTHINK] Продумать ограничения на MODULEPATH
====================================================================================================

  [TOTHINK] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.


====================================================================================================
  [TODO] Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Необходимо добавить следующие функции:
  (*) Функция, которая склеивает имя папки с относительным именем.
  (*) Функция, которая унифицирует имя папки -- т.к. в Windows одни и те же пути к файлам могут
выглядеть по-разному (прямой и обратный слеш, регистр символов).
  (*) Функция, возвращающая абсолютное имя для относительного. Такая функция может проверять также
наличие данного файла/папки. А может и не проверять.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Помимо этого необходима функция, способная распарсить имя папки на сегменты вида t.RootMode
(e.NameSegment), где t.RootMode ::= (Relative) | (Relative-Disk s.Disk) | (Absolut) | (Absolut-Disk
s.Disk) | (Absolut-Net e.Server), соответственно для 'Dir/File', 'C:Dir/File', '/Dir/File', 'C:/Dir'
'/File', '//SERVER/Dir/File'. Очевидно, поведение этой функциии будет зависеть от используемой опе-
рационной системы, т.к. в POSIX-системах имя папки может содержать любые символы, кроме 0x00 и пря-
мого слеша.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.


====================================================================================================
  [TODO] Продумать back-end C++
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Если я буду представлять версию 0.2 широкой общественности (списку рассылки Рефала), то реализо-
вать генерацию сишного кода необходимо. Удобнее, конечно, вариант с генерацией самим компилятором
Модульного Рефала Си++-файлов, но вариант с генерацией файлов Простого Рефала проще в реализации
(хотя для этого придётся расширять Простой Рефал аналогом квалифицированных имён, АТД, статическими
ящиками). Как обычно, ничто не мешает совмещать оба подхода в разных back-end'ах.
  Поэтому надо продумать необходимость этого средства в версии 0.2.


====================================================================================================
  [TODO] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.


====================================================================================================
  [TODO] Изменить обработку командной строки
====================================================================================================

  [TODO] 18.04.2008 - 22:57:27,21

  Сейчас (в текущей версии 0.1.904) модули/файлы в командной строке мыслятся как модули/файлы, вхо-
дящие в проект. "Лишние" файлы, которые компилируются и прилинковываются, могут иметь свои функции
инициализации, что позволяет осуществить гамак. Сие не есть хорошо. Надо изменить смысл командной
строки следующим образом.
  (1) Если некоторый аргумент командной строки является головным модулем, то он рекурсивно компи-
лируется и линкуется в .exe-шник. Если аргумент явяляется обычным модулем, то он рекурсивно компили-
руется, но не линкуется.
  (2) В командной строке можно указать несколько имён файлов/модулей. Каждый из них обрабатывается
согласно пункту (1). Таким образом, можно одновременно компилировать и собирать несколько проектов
одновременно. Если эти проекты имеют общие модули, то общее время компиляции должно снизиться.
  (3) Если расширение файла не указано, то поиск модуля выполняется по всем доступным front-end'ам.
Если расширение указано, то компиляция осуществляется указанным front-end'ом.
  (4) В командной строке могут быть опции, позволяющие выбрать необходимые back-end'ы.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Практически все вышеперечисленные пункты поддерживаются, кроме последнего (пока нет необходимости
выбирать back-end -- выбор сильно ограничен :-)), но поддерживаются они криво. В случае неверной ко-
мандной строки компилятор просто рушится с выдачей дампа. За образец можно взять обработку командной
строки из утилиты TODO_list, которую я недавно переписал с нуля.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Безусловно необходимо для выпуска версии 0.2.


====================================================================================================
  [TODO] АТД "Конфигурация"
====================================================================================================

  [TODO] 05.01.2009 - 21:31:08,54

  Предполагается ввести абстрактный тип данных (по аналогии с контекстом), хранящий текущую конфигу-
рацию программы, т.е. сведения о front- и back-end'ах (расширения, подпапки, callback-функции), све-
дения об окружении (MP-каталоги, режим работы: полная перекомпиляция, частичная перекомпиляция, то-
лько сборка). Данный АТД дескриптором считать не будем, чтобы после инициализации его можно было ко-
пировать и удалять нужное число раз -- т.к. после создания необходимости в его пополнении/модифика-
ции быть не должно. Конфигурация должна инициализироваться в парсере командной строки (который тоже
должен быть написан) и в дальнейшем оставаться неизменной.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо для выпуска версии 0.2, т.к. это является частью поддержки модулей и "мультикомпиля-
ции" (несколько front- и back-end'ов).


====================================================================================================
  [ERROR] Функция MOS::Exit и финализаторы
====================================================================================================

  [ERROR] 05.01.2009 - 21:31:08,54

  На данный момент функция MOS::Exit перенаправляет вызов к одноимённой функции модуля MRefalRTS,
которая в свою очередь, перенаправляет вызов к функции Exit Рефала 5. Поэтому, если в программе име-
ются модули с нетривиальной инициализацией (которая устанавливает некоторый инвариант) и нетривиаль-
ной финализацией (которая разрушает этот инвариант), финализаторы при вызове функции Exit не вызыва-
ются.
  Необходимо продумать пути исправления и исправить данную ошибку.
  Возможен такой вариант. Линковщик собирает все вызовы функций финализации в некоторую с заранее
известным именем. Далее, эту же функцию вызывает функция MRefalRTS::Exit. Недостаток этого варианта
в том, что при вызове функции Exit из финализатора поведение программы будет неопределено (хотя фак-
тически она зависнет). К тому же, при вызове функции Exit из инициализатора будут вызваны финализа-
торы ещё не инициализированных модулей.
  Другой вариант состоит в том, что список функций-финализаторов заносится в копилку Рефала 5 под
некоторым именем, каждый из финализаторов заносится в момент выполнения функции инициализации соот-
ветствующего модуля (стековая архитектура копилки для этого подходит чрезвычайно хорошо). Затем,
после выполнения функции Go происходит вызов <MRefalRTS::Exit s.RetCode> с s.RetCode == 0, который,
если стек финализаторов в копилке не пуст, вызывает финализатор с верхушки и за тем себя же
(<MRefalRTS::Exit s.RetCode>), если же стек пуст -- вызывается <Exit s.RetCode>. Данный метод хорош
тем, что позволяет безопасно вызвать Exit в инициализаторах и финализаторах. Недостаток в том, что
обработка инициализаторов усложняется (нужно определённым образом вставлять в них код сохранения фи-
нализатора).
----------------------------------------------------------------------------------------------------
  [ERROR] 01.02.2009 - 21:42:25,09

  Для выпуска версии 0.2 ошибку надо исправлять безусловно.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.


