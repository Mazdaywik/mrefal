====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Целесообразность такой функции сомнительна, но как интересную идею оставлю.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Есть задумка использовать не генератор синтаксического анализа, а интерпретируемый DSL. Задумка
уже есть (Documentation/Перспективы и тупики/Синтаксический анализатор.txt).


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Мне хочется, чтобы версия 0.2 была совместима с синтаксисом языка версии 0.1, т.е. чтобы можно
было откомпилировать исходники выпуска 0.1 выпущенной версией 0.2. Поэтому комментарии со звёздоч-
кой я убирать пока не буду, а только назову их deprecated.
  Комментарии со звёздочкой удалю при первой же переработке синтаксиса языка. А имена со строчной
буквы не нужны, т.к. никаких принципиально новых возможностей дать пока не могут.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках в журнале проекта
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.02.2009 - 21:42:25,09

  К версии 0.2 непосредстенно не относится.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Ошибок у меня обнаруживается, как правило, мало, они своевременно устраняются. Поэтому некритично.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [TODO] ‚в 21.04.2009 - 13:02:07.17

  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Синтаксис менять я не собираюсь, поэтому оставляю этот пункт в копилку идей.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия версии сохраняются.
  Идея версии 0.2 в том, чтобы получить стабильную реализацию языка Модульный Рефал, включающую в
себя компилятор, библиотеку и, возможно, документацию.
  Компилятор должен прежде всего стабильно работать, иметь удобный интерфейс (что уже почти достиг-
нуто) и быть логически законченным --- не иметь каких-либо недоделок и незавершённых начинаний.
  Библиотека тоже должна стабильно работать и предоставлять достаточно юзабельный и кроссплатфор-
менный интерфейс.
  Поскольку добавление ряда фич (например, расширение синтаксиса) не повлияет или слабо повлияет
на упомянутые выше цели, но сильно замедлит разработку, не собираюсь внедрять новые фичи в язык
или компилятор.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 26.04.2009 - 12:56:39,09

  Сегодняшняя реализация на Модульном Рефале потенциально способна работать с именами модулей, па-
кетов или квалифицированными именами любой длины. Однако создать модуль с килобайтным именем. Слиш-
ком длинные квалифицированные имена невозможны из-за ограничений файловой системы: максимальная дли-
на пути в Windows равна 260 байтам. Поэтому при попытке создать модуль с очень длинным именем, мы
всего лишь столкнёмся с ошибкой невозможности открытия файла: программа рухнет.
  В дальнейшей перспективе при переходе на Unicode можно будет использовать UNC-имена, т.к. для та-
ких имён практически не существует ограничения на длину (максимальная длина имени -- 64К unicode-
символа, что на практике дофига).
  Поэтому необходимо продумать проверку корректности имени файлов front- и back-end'ов (с точки
зрения длины) на уровне поиска модулей, а для подобной проверки создать платформенно-зависимую
функцию проверки корректности имени (т.к. на POSIX-системах другие ограничения). В таком случае
модули с длинными именами ко входным и выходным файлам будут просто игнорироваться при поиске
(не будут найдены, даже если они есть) и обрушений программ при открытии подобных файлов можно будет
избежать.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Эти ограничения в большей степени относятся к возможностям back-end'ов, целевого языка и исполь-
зуемой платформы. А вот нужны ли синтаксические ограничения, этот вопрос надо обдумать.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Вообще, надо разобраться, как поведёт себя компилятор, если это требование будет нарушено.
  На данный момент в полных квалифицированных именах функций модули всегда являются предпоследними
сегментами в именах, а пакеты --- перед ними. Так что конфликтов быть не должно. Но при появлении
вложенных именованных функций возможны проблемы с этим. Так что надо обдумать это дело.


====================================================================================================
  [TOTHINK] Имя и путь целевого файла
====================================================================================================

  [TOTHINK] 19.05.2009 - 22:23:09,31

  Под целевым файлом будем понимать или исполнимый файл, или файл, обобщающий какую либо информацию
по всей программе (перекрёстные связи, отладочная информация, та или иная статистика о программе).
На данный момент в компоновщик передаётся только конечный сегмент имени головного модуля (так на-
пример, если головной файл имеет имя Packet::Module, то сгенерированный исполнимый файл будет распо-
лагаться в текущей папке с именем Module. Для целевого файла таблицы перекрёстных связей XLinx про-
водится в компоновщике дополнительная обработка имени файла и тот оказывается в каталоге .Info в те-
кущей папке.
  Back-end Рефала 5 помимо "исполнимого" файла -- исходного текста на Рефале 5, компилируемого в
единый .rsl-файл, создаётся файл отладочной информации в каталоге .Info с именем Aliases.als и файл
со списком нескомпонованных функций в том же каталоге с именем Not linked.txt. Если одновременно
компилируется несколько проектов, то последний компилируемый проект перезапишет эти файлы.
  Следует продумать несколько вариантов.
  (1) В качестве каталога с целевым файлом всегда использовать текущую папку.
  (2) В качетсве каталога с целевым использовать MP-каталог головного модуля.
  (3-4) В качетсве каталога с целевым файлом использовать имя пакета + текущий каталог или MP-ката-
лог головного модуля.
  Кроме того, каталог с целевыми файлами можно задавать как параметр командной строки, а также зада-
вать само имя целевого файла. Поскольку одновременно может компилироваться несколько проектов, то
имя целевого файла должно распространяться на ближайшее (а) имя файла-корня грозди или (б) имя го-
ловного файла. Имя файла, указанного в командной строке, не обязательно должно быть именем грозди.
  Компоновщик должен без лишних усилий, получив на входе путь к файлу (папка+собственно имя), пос-
троить из него путь с подпапкой (как в случае с каталогом .Info для XLinx), выбрать расширение.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Этот пункт имеет важное значение с точки зрения юзабельности компилятора, поэтому он требуется для
выпуска версии 0.2.


====================================================================================================
  [TODO] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 17:52:48,14

  Относительно предыдущего TODO-звена сделано следующее.
  (1) Математическая библиотека только расширилась вышеупомянутыми функциями.
  (2) Что касается упрощения переносимости, то с этой точки зрения библиотека сильно изменилась. Во
многих случаях добавились дополнительные слои абстракции, выраженные пакетами CoreBE и CoreOS, хотя
внимание было больше сосредоточено на переносимости между back-end'ами в рамках платформы Windows.
  Для достижения более чёткой переносимости между различными операционными системами следует тща-
тельнее проанализировать модули MOS и MFileSystem, вынося из них код на Рефале, характерный для ОС
Windows.
  (3) Поскольку последние изменения библиотеки касались в большей степени внутренней структуры, чем
интерфейса, переносить модули библиотеки в пакет я не счёл нужным. Перенос модулей библиотеки в па-
кет логически относится к изменению интерфейса библиотеки, поэтому его следует отложить до того вре-
мени, когда нужно будет существенно переработать интерфейс. Последнее целесообразнее делать после
введения в язык вложенных функций --- в этом случае замыкания будут гораздо активнее применяться в
языке и, соответственно, интерфейс библиотеки надо будет адаптировать под изменение стилей програм-
мирования.
  Итог. Для завершения данного TODO следует грамотно переработать библиотеку с точки зрения перено-
симости между различными ОС.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, т.к. в круг задач входит получение стабиль-
ной и логически согласованной библиотеки.


====================================================================================================
  [TODO] СМКиРФ: Подготовка библиотеки к переносимости между различными ОС
====================================================================================================

  [TODO] 01.05.2010 - 17:52:48,14

  Суть в том, чтобы подготовить библиотеку к переносу на другие платформы, прежде всего, под плат-
форму POSIX. Выбор последней обусловлен тем, что это достаточно распространённая платформа (вклю-
чает в себя GNU/Linux, *BSD, QNX и даже MacOS X) и у меня есть опыт работы с двумя представителями:
QNX и GNU/Linux. DOS я не рассматриваю вследствие большого объёма исполнимого файла (несколько ме-
габайт) и больших потребностей в оперативной памяти, что затрудняет работу с ним. Мобильные платфор-
мы я не рассматриваю по двум причинам: у меня на данный момент нет смартфона и Рефал на них не так
уж и нужен.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется для выпуска версии 0.2, как подзадача требуемой задачи.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия номера версии сохраняются.


====================================================================================================
  [TODO] "Подчистить" Простой Рефал
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  Задача состоит в том, чтобы проработать следующие мелкие недостатки Простого Рефала:
  1. Т.к. Простой Рефал поддерживает идентификаторы, заменить в большинстве мест (если не во всех)
использование функций-перечислений ($EENUM) на метки ($LABEL). Недостаток пустых функций в том, что
они должны быть определены только в одном файле, а в остальных --- только объявлены, что создаёт
лишние зависимости между модулями.
  2. Добавить поддержку escape-последовательностей вида \xXX или \ooo, как и в языках семейства Си.
Ранее, Модульный Рефал не поддерживал операций умножения, деления и взятия остатка (глупое ограни-
чение библиотеки), поэтому не поддерживались такого рода escape-последовательности. Возможно добав-
ление и других escape-последовательностей, традиционных для Си.
  3. Удаление интерпретируемого кода. Преимуществ по быстродействию интерпретация не даёт, размер
исполняемого файла в наше время некритичен, а вот структуру кода запутывает.
  Изменение отношу к неприоритетным (для версии 0.2), т.к. не вижу причин делать его приоритетным.
----------------------------------------------------------------------------------------------------
  [TODO] 02.07.2010 - 12:59:05,15

  Т.к. требовалось обеспечить поддержку escape-последовательностей в Модульном Рефале, а Простой
Рефал является одним из целевых языков компиляции, то необходимо было релизовать поддержку escape-
последовательностей и в нём.
  Реализована поддержка тех же escape-последовательностей, что и в Модульном Рефале (см. ниже).


====================================================================================================
  [TODO] Интегрировать Простой Рефал в общую структуру каталогов
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  На данный момент файлы, относящиеся к Простому Рефалу, находятся в каталоге /Simple Refal относи-
тельно корня проекта. Папка Simple Refal имеет ту же каталоговую структуру, что и подпапки лаб по
Простому Рефалу (т.к. представляет собой фактически копию лабы версии 004) и включает в себя давно
устаревший bootstrap-каталог (т.к. необходимости в его обновлении нет, скрипт автоматического обно-
вления не предусмотрен); исходные тексты компилятора, библиотеки и сопутствующих утилит: генератора
лексического анализатора и препроцессора Простого Рефала в Модульный; а также папка с набором уста-
ревших тестов и заготовок для написания внешних функций.
  В общем, схема неплохая. Но есть и недостатки, а именно
  1. Исходные тексты Простого Рефала находятся как-то поодаль относительно прочих исходных текстов,
входящих в проект, что идеологически усложняет общее дерево каталогов проекта.
  2. В каталогах bootstrap и "Тесты и заготовки" много уже давно нерелевантных файлов, так что, воз-
можно, их следует удалить.
  3. Обособленность исходных текстов затрудняет написание общего скрипта перекомпиляции и пересбор-
ки.
  4. Файлы библиотеки времени выполнения refalrts.h и refalrts.cpp присутствуют в двух разных ката-
логах, что усложняет их синхронизацию (на данный момент они не синхронизированы).
  Задачу считаю приоритетной (для версии 0.2), т.к. устраняет логическую ошибку, связанную с рассин-
хронизацией исходных текстов библиотеки времени выполнения.
----------------------------------------------------------------------------------------------------
  [TODO] 02.07.2010 - 12:59:05,15

  Есть мысль сконвертировать утилиты типа генератора лексического анализатора и srmake в Модульный
Рефал и поместить в общий каталог утилит. Хотя, сомнительно.


====================================================================================================
  [ERROR] В некоторых случаях падает профиль Простого Рефала
====================================================================================================

  [ERROR] 02.07.2010 - 12:59:05,15

  Ошибка возникает в back-end'е Простого Рефала, если .cpp-файл (в широком смысле), являющийся ре-
зультатом компиляции исходного текста на Простом Рефале, отсутствует (как правило, из-за ошибок
компиляции).
  Ошибка проявляется, если такой .cpp-файл предполагается копировать для избежания конфликта имён,
в результате возникает ошибка открытия файла.


====================================================================================================
  [ERROR] Компилятор на Рефале 5 падает на функции System
====================================================================================================

  [ERROR] 02.07.2010 - 12:59:05,15

  При достаточно длинных аргументах встроенной функции System Рефала 5, интерпретатор падает с ошиб-
кой нехватки памяти. Сначала я предполагал, что ошибка связана обычным переполнением изначально за-
данного фиксированного объёма памяти, но увеличив объём до 300 единиц кода и 200 поля зрения (т.е.
-c300 -l200 в командной строке), я от ошибки не избавился. Так что предположительно, длина команд=
ной строки, принимаемой функцией System, меньше приблизительно 3000 байт (примерно такую длину име-
ет командная строка при самомприменении компилятора с профилями Простого Рефала и C++/SR).
  При превышении этого лимита, функция, вместо стандартного нарушения формата встроенной функции,
возвращает недостаток памяти.
  Возможным путём решения является генерация bat-файла, который и содержит эту длинющую строку.


