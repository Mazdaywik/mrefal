====================================================================================================
  [TOTHINK] Упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [RENAME] 07.09.2010 - 23:30:08,46

  Old name is "[TODO] Продумать упрощение структуры Lexer'а и Parser'а"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 07.09.2010 - 23:30:08,46

  Удалено слово "продумать" ("обдумать") из заголовка, сменён тег с TODO на TOTHINK. (Переименова-
ние было проведено при первой возможности — сразу после того, как был введён тег RENAME.)
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Скорее всего, интерфейс лексического анализатора пока видоизменяться не будет. Но подход
к семантической проверке и интерфейсу IModule может быть изменён: новый синтаксис со вложенными
функциями плохо ложится на текущую модель с одномерным списком функций в IModule.


====================================================================================================
  [TOTHINK] Двухуровневая структура синтаксического анализатора
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [RENAME] 07.09.2010 - 23:30:08,46

  Old name is "[TODO] Продумать двухуровневую структуру синтаксического анализа"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 07.09.2010 - 23:30:08,46

  Удалено слово "продумать" ("обдумать") из заголовка, сменён тег с TODO на TOTHINK. (Переименова-
ние было проведено при первой возможности — сразу после того, как был введён тег RENAME.)
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  При дальнейшем развитии синтаксиса неизбежно возникнет вопрос адаптации имеющихся структур
данных к новым синтаксическим конструкциям. Тогда же этот вопрос и будет решён.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  По хорошему, надо писать не только тесты (некоторый небольшой набор тестов у меня есть), но и
средства автоматического тестирования (например, скриптом) и эти средства периодически обновлять.
  Некоторым подобием автоматического теста у меня является большой скрипт пересборки: он пересоби-
рает весь компилятор каждым исполнимым файлом, созданным некоторым профилем, с каждым профилем, что
в некоторой степени гарантирует его корректность.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В первую очередь нужно реализовать средства автоматического тестирования, а уже потом,
с их использованием, покрывать тестами и библиотеку, и компилятор. Сейчас у меня это в планах
не стоит, поэтому задача остаётся в статусе TOTHINK.


====================================================================================================
  [TOTHINK] Грамотная реализация библиотеки
====================================================================================================

  [TOTHINK] 10.07.2010 - 15:35:46,55

  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2, т.к. текущая версия библиотеки уже не-
плоха и вполне соответствует возможностям синтаксиса языка.
  С точки зрения грамотной реализации, текущая библиотека соответствует варианту пакета Std, но без
префикса Std и без альтернатив (Platform и BackEnd).
  Для выпуска публичной версии также не требуется, т.к. публичную версию вполне можно выпустить и с
текущей реализацией библиотеки.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея интересная, к ней следует стремиться. Но пока не актуально. Библиотеку лучше развивать
исходя из потребностей, и, время от времени, при мажорных релизах (до выпуска версии 1.0) делать
её рефакториг. Сейчас потребности перерабатывать библиотеку нет, но как часть генерального плана
развития данную задачу следует оставить.


====================================================================================================
  [TODO] НД: Написание текста документации
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Требуется написать документацию к компиляторам и языкам Модульного и Простого Рефалов в текущей
реализации. Документация должна включать в себя следующие пункты:
  1 Описание текущей версии языка Модульный Рефал без рассмотрения особенностей конкретной реали-
зации. Включает в себя синтаксис и семантику Рефала, концепцию модульности.
  2 Описание текущей версии компилятора Модульного Рефала: представление модулей в виде исходных
и промежуточных файлов, компиляция, компоновка, расположение файлов модулей.
  3 Описание текущей версии языка Простого Рефала, при этом следует акцентировать внимание на том,
что ряд возможностей (идентификаторы, статические ящики) добавлены для совместимости с Модульным
Рефалом. Поскольку семантика управляющих конструкций Модульного и Простого Рефалов во многом сход-
ны, то их можно рассмотреть бегло.
  4 Описание текущей реализации Простого Рефала в Си++, рассмотрение интерфейса с языком Си++.
  5 Рассмотрение back-end'ов реализации Модульного Рефала, написание библиотечных модулей для
back-end'ов C++/SR и SR.
  6 (Приложение) Установка реализации Модульного Рефала на компьютер.
  7 (Приложение) Установка реализации Простого Рефала на компьютер.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: НД: Написание текста документации"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Проект Простого Рефала теперь развивается независимо от Модульного Рефала, соответственно,
документация к нему пишется независимо. А документацию к Модульному Рефалу писать надо. Следствие:
пункты 3 и 4 исключаются, остальное пока неизменно.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.


====================================================================================================
  [TOTHINK] Средство автоматической установки
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует продумать способ установки компиляторов на диск компьютера. Возможные варианты для
платформы Windows:
  1. Использование make-файлов.
  2. Использование специализированных средств установки типа пакетов MSI.
  3. Написание кустарного инсталлятора на базе sfx-архивов WinRAR и пакетных файлов.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TOTHINK] ВПВ: Средство автоматической установки"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Задача актуальна, но не приоритетна. В рамках проекта Простого Рефала сейчас планируется создание
отдельного репозитория, в котором будут храниться полускомпилированные исходники компилятора(файлы
на C++). Сам репозиторий в некотором смысле может играть роль инсталлятора: клонирование и сборка
исполнимых файлов должны будут создавать готовый к использованию дистрибутив. Опыт работы с таким
репозиторием будет учтён в текущей задаче.
  Задача переименована, поскольку создание инсталлятора теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.


====================================================================================================
  [TODO] Написание документации (НД)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Выпуск публичной версии компилятора требует написания документации: описания языка и описания
конктретной реализации. Поскольку предполагается распространение Модульного и Простого Рефалов
в одном дистрибутиве, документация должна включать в себя сведения об обоих диалектах.
  Отсюда две подзадачи:
  1 Написание "контента";
  2 Выбор способа представления контента.
----------------------------------------------------------------------------------------------------
  [TODO] 16.09.2012 - 11:13:49,96

  Сначала я предполагал размещать документацию на сайте blogspot, даже уже частично написал, однако,
к некоторому моменту я потерял интерес к этому процессу. В качестве представления этот способ
оказался не слишком удобен: данные хранятся на удалённом сервере, поэтому для редактирования надо
быть в онлайне, к тому же, необходимо логиниться на сайте.
  Недавно мне пришла в голову неплохая идея: можно писать документацию в формате docx/odt — с одной
стороны, это автоматически даёт возможность получить красиво отформатированный pdf, с другой —
формат представляет собой набор зазипованных xml’ек, который, при необходимости, относительно легко
распарсить, просто выбирая только теги с понятным содержимым, а остальные игнорируя.
  Преимущество формата docx — возможности форматирования Microsoft Word, которым я умею эффективно
пользоваться.
  Преимущество формата odt — кроссплатформенность и простота для парсинга (XML более ясный, чем
у Microsoft Word).
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: Написание документации (НД)"
  """""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея с использованием файлов docx или odt и конвертером, например, в текстовый формат, имеет
тот недостаток, что разница между коммитами либо не отображается, либо отображается в довольно
неудобном виде.
  Более подходящий вариант — использование изначально текстового представления. Варианты:
  * Свой конвертер. Начинал писать, дело далеко не продвинулось. Велосипед, вероятно, тупиковый
путь.
  * TeX:
    (+) Красиво отформатированный, пригодный для публикации формат.
    (−) Высокий порог вхождения, т.е. мне потребуется изучать новую среду: LaTeX или Lyx.
    (−) Тяжёлые для чтения исходники.
  * Markdown:
    (+) Лёгкость в использовании, низкий порог вхождения.
    (+) Доступно множество редакторов, конверторов. (Ни одним ещё не пользовался, но список
на Википедии длинный.)
    (+) Исходники легко читать.
    (+) Если просто хранить в подпапке набор файлов в разметке Markdown с гиперссылками друг
на друга, то в web-интерфейсе GitHub оно будет отображаться фактически как wiki-энциклопедия.
    (−) Чтобы сохранять читаемость исходников, нужно будет при редактировании каждый раз выравнивать
длины строк. Это снижает сопровождаемость (хотя в ряде текстовых редакторов (Vim, Emacs) есть
функция выравнивания строк). Соответственно, различия между коммитами будут включать много замен
строк, даже если изменилось только несколько слов. В TeX такая проблема тоже присутствует,
но исходники не предназначены для чтения.
    (−) Для ввода типографских плюшек (длинные тире, кавычки-ёлочки, неразрывные пробелы) нужно
или использовать последовательности HTML (что засоряет текст), либо специальные раскладки
клавиатуры. Кроме того, неразрывные пробелы внешне неотличимы от обычных, что тоже создаёт проблемы.
  Так что задача пока остаётся открытой. Возможен вариант использования wiki, встроенной в GitHub.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.


====================================================================================================
  [TODO] Вложенные функции (ВФ)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Как показала практика работы с Простым Рефалом, вложенные функции существенным образом повышают
выразительность программы и производительность программиста, даже если они и безымянные.
  Кроме того, практика показала, что если синтаксический анализ написан методом рекурсивного спуска
достаточно регулярным образом, то добавить в него вложенные безымянные функции тоже достаточно
несложно.
  Используемый рантайм (общий для Простого Рефала и back-end'а C++/SR Модульного Рефала) поддержи-
вает замыкания (представление вложенных функций во время выполнения программы).
  Версия 0.2 завершена, поэтому ничего не мешает расширению синтаксиса (на который был ранее нало-
жен запрет, дабы сконцентрировать усилия на других задачах).
  Вышеперечисленных аргументов достаточно, чтобы внедрить в язык вложенные безымянные функции
(позже можно будет придумать и именованные). Однако, есть и сложность на этом пути.
  Дело в том, что относительно безболезненно внедрить замыкания только в два профиля из трёх. Ран-
тайм профиля Рефала 5, в отличие от рантайма профилей C++/SR и SR, не поддерживает имманентно замы-
каний и, как следствие, реализация вложенных функций потребует костылей.
  Замыкание представляет собой кортеж, включающий в себя указатель на глобальную функцию и набор
связанных переменных, представляющих собой контекст замыкания. Поэтому задача состоит в том, чтобы
каким-либо образом их хранить в поле зрения. Семантически не должно быть способа разделить замыка-
ние на элементы каким-либо сопоставлением с образцом, следовательно, замыкание должно быть атомом
и сопоставляться с s-переменной.
  Под контеНтом замыкания будем подразумевать кортеж из контеКСта и указателя (имени) глобальной
функции.
  Среди способов реализации замыканий в профиле Рефала 5 можно выделить две группы: надёжные
и ненадёжные.

  I. Простые ненадёжные методы.

  1 При каждом создании замыкания создавать новый уникальный атом (например, функцией Implode),
а контент замыкания помещается в копилку с ключом в виде уникального атома. Непрямой вызов функции
представляется как вызов специальной функции, которая осуществляет проверку наличия уникального
атома в копилке и вызов контента при помощи функции Mu. При отсутствии атома в копилке функцией
Mu вызывается сам атом на входе.
  Недостаток: контенты замыканий не освобождаются, поэтому память будет непрерывно утекать.
  Достоинство: простота.

  2 По аналогии с п. 1, но используется фиксированный пул уникальных атомов. Если же пул опустошён,
то разрушается какое-то замыкание и его атом используется для создания нового замыкания.
  Недостаток: метод невозможно применять на практике, т.к. программа, использующая замыкания,
становится абсолютно ненадёжной — любое замыкание может быть похерено в любой момент.
  Достоинство: относительная простота, отсутствие утечек памяти.
  Метод тут рассматривается только для полноты картины.

  3 По аналогии с п. 1, но с замыканием ассоциируется счётчик вызовов, после которого оно становит-
ся недействительным (соответственно, контент освобождается). Соответственно, при каждом вызове
замыкания счётчик декрементируется.
  Недостаток: необходимо при создании замыкания инициализировать счётчик или специальным синтакси-
сом, или специальной библиотечной функцией, или выбирать значение счётчика по умолчанию. Если при
создании значение счётчика оказалось заниженным, то при "избыточных" вызовах получим ошибку. Если
значение счётчика оказалось заниженным, то память не освободится.
  Достоинство: способ более надёжен, чем п. 2, также способен бороться с утечками памяти.

  4 По аналогии с предыдущим пунктом с замыканием ассоциируется счётчик вызовов, но пользователь
получает возможность управлять этим счётчиком. Например, при создании ассоциируется значение 1,
при копировании замыкания пользователь явно инкрементирует счётчик, при удалении замыкания поль-
зователь должен счётчик явно декрементировать. Фактически, ручной подсчёт ссылок.
  Достоинства: способен обеспечить надёжность программы, а также избежать утечек памяти. Способ
прост. Способ эффективен.
  Недостаток: человеческий фактор. Контроль программиста за копированием напоминает управление
памятью в языках без сборки мусора (например, Си), но здесь последствия не так пагубны. Также недо-
статком является загромождение кода вызовами функций, которые ничего не делают в других профилях.

  II. Сложные надёжные методы. Данные методы всегда обеспечивают надёжность программы и ликвидируют
утечки памяти.

  5 Поскольку циклических связей между замыканиями быть не должно, можно применить подсчёт ссылок.
Т.е. в каждом предложении следует сравнивать количество переменных слева и справа: при уничтожении
переменных следует рекурсивно просматривать удаляемые переменные и декрементировать счётчики, при
копировании — аналогичным способом инкрементировать.
  Достоинство: процесс автоматизирован, надёжен.
  Недостаток: резкое снижение быстродействия.

  6 Изменение формата поля зрения. Атомы можно представлять как (s.Тип e.Значение), скобочные термы
как ((s.Тип e.Значение)). Такой формат позволяет хранить внутри атомов любые объектные выражения,
в том числе и контент замыкания.
  Достоинства: нет нужды в подсчётах ссылок и сборках мусора, утечки памяти невозможны, приличное
быстродействие.
  Недостатки: сравнение одноимённых переменных не за постоянное время, переделка всей библиотеки,
нечитаемость дампов памяти.

  7 Сборка мусора. Идея аналогична п. 2, только при исчерпании пула вызывается сборщик мусора.
  Недостаток: сложность в поддержке корневого множества (не иначе как в п. 5).
  Достоинство: метод надёжный в отличие от п. 2.

  8 Генерация кода в виде CPS (continuation-passing style). В этом случае вместо поля зрения
используется "пассивная" структура данных, в каждый момент времени в реальном поле зрения присут-
ствует только одна скобка конкретизации, поэтому корневое множество поддерживается элементарно.
  Достоинство: корневое множество доступно напрямую.
  Недостаток: это фактически написание нового back-end'а, снижение быстродействия вдвое (на каждый
вызов функции требуется по две скобки конкретизации), сложность кодогенерации.

  9 Эмуляция абстрактной рефал-машины. Можно добиться сравнительно малыми изменениями в кодогене-
рации и в реализации библиотечных модулей.
  Достоинство: доступность корневого множества, простота переделок.
  Недостатки: снижение быстродействия, фактически, написание нового back-end'а.

  Из приемлемых вариантов можно назвать п. 1, п. 4 и п. 9.
----------------------------------------------------------------------------------------------------
  [RENAME] 05.11.2010 - 21:36:08,97

  Old name is "[TODO] ВПВ: Вложенные функции (ВФ)"
  """"""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 05.11.2010 - 21:36:08,97

  Снят префикс ВПВ в связи с тем, что их реализация не входит в приоритеты публичной версии.
  В качестве варианта реализации замыканий для back-end'а Рефала 5 предполагается использовать
модифицированный п. 1, подразумевающий создание нового атома для каждого замыкания, но с явной
операцией уничтожения. Возможна разработка специального модуля аналога MLambda, который вызывает
функцию уничтожения после выполнения требуемой операции. Функция уничтожения замыкания на других
back-end'ах не будет делать ничего.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2014 - 12:35:00,01

  Предлагаемый выше вариант вполне работоспособен, однако есть один нюанс. Замыкания могут
содержать внутри себя другие замыкания (например операции MLambda::BindLeft или MLambda::Composite).
Следовательно, явная операция удаления должна удалять замыкания рекурсивно. Но, при этом только
программист знает, когда замыкания удалять нужно, а когда не нужно. В частности, возможен случай,
когда замыкание, после вызова подлежащее удалению, замыкает контекст, содержащий другое замыкание,
пока не подлежащее удалению. Т.е. нужно что-то вроде «деструктора» замыкания.
  Если делать деструктор в соответствии с идиомой ООП, то одно из предложений функции будет
представлять собой метод, левая часть которого должна принимать аргумент, который не могут принимать
другие предложения функции. Недостатки такого подхода:
  1 Невозможно написать замыкание, которое одинаково обрабатывает любой аргумент (частный случай —
деструктор должен будет обрабатываться по особому).
  2 Любое замыкание обязано содержать специальный образец, иначе при удалении замыкания будет
происходить ошибка сопоставления.
  3 В других back-end’ах это предложение не будет иметь смысла, но может (незначительно) снижать
быстродействие.
  Этих трёх проблем можно избежать, если предложение-деструктор сделать синтаксически отличным
от регулярных предложений, например, состоять из одного символа $DELETE. В результатных частях
тот же символ $DELETE может использоваться только как Callable, т.е. после левой скобки
конкретизации. Преимущества:
  1 Выполнить это предложение вызовом <s.Closure $DELETE> невозможно, поскольку синтаксически
некорректно. Единственный способ вызвать это предложение — уничтожить замыкание (вычислив
<$DELETE s.Closure>). Следовательно, данный образец никак не конфликтует с другими образцами.
Следствие: предложение-деструктор может идти любым по счёту: первым, последним…
  2 При отсутствии предложения оно неявно подразумевается с пустой правой частью, т.е. при удалении
замыкания ничего не должно выполняться.
  3 Специальный синтаксис допускает и особый способ компиляции. В других back-end’ах эти предложения
при трансляции будут игнорироваться, равно как будут игнорироваться вызовы <$DELETE …> в правых
частях. Следствие: переносимая программа в предложениях-деструкторах не должна ничего делать, кроме
уничтожения замыканий, захваченных контекстом. Также переносимая программа не должна вкладывать
в вызовы <$DELETE …> вызовы функций с побочным эффектом. Либо, вызовы <$DELETE …> должны
компилироваться в вызовы <NIL …> при наличии скобок конкретизации внутри вызова <$DELETE …>. Такое
поведение снизит быстродействие в корректной программе, но сделает переносимым поведение
в некорректной. Способ трансляции разумно сделать управляемым параметром конфигурации.
  4 Синтаксис Модульного Рефала допускает использование функций с пустым телом, а Рефал-5 — нет.
Приходится для пустых функций добавлять предложение NF = NF (в промежуточном представлении
не существует идентификаторов NF, поэтому такой метод корректен). Использование деструктора
устраняет этот костыль: любая сгенерированная функция будет содержать предложение-деструктор.

  Дополнительные замечания.
  Функция $DELETE соответствует идеологии Модульного Рефала — использование встроенных средств
только для встроенных в язык возможностей.
  Функция $DELETE может принимать не только s-переменную, но и вообще любое объектное выражение,
что имеет смысл, когда замыканий в контексте несколько. Разумеется, передавать литералы атомов
бессмысленно (их даже можно удалять во время компиляции или выдавать предупреждение), но для
унификации синтаксиса допустимо.
  Разрешать ли передачу в $DELETE скобок, как безымянных, так и абстрактных, я пока не определился.
  Конструкции &$DELETE и $DELETE не после левой скобки вызова в результатной части следует считать
ошибочными, равно как и использование $DELETE внутри образца, за исключением образца, состоящего
из единственного символа $DELETE.
  Допустимы два варианта написания $DELETE и $delete.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В рамках ревизии комментирую: задача низкоприоритетная, когда будет настроение, ею займусь. Новых
мыслей по ней у меня нет.


====================================================================================================
  [TODO] Ускорение работы компилятора на слабых машинах
====================================================================================================

  [TODO] 27.12.2014 - 15:43:41,16

  На слабых машинах (например, Pentium MMX, 64 Mb RAM) становится очевидным низкое быстродействие
быстродействие компилятора, связанное как с низким быстродействием сгенерированного кода, так и
с неоптимальными алгоритмами в самом компиляторе. К примеру, цикл раскрутки компилятора требует
нескольких десятков минут.
  На момент написания TODO часть работы по оптимизации была выполнена, а именно, были сделаны
следующие выводы и оптимизации.
  * Много времени уходит на создание статистической информации XLinx — около пяти с половиной
минут. Основная причина — отжор виртуальной памяти большей, чем физически установлено на машине.
Компилятор с профилем C++/SR потребляет более 80 Мбайт оперативной памяти, в то время как без свопа
в память влезает не более ≈35 Мбайт (остальное требуется операционной системе и фоновым программам).
Виртуальная память отжиралась по причине трёхкратного копирования перекрёстной информации при
порождении 4 файлов статистики. Двум файлам статистики требовался только список модулей — он стал
формироваться без потребления дополнительной памяти во время прохода по перекрёстной информации;
функция порождения таблицы перекрёстных связей стала прозрачной — в результате копирование
переменной стало ненужным.
  * Другой причиной низкого быстродействия был ассоциативный поиск среди всех записей при
построении инверсных сведений. Было применено хеширование — для каждого имени вычислялся хеш
(число от 0 до 37) и затем применялся двухуровневый ассоциативный поиск (среди имён с данным хешем
и внутри соответствующей корзины). Таким образом сложность была снижена с N² до N*sqrt(N), т.е.
на целый корень. Также хеширование ускорило поиск неслинкованных элементов.
  * Много времени отнимало построение деревьев модулей. Путей модификации логики самого алгоритма
я не обнаружил, а вот изменение структур данных ускорило этот этап примерно вдвое (с ≈40 до ≈20
секунд). Речь идёт о замене имён модулей (e-переменных) на числовые идентификаторы (s-переменнные).
Экономия времени связана со скоростью сравнения на равенство одноимённых переменных.
  * Суммарно эти две оптимизации снизили продолжительность построения статистической информации
до 2 минут.
  * Неплохо ускоряет работу back-end’а C++/SR использование компоновщика на make-файле. При
повторной перекомпиляции даже не запускается компоновщик Си++, т.к. make видит, что исполнимый файл
не обновлён по сравнению с объектными.
  * Перекомпиляция для back-end’а Простого Рефала занимает продолжительное время (порядка 4-5
минут), режимы, ускоряющие его работу, я пока не смотрел, т.к. часто им и не пользовался.
  * Back-end Рефала-5 ещё не оптимизирован, работает сильно медленно (несколько минут), возможно,
его также спасёт хеширование.
  * Профилировщик очень полезен в деле оптимизации.
  * Также полезно наблюдение за работой программы в диспетчере задач Windows XP, т.к. он показывает
не загрузку физической памяти (как в более поздних ОС), а загрузку виртуальной. Визуально по
графикам можно определять причины проблем:
    — если сильно выросло потребление памяти, а загрузка процессора не полная — проблема в свопе;
    — если загрузка процессора полная — проблема в вычислениях.
Сейчас на всём протяжении перекомпиляции имеем практически 100%-ную загрузку процессора.
  * Сейчас уже проблема находится не в свопе, а в затратах на вычисление.
  * Функция MOrder::Sort медленная и путей её ускорения я не вижу.

  Что предстоит сделать:
  * Сделать профилировщики более интеллектуальными. См. отдельное TODO.
  * Рассмотреть вопрос оптимизации кэша. На текущий момент звенья поля зрения в back-end’ах C++/SR
и Простого Рефала имеют размер 5 слов (20 и 40 байт на x86 и amd64 соответственно), что
не оптимально с точки зрения кэша процессора. Каждое звено включает в себя ссылки вперёд и назад
(по 1 слову), поле тега (из-за выравнивания — 1 слово, хотя хватило бы и байта), поле информации
(2 слова).
  Едиственная альтернатива в поле информации, занимающая два слова — ссылка на функцию, включающая
в себя указатель на функцию и указатель на её имя. Если в поле информации хранить не пару
указателей, а указатель на структуру, хранящую эту пару указателей, то звено уже будет кратно строке
кэша. Возможно снижение производительности, связанное с дополнительной косвенной адресацией, но оно
будет пренебрежимо мало по сравнению с затратами времени на всё остальное. Другим преимуществом
будет отход от генерации идентификаторов для представления имён функций в C++/SR.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  * Оптимизировать компоновщик back-end’а Рефала 5, возможно, путём хеширования.
  * Когда исследование совместного сопоставления с образцами будет завершено, внедрить этот механизм
оптимизации.
  
----------------------------------------------------------------------------------------------------
  [TODO] 21.10.2015 - 11:41:49,72

  Из того, что сделано.
  * Профилировщики сделаны интеллектуальными. Соответствующая задача закрыта.

  Из того, что предстоит сделать.
  * Рассмотреть вопрос по оптимизации кэша. Остаётся как есть, см. выше.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  Последние несколько месяцев проект Простого Рефала начал активно развиваться. Применительно
к текущей задаче — быстродействие компилятора заметно повысилось (приблизительно на 5…10 %). Имеет
смысл актуализировать версию Простого Рефала, входящую в проект Модульного Рефала как минимум
из соображений быстродействия.
  См. отдельное TODO.
  * Оптимизировать компоновщик back-end’а Рефала-5. Поиск путей оптимизации пока ведётся. Видятся
два варианта. Эволюционный: ищем в коде узкие места, оптимизируем их. Революционный: отказаться
от переименований функций и переменных на уровне компоновщика, вместо этого просто склеивать файлы.
Правильные имена функций и переменных давать сразу на этапе генерации «объектников».
  См. отдельное TODO.
  * Про совместное сопоставление с образцом. Ничего нового.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2015 - 10:21:12,56

  Back-end РЕФАЛа-5 оптимизирован, остальные пункты не потеряли актуальности.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Что касается оптимизации кэша (4-байтовые узлы), проведено такое исследование для Простого Рефала
(ветка 4bytes не в основной ветке, ветка черновая). Предварительные результаты — снижение
быстродействия на уровне статистической погрешности (около 1 %). Имеет смысл сделать, но только
ради экономии памяти.
  Оптимизация компоновщика профиля Простого Рефала имеет несколько направлений деятельности:
  * оптимизация самого компилятора Простого Рефала,
  * вызов компилятора Простого Рефала только для исходников, изменившихся с момента последней
компиляции.
  Очевидно, первый вариант следует обсуждать не тут, а в трекере самого Простого Рефала, поэтому
заметим, что в ближайшем будущем предстоит исследование некоторых оптимизаций Простого Рефала
в рамках бакалаврских квалификационных работ.
  Второй вариант также возможен и даже имеет больше смысла, ведь при неполной компиляции программы
back-end’ом компилируется весь набор исходников. Устранение избыточной компиляции принесёт большую
пользу, чем ускорение самого Простого Рефала на десятки процентов.


====================================================================================================
  [TOTHINK] ВПВ: Opensource-лицензия
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует выбрать opensource-лицензию. TOTHINK станет TODO когда лицензия будет выбрана. TODO
включит в себя задачу по внедрению лицензионного соглашения в исходные тексты программы.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Во-первых, компилятор коммерческой ценности не представляет, но может представлять научную или
программистскую ценность, поэтому для него следует использовать лицензию opensource.
  Во-вторых, из opensource-лицензий я предпочитаю либеральные по типу BSD, чем свободные GNU.
Дело в том, что код под либеральной лицензией можно использовать в рамках проектов под одной
из лицензий *GPL, но наоборот уже нельзя. Кроме того, BSD-лицензии разрешают использовать код
и в несвободном ПО. Таким образом, они налагают меньшее число ограничений.
  Из того, какие лицензии можно использовать. Во-первых, компилятор и библиотеки к языку следует
распространять под разными лицензиями: создание производного продукта на основе компилятора должно
требовать сохранения указания авторских прав в производном продукте, но создание производного
продукта на основе библиотеки (т.е. просто написание программы, использующей библиотеку) не должно
налагать такого ограничения.
  Для компилятора предпочтительны лицензии типа двухпунктовой BSD или MIT (они эквивалентны,
выбор — исключительно вопрос вкуса), для библиотек — «однопунктовая» BSD или Boost. В обоих случаях
распространение библиотек в исходном виде будет требовать сохранения копирайта, в двоичном виде —
нет.
  С конкретным выбором библиотек я пока не определился.
  Для Простого Рефала используется двухпунктовая BSD для компилятора и «однопунктовая» — для
библиотек.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.02.2016 - 11:42:56,37

  Временно выбрана двухпунктовая BSD для всего проекта. Лицензия на библиотечные компоненты будет
уточнена, возможно, позаимствована из Простого Рефала.


====================================================================================================
  [TOTHINK] Серьёзное расширение синтаксиса
====================================================================================================

  [TOTHINK] 06.11.2014 - 12:35:00,01

  Обоснование.
  1 Отсутствие вложенных функций приводит как к необходимости явного написания глобальных функций,
затем явно связываемых с контекстом, так и к сложночитаемым комбинациям функций при помощи средств
модуля MLambda ← таково краткое обоснование внедрения в язык хотя бы вложенных безымянных функций.
При этом внедрение в язык только вложенных безымянных функций может привести к похожему результату,
а именно к сложночитаемым комбинациям вложенных безымянных функций (при помощи комбинатора Y,
функций Composite и Fetch). Использование именованных функций полностью обесценивает комбинатор Y,
а соответствующие синтаксические средства снижают потребность в функциях Composite, Fetch и ряде
других. Таким образом, вложенные безымянные функции есть полумера.
  2 Во многих развитых диалектах Рефала есть механизм, позволяющий задавать дополнительные
ограничения на образец в левой части — условия в Рефале-5, неуспехи в других диалектах. Механизм,
очевидно, полезный, однако имитировать его при помощи одних лишь вложенных функций (не важно,
именованных или нет) достаточно трудно (без открытых e-переменных) или даже практически невозможно
(с открытыми e-переменными). Под трудностью и практической невозможностью подразумевается тот факт,
что код в результате получится чрезвычайно сложным и нечитаемым («овчина выделки не стоит»).

  Предлагается реализовать синтаксис, являющийся средним между Рефалом-5 и Рефалом-7: из Рефала-7
берём вложенные функции и действия ":", ",", "->", "::", "=", "=>", из Рефала-5 невозможность
возврата неуспеха из функции. Таким образом, неуспехи могут порождаться только действием ":"
(действие "::" при невозможности сопоставления аварийно останавливает программу), "," и "->"
прозрачны для неуспехов, "=" и "=>" непрозрачны для неуспехов (неперехваченный неуспех после
них приводит к аварийному останову программы), образец после ":" может перехватывать неуспех
(путём удлинения открытых e-переменных), образец после "::" не может перехватывать неуспех
(сопоставление однозначно).
  Вопрос об образцах после "::" (допустимы любые образцы, либо только жёсткие) требует
дополнительной проработки.
  Некоторые переменные могут помечаться как переопределяемые символом "^". Требуют проработки
следующие вопросы: символ "^" должен идти перед переменной или после, если переменная с крышкой
повторная в данном образце, все ли экземпляры должны быть помечены или не все, какие из них.

  В дальнейшем требуется:
  1 Подробнее сформулировать синтаксис и семантику
  2 Проработать указанные выше вопросы
  3 Продумать особенности реализации.
  4 Проанализировать плюсы и минусы возврата неуспехов из функций.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Есть интересные мысли, описывающие довольно цельный, но сложный и громоздкий синтаксис. Их нужно
оформить в виде отдельной спецификации, а также решить, воплощать ли их в программе.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 13.03.2016 - 23:24:12,47

  Предлагается функции делить на три вида (modes):
  1. Чистые функции. Далее — просто функции. Они не могут возвращать неуспех, всегда детерминированы
и не имеют побочных эффектов. Им соответствует символ "&"
  2. Функции, способные вернуть неуспех. Далее — функции-предикаты или просто предикаты. Они чистые,
то есть детерминированы и не имеют побочных эффектов. Им соответствует символ "?".
  3. Недетерминированные функции и/или функции с побочными эффектами. Далее — процедуры (ну не нашёл
другого подходящего слова). Они не могут возвращать неуспех. Им соответствует символ "!".

  Чистые функции могут вызывать только чистые функции и предикаты. При этом, если вызываемые
предикаты возвращают неперехваченный неуспех, происходит аварийное завершение программы. Вызвать
из чистой функции процедуру напрямую синтаксически невозможно, косвенно (по указателю) — приведёт
к тому же авосту во время выполнения.
  Предикаты могут вызывать только чистые функции и другие предикаты. Неперехваченный неуспех
из вызываемого предиката приводит к неуспеху вызывающего предиката. Вызов процедур невозможен
аналогично случаю с чистыми функциями.
  Процедуры могут функции любого вида. Неперехваченный неуспех в процедуре приводит к аварийному
завершению программы.

  Вид функции указывается в объявлении функции:

    &PureFunction {
      …
    }

    PureFunction2 {
      …
    }

    ?Predicate {
      …
    }

    !Procedure {
      …
    }

  При этом у чистых функций знак "&" можно опускать. Вызов функции оформляется аналогично:

    … <&PureFunction …> …
    … <PureFunction2 …> …
    … <?Precicate …> …
    … <!Procedure …> …

    … <& s.FnPureFunction …> …
    … <s.FnPureFunction …> …
    … <? s.FnPrecicate …> …
    … <! s.FnProcedure …> …

  Точно также, в скобках вызова чистой функции знак "&" можно опускать. Последние четыре примера
выше — косвенный запуск. В ряде случаев допустимо косвенно вызывать функцию не того вида, какой
ожидается в вызове — при этом получаем вполне ожидаемое поведение:

    ┌──────────┬───────────────────────────────────────┐
    │          │               Вызов                   │
    │ Функция  ├───────────────────────────────────────┤
    │          │  <& s.Func>   <? s.Func>   <! s.Func> │
    ├──────────┼───────────────────────────────────────┤
    │ &Func    │      ++           ++           ++     │
    │ ?Func    │      +-           ++           +-     │
    │ !Func    │      --           --           ++     │
    └──────────┴───────────────────────────────────────┘

  Обозначения:
  ++ — полностью поддерживается.
  -- — приводит к аварийному останову.
  +- — приводит к аварийному останову при возврате неуспеха вызываемой функции.

  Функция есть набор предложений, синтаксис отдельного предложения:

    Sentence = Pattern { Action }+.
    Action =
        "=" Result
      | "?=" Result
      | "," Result
      | ":" Pattern
      | "::" Pattern
      | "=>" Mode Result
      | "?=>" Mode Result
      | "->" Mode Result
      | Mode "~" Result
      | ( "\&" | "\?" | "\!" ) Pattern Action
      .
    Mode = ( "&" | "?" | "!" ).
    Mode = [ ModeReq ].

  Рассмотрим отдельно каждый из вариантов.
  1. "=" Result — результатное действие, непрозрачное для неуспехов. При возникновении
неперехваченного неуспеха справа от знака "=" происходит аварийный останов программы. Действие
допустимо в любых видах функций.
  2. "?=" Result — результатное действие, способное вернуть неуспех. При возникновении
неперехваченного неуспеха справа от знака "?=", результатом всей функции становится неуспех.
Действие допустимо только в функциях-предикатах.
  3. "," Result — результатное выражение, прозрачное для неуспехов — передаёт неуспех справа-налево.
Действие допустимо в любых видах функций.
  4. ":" Pattern — образцовое действие, способное вернуть неуспех и прозрачное для неуспехов. При
возникновении неуспеха справа от действия, осуществляется поиск нового сопоставления с образцом.
Если удалось сопоставить образец другим образом, выполнение передаётся на следующее действие
предложения. В противном случае действие возвращает неуспех. Действие допустимо в любых видах
функций.
  5. "::" Pattern — перестройка — образцовое действие, прозрачное для неуспехов, но сопоставляющееся
всегда успешно и однозначно. При невозможности сопоставления с образцом программа аварийно
завершается. При возникновении неуспеха справа от действия неуспех передаётся справа-налево.
  6. "=>" @ Result — действие-вызов, непрозрачное для неуспехов. Здесь и ниже @ заменяет "&", "?"
или "!".  Синтаксический сахар. Конструкция
    =>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 = R1 :: e.Env2 = <@ e.Env2 e.Env1>
Действие допустимо в любых видах функций.
  7. "?=>" @ Result — действие-вызов, способное вернуть неуспех. Синтаксический сахар. Конструкция
    ?=>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 ?= R1 :: e.Env2 ?= <@ e.Env2 e.Env1>
Действие допустимо только в функциях-предикатах.
  8. "->" @ Result — действие-вызов, прозрачное для неуспехов. Синтаксический сахар. Конструкция
    ->@ R1
эквивалентна следующей конструкции:
    :: e.Env1, R1 :: e.Env2, <@ e.Env2 e.Env1>
  9. @ "~" Result — действие декаррирования. Прозрачно для неуспехов. Синтаксический сахар.
Конструкция
    @~R1
эквивалентная следующей конструкции:
    :: e.Env1, <@ e.Env1 R1>.
Действие допустимо функциях любых видов.
  10. "\@" Pattern Action — лямбда. Допустима только после результатных действий. Синтаксический
сахар. Конструкция
    … R1 \@ P2 sentence-tail;
эквивалентна
    … R1 @{ P2 sentence-tail; };
Конструкция допустима в любых видах функций. Конструкция может быть полезна для использования в DSL
для каких-нибудь монад или ещё чего-то.

  Вложенные функции могут быть как безымянные, так и именованные. Безымянные имеют вид:
    … &{ … } …
    … { … } …
    … ?{ … } …
    … !{ … } …
Именованные:
    … $func &Pure { … } …
    … $func Pure2 { … } …
    … $func ?Pred { … } …
    … $func !Proc { … } …
Как и ранее, знак "&" допустимо опускать.
  Указатели на глобальные функции представляют собой имена функций, предварённые символом вида:
    FnPtr = ModeReq IDENTIFIER | Mode DotQualifiedName.

  Скобки активации существенно усложнились:

    CallTerm = "<" CallInit { Action } ">".
    CallInit =
        Mode Callable Result
      | "=" Result
      .
    Callable = FunctionName | Variable | CallTerm | FnPtr.
    FunctionName = QuadQualifiedName.

  Смысл здесь в том, что в угловых скобках теперь не просто вызов функции с аргументом-результатным
выражением, а целое предложение, начальный компонент которого — либо вызов функции, либо просто
порождение результата. Список вызываемых объектов теперь включает также все виды переменных, либо
другие скобки вызова — почти всё, что угодно.
  Конструкция "=" Result инициализирует среду значением данного результатного выражения. Таким
образом, запись <= R1> будет эквивалентна просто R1. Смысл конструкции в том, чтобы можно было
писать такие конструкции:
    <=
      <CalcSomething> => {
        Success = …;
        Fails = …;
      }
    >
что эквивалентно идиоме <Fetch …> Простого Рефала:
    <Fetch
      <CalcSomething> {
        Success = …;
        Fails = …;
      }
    >


  Заключение.
  Это описание намеренно сделано нечётким, есть куча неописанных деталей. Причина — это всего лишь
черновик описания. В частности, остаются вопросы:
  1. В ряде мест конфликтуют имена, квалифицированные квадроточием, и перестройки. А не отказаться
ли нам от имён с квадроточиями вообще — перейти на точку? Или можно сделать компилятор
интеллектуальным — догадываться в каждом конкретном случае, что имел ввиду программист. Если
допустимы оба варианта, выдавать ошибку?
  2. Вопрос реализации — надо продумать, как генерить оптимальный код для этих конструкций.
  3. Остался вопрос по перестройкам — должны ли после них быть только жёсткие выражения.
  4. Никак не затронут вопрос переопределения переменных.

  А неуспехи из функций нужны. Они могут существенно поднимать выразительность кода. Но они должны
быть явно синтаксически выделены. Также полезно выделять функции с побочным эффектом. Поэтому как-то
так.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 14.03.2016 -  1:06:36,70

  Дополнительные вопросы:
  5. Синтаксис оказался довольно сложен. Нужно либо обосновать сложность синтаксиса с идеологических
позиций, либо упростить.
  6. Вопрос: можно ли создать в одном модуле несколько функций с одинаковым именем и разными видами?


