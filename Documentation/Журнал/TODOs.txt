====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.


====================================================================================================
  [TODO] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.


====================================================================================================
  [TODO] Удалить MRefalRTS::Put
====================================================================================================

  [TODO] 02.02.2008 - 17:55:52,95

  См. выше, почему это не особо критично.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей


====================================================================================================
  [TODO] Новая модель модулей
====================================================================================================

  [TODO] 27.10.2007 - 18:34:49,78

  Изучены механизмы модулей в других языка программирования, т.е. лаба Module Conception. Для этого
TODO я выбрал не название "Механизм поиска модулей", а другое имя, т.к. эта задача более общая. Ког-
да я её выполню, я сделаю метки DONE для обоих задач.
  Подробности задачи см. в файле "Module conception for Module Refal.txt".
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Разумеется. А именно, головной модуль, Java-иерархия. А также параллельно будет переписан
драйвер.

  [TODO] Модуль-программа
  [TODO] Иерархия в стиле Java


====================================================================================================
  [TODO] Иерархия в стиле Java
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Обсуждалось. Добавляем.
  
  [TODO] Продумать квалификацию точкой
  Пока не продумал. Думаю. Буду долго думать, дольше, чем писать версию 0.2.
  Не выделяем.

  [TODO] SymInfo как АТД


====================================================================================================
  [TODO] Добавление категории "квалифицированное имя"
====================================================================================================

  [TODO] 27.10.2007 - 22:34:49,97

----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Добавление этого является прямым следствием иерархии языка Java.

  [TODO] Номер версии независимо от компиляции
  [TODO] Вывод номера версии компилятора
  Желательно. Но не критично. Конечно, раздражает лишний файл, но критически и идеологически не
важен.
  Не выделяем.

  [TODO] Удалить MRefalRTS::Put
  Идеологически не принципиально. Всё равно это деталь реализации.
  Не выделяем.

  [TODO] Исключение промежуточного представления модуля


====================================================================================================
  [TODO] Таблица перекрёстных ссылок
====================================================================================================

  [TODO] 04.02.2008 - 23:26:22,87

  Мотивация: в проекте очень много функций, которые мне не нравятся и я от них хотел в своё время
избавиться. А избавляюсь я от лишних функций как правило одним способом: создаю более совершенную фун-
кцию (или во всяком случае, начинаю создавать) и некоторое время использую их параллельно. Поэтому в
проекте параллельно существует несколько порой недоделанных альтернативных способов сделать что-либо.
Это модули MSymModule и MSymInfo, а также всякие многочисленные функции с суффиксом -Old.
  Необходимо уметь быстро найти те точки, откуда вызывается та или иная функция, а также, список
модулей, импортирующих заданный. Сейчас я просто меняю имя экспортирующей функции и запускаю на ком-
пиляцию, а затем наблюдаю список ошибок. Этот способ кустарный, неудобный и даёт неполную информацию
(т.к. при обнаружении модуля с ошибкой процесс компиляции останавливается), необходимо его заменить на
цивилизованный.
  В принципе, анализ перекрёстных связей можно осуществить как дополнительный back-end, объектные
файлы которого будут содержрать информацию о вызовах функций из модулей, а линковщик будет обобщать
обнаруженные сведения.
----------------------------------------------------------------------------------------------------
  [TODO] 05.02.2008 -  1:22:49,77

  Это удобный инструмент, к тому же он может стать пилотным альтернативным back-end'ом.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77



====================================================================================================
  [TODO] Пересмотреть/переписать mOutModuleStatus.mref
====================================================================================================

  [TODO] 09.02.2008 -  3:00:29,53

  Написал новый модуль mOutModuleStatus.mref. Мотивация в том, что при большом количестве модулей
сообщения об обновлённых или перекомпилированных файлах быстро убегают и не умещаются на экране.
Однако, новый модуль написан достаточно криво и запутано, поэтому в перспективе его желательно пере-
смотреть или переписать. Соответственно, TODO.

  См. выше.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).


====================================================================================================
  [TODO] Вынести из компилятора метаданные
====================================================================================================

  [TODO] 21.02.2008 - 15:51:11,21

  Здесь под метаданными подразумеваются сведения об каталогах поиска и расширениях файлов. Их сле-
дует или хранить в конфигурационном файле, или задавать в командной строке, или и то и другое. Также
было бы полезным вынести и другие сведения.
  Однако, это изменение я к приоритетным не отношу. Подождёт следующей версии.


====================================================================================================
  [TODO] Перевести Parser на квалифицированные имена
====================================================================================================

  [TODO] 23.02.2008 - 21:33:32,54

  Имена модулей (текущий и импортируемые) и имена функций в вызовах функций в порождаемом промежу-
точном представлении должны быть представлены как квалифицируемые.


====================================================================================================
  [TODO] Ввести особый тип компоновки для особых функций
====================================================================================================

  [TODO] 13.04.2008 - 21:06:47,07

  Было бы красиво, на мой взгляд, для функций Init и Final обычных модулей и функции Go головного
модуля иметь специальный тип компоновки.


====================================================================================================
  [TODO] Изменить обработку командной строки
====================================================================================================

  [TODO] 18.04.2008 - 22:57:27,21

  Сейчас (в текущей версии 0.1.904) модули/файлы в командной строке мыслятся как модули/файлы, вхо-
дящие в проект. "Лишние" файлы, которые компилируются и прилинковываются, могут иметь свои функции
инициализации, что позволяет осуществить гамак. Сие не есть хорошо. Надо изменить смысл командной
строки следующим образом.
  (1) Если некоторый аргумент командной строки является головным модулем, то он рекурсивно компи-
лируется и линкуется в .exe-шник. Если аргумент явяляется обычным модулем, то он рекурсивно компили-
руется, но не линкуется.
  (2) В командной строке можно указать несколько имён файлов/модулей. Каждый из них обрабатывается
согласно пункту (1). Таким образом, можно одновременно компилировать и собирать несколько проектов
одновременно. Если эти проекты имеют общие модули, то общее время компиляции должно снизиться.
  (3) Если расширение файла не указано, то поиск модуля выполняется по всем доступным front-end'ам.
Если расширение указано, то компиляция осуществляется указанным front-end'ом.
  (4) В командной строке могут быть опции, позволяющие выбрать необходимые back-end'ы.


====================================================================================================
  [ERROR] Возможна ошибка при чтении папок
====================================================================================================

  [ERROR] 23.04.2008 - 20:49:40,97

  Команду dir можно заместить, добавив в текущую папку/в один из каталогов PATH файл с именем, нап-
ример dir.exe. Такая ситуация может возникнуть, если на комп установлен cygwin (команда dir имитирует
команду ls системы Linux) -- сам видел. А это значит, что программы становятся непереносимыми.
  Решить проблему можно, если разработать отдельную программу с некоторым редким именем типа
mr_extent.exe, которая может в том числе выводить и листинг папки в более удобном для распознавания
формате. Эта же программа может возвращать значения переменных среды, конвертировать бинарные файлы
в текстовые специального формата и наоборот (чтобы имитировать работу с бинарными файлами). Для под-
держки этой программы можно создать отдельный стандартный модуль, который в момент инициализации про-
веряет наличие программы и корректность её версии.
  Примерный внешний вид програмы.
    > mr_extent.exe VERSION
  MRefal Extensions version 0.1.123
  или (в виде XXIO)
  MR_extent#0 #1 #123
  > mr_extent.exe LIST DirName
  file1.ext
  file2.txt
  dir3
  или
  (file1.ext)(file2.exe)(dir3)
  > mr_extent.exe INFO file1.ext
  #2048 #2008 #5 #9 #23 #59 #59 file1.ext
  Размер,  дата, время, имя
  > mr_extent.exe INFO dir3
  D#2008 #5 #9 #23 #59 #59 dir3
  > mr_extent.exe INFO file3.lst
  N
для папок может возвращаться вместо размера буква D, для несуществующих файлов N.
  Это ERROR я удалю, когда реализую эту программку.


====================================================================================================
  [TODO] При компоновке заменять самые примитивные функции на функции Рефала-5
====================================================================================================

  [TODO] 23.04.2008 - 22:49:01,30

  Т.е. идея в том, что нужно будет заменять вызовы функций типа MRefalRTS::Card сразу на <Card...>.
Причём это можно реализовать так, что в линковщик явно не будут встраиваться эти функции. Примитивные
функции будут описаны как псевдоними в файле MRefalRTS особыми директивами линковщика. Можно, напри-
мер, ввести тег 'p ' с таким синтаксисом
  p Entry::MRefalRTS::Prout Prout
или
  b Entry::MRefalRTS::Prout
  p Prout.
  В этом случае в таблицу MLinkerAliasTable вместо сгенерированного псевдонима вида X123 будет до-
бавлен псевдоним Prout.
  Способ этот ортогонален компилятору, т.к. позволяет легко изменять набор встроенных функций не
меняя ни строчки кода самого компилятора. Файл MRefalRTS всё равно пишется вручную.


====================================================================================================
  [TODO] ПИ:Проверять корректность имени модуля/пакета
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.


====================================================================================================
  [TODO] ПИ:Поддержка переменной MODULEPATH с проверкой корректности
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Надо осуществлять проверку того, что никакой каталог в переменной MODULEPATH не является подка-
талогом другого MP-каталога. А также проверять существование данного каталога.


====================================================================================================
  [TODO] Добавить в модуль ОС или ФС функции работы с именами файлов и каталогов
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Необходимо добавить следующие функции:
  (*) Функция, которая склеивает имя папки с относительным именем.
  (*) Функция, которая унифицирует имя папки -- т.к. в Windows одни и те же пути к файлам могут
выглядеть по-разному (прямой и обратный слеш, регистр символов).
  (*) Функция, возвращающая абсолютное имя для относительного. Такая функция может проверять также
наличие данного файла/папки. А может и не проверять.


====================================================================================================
  [TODO] ПИ:Полная поддержка parser'ом квалифицированных имён
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Одно из требований гласит:  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно
быть указано в файле исходного текста (синтаксис файла исходного текста должен позволять это делать)
и в файлах с информацией о межмодульных связях (структура хотя бы одного из этих файлов должна поз-
волять это делать).
  Таким образом, синтаксис файлов исходного текста (распознаётся в mParser.mref) и структура (она
же синтаксис) файлов символической информации (распознаётся там же) должна полностью поддерживать
квалифицированные имена.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о модулях. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.


====================================================================================================
  [TODO] ПИ:Режимы "только связывание" и "полной перекомпиляции"
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Должна быть возможность выбора режима перекомпиляции (на начальном этапе -- опцией командной
строки): make (быстрая перекомпиляция), build (полная перекомпиляция), linkonly (только связывание).


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.


====================================================================================================
  [TODO] Перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  Если вводить нормальные квалифицированные имена, то в IModule надо будет каким-то образом поме-
щать квалифицированные имена импортируемых модулей и проверять их на несовпадение с именами функций.
Это первая причина.
  Вторая причина. Хотя загадывать в далёкое будущее -- дело неблагодарное, всё равно загадаю. Пред-
полагается, что если я введу расширенный синтаксис (в виде образцовых или результатных окончаний), то
этот синтаксис промежуточно будет преобразовываться в набор функций базисного Рефала. Эти функции
могут получать имена на основе материнской функции путём добавления суффиксов. Добавлять суффиксы
удобнее всего в виде отдельных сегментов квалифицированного имени.
  Третья причина. Можно одинаковым образом реализовать контекст и IModule, т.к. оба контейнера,
фактически будут представляют собой ассоциативный массив, индексируемый по паре {квалифицированное
имя, имя атрибута}.
  Четвёртая причина. Всё большая часть компилятора поддерживает квалифицированные имена. Поэтому
совместимость IModule с остальным кодом улучшится с введением индексации по квалифицированному имени.
  Однако, на этом пути есть и нерешённые проблемы:
  (1) Индексировать функции надо относительным или абсолютным именем?
  (2) Может быть, достаточно ввести квалифицированные имена только для импортируемых модулей?


====================================================================================================
  [TODO] Додумать детали перевода IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 20:27:00,31

  Частично продумал. Можно изнутри перевести IModule на квалифицированные имена, при этом внешне ква-
лифицированными будут только имя самого модуля и имена импортируемых модулей. В этом случае легко га-
рантируется, что имя функции не будет совпадать с именем модуля, состоящего из одного сегмента, при
этом легко гарантировать, что имя импортируемого модуля, состоящего из одного сегмента не будет сов-
падать с именем функции/АТД.
  Однако, для функций/АТД пока вопрос остаётся открытым: квалифицировать их относительными или абсо-
лютными именами или их даже не квалифицировать их никак. Оставим пока для функций и АТД индексацию
простым именем.
  Когда я найду ответ на указанный в предыдущем абзаце вопрос, я закрою это TODO.


====================================================================================================
  [TODO] Частично перевести IModule на квалифицированные имена
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.


====================================================================================================
  [TODO] Подготовиться к переходу на пакеты
====================================================================================================

  [TODO] 05.07.2008 - 23:58:33,14

  Повторим положительный опыт по внедрению АТД, А именно, подготовим частичную поддержку синтаксиса
с пакетами для того, чтобы впоследствии можно было иметь на переходный период стабильную версию, ра-
ботающую вместе с пакетами. Для этого разрешим индексацию IModule квалифицированными именами для
импортируемых модулей и поддержку квалифицированного имени для имени самого модуля.
  Подготовка заключается в том, что все модули по-прежнему будут находиться в глобальном пространстве
имён, а ввод квалифицированных имён для самих модулей и импортируемых модулей будет лишь временной
заглушкой. При этом внутри IModule индексация для таких элементов будет осуществляться по окончаниям
квалифицированных имён.


====================================================================================================
  [TODO] Продумать back-end C++
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.


====================================================================================================
  [ERROR] Не определяется обновлённость импортированного модуля
====================================================================================================

  [ERROR] 25.11.2008 - 15:52:21,87

  Согласно спецификации, перекомпиляция модуля должна осуществляться в случае, если исходные тексты
импортируемых модулей или выходные файлы импортируемых библиотек обновлены позже рассматриваемого
модуля. Для исходных текстов это правило не выполняется, для библиотек -- ещё не проверял. Надо ис-
править.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.


