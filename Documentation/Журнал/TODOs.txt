====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Целесообразность такой функции сомнительна, но как интересную идею оставлю.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Есть задумка использовать не генератор синтаксического анализа, а интерпретируемый DSL. Задумка
уже есть (Documentation/Перспективы и тупики/Синтаксический анализатор.txt).


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Мне хочется, чтобы версия 0.2 была совместима с синтаксисом языка версии 0.1, т.е. чтобы можно
было откомпилировать исходники выпуска 0.1 выпущенной версией 0.2. Поэтому комментарии со звёздоч-
кой я убирать пока не буду, а только назову их deprecated.
  Комментарии со звёздочкой удалю при первой же переработке синтаксиса языка. А имена со строчной
буквы не нужны, т.к. никаких принципиально новых возможностей дать пока не могут.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках в журнале проекта
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.02.2009 - 21:42:25,09

  К версии 0.2 непосредстенно не относится.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Ошибок у меня обнаруживается, как правило, мало, они своевременно устраняются. Поэтому некритично.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [TODO] ‚в 21.04.2009 - 13:02:07.17

  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Синтаксис менять я не собираюсь, поэтому оставляю этот пункт в копилку идей.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия версии сохраняются.
  Идея версии 0.2 в том, чтобы получить стабильную реализацию языка Модульный Рефал, включающую в
себя компилятор, библиотеку и, возможно, документацию.
  Компилятор должен прежде всего стабильно работать, иметь удобный интерфейс (что уже почти достиг-
нуто) и быть логически законченным --- не иметь каких-либо недоделок и незавершённых начинаний.
  Библиотека тоже должна стабильно работать и предоставлять достаточно юзабельный и кроссплатфор-
менный интерфейс.
  Поскольку добавление ряда фич (например, расширение синтаксиса) не повлияет или слабо повлияет
на упомянутые выше цели, но сильно замедлит разработку, не собираюсь внедрять новые фичи в язык
или компилятор.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 26.04.2009 - 12:56:39,09

  Сегодняшняя реализация на Модульном Рефале потенциально способна работать с именами модулей, па-
кетов или квалифицированными именами любой длины. Однако создать модуль с килобайтным именем. Слиш-
ком длинные квалифицированные имена невозможны из-за ограничений файловой системы: максимальная дли-
на пути в Windows равна 260 байтам. Поэтому при попытке создать модуль с очень длинным именем, мы
всего лишь столкнёмся с ошибкой невозможности открытия файла: программа рухнет.
  В дальнейшей перспективе при переходе на Unicode можно будет использовать UNC-имена, т.к. для та-
ких имён практически не существует ограничения на длину (максимальная длина имени -- 64К unicode-
символа, что на практике дофига).
  Поэтому необходимо продумать проверку корректности имени файлов front- и back-end'ов (с точки
зрения длины) на уровне поиска модулей, а для подобной проверки создать платформенно-зависимую
функцию проверки корректности имени (т.к. на POSIX-системах другие ограничения). В таком случае
модули с длинными именами ко входным и выходным файлам будут просто игнорироваться при поиске
(не будут найдены, даже если они есть) и обрушений программ при открытии подобных файлов можно будет
избежать.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Эти ограничения в большей степени относятся к возможностям back-end'ов, целевого языка и исполь-
зуемой платформы. А вот нужны ли синтаксические ограничения, этот вопрос надо обдумать.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Требуется продумать этот вопрос для выпуска версии 0.2.
  Вообще, надо разобраться, как поведёт себя компилятор, если это требование будет нарушено.
  На данный момент в полных квалифицированных именах функций модули всегда являются предпоследними
сегментами в именах, а пакеты --- перед ними. Так что конфликтов быть не должно. Но при появлении
вложенных именованных функций возможны проблемы с этим. Так что надо обдумать это дело.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  Условия поднятия номера версии сохраняются.


====================================================================================================
  [TODO] "Подчистить" Простой Рефал
====================================================================================================

  [TODO] 01.07.2010 - 19:46:23,09

  Задача состоит в том, чтобы проработать следующие мелкие недостатки Простого Рефала:
  1. Т.к. Простой Рефал поддерживает идентификаторы, заменить в большинстве мест (если не во всех)
использование функций-перечислений ($EENUM) на метки ($LABEL). Недостаток пустых функций в том, что
они должны быть определены только в одном файле, а в остальных --- только объявлены, что создаёт
лишние зависимости между модулями.
  2. Добавить поддержку escape-последовательностей вида \xXX или \ooo, как и в языках семейства Си.
Ранее, Модульный Рефал не поддерживал операций умножения, деления и взятия остатка (глупое ограни-
чение библиотеки), поэтому не поддерживались такого рода escape-последовательности. Возможно добав-
ление и других escape-последовательностей, традиционных для Си.
  3. Удаление интерпретируемого кода. Преимуществ по быстродействию интерпретация не даёт, размер
исполняемого файла в наше время некритичен, а вот структуру кода запутывает.
  Изменение отношу к неприоритетным (для версии 0.2), т.к. не вижу причин делать его приоритетным.
----------------------------------------------------------------------------------------------------
  [TODO] 02.07.2010 - 12:59:05,15

  Т.к. требовалось обеспечить поддержку escape-последовательностей в Модульном Рефале, а Простой
Рефал является одним из целевых языков компиляции, то необходимо было релизовать поддержку escape-
последовательностей и в нём.
  Реализована поддержка тех же escape-последовательностей, что и в Модульном Рефале (см. ниже).


====================================================================================================
  [TOTHINK] Грамотная реализация библиотеки
====================================================================================================

  [TOTHINK] 10.07.2010 - 15:35:46,55

  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.


====================================================================================================
  [TOTHINK] Систематизировать имена профилей и end'ов
====================================================================================================

  [TOTHINK] 09.07.2010 - 20:34:59,06

  Придумать красивые и краткие имена для профилей и end'ов, а также "венгерскую нотацию" для их
внутренних имён. Единственное красивое имя сейчас имеет только профиль C++/SR, которое лаконично и
отражает суть. На данный момент для back-end'ов и front-end'а применяются следующие внутренние име-
на (файл "Имена end-ов.txt"):

  FrontEnds:
    MRefal_FrontEnd
  BackEnds:
    Refal5BE
    XLinxBE
    SymInfo
    SRefal-BE
    Cpp-SR-BE

  К запрещённым именам относятся Library и None. Как видно, здесь в именовании сплошной хаос: front-
end имеет суффикс _FrontEnd, back-end'ы имеют суффиксы BE, -BE или вообще не имеют.
  Внутренние имена профилей определены в функции Config::Load::ProfileBackEnd, которую я приведу
ниже:

  ProfileBackEnd =
    (Refal5 (Refal5-BE SymInfo) ('Refal5') ('R5'))
    (SimpleRefal (SRefal-BE SymInfo)
      ('SRefal') ('Simple') ('SimpleRefal') ('SR')
    )
    (Cpp-SR (Cpp-SR-BE SymInfo) ('CPPSR'));

  Кроме того, полезно продумать адекватную замену терминам back-end и front-end, т.к. (а) запись
через дефис мне кажется некорректной и (б) приходится переключать раскладку и приписывать окончание
через апостроф.
  Задачу считаю приоритетной, т.к. при объяснении модульной концепции в документации для этих поня-
тий нужно же будет использовать какие-нибудь термины.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 17.07.2010 - 20:45:57,84

  Относительно терминов front-end и back-end.
  Как показал анализ (просмотр текста двух печатных книг, поиск в Google и Википедия, в англоязыч-
ной литературе принято писать front end и back end без дефиса, что не мудрено, т.к. это обычные
английские словосочетания. В частности, такое написание было найдено в статьях
http://en.wikipedia.org/wiki/Front_and_back_ends и http://en.wikipedia.org/wiki/Compiler, в первой
странице поисковых запросов в Google и в книге Дракона (Ахо, Альфред В., Лам, Моника С., Сети, Ра-
ви, Ульман, Джеффри Д. Компиляторы: принципы, технологии и инструментарий, 2-е изд.: Пер. с англ.
--- М.: ООО "И.Д. Вильямс", 2008. --- 1184 с.: ил. --- Парал. тит. англ.): "Анализ часто называют
начальной стадией (front end), а синтез --- заключительной (back end)." (стр. 33).
  В пользу написания через дефис также говорят Википедия
( http://ru.wikipedia.org/w/index.php?title=Front-end_%D0%B8_back-end ), первая страница поиска
Google (с опцией "Только на русском") и книга Сергея Залмановича Свердлова (Свердлов С.З. Языки
программирования и методы трансляции: Учебное пособие. --- СПб.: Питер, 2007. --- 683 с.: ил):

    Блоки компилятора, зависящие от входного языка, выполняющие анализ исходной программы и её
  преобразование в промежуточное представление, образуют его анализирующию, входную, фронтальную
  часть (по-английски front-end). Блоки, ответственные за формирование выходной программы и не
  зависящие от входного языка, образуют синтезирующую, выходную часть (back-end) [сноска 1].

    [Сноска 1] К сожалению, устоявшиеся русские термины, эквивалентные полезным английским словам
  "front-end" и "back-end", не сформировались и, наверное, уже не сформируются. В устных беседах
  "компиляторостроители" обычно так и говорят: "фронт-энд", "бэк-энд". Ввести такие кальки с ан-
  глийского в письменную речь я не рискну. (стр. 308)

  Таким образом, термины front-end и back-end вполне имеют права на существование, тем более ком-
пактных альтернатив я к ним не знаю.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 19.07.2010 - 22:35:02,20

  Подумать о том, не разбить ли модуль MSymModule на два: для загрузки и для сохранения.


====================================================================================================
  [TODO] Ревизия задач
====================================================================================================

  [TODO] 24.07.2010 - 22:57:01,29

  Осталось, фактически три задачи (ниже пишу четвёртую), выполнив которые я буду должен увеличить
младший номер версии. Теперь, в преддверии этого инкремента, уже чётче видно, что является важным
и что является неважным, поэтому список задач надо проанализировать и определиться с приоритетами.


====================================================================================================
  [TOTHINK] Выпуск публичной версии (ВПВ)
====================================================================================================

  [TOTHINK] 24.07.2010 - 22:57:01,29

  Под публичной версией я подразумеваю версию, которую можно представить другим пользователям, нап-
ример, выложить у себя на сайте/блоге, в рефал-рассылке или рефал-семинаре (на который я, возможно,
поеду).
  Нужно продумать, что требуется для выпуска публичной версии Модульного Рефала, в частности способ
установки (setup.exe, make install и др.), выполнение под POSIX, документация, мелочи в виде дефол-
тового конфигурационного файла (загружаемого, скажем, из %USERPROFILE% и содержащего MP-пути) и др.
  А также нужно продумать, должна ли публичная версия совпадать с ожидаемой версией 0.2.


