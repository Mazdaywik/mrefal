====================================================================================================
  [TOTHINK] Рефакторинг интерфейса и реализации IModule
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [RENAME] 07.09.2010 - 23:30:08,46

  Old name is "[TODO] Продумать двухуровневую структуру синтаксического анализа"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 07.09.2010 - 23:30:08,46

  Удалено слово "продумать" ("обдумать") из заголовка, сменён тег с TODO на TOTHINK. (Переименова-
ние было проведено при первой возможности — сразу после того, как был введён тег RENAME.)
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  При дальнейшем развитии синтаксиса неизбежно возникнет вопрос адаптации имеющихся структур
данных к новым синтаксическим конструкциям. Тогда же этот вопрос и будет решён.
----------------------------------------------------------------------------------------------------
  [RENAME] 28.03.2018 - 11:33:50,24

  Old name is "[TOTHINK] Двухуровневая структура синтаксического анализатора"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Текущая реализация IModule уже «жмёт» — сначала пришлось некрасивым образом в неё добавить блоки
инициализации и финализации, а потом ещё и нативные вставки верхнего уровня.
  Изначально IModule был простой обёрткой над дважды ассоциативным массивом, «атрибутной таблицей
символов». Поддержка точек входа потребовала добавления в АТД записи t.EntryPoint (из-за чего
пришлось поменять все термы [IModule …]). Такую же масштабную правку потребовали и вставки
нативного кода. Для файлов с нативными вставками требуется сохранять их относительный порядок,
а также относительный порядок определённых функций, поэтому потребовалось в IModule хранить список
объектов «верхнего» уровня, дабы его итерировать при кодогенерации.
  Предлагаемое решение. Внешний интерфейс следует сохранить (расширив и удалив устаревшие функции).
Но внутреннюю реализацию описывать не в виде «атрибутной таблицы символов», а в виде AST.
Актуальная реализация представляет некоторые сущности в виде квалифицированного имени с набором
атрбиутов, разумно сохранить это же представление для соответствующих узлов дерева. Однако, для
узлов, которым это представление не подходит, не нужно искусственно навязывать такой подход.

  В актуальной реализации атрибуты функций запрашиваются у IModule по имени функции и атрибуту.

  <GetFunctionAttrubute t.hIModule s.Attrib t.FnName>
    == t.hIModule Found e.Value
    == t.hIModule s.ErrorStatus

  Имеет смысл продумать другой вариант: по имени запрашивается объект функции, у которого
запрашиваются атрибуты:

  <GetFunction t.hIModule t.Name>
    == t.hIModule Found t.Function
    == t.hIModule NotFound

  <GetFunctionAttribute t.Function s.Attribute>
    == Success e.Value
    == Fails

  <GetFunctionBody t.Function>
    == Sentences e.Sentences
    == Native e.Code
    == NoBody

  <UpdateFunction t.hIModule t.Function>
    == t.hIModule Success
    == t.hIModule s.Error

  Задача переименована, поскольку изначальное её описание не соответствует предлагаемому решению.
Вместо замены IModule на дерево на фазе синтаксического анализа предлагается модернизировать
IModule с новым интерфейсом и реализацией, хранящей дерево.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  По хорошему, надо писать не только тесты (некоторый небольшой набор тестов у меня есть), но и
средства автоматического тестирования (например, скриптом) и эти средства периодически обновлять.
  Некоторым подобием автоматического теста у меня является большой скрипт пересборки: он пересоби-
рает весь компилятор каждым исполнимым файлом, созданным некоторым профилем, с каждым профилем, что
в некоторой степени гарантирует его корректность.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В первую очередь нужно реализовать средства автоматического тестирования, а уже потом,
с их использованием, покрывать тестами и библиотеку, и компилятор. Сейчас у меня это в планах
не стоит, поэтому задача остаётся в статусе TOTHINK.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  На данный момент пока имеет смысл при расширении библиотеки ad hoc одновременно к новым функциям
писать автотесты в папке Sources/Compiler/Tests.
  При большой переработке библиотеки естественным образом добавятся тесты для вновь написанных
функций.
  P.S. Фреймворк автоматического тестирования, упоминающийся выше по задаче, уже есть и на данный
момент представляет собой упомянутую папку Sources/Compiler/Tests, тесты в которой могут
запускаться автоматически.


====================================================================================================
  [TODO] НД: Написание текста документации
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Требуется написать документацию к компиляторам и языкам Модульного и Простого Рефалов в текущей
реализации. Документация должна включать в себя следующие пункты:
  1 Описание текущей версии языка Модульный Рефал без рассмотрения особенностей конкретной реали-
зации. Включает в себя синтаксис и семантику Рефала, концепцию модульности.
  2 Описание текущей версии компилятора Модульного Рефала: представление модулей в виде исходных
и промежуточных файлов, компиляция, компоновка, расположение файлов модулей.
  3 Описание текущей версии языка Простого Рефала, при этом следует акцентировать внимание на том,
что ряд возможностей (идентификаторы, статические ящики) добавлены для совместимости с Модульным
Рефалом. Поскольку семантика управляющих конструкций Модульного и Простого Рефалов во многом сход-
ны, то их можно рассмотреть бегло.
  4 Описание текущей реализации Простого Рефала в Си++, рассмотрение интерфейса с языком Си++.
  5 Рассмотрение back-end'ов реализации Модульного Рефала, написание библиотечных модулей для
back-end'ов C++/SR и SR.
  6 (Приложение) Установка реализации Модульного Рефала на компьютер.
  7 (Приложение) Установка реализации Простого Рефала на компьютер.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: НД: Написание текста документации"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Проект Простого Рефала теперь развивается независимо от Модульного Рефала, соответственно,
документация к нему пишется независимо. А документацию к Модульному Рефалу писать надо. Следствие:
пункты 3 и 4 исключаются, остальное пока неизменно.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28): новых замечаний нет.


====================================================================================================
  [TOTHINK] Средство автоматической установки
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует продумать способ установки компиляторов на диск компьютера. Возможные варианты для
платформы Windows:
  1. Использование make-файлов.
  2. Использование специализированных средств установки типа пакетов MSI.
  3. Написание кустарного инсталлятора на базе sfx-архивов WinRAR и пакетных файлов.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TOTHINK] ВПВ: Средство автоматической установки"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Задача актуальна, но не приоритетна. В рамках проекта Простого Рефала сейчас планируется создание
отдельного репозитория, в котором будут храниться полускомпилированные исходники компилятора(файлы
на C++). Сам репозиторий в некотором смысле может играть роль инсталлятора: клонирование и сборка
исполнимых файлов должны будут создавать готовый к использованию дистрибутив. Опыт работы с таким
репозиторием будет учтён в текущей задаче.
  Задача переименована, поскольку создание инсталлятора теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Неплохой вариант реализован в Рефале-5λ: для платформы Windows создаётся инсталляшка на базе
SFX-архива WinRAR со скриптом установки на Windows Script Hosting. А вот от подмодуля дистрибутива
мне уже хочется отказаться.


====================================================================================================
  [TODO] Написание документации (НД)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Выпуск публичной версии компилятора требует написания документации: описания языка и описания
конктретной реализации. Поскольку предполагается распространение Модульного и Простого Рефалов
в одном дистрибутиве, документация должна включать в себя сведения об обоих диалектах.
  Отсюда две подзадачи:
  1 Написание "контента";
  2 Выбор способа представления контента.
----------------------------------------------------------------------------------------------------
  [TODO] 16.09.2012 - 11:13:49,96

  Сначала я предполагал размещать документацию на сайте blogspot, даже уже частично написал, однако,
к некоторому моменту я потерял интерес к этому процессу. В качестве представления этот способ
оказался не слишком удобен: данные хранятся на удалённом сервере, поэтому для редактирования надо
быть в онлайне, к тому же, необходимо логиниться на сайте.
  Недавно мне пришла в голову неплохая идея: можно писать документацию в формате docx/odt — с одной
стороны, это автоматически даёт возможность получить красиво отформатированный pdf, с другой —
формат представляет собой набор зазипованных xml’ек, который, при необходимости, относительно легко
распарсить, просто выбирая только теги с понятным содержимым, а остальные игнорируя.
  Преимущество формата docx — возможности форматирования Microsoft Word, которым я умею эффективно
пользоваться.
  Преимущество формата odt — кроссплатформенность и простота для парсинга (XML более ясный, чем
у Microsoft Word).
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: Написание документации (НД)"
  """""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея с использованием файлов docx или odt и конвертером, например, в текстовый формат, имеет
тот недостаток, что разница между коммитами либо не отображается, либо отображается в довольно
неудобном виде.
  Более подходящий вариант — использование изначально текстового представления. Варианты:
  * Свой конвертер. Начинал писать, дело далеко не продвинулось. Велосипед, вероятно, тупиковый
путь.
  * TeX:
    (+) Красиво отформатированный, пригодный для публикации формат.
    (−) Высокий порог вхождения, т.е. мне потребуется изучать новую среду: LaTeX или Lyx.
    (−) Тяжёлые для чтения исходники.
  * Markdown:
    (+) Лёгкость в использовании, низкий порог вхождения.
    (+) Доступно множество редакторов, конверторов. (Ни одним ещё не пользовался, но список
на Википедии длинный.)
    (+) Исходники легко читать.
    (+) Если просто хранить в подпапке набор файлов в разметке Markdown с гиперссылками друг
на друга, то в web-интерфейсе GitHub оно будет отображаться фактически как wiki-энциклопедия.
    (−) Чтобы сохранять читаемость исходников, нужно будет при редактировании каждый раз выравнивать
длины строк. Это снижает сопровождаемость (хотя в ряде текстовых редакторов (Vim, Emacs) есть
функция выравнивания строк). Соответственно, различия между коммитами будут включать много замен
строк, даже если изменилось только несколько слов. В TeX такая проблема тоже присутствует,
но исходники не предназначены для чтения.
    (−) Для ввода типографских плюшек (длинные тире, кавычки-ёлочки, неразрывные пробелы) нужно
или использовать последовательности HTML (что засоряет текст), либо специальные раскладки
клавиатуры. Кроме того, неразрывные пробелы внешне неотличимы от обычных, что тоже создаёт проблемы.
  Так что задача пока остаётся открытой. Возможен вариант использования wiki, встроенной в GitHub.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Хороший вариант — использовать Markdown. Более того, поскольку исходники теперь хранятся
в репозитории на GitHub, документация удобно читается через интерфейс сайта. И даже больше — можно
сделать сайт на GitHub Pages, написанный целиком в Markdown’е. Документацию писать буду я,
я пользуюсь раскладкой Бирмана, так что типографские знаки для меня не проблема.


====================================================================================================
  [TODO] Вложенные функции (ВФ)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Как показала практика работы с Простым Рефалом, вложенные функции существенным образом повышают
выразительность программы и производительность программиста, даже если они и безымянные.
  Кроме того, практика показала, что если синтаксический анализ написан методом рекурсивного спуска
достаточно регулярным образом, то добавить в него вложенные безымянные функции тоже достаточно
несложно.
  Используемый рантайм (общий для Простого Рефала и back-end'а C++/SR Модульного Рефала) поддержи-
вает замыкания (представление вложенных функций во время выполнения программы).
  Версия 0.2 завершена, поэтому ничего не мешает расширению синтаксиса (на который был ранее нало-
жен запрет, дабы сконцентрировать усилия на других задачах).
  Вышеперечисленных аргументов достаточно, чтобы внедрить в язык вложенные безымянные функции
(позже можно будет придумать и именованные). Однако, есть и сложность на этом пути.
  Дело в том, что относительно безболезненно внедрить замыкания только в два профиля из трёх. Ран-
тайм профиля Рефала 5, в отличие от рантайма профилей C++/SR и SR, не поддерживает имманентно замы-
каний и, как следствие, реализация вложенных функций потребует костылей.
  Замыкание представляет собой кортеж, включающий в себя указатель на глобальную функцию и набор
связанных переменных, представляющих собой контекст замыкания. Поэтому задача состоит в том, чтобы
каким-либо образом их хранить в поле зрения. Семантически не должно быть способа разделить замыка-
ние на элементы каким-либо сопоставлением с образцом, следовательно, замыкание должно быть атомом
и сопоставляться с s-переменной.
  Под контеНтом замыкания будем подразумевать кортеж из контеКСта и указателя (имени) глобальной
функции.
  Среди способов реализации замыканий в профиле Рефала 5 можно выделить две группы: надёжные
и ненадёжные.

  I. Простые ненадёжные методы.

  1 При каждом создании замыкания создавать новый уникальный атом (например, функцией Implode),
а контент замыкания помещается в копилку с ключом в виде уникального атома. Непрямой вызов функции
представляется как вызов специальной функции, которая осуществляет проверку наличия уникального
атома в копилке и вызов контента при помощи функции Mu. При отсутствии атома в копилке функцией
Mu вызывается сам атом на входе.
  Недостаток: контенты замыканий не освобождаются, поэтому память будет непрерывно утекать.
  Достоинство: простота.

  2 По аналогии с п. 1, но используется фиксированный пул уникальных атомов. Если же пул опустошён,
то разрушается какое-то замыкание и его атом используется для создания нового замыкания.
  Недостаток: метод невозможно применять на практике, т.к. программа, использующая замыкания,
становится абсолютно ненадёжной — любое замыкание может быть похерено в любой момент.
  Достоинство: относительная простота, отсутствие утечек памяти.
  Метод тут рассматривается только для полноты картины.

  3 По аналогии с п. 1, но с замыканием ассоциируется счётчик вызовов, после которого оно становит-
ся недействительным (соответственно, контент освобождается). Соответственно, при каждом вызове
замыкания счётчик декрементируется.
  Недостаток: необходимо при создании замыкания инициализировать счётчик или специальным синтакси-
сом, или специальной библиотечной функцией, или выбирать значение счётчика по умолчанию. Если при
создании значение счётчика оказалось заниженным, то при "избыточных" вызовах получим ошибку. Если
значение счётчика оказалось заниженным, то память не освободится.
  Достоинство: способ более надёжен, чем п. 2, также способен бороться с утечками памяти.

  4 По аналогии с предыдущим пунктом с замыканием ассоциируется счётчик вызовов, но пользователь
получает возможность управлять этим счётчиком. Например, при создании ассоциируется значение 1,
при копировании замыкания пользователь явно инкрементирует счётчик, при удалении замыкания поль-
зователь должен счётчик явно декрементировать. Фактически, ручной подсчёт ссылок.
  Достоинства: способен обеспечить надёжность программы, а также избежать утечек памяти. Способ
прост. Способ эффективен.
  Недостаток: человеческий фактор. Контроль программиста за копированием напоминает управление
памятью в языках без сборки мусора (например, Си), но здесь последствия не так пагубны. Также недо-
статком является загромождение кода вызовами функций, которые ничего не делают в других профилях.

  II. Сложные надёжные методы. Данные методы всегда обеспечивают надёжность программы и ликвидируют
утечки памяти.

  5 Поскольку циклических связей между замыканиями быть не должно, можно применить подсчёт ссылок.
Т.е. в каждом предложении следует сравнивать количество переменных слева и справа: при уничтожении
переменных следует рекурсивно просматривать удаляемые переменные и декрементировать счётчики, при
копировании — аналогичным способом инкрементировать.
  Достоинство: процесс автоматизирован, надёжен.
  Недостаток: резкое снижение быстродействия.

  6 Изменение формата поля зрения. Атомы можно представлять как (s.Тип e.Значение), скобочные термы
как ((s.Тип e.Значение)). Такой формат позволяет хранить внутри атомов любые объектные выражения,
в том числе и контент замыкания.
  Достоинства: нет нужды в подсчётах ссылок и сборках мусора, утечки памяти невозможны, приличное
быстродействие.
  Недостатки: сравнение одноимённых переменных не за постоянное время, переделка всей библиотеки,
нечитаемость дампов памяти.

  7 Сборка мусора. Идея аналогична п. 2, только при исчерпании пула вызывается сборщик мусора.
  Недостаток: сложность в поддержке корневого множества (не иначе как в п. 5).
  Достоинство: метод надёжный в отличие от п. 2.

  8 Генерация кода в виде CPS (continuation-passing style). В этом случае вместо поля зрения
используется "пассивная" структура данных, в каждый момент времени в реальном поле зрения присут-
ствует только одна скобка конкретизации, поэтому корневое множество поддерживается элементарно.
  Достоинство: корневое множество доступно напрямую.
  Недостаток: это фактически написание нового back-end'а, снижение быстродействия вдвое (на каждый
вызов функции требуется по две скобки конкретизации), сложность кодогенерации.

  9 Эмуляция абстрактной рефал-машины. Можно добиться сравнительно малыми изменениями в кодогене-
рации и в реализации библиотечных модулей.
  Достоинство: доступность корневого множества, простота переделок.
  Недостатки: снижение быстродействия, фактически, написание нового back-end'а.

  Из приемлемых вариантов можно назвать п. 1, п. 4 и п. 9.
----------------------------------------------------------------------------------------------------
  [RENAME] 05.11.2010 - 21:36:08,97

  Old name is "[TODO] ВПВ: Вложенные функции (ВФ)"
  """"""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 05.11.2010 - 21:36:08,97

  Снят префикс ВПВ в связи с тем, что их реализация не входит в приоритеты публичной версии.
  В качестве варианта реализации замыканий для back-end'а Рефала 5 предполагается использовать
модифицированный п. 1, подразумевающий создание нового атома для каждого замыкания, но с явной
операцией уничтожения. Возможна разработка специального модуля аналога MLambda, который вызывает
функцию уничтожения после выполнения требуемой операции. Функция уничтожения замыкания на других
back-end'ах не будет делать ничего.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2014 - 12:35:00,01

  Предлагаемый выше вариант вполне работоспособен, однако есть один нюанс. Замыкания могут
содержать внутри себя другие замыкания (например операции MLambda::BindLeft или MLambda::Composite).
Следовательно, явная операция удаления должна удалять замыкания рекурсивно. Но, при этом только
программист знает, когда замыкания удалять нужно, а когда не нужно. В частности, возможен случай,
когда замыкание, после вызова подлежащее удалению, замыкает контекст, содержащий другое замыкание,
пока не подлежащее удалению. Т.е. нужно что-то вроде «деструктора» замыкания.
  Если делать деструктор в соответствии с идиомой ООП, то одно из предложений функции будет
представлять собой метод, левая часть которого должна принимать аргумент, который не могут принимать
другие предложения функции. Недостатки такого подхода:
  1 Невозможно написать замыкание, которое одинаково обрабатывает любой аргумент (частный случай —
деструктор должен будет обрабатываться по особому).
  2 Любое замыкание обязано содержать специальный образец, иначе при удалении замыкания будет
происходить ошибка сопоставления.
  3 В других back-end’ах это предложение не будет иметь смысла, но может (незначительно) снижать
быстродействие.
  Этих трёх проблем можно избежать, если предложение-деструктор сделать синтаксически отличным
от регулярных предложений, например, состоять из одного символа $DELETE. В результатных частях
тот же символ $DELETE может использоваться только как Callable, т.е. после левой скобки
конкретизации. Преимущества:
  1 Выполнить это предложение вызовом <s.Closure $DELETE> невозможно, поскольку синтаксически
некорректно. Единственный способ вызвать это предложение — уничтожить замыкание (вычислив
<$DELETE s.Closure>). Следовательно, данный образец никак не конфликтует с другими образцами.
Следствие: предложение-деструктор может идти любым по счёту: первым, последним…
  2 При отсутствии предложения оно неявно подразумевается с пустой правой частью, т.е. при удалении
замыкания ничего не должно выполняться.
  3 Специальный синтаксис допускает и особый способ компиляции. В других back-end’ах эти предложения
при трансляции будут игнорироваться, равно как будут игнорироваться вызовы <$DELETE …> в правых
частях. Следствие: переносимая программа в предложениях-деструкторах не должна ничего делать, кроме
уничтожения замыканий, захваченных контекстом. Также переносимая программа не должна вкладывать
в вызовы <$DELETE …> вызовы функций с побочным эффектом. Либо, вызовы <$DELETE …> должны
компилироваться в вызовы <NIL …> при наличии скобок конкретизации внутри вызова <$DELETE …>. Такое
поведение снизит быстродействие в корректной программе, но сделает переносимым поведение
в некорректной. Способ трансляции разумно сделать управляемым параметром конфигурации.
  4 Синтаксис Модульного Рефала допускает использование функций с пустым телом, а Рефал-5 — нет.
Приходится для пустых функций добавлять предложение NF = NF (в промежуточном представлении
не существует идентификаторов NF, поэтому такой метод корректен). Использование деструктора
устраняет этот костыль: любая сгенерированная функция будет содержать предложение-деструктор.

  Дополнительные замечания.
  Функция $DELETE соответствует идеологии Модульного Рефала — использование встроенных средств
только для встроенных в язык возможностей.
  Функция $DELETE может принимать не только s-переменную, но и вообще любое объектное выражение,
что имеет смысл, когда замыканий в контексте несколько. Разумеется, передавать литералы атомов
бессмысленно (их даже можно удалять во время компиляции или выдавать предупреждение), но для
унификации синтаксиса допустимо.
  Разрешать ли передачу в $DELETE скобок, как безымянных, так и абстрактных, я пока не определился.
  Конструкции &$DELETE и $DELETE не после левой скобки вызова в результатной части следует считать
ошибочными, равно как и использование $DELETE внутри образца, за исключением образца, состоящего
из единственного символа $DELETE.
  Допустимы два варианта написания $DELETE и $delete.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В рамках ревизии комментирую: задача низкоприоритетная, когда будет настроение, ею займусь. Новых
мыслей по ней у меня нет.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Есть интересная мысль реализовать перпендикулярный вышеописанному подход.

  В исходной постановке задачи говорится:

> Семантически не должно быть способа разделить замыкание на элементы каким-либо сопоставлением
> с образцом, следовательно, замыкание должно быть атомом и сопоставляться с s-переменной.
              ^^^^^^^^^^^^^

  Слово «следовательно» подчёркнуто специально. Потому что не следовательно. Для Рефала-7
«следовательно», для Простого Рефала — s-переменные по историческим причинам, для Модульного Рефала
существуют термы (t-переменные), которые в некоторых обстоятельствах неразложимы сопоставлением
с образцом.
  Речь идёт об АТД-термах. В «своём» модуле они синтезируются и анализируются при помощи синтаксиса
квадратных скобок, в «чужих» — они чёрные ящики.
  Так почему же не представлять вложенные функции как некоторые АТД, которые не разложимы ни в каком
модуле? В таком случае потребуется расширить синтаксис вызовом t-переменной:

  <t.Func ...>

  Реализация может быть такой. Теги абстрактных скобок в текущей реализации компилируются в пустые
функции (в профилях C++/SR и SimRef) либо просто в какие-то идентификаторы (в профиле Рефала-5).
Для (неявно создаваемых) абстрактных тегов вложенных функций можно генерировать уже непустую функцию.
  Вызов t-переменной будет, в случае, если это простой указатель на функцию, вызывать его как
и раньше, если это абстрактный терм — вызывать тег терма как функцию, передавая ей содержимое терма
и аргумент вызова. Для обычных АТД такой вызов будет приводить к фейлу — вызову пустой функции либо
к вызову несуществующей функции при помощи Mu.

  Преимущества решения перед s-переменными:
  (+) Простота реализации во всех профилях.
  (+) Нет утечек памяти. Не нужно явно разрушать замыкание.
  (+) Простое и понятное сравнение на равенство — две вложенные функции с идентичным захваченным
контекстом, построенные из одного блока, будут равны. Как равны два абстракных терма.
  (+) Возможность реализации взаимно рекурсивных именованных функций. Если каждая из вложенных
функций будет возвращать «указатель» на соседнюю, то отдельные вызовы для возврата этого указателя
будут давать один и тот же терм. Просто в силу сравнения не по ссылке, а по значению. Ссылочная
эквивалентность потребовала циклических связей на уровне структуры данных, что крайне трудоёмко
(если вообще возможно) было бы разрешать для счётчика ссылок (или ручного удаления).

  Особенности (считать ли их недостатками — вопрос открытый):
  (*) Копирование не за константное время. Вложенные функции Простого Рефала являются атомами
и всегда копируются за константное время — просто увеличивается счётчик ссылок. Платой
за эффективность копирования является неэффективность вызова — если ссылок несколько, контекст
не переносится, а копируется. Так что можно сказать, что происходит отложенное копирование
контекста.
  t-переменные всегда будут копироваться энергично, но при вызове контекст копировать не надо.
  Т.е. при таком подходе мы жертвуем механизмом отложенного копирования, который мог бы
использоваться в каких-нибудь идиомах или при оптимизации (я этим не пользовался).
  (*) Симметрично — медленная проверка на равенство. Но вообще это не проблема, поскольку мне
на практике не приходилось сравнивать на равенство два замыкания. И мне не известны сценарии,
когда это может понадобиться.

  Недостатки:
  (-) Механизм конфликтует с задачей #1 — внедрением в язык ограниченного ООП. Для реализации
последнего тоже используются теги абстрактных скобок, которые тоже трактуются как функции
с некоторой реализацией.

  Разрешить конфликт можно разными способами.
  Можно придумать более хитрую реализацию вызова методов и замыканий. Если после открывающей
скобки активации находится имя виртуальной функции, то вызов трактуется как вызов метода.
Если там располагается абстрактная скобка — это вызов замыкания. Недостаток: придётся менять
рантайм Рефала-5λ ради Модульного Рефала. Да и реализация сложна.
  Можно вызовы <t.Func ...> неявно транслировать во что-то вроде <CALL t.Func ...>, где
CALL — некоторая встроенная функция. Тогда тег абстрактного терма сможет отличать виртуальные
функции от вызова замыканий просто по имени.
  Но можно пойти ещё дальше! Можно эту функцию CALL считать виртуальной! Тогда механизм вызова
замыкания будет выражаться через механизм вызова виртуальных функций. Реализация становится
существенно проще.
  Но если существует виртуальная функция для вызова замыканий, то почему бы не дать возможность
пользователю расширять эту виртуальную функцию для своих АТД. Тогда они тоже смогут поддерживать
синтаксис вызова функций. Будут своего рода функциональными объектами.

  Первое, что мне пришло в голову — создать библиотечный модуль с определением виртуальной
функции вроде такого:

  $MODULE RUNTIME;

  $VIRTUAL CALL {
    s.Func e.Arg = <s.Func e.Arg>;
    $DATA e.Arg;
  }

  $END RUNTIME.

  Тогда, если модуль содержит вызовы <t.Func ...>, то он неявно импортирует модуль RUNTIME,
а сами вызовы заменяются на вызов <RUNTIME::CALL ...>. При этом пользователь может явно
импортировать этот модуль и расширить RUNTIME.CALL для своих АТД.

  Преимущество:
  (+) Модуль RUNTIME можно использовать для ещё чего-нибудь. Например, он может содержать
вызов функции завершения работы программы, которая вызывает все финализаторы и завершает работу.
Сейчас эта функция генерируется для Рефала-5 и подключается как файл рантайма mrefalrts в других
профилях (реализация в C++/SR сейчас довольно кривая).
  Недостаток:
  (-) Решение противоречит идеологии Модульного Рефала: встроенные средства языка не должны быть
привязаны к пользовательским определениям. Например, пользователь может переопределить модуль
RUNTIME в котором функция CALL может остутствовать, и вся механика разрушится.
  Кроме того, теперь замыкания выглядят не как фундаментальный механизм языка, а как
синтаксический сахар для создания АТД, для которых расширяется некоторая виртуальная функция.
Т.е. компилятор генерит специальный код для какого-то прикладного библиотечного модуля. Это
противоречит идеологии.
  Аналогично запись <t.Func ...> тоже оказывается синтаксическим сахаром для вызова некоторой
прикладной функции.
  Дабы подчеркнуть идеологический конфликт, представим, что <t.Func ...> заменяется
не на <RUNTIME::CALL t.Func ...>, а на <MLambda::Apply t.Func ...>!

  Разрешить это противоречие можно, сделав расширяемую виртуальную функцию «безымянной». И либо
расширить её для своих АТД пользователь не может, либо должен использовать _специальный синтаксис._
Например, так:

  $DATA MyData;

  $EXTENDS <> {
    [MyData e.Context] e.Arg = ...;
  }

  Вместо квалифицированного имени используется пара скобок активации. Такая запись чем-то
напоминает переопределения операторов в C++: operator+(…), operator Type(…), operator()(…) и т.д.
Тоже используются специальные обозначения для специальных функций.

  Очевидно, получается, что задача зависит от задачи #1.


====================================================================================================
  [TODO] Ускорение работы компилятора на слабых машинах
====================================================================================================

  [TODO] 27.12.2014 - 15:43:41,16

  На слабых машинах (например, Pentium MMX, 64 Mb RAM) становится очевидным низкое быстродействие
быстродействие компилятора, связанное как с низким быстродействием сгенерированного кода, так и
с неоптимальными алгоритмами в самом компиляторе. К примеру, цикл раскрутки компилятора требует
нескольких десятков минут.
  На момент написания TODO часть работы по оптимизации была выполнена, а именно, были сделаны
следующие выводы и оптимизации.
  * Много времени уходит на создание статистической информации XLinx — около пяти с половиной
минут. Основная причина — отжор виртуальной памяти большей, чем физически установлено на машине.
Компилятор с профилем C++/SR потребляет более 80 Мбайт оперативной памяти, в то время как без свопа
в память влезает не более ≈35 Мбайт (остальное требуется операционной системе и фоновым программам).
Виртуальная память отжиралась по причине трёхкратного копирования перекрёстной информации при
порождении 4 файлов статистики. Двум файлам статистики требовался только список модулей — он стал
формироваться без потребления дополнительной памяти во время прохода по перекрёстной информации;
функция порождения таблицы перекрёстных связей стала прозрачной — в результате копирование
переменной стало ненужным.
  * Другой причиной низкого быстродействия был ассоциативный поиск среди всех записей при
построении инверсных сведений. Было применено хеширование — для каждого имени вычислялся хеш
(число от 0 до 37) и затем применялся двухуровневый ассоциативный поиск (среди имён с данным хешем
и внутри соответствующей корзины). Таким образом сложность была снижена с N² до N*sqrt(N), т.е.
на целый корень. Также хеширование ускорило поиск неслинкованных элементов.
  * Много времени отнимало построение деревьев модулей. Путей модификации логики самого алгоритма
я не обнаружил, а вот изменение структур данных ускорило этот этап примерно вдвое (с ≈40 до ≈20
секунд). Речь идёт о замене имён модулей (e-переменных) на числовые идентификаторы (s-переменнные).
Экономия времени связана со скоростью сравнения на равенство одноимённых переменных.
  * Суммарно эти две оптимизации снизили продолжительность построения статистической информации
до 2 минут.
  * Неплохо ускоряет работу back-end’а C++/SR использование компоновщика на make-файле. При
повторной перекомпиляции даже не запускается компоновщик Си++, т.к. make видит, что исполнимый файл
не обновлён по сравнению с объектными.
  * Перекомпиляция для back-end’а Простого Рефала занимает продолжительное время (порядка 4-5
минут), режимы, ускоряющие его работу, я пока не смотрел, т.к. часто им и не пользовался.
  * Back-end Рефала-5 ещё не оптимизирован, работает сильно медленно (несколько минут), возможно,
его также спасёт хеширование.
  * Профилировщик очень полезен в деле оптимизации.
  * Также полезно наблюдение за работой программы в диспетчере задач Windows XP, т.к. он показывает
не загрузку физической памяти (как в более поздних ОС), а загрузку виртуальной. Визуально по
графикам можно определять причины проблем:
    — если сильно выросло потребление памяти, а загрузка процессора не полная — проблема в свопе;
    — если загрузка процессора полная — проблема в вычислениях.
Сейчас на всём протяжении перекомпиляции имеем практически 100%-ную загрузку процессора.
  * Сейчас уже проблема находится не в свопе, а в затратах на вычисление.
  * Функция MOrder::Sort медленная и путей её ускорения я не вижу.

  Что предстоит сделать:
  * Сделать профилировщики более интеллектуальными. См. отдельное TODO.
  * Рассмотреть вопрос оптимизации кэша. На текущий момент звенья поля зрения в back-end’ах C++/SR
и Простого Рефала имеют размер 5 слов (20 и 40 байт на x86 и amd64 соответственно), что
не оптимально с точки зрения кэша процессора. Каждое звено включает в себя ссылки вперёд и назад
(по 1 слову), поле тега (из-за выравнивания — 1 слово, хотя хватило бы и байта), поле информации
(2 слова).
  Едиственная альтернатива в поле информации, занимающая два слова — ссылка на функцию, включающая
в себя указатель на функцию и указатель на её имя. Если в поле информации хранить не пару
указателей, а указатель на структуру, хранящую эту пару указателей, то звено уже будет кратно строке
кэша. Возможно снижение производительности, связанное с дополнительной косвенной адресацией, но оно
будет пренебрежимо мало по сравнению с затратами времени на всё остальное. Другим преимуществом
будет отход от генерации идентификаторов для представления имён функций в C++/SR.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  * Оптимизировать компоновщик back-end’а Рефала 5, возможно, путём хеширования.
  * Когда исследование совместного сопоставления с образцами будет завершено, внедрить этот механизм
оптимизации.
  
----------------------------------------------------------------------------------------------------
  [TODO] 21.10.2015 - 11:41:49,72

  Из того, что сделано.
  * Профилировщики сделаны интеллектуальными. Соответствующая задача закрыта.

  Из того, что предстоит сделать.
  * Рассмотреть вопрос по оптимизации кэша. Остаётся как есть, см. выше.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  Последние несколько месяцев проект Простого Рефала начал активно развиваться. Применительно
к текущей задаче — быстродействие компилятора заметно повысилось (приблизительно на 5…10 %). Имеет
смысл актуализировать версию Простого Рефала, входящую в проект Модульного Рефала как минимум
из соображений быстродействия.
  См. отдельное TODO.
  * Оптимизировать компоновщик back-end’а Рефала-5. Поиск путей оптимизации пока ведётся. Видятся
два варианта. Эволюционный: ищем в коде узкие места, оптимизируем их. Революционный: отказаться
от переименований функций и переменных на уровне компоновщика, вместо этого просто склеивать файлы.
Правильные имена функций и переменных давать сразу на этапе генерации «объектников».
  См. отдельное TODO.
  * Про совместное сопоставление с образцом. Ничего нового.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2015 - 10:21:12,56

  Back-end РЕФАЛа-5 оптимизирован, остальные пункты не потеряли актуальности.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Что касается оптимизации кэша (4-байтовые узлы), проведено такое исследование для Простого Рефала
(ветка 4bytes не в основной ветке, ветка черновая). Предварительные результаты — снижение
быстродействия на уровне статистической погрешности (около 1 %). Имеет смысл сделать, но только
ради экономии памяти.
  Оптимизация компоновщика профиля Простого Рефала имеет несколько направлений деятельности:
  * оптимизация самого компилятора Простого Рефала,
  * вызов компилятора Простого Рефала только для исходников, изменившихся с момента последней
компиляции.
  Очевидно, первый вариант следует обсуждать не тут, а в трекере самого Простого Рефала, поэтому
заметим, что в ближайшем будущем предстоит исследование некоторых оптимизаций Простого Рефала
в рамках бакалаврских квалификационных работ.
  Второй вариант также возможен и даже имеет больше смысла, ведь при неполной компиляции программы
back-end’ом компилируется весь набор исходников. Устранение избыточной компиляции принесёт большую
пользу, чем ускорение самого Простого Рефала на десятки процентов.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Последнее время я редко пользуюсь старым ноутбуком, поэтому задача пока не актуальна. Да и вроде
уже достигнуто приемлемое быстродействие (надо подумать над этим и закрыть задачу).


====================================================================================================
  [TOTHINK] ВПВ: Opensource-лицензия
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует выбрать opensource-лицензию. TOTHINK станет TODO когда лицензия будет выбрана. TODO
включит в себя задачу по внедрению лицензионного соглашения в исходные тексты программы.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Во-первых, компилятор коммерческой ценности не представляет, но может представлять научную или
программистскую ценность, поэтому для него следует использовать лицензию opensource.
  Во-вторых, из opensource-лицензий я предпочитаю либеральные по типу BSD, чем свободные GNU.
Дело в том, что код под либеральной лицензией можно использовать в рамках проектов под одной
из лицензий *GPL, но наоборот уже нельзя. Кроме того, BSD-лицензии разрешают использовать код
и в несвободном ПО. Таким образом, они налагают меньшее число ограничений.
  Из того, какие лицензии можно использовать. Во-первых, компилятор и библиотеки к языку следует
распространять под разными лицензиями: создание производного продукта на основе компилятора должно
требовать сохранения указания авторских прав в производном продукте, но создание производного
продукта на основе библиотеки (т.е. просто написание программы, использующей библиотеку) не должно
налагать такого ограничения.
  Для компилятора предпочтительны лицензии типа двухпунктовой BSD или MIT (они эквивалентны,
выбор — исключительно вопрос вкуса), для библиотек — «однопунктовая» BSD или Boost. В обоих случаях
распространение библиотек в исходном виде будет требовать сохранения копирайта, в двоичном виде —
нет.
  С конкретным выбором библиотек я пока не определился.
  Для Простого Рефала используется двухпунктовая BSD для компилятора и «однопунктовая» — для
библиотек.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.02.2016 - 11:42:56,37

  Временно выбрана двухпунктовая BSD для всего проекта. Лицензия на библиотечные компоненты будет
уточнена, возможно, позаимствована из Простого Рефала.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Пока неактуально придумывать что-то новое. Потом что-нибудь придумаю и закрою задачу.


====================================================================================================
  [TODO] Грамотная реализация библиотеки
====================================================================================================

  [TOTHINK] 10.07.2010 - 15:35:46,55

  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2, т.к. текущая версия библиотеки уже не-
плоха и вполне соответствует возможностям синтаксиса языка.
  С точки зрения грамотной реализации, текущая библиотека соответствует варианту пакета Std, но без
префикса Std и без альтернатив (Platform и BackEnd).
  Для выпуска публичной версии также не требуется, т.к. публичную версию вполне можно выпустить и с
текущей реализацией библиотеки.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея интересная, к ней следует стремиться. Но пока не актуально. Библиотеку лучше развивать
исходя из потребностей, и, время от времени, при мажорных релизах (до выпуска версии 1.0) делать
её рефакториг. Сейчас потребности перерабатывать библиотеку нет, но как часть генерального плана
развития данную задачу следует оставить.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Все вышеприведённые рассуждения остаются актуальными.
  Можно добавить, что модуль Platform::Refal5 уже был бы актуальным. Когда я реализовал нативные
вставки, я сделал частичный рефакторинг библиотеки — библиотечные модули без .mref я преобразовал
в регулярные, но со вставками на языке реализации. Для back-end’а Рефала-5 помимо обычных нативных
вставок с кодом была добавлена конструкция ALIAS, позволяющая создать псевдоним для функции
(вернее, идентификатора) Рефала-5 в целевом коде. И оказалось, что некоторые библиотечные функции
оказалось удобно переписать из нативной вставки в обычные функции Модульного Рефала, которые
вызывают встроенные функции Рефала-5 как псевдонимы. Побочным эффектом оказалось то, что многие
модули библиотеки теперь содержат псевдонимы для одних и тех же встроенных функций.
  Поэтому имеет смысл все эти псевдонимы собрать в одном месте и для этого места уже есть имя —
Platform::Refal5. Но имеет смысл это делать только при переработке библиотеки.
----------------------------------------------------------------------------------------------------
  [TODO] 17.02.2019 - 16:46:33,32

  Написан модуль Platform::Refal-5, через него описаны платформенно-зависимые функции библиотеки
для соответствующего профиля.


====================================================================================================
  [TOTHINK] Серьёзное расширение синтаксиса
====================================================================================================

  [TOTHINK] 06.11.2014 - 12:35:00,01

  Обоснование.
  1 Отсутствие вложенных функций приводит как к необходимости явного написания глобальных функций,
затем явно связываемых с контекстом, так и к сложночитаемым комбинациям функций при помощи средств
модуля MLambda ← таково краткое обоснование внедрения в язык хотя бы вложенных безымянных функций.
При этом внедрение в язык только вложенных безымянных функций может привести к похожему результату,
а именно к сложночитаемым комбинациям вложенных безымянных функций (при помощи комбинатора Y,
функций Composite и Fetch). Использование именованных функций полностью обесценивает комбинатор Y,
а соответствующие синтаксические средства снижают потребность в функциях Composite, Fetch и ряде
других. Таким образом, вложенные безымянные функции есть полумера.
  2 Во многих развитых диалектах Рефала есть механизм, позволяющий задавать дополнительные
ограничения на образец в левой части — условия в Рефале-5, неуспехи в других диалектах. Механизм,
очевидно, полезный, однако имитировать его при помощи одних лишь вложенных функций (не важно,
именованных или нет) достаточно трудно (без открытых e-переменных) или даже практически невозможно
(с открытыми e-переменными). Под трудностью и практической невозможностью подразумевается тот факт,
что код в результате получится чрезвычайно сложным и нечитаемым («овчина выделки не стоит»).

  Предлагается реализовать синтаксис, являющийся средним между Рефалом-5 и Рефалом-7: из Рефала-7
берём вложенные функции и действия ":", ",", "->", "::", "=", "=>", из Рефала-5 невозможность
возврата неуспеха из функции. Таким образом, неуспехи могут порождаться только действием ":"
(действие "::" при невозможности сопоставления аварийно останавливает программу), "," и "->"
прозрачны для неуспехов, "=" и "=>" непрозрачны для неуспехов (неперехваченный неуспех после
них приводит к аварийному останову программы), образец после ":" может перехватывать неуспех
(путём удлинения открытых e-переменных), образец после "::" не может перехватывать неуспех
(сопоставление однозначно).
  Вопрос об образцах после "::" (допустимы любые образцы, либо только жёсткие) требует
дополнительной проработки.
  Некоторые переменные могут помечаться как переопределяемые символом "^". Требуют проработки
следующие вопросы: символ "^" должен идти перед переменной или после, если переменная с крышкой
повторная в данном образце, все ли экземпляры должны быть помечены или не все, какие из них.

  В дальнейшем требуется:
  1 Подробнее сформулировать синтаксис и семантику
  2 Проработать указанные выше вопросы
  3 Продумать особенности реализации.
  4 Проанализировать плюсы и минусы возврата неуспехов из функций.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Есть интересные мысли, описывающие довольно цельный, но сложный и громоздкий синтаксис. Их нужно
оформить в виде отдельной спецификации, а также решить, воплощать ли их в программе.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 13.03.2016 - 23:24:12,47

  Предлагается функции делить на три вида (modes):
  1. Чистые функции. Далее — просто функции. Они не могут возвращать неуспех, всегда детерминированы
и не имеют побочных эффектов. Им соответствует символ "&"
  2. Функции, способные вернуть неуспех. Далее — функции-предикаты или просто предикаты. Они чистые,
то есть детерминированы и не имеют побочных эффектов. Им соответствует символ "?".
  3. Недетерминированные функции и/или функции с побочными эффектами. Далее — процедуры (ну не нашёл
другого подходящего слова). Они не могут возвращать неуспех. Им соответствует символ "!".

  Чистые функции могут вызывать только чистые функции и предикаты. При этом, если вызываемые
предикаты возвращают неперехваченный неуспех, происходит аварийное завершение программы. Вызвать
из чистой функции процедуру напрямую синтаксически невозможно, косвенно (по указателю) — приведёт
к тому же авосту во время выполнения.
  Предикаты могут вызывать только чистые функции и другие предикаты. Неперехваченный неуспех
из вызываемого предиката приводит к неуспеху вызывающего предиката. Вызов процедур невозможен
аналогично случаю с чистыми функциями.
  Процедуры могут функции любого вида. Неперехваченный неуспех в процедуре приводит к аварийному
завершению программы.

  Вид функции указывается в объявлении функции:

    &PureFunction {
      …
    }

    PureFunction2 {
      …
    }

    ?Predicate {
      …
    }

    !Procedure {
      …
    }

  При этом у чистых функций знак "&" можно опускать. Вызов функции оформляется аналогично:

    … <&PureFunction …> …
    … <PureFunction2 …> …
    … <?Precicate …> …
    … <!Procedure …> …

    … <& s.FnPureFunction …> …
    … <s.FnPureFunction …> …
    … <? s.FnPrecicate …> …
    … <! s.FnProcedure …> …

  Точно также, в скобках вызова чистой функции знак "&" можно опускать. Последние четыре примера
выше — косвенный запуск. В ряде случаев допустимо косвенно вызывать функцию не того вида, какой
ожидается в вызове — при этом получаем вполне ожидаемое поведение:

    ┌──────────┬───────────────────────────────────────┐
    │          │               Вызов                   │
    │ Функция  ├───────────────────────────────────────┤
    │          │  <& s.Func>   <? s.Func>   <! s.Func> │
    ├──────────┼───────────────────────────────────────┤
    │ &Func    │      ++           ++           ++     │
    │ ?Func    │      +-           ++           +-     │
    │ !Func    │      --           --           ++     │
    └──────────┴───────────────────────────────────────┘

  Обозначения:
  ++ — полностью поддерживается.
  -- — приводит к аварийному останову.
  +- — приводит к аварийному останову при возврате неуспеха вызываемой функции.

  Функция есть набор предложений, синтаксис отдельного предложения:

    Sentence = Pattern { Action }+.
    Action =
        "=" Result
      | "?=" Result
      | "," Result
      | ":" Pattern
      | "::" Pattern
      | "=>" Mode Result
      | "?=>" Mode Result
      | "->" Mode Result
      | Mode "~" Result
      | ( "\&" | "\?" | "\!" ) Pattern Action
      .
    Mode = ( "&" | "?" | "!" ).
    Mode = [ ModeReq ].

  Рассмотрим отдельно каждый из вариантов.
  1. "=" Result — результатное действие, непрозрачное для неуспехов. При возникновении
неперехваченного неуспеха справа от знака "=" происходит аварийный останов программы. Действие
допустимо в любых видах функций.
  2. "?=" Result — результатное действие, способное вернуть неуспех. При возникновении
неперехваченного неуспеха справа от знака "?=", результатом всей функции становится неуспех.
Действие допустимо только в функциях-предикатах.
  3. "," Result — результатное выражение, прозрачное для неуспехов — передаёт неуспех справа-налево.
Действие допустимо в любых видах функций.
  4. ":" Pattern — образцовое действие, способное вернуть неуспех и прозрачное для неуспехов. При
возникновении неуспеха справа от действия, осуществляется поиск нового сопоставления с образцом.
Если удалось сопоставить образец другим образом, выполнение передаётся на следующее действие
предложения. В противном случае действие возвращает неуспех. Действие допустимо в любых видах
функций.
  5. "::" Pattern — перестройка — образцовое действие, прозрачное для неуспехов, но сопоставляющееся
всегда успешно и однозначно. При невозможности сопоставления с образцом программа аварийно
завершается. При возникновении неуспеха справа от действия неуспех передаётся справа-налево.
  6. "=>" @ Result — действие-вызов, непрозрачное для неуспехов. Здесь и ниже @ заменяет "&", "?"
или "!".  Синтаксический сахар. Конструкция
    =>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 = R1 :: e.Env2 = <@ e.Env2 e.Env1>
Действие допустимо в любых видах функций.
  7. "?=>" @ Result — действие-вызов, способное вернуть неуспех. Синтаксический сахар. Конструкция
    ?=>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 ?= R1 :: e.Env2 ?= <@ e.Env2 e.Env1>
Действие допустимо только в функциях-предикатах.
  8. "->" @ Result — действие-вызов, прозрачное для неуспехов. Синтаксический сахар. Конструкция
    ->@ R1
эквивалентна следующей конструкции:
    :: e.Env1, R1 :: e.Env2, <@ e.Env2 e.Env1>
  9. @ "~" Result — действие декаррирования. Прозрачно для неуспехов. Синтаксический сахар.
Конструкция
    @~R1
эквивалентная следующей конструкции:
    :: e.Env1, <@ e.Env1 R1>.
Действие допустимо функциях любых видов.
  10. "\@" Pattern Action — лямбда. Допустима только после результатных действий. Синтаксический
сахар. Конструкция
    … R1 \@ P2 sentence-tail;
эквивалентна
    … R1 @{ P2 sentence-tail; };
Конструкция допустима в любых видах функций. Конструкция может быть полезна для использования в DSL
для каких-нибудь монад или ещё чего-то.

  Вложенные функции могут быть как безымянные, так и именованные. Безымянные имеют вид:
    … &{ … } …
    … { … } …
    … ?{ … } …
    … !{ … } …
Именованные:
    … $func &Pure { … } …
    … $func Pure2 { … } …
    … $func ?Pred { … } …
    … $func !Proc { … } …
Как и ранее, знак "&" допустимо опускать.
  Указатели на глобальные функции представляют собой имена функций, предварённые символом вида:
    FnPtr = ModeReq IDENTIFIER | Mode DotQualifiedName.

  Скобки активации существенно усложнились:

    CallTerm = "<" CallInit { Action } ">".
    CallInit =
        Mode Callable Result
      | "=" Result
      .
    Callable = FunctionName | Variable | CallTerm | FnPtr.
    FunctionName = QuadQualifiedName.

  Смысл здесь в том, что в угловых скобках теперь не просто вызов функции с аргументом-результатным
выражением, а целое предложение, начальный компонент которого — либо вызов функции, либо просто
порождение результата. Список вызываемых объектов теперь включает также все виды переменных, либо
другие скобки вызова — почти всё, что угодно.
  Конструкция "=" Result инициализирует среду значением данного результатного выражения. Таким
образом, запись <= R1> будет эквивалентна просто R1. Смысл конструкции в том, чтобы можно было
писать такие конструкции:
    <=
      <CalcSomething> => {
        Success = …;
        Fails = …;
      }
    >
что эквивалентно идиоме <Fetch …> Простого Рефала:
    <Fetch
      <CalcSomething> {
        Success = …;
        Fails = …;
      }
    >


  Заключение.
  Это описание намеренно сделано нечётким, есть куча неописанных деталей. Причина — это всего лишь
черновик описания. В частности, остаются вопросы:
  1. В ряде мест конфликтуют имена, квалифицированные квадроточием, и перестройки. А не отказаться
ли нам от имён с квадроточиями вообще — перейти на точку? Или можно сделать компилятор
интеллектуальным — догадываться в каждом конкретном случае, что имел ввиду программист. Если
допустимы оба варианта, выдавать ошибку?
  2. Вопрос реализации — надо продумать, как генерить оптимальный код для этих конструкций.
  3. Остался вопрос по перестройкам — должны ли после них быть только жёсткие выражения.
  4. Никак не затронут вопрос переопределения переменных.

  А неуспехи из функций нужны. Они могут существенно поднимать выразительность кода. Но они должны
быть явно синтаксически выделены. Также полезно выделять функции с побочным эффектом. Поэтому как-то
так.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 14.03.2016 -  1:06:36,70

  Дополнительные вопросы:
  5. Синтаксис оказался довольно сложен. Нужно либо обосновать сложность синтаксиса с идеологических
позиций, либо упростить.
  6. Вопрос: можно ли создать в одном модуле несколько функций с одинаковым именем и разными видами?
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Предложенное расширение синтаксиса, если кратко, предлагает следующие цели:
  * Синтаксические конструкции Рефала-7.
  * Разделение на уровне синтаксиса для чистых функций, функций с неуспехами и нечистых.
  * Расширение синтаксиса угловых скобок — синтаксический сахар.

  Вторая цель интересна и важна — она полностью соответствует идеологии Модульного Рефала:
надёжность и контроль на стадии компиляции.
  Третья цель — удобный синтаксический сахар, на сколько полезен, ещё вопрос.

  А вот на первую цель я сейчас смотрю скептически. Дело в том, что Рефал-7 не замкнут относительно
прогонки, а значит, промежуточное представление будет отличаться от синтаксического дерева, если
я буду делать эту оптимизацию.
  Для замыкания необходимы два синтаксических средства: механизм управления неуспехами
и результатные блоки. И того, и другого во входном синтаксисе нет.
  Когда я предлагал новый синтаксис, я этого ещё не понимал, думал, что результатные блоки — это
просто удобный синтаксис, без которого, однако, можно вполне обойтись. Оказалось, что наоборот.
И чтобы писать эффективно оптимизируемые программы, программист должен мыслить в терминах
оптимизатора, а значит, результатные блоки должны быть.

  Следовательно, надо продумывать внедрение синтаксических конструкций Рефала Плюс/Рефала-6.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 02.06.2018 - 13:46:23,43

  Некоторые дополнительные мысли к этой задаче.

  В препринтах:

• С. А. Романенко. Рефал-4 — расширение Рефала-2, обеспечивающее выразимость результатов прогонки. —
  М.:ИПМ им. М. В. Келдыша АН СССР, 1987, препринт N 147. — 27 с.
  http://pat.keldysh.ru/~roman/doc/1987-Romanenko--Refal-4_-_rasshirenie_Refala-2.pdf
• С. А. Романенко. Прогонка для программ на Рефале-4. — М.:ИПМ им. М. В. Келдыша АН СССР, 1987,
  препринт N 211. — 19 с.
  http://pat.keldysh.ru/~roman/doc/1987-Romanenko--Progonka_dlya_programm_na_Refale-4.pdf

предложено минимальное расширение Базисного Рефала, обеспечивающее выразимость прогонки. Расширение
включает в себя перестройки (условия в терминах Рефала-5), ветвления (результатные блоки в терминах
Рефала-6) и средства управления неуспехом — калитки (#GATE) и заборы (#FENCE).

  Если хочется обеспечить выразимость прогонки, то придётся обеспечить «ядро» языка, содержащее
эти синтаксические конструкты.

  Внезапно: интересная мысль. Если в Рефал-5 добавить средства управления неуспехами и «оконечные»
«образцовые» блоки заменить «результатными», то в нём тоже будет выразима прогонка. Позже эта мысль
раскроется.

  В отличие от блоков Рефала Плюс и Рефала-6, во внутрь ветвления в Рефале-4 можно попасть как
слева-направо (при обычном выполнении программы), так и справа-налево (при перехвате неуспеха).
В последнем случае управление вернётся в последнюю выполненную ветвь.
  Эту семантику можно имитировать путём приписывания в конец каждой ветви блока остатка
предложения. Более того, во втором препринте эта операция как раз и описывается, как эквивалентное
преобразование.

  Поэтому можно для эквивалентных преобразований, которые описаны в препринте как

    R : L → #ALT A1 A2 … AN #END
    R : L → #GATE #ALT A1 A2 … AN #END

описать эквивалентные преобразования для такого «модифицированного Рефала-5» в виде

    R : L хвост → { A1 хвост; A2 хвост; … ; AN хвост }
    R : L хвост → $gate { A1 хвост; A2 хвост; … ; AN хвост }

При таком подходе все преобразования Романенко останутся в силе.

  Синтаксис «модифицированного» Рефала-5 можно описать следующим образом:

    Функция = ИМЯ "{" { Предложение ";" } "}".
    Предложение = Образец Хвост.
    Хвост =
        "=" Результат
      | ("," | "$gate" | "$fence") Тропа
      | "$fail" | "$error"
      .
    Тропа =
        Результат ":" Образец Хвост
      | РезультатныйБлок
      .
    РезультатныйБлок = "{" { Хвост ";" } "}" .

  Как-то так. Теперь надо думать, как объединить вот это «ядро» с возможностями синтаксиса
(богатого полезным синтаксическим сахаром), описанными ранее.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 12.12.2020 - 23:12:12,92

  Сразу весь новый синтаксис реализовывать трудоёмко. Во-первых, писать его придётся на имеющемся
базисном Рефале, что уныло. Во-вторых, для него необходимо другое представление данных, в котором
копирования выполняются более эффективно = нужно писать новый back-end с рантаймом.

  Поэтому реализовывать новый синтаксис надо по частям. Каждое новое средство, добавленное
во входной язык, упрощает и ускоряет дальнейшую разработку. Если добавить хотя бы часть новых
возможностей, это уже даст заметное повышение выразительности.

  Ниже будут приведены начальные шаги реализации нового синтаксиса. Они образуют лишь подмножество
синтаксиса, описанного выше. В частности, полноценных неуспехов и действий не будет. Но предложенные
средства уже в несколько раз повысят выразительность языка. Также будут прояснены некоторые
синтаксические детали, которые выше были оставлены за кадром.

  Шаги будут описаны в некотором порядке, и этот порядок не случаен.

  Шаг 1. Перестройки-присваивания.
  После образцового предложения может следовать ноль или более конструкций вида

  "," Result "::" HardPattern

  Образец должен быть жёстким выражением. Все переменные в нём новые — если в нём есть переменная
с индексом, которое ранее встречалось в предложении, считается, что перестройка объявляет новую
переменную с тем же индексом, которая сокрывает исходную в остальной части предложения. И это
поведение невозможно изменить. Если сопоставление с жёстким выражением невозможно, получаем ошибку
времени выполнения. В будущем в этом месте возможна статическая проверка форматов.
  Введение перестроек уже позволит избежать написания кучи вспомогательных функций и упростит
дальнейшую разработку.

  Шаг 2. Условия при простых образцах.
  После образцового выражения кроме перестроек могут присутствовать условия вида

  "," Result ":" Pattern

  Условия и перестройки могут перемежаться между собой произвольным образом. В предложении образец
самого предложения и образцы других условий, предшествующих некоторому, должны быть «простыми».
«Простой» образец не содержит подвыражений вида e.1 … e.2, т.е. заведомо не содержит открытых
e-переменных, а также повторных e-переменных определённого вида. Вообще, достаточно запретить только
открытые переменные, но для упрощения анализа можно наложить ограничение и пожёстче.
  Перестройки, в отличие от присваиваний Рефала-5λ, являются прозрачными для неуспехов, порождённых
условиями.
  Запрет открытых переменных в образцах перед условиями позволяет их рассахаривать в базисный Рефал
относительно малыми усилиями (т.к. работа с открытыми переменными — вообще жесть).
  Если образец условия содержит переменные с индексами, которые встречались ранее в предложении,
то они должны быть явно помечены или как повторные, или как новые. Повторные переменные помечаются
символом "@" перед переменной, новые — символом "^". Помечается только самое левое вхождение
переменной. Переменная с известным индексом без пометки является синтаксической ошибкой. Переменная
с новым индексом и с пометкой тоже является синтаксической ошибкой.
  Ограничение с пометками выглядит жёстким. Если практика покажет, что оно больше ограничивает, чем
помогает, от него можно отказаться.

  Шаг 3. Реализация вложенных функций.
  Полная реализация подразумевает, что в компиляторе уже реализованы рантайм на Модульном Рефале
(#13) и ООП (#1). Но можно сделать неполную реализацию.
  Замыкание реализуется как АДТ вида [Closure s.Func e.Context], для вызова t-переменной пишется
функция <Call …> или <Apply …>. Для профилей SimRef и C++/SR объект замыкания и саму функцию
можно поместить в mrefalrts.sref, для профиля R5 — захардкодить в линковщике (как это сделано для
инициализации и финализации).
  Переменные с известными индексами в образцах внутри вложенных функций (начало предложения,
условия) оформляются точно также, как и для условий, знаками "@" и "^". Переменные с известными
индексами в присваиваниях внутри вложенных функций — тоже всегда новые.
  Вложенные функции могут быть как безымянными, так и именованными. Именованные вложенные функции
здесь не представляют большой проблемы, т.к. их проверка на равенство выполняется по значению.
В Рефале-5λ замыкания сравниваются по ссылке, поэтому для именованных функций потребовались бы
циклические ссылки, что затруднит управление памятью.
  Но вложенные функции пишутся не только сами по себе, они необходимы для следующего шага.

  Шаг 4. «Образцовые блоки».
  Добавляется синтаксис вида

  "->" Callable Result

  Это действие можно писать после любого результатного выражения — в перестройках, условиях
и в правой части. Таким образом, после знака "=" в правой части может быть результатное выражение
с одним или несколькими блоками. Либо просто одно результатное выражение. Знак "=" в предложении
может быть только один (исключая эти знаки во вложенных функциях).

  Вложенные функции можно делать независимо от шагов 1 и 2, однако шаги 1 и 2 (особенно, 1)
упростят работу по их реализации.

  Все вышеперечисленные конструкции бесхитростно рассахариваются до базисного Рефала, но при
этом серьёзно повышают выразительность языка. Поэтому они и предложены.

  После описанных расширений уже можно разрабатывать новый back-end и новое представление
данных в памяти, для которого можно реализовать достаточно эффективный Рефал с неуспехами.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.08.2025 - 17:02:27,98

  Есть соображение отказаться от всего (или почти всего), описанного ранее, и предложить
совершенно новый взгляд на развитие синтаксиса Модульного Рефала: не косплеить Рефал-6 или
Рефал-7, усложняя их синтаксис, а пойти иначе.
  Недостаток предложенного ранее варианта в том, что в языке присутствуют неуспехи, более
приручённые, чем в Рефале-6 или Рефале-7, но тем не менее они есть. Неуспех — конструкция языка,
прерывающая нормальное выполнение предложения и вызывающая переход куда-то, почти как исключение.
Если, как в Рефале-6 или -7, любая функция может сформировать неуспех, то условие , R : P может
не выполниться не только из-за неудачи сопоставления с образцом, но и из-за неудачи при выполнении
любого вызова функций в R. Конечно, их можно ограничивать, например, синтаксически требуя, чтобы
вызовы функций, порождающих неуспехи, записывались как <?Func …> и тем самым упрощать отладку —
опасный вызов становится очевидным. Но есть и другая сторона — при использовании неуспехов всегда
нужно думать, где этот неуспех ловится, а это может быть неочевидно — приходится читать код задом
наперёд. Заборы и калитки, управляющие силой неуспеха, ещё более усложняют программирование.

  В Рефале-5 передачи неуспехов ограничены лишь условиями, из блоков неуспехи выходить не могут.
С одной стороны, это повышает надёжность программ, с другой понижает выразительность и делает
невыразимой прогонку.

  Выразимостью прогонки, на мой взгляд, можно пожертвовать ради надёжности и удобства разработки.

  Пора к делу. Предлагается новый синтаксис, допусающий условия, блоки, перестройки и прочие
радости выразительного синтаксиса, однако, полностью лишённый понятия неуспеха. Прогонка в нём
будет невыразима, но этим мы жертвуем. Как ни странно, синтаксис будет напоминать Рефал-6, однако,
всё будет описано в другой терминологии, более понятной программисту — в терминах логических
выражений!

  Сначала мы рассмотрим ядро синтаксиса, а затем надстройки типа синтаксического сахара, причём
чёткой границы у ядра не будет.

  В основе синтаксиса управляющих конструкций лежит логическое выражение, описываемое следующим
синтаксисом:

  Сумма = Слагаемое {(";" | "|") Слагаемое}.
  Слагаемое = ε | Непустое слагаемое.
  НепустоеСлагаемое = Множитель ["," НепустоеСлагаемое].
  Множитель = "{" Сумма "}" | ...

  Сумма — дизъюнкция слагаемых, истинна, когда хотя бы одно слагаемое истинно. Слагаемые разделяет
точка с запятой или вертикальная черта — они взаимозаменяемы. Можно использовать традиционную
для Рефала точку с запятой, можно черту.

  Слагаемое — конъюнкция множителей. При этом слагаемое может записываться пустотой — такое
слагаемое считается тождественно ложным, что позволяет завершать (или даже начинать) сумму точкой
с запятой или вертикальной чертой — если после последнего непустого слагаемого стоит разделитель,
то он как бы означает «или ложь». Множители непустого слагаемого разделяются запятой. Есть соблазн
использовать и знак «&», но это приведёт к неоднозначности — амперсенд уже используется для
создания указателя на функцию. Вариант: поменять синтаксис указателей на функцию, используя,
например, знак «*», как в Рефале-6, и допустить знак «&» как альтернативу запятой.
  Обратим внимание, что конъюнкция правоассоциатина.

  Для группировки используются фигурные скобки, поэтому один из вариантов множителя — сумма,
записанная в фигурных скобках. Рассмотрим другие варианты множителя:

  Множитель = "{" Сумма "}" | Перестройка | Условие | Отрицание | ВызовПредиката.
  Перестройка = Результат "::" Образец.
  Условие = Результат ":" Образец.
  Отрицание = ! ("{" Сумма "}" | Предикат).
  ВызовПредиката = "<" Функция "?" Результат ">".

  Перестройка всегда истинна, образец перестройки является жёстким выражением, переменные всегда
новые (т.е. если ранее уже означивалась переменная с данным именем, то переменная из перестройки
её перекрывает). При неудаче сопоставления программа аварийно завершается. В перспективе здесь
возможна проверка форматов, допускающая только успешные перестройки.
  Условие истинно, когда споставление оказалось успешным и наоборот. Здесь играет роль правая
ассоциативность — в конструкции

  Результат "::" Образец "," НепустоеСлагаемое

если в образце есть открытые переменные, будет подбираться такое удлинение, чтобы остаток
слагаемого оказался успешен. Здесь также будут использоваться знаки ^ и @ перед именем переменной
для повторной и новой соответственно, как было описано ранее.
  Отрицание инвертирует логическое значение суммы, записанной в скобках, или предиката. Синтаксис
множителя не описан как «! Множитель», т.к. у отрицания перестройки смысла нет, а с отрицанием
условия становится неочевидной видимость переменных и ассоциативность (условие после отрицания
условия относится к образцу отрицания или нет).
  Вызов предиката — это вызов функции, которая должна вернуть или символ True, или символ False.
Соответственно, в первом случае вызов предиката будет истинным, во втором — ложным. Если функция
вернула что-то иное, то программа завершается аварийно. Предикатом будем называть функцию, которая
возвращает или символ True, или символ False. Заметим, что в именах функций нужно будет запретить
знаки вопроса, т.к. знак вопроса после имени функции позволяет отличить её от предиката. Вариант
синтаксиса, знак вопроса можно ставить не после имени, а между открывающей скобкой и именем:

  ВызовПредиката = "<?" Функция Результат ">".

Заметим, что внутри результатных выражений вызов функции выглядит только как <Имя Аргумент>, без
всяких знаков вопроса.

  Перестройки и условия могут определять новые переменные, чья видимость начинается с образца
и по умолчанию заканчивается в конце текущего слагаемого. Предлагаемый синтаксис вводит понятие
экспортируемой переменной — переменной, которая определяется внутри фигурных скобок. Чтобы сумма
в скобках определяла новую переменную, нужно, чтобы каждое непустое слагаемое суммы эту переменную
определяло и эта переменная в каждом слагаемом была помечена восклицательным знаком после имени
переменной. Пример:

  { <Foo> : Ok (e.X!) e.Y, 1 :: e.A! | <Bar> : Ok (e.Y) e.X!, 2 :: e.A! }, <Prout e.X e.A> : e._

  Здесь экспортируются переменные e.X и e.A. Переменная e.Y не экспортируется, не смотря на то,
что она определяется в обоих слагаемых. Можно было бы сформулировать более простое правило:
«переменная экспортируется, если в каждом непустом слагаемом она определена», но из соображений
надёжности введено явное обозначение для экспорта.
  Восклицательных знаков может быть несколько, что говорит о том, что переменная экспортируется
сразу на несколько уровней:

  { … e.X! … | … { … e.X!! … | … e.X!! … } … | … e.X! }

Чтобы «поднять» переменную из дважды вложенных фигурных скобок, здесь добавлены два восклицательных
знака. Количество восклицательных знаков при экспортируемой переменной будем называть уровнем
экспорта (формально: уровень экспорта у неэкспортируемой переменной нулевой).

  Заметим, что некоторые типичные применения управления неуспехами могут быть заменены описываемым
синтаксисом. Например, следующее слагаемое имеет квадратичную сложность:

  <GetKey> :: s.Key, e.X : e.X-B (s.Key s.X) e.X-E, e.Y : e.Y-B (s.Key s.Y) e.Y-E

  Здесь происходит поиск в двух ассоциативных списках по одному и тому же ключу. Согласно описанной
семантике непустого слагаемого, при неудаче во втором условии первое условие будет перебирать все
возможные удлинения, что даст квадратичную сложность. В языках с управлением неуспехами здесь бы
добавили соответствующие конструкции отсечения (я ими не владею, поэтому не рискну приводить
пример). В предлагаемом синтаксисе можно воспользоваться скобками и экспортируемыми переменными:

  <GetKey> :: s.Key, { e.X : e.B (s.Key s.X!) e.E }, { e.Y : e.B (s.Key s.Y!) e.E }

  Здесь экспортируются переменные s.X и s.Y, переменные e.B и e.E видны только в своих фигурных
скобках, снаружи они не нужны.

  Введём понятие синтаксической факторизации. Их будет две: левая и правая. Левая вводит новый
синтаксис, а правая является синтаксическим сахаром.

  Рассмотрим случай суммы в фигурных скобках, в которой каждое слагаемое начинается на условие
с одной и той же левой частью:

  { R : P1, … | R : P2, … | … | R : Pn, … }

  Тогда левой синтаксической факторизацией назовём запись, когда результатное выражение «вынесено
за скобки»:

  R : { P1, … | P2, … | … | Pn, … }

  Заметим, что это не эквивалентное преобразование: если вычисление результатного выражения R
не является чистым (недетерминированное или имеет побочный эффект), то в первом случае оно может
несколько раз осуществить побочный эффект либо вычислиться в разные значения, а во втором случае —
нет. Поэтому факторизация и названа синтаксической — выглядит, как вынос общей конструкции
за скобки, но семантика при этом меняется. Левая синтаксическая факторизация будет эквивалентным
преобразованием, только если выражение R не содержит вызовов функций.

  В принципе, выражение

  R : { P1, … | P2, … | … | Pn, … }

может быть эквивалентно рассахарено в базовый вариант суммы следующим образом:

  R :: e.new, { e.new : P1, … | e.new : P2, … | … | e.new : Pn, … }

где e.new — переменная с индексом, который больше нигде не встречается. В такой трактовке левая
синтаксическая факторизация становится эквивалентным преобразованием.

  Правая синтаксическая факторизация, напротив, является эквивалентным преобразованием. Рассмотрим
сумму в скобках, где каждое слагаемое заканчивается на перестройку с одной и той же правой частью,
при этом в образце перестройки все переменные экспортируются:

  { …, R1 :: P | …, R2 :: P | … | …, Rn :: P }

  Тогда правой синтаксической факторизацией назовём запись, в которой образец перестроек «вынесен
за скобки» и уровень экспорта каждой переменной в нём понижен на единицу (на это указывает штрих):

  { …, R1 | …, R2 | … | …, Rn } :: P′

  Пример, демонстрирующий экспорт переменных, может быть переписан с использованием правой
факторизации:

  { <Foo> : Ok (e.X!) e.Y, 1 | <Bar> : Ok (e.Y) e.X!, 2 } :: e.A, <Prout e.X e.A> : e._

Здесь мы увидели, что оба слагаемых заканчиваются на перестройку с :: e.A! в правой части
и воспользовались преобразованием буквально. Можно этот пример переписать вообще без экспорта
переменных:

  { <Foo> : Ok (e.X) e.Y, e.X 1 | <Bar> : Ok (e.Y) e.X, e.X 2 } :: e.X e.A, <Prout e.X e.A> : e._

  Заметим, что синтаксическая факторизация может выполняться и рекурсивно:

  { …, R1 :: P! | …, { …, R2 :: P!! | …, R3 :: P!! } }
  { …, R1 :: P! | …, { …, R2 | …, R3 } :: P! }
  { …, R1 | …, { …, R2 | …, R3 } } :: P

  Для повышения надёжности программ синтаксис слагаемого расширим следующим образом:

  Слагаемое = [НепустоеСлагаемое ["=" НепустоеСлагаемое]].

  В синтаксис слагаемого мы добавили знак «=», который может заменять не более чем один знак
конъюнкции («,» или, возможно, «&»). Истинность слагаемого определяется истинностью части,
предшествующей знаку равенства — часть слагаемого после равенства всегда должна быть истинной,
иначе программа должна завершиться аварийно.

  Рассмотрим определение функции:

  ИмяФункции { ТелоФункции }

  Синтаксис и семантика вычисления тела функции описывается путём построения следующего логического
выражения:

  e.Argument : { ТелоФункции } :: e.Result

где переменная e.Argument содержит аргумент функции, а переменная e.Result должна получить значение
результата. Предполагается, что переменных e.Argument и e.Result в теле функции нет. Из этой записи
следует, что тело функции должно быть записью суммы, подвергнутой и левой, и правой синтаксической
факторизации.
  Если это логическое выражение приняло ложное значение, то, очевидно, переменная e.Result
не получила значения. В этом случае программа завершается аварийно.

  Для записи предикатов можно использовать следующий синтаксический сахар:

  ИмяФункции? { ТелоФункции }

  В данном случае тело функции вычисляется как

  e.Argument : { ТелоФункции }

  Если данное выражение истинно, то функция возвращает символ True, если ложно — False.

  Заметим, что можно написать функции, возвращающие True или False, не содержа при этом самих
символов True и False:

  AlwaysTrue? {
    e.X = ::   /* перестройка всегда истинна */
  }

  AlwaysFalse? {
    e.X, {}    /* пустое слагаемое всегда ложно */
  }

  Для большей наглядности вместо здесь использовалась новая терминология вместо привычной:
слагаемое вместо предложения и сумма в скобках вместо блока. Новая терминология не отменяет старой,
а просто вводит синонимы. В названии факторизаций слово «синтаксическая» будем иногда опускать.

  Блок, подвергнутый левой синтаксической факторизации, можно рассматривать как функцию,
принимающую аргумент. Если блок также подвергнут и правой синтаксической факторизации, то получаем
обычную функцию, возвращающую значение, если нет — предикат, возвращающий True или False.

  Можно описывать рекурсивные блоки при помощи синтаксиса:

  Результат ":" "$rec" ИмяБлока ["?"] "{" ТелоБлока "}"

  В качестве примера рассмотрим функцию-предикат, проверяющую дерево на корректность:

  ValidTree? {
    t.Tree
      , None t.Tree None
      : $rec ValidTreeRec? {
          s.Min Leaf s.Max

        | s.Min (Tree s.Key t.Value t.Left t.Right) s.Max
          , { s.Min : None | <Order.Lt? s.Min s.Key> }
          , { s.Max : None | <Order.Gt? s.Max s.Key> }
          , <ValidTreeRec? s.Min t.Left s.Key>
          , <ValidTreeRec? s.Key t.Right s.Max>
        }
  }

  Если поменять синтаксис для указателей на функции, то можно разрешить разделять сомножители
амперсендом:

  ValidTree? {
    t.Tree
      & None t.Tree None
      : $rec ValidTreeRec? {
          s.Min Leaf s.Max

        | s.Min (Tree s.Key t.Value t.Left t.Right) s.Max
          & { s.Min : None | <Order.Lt? s.Min s.Key> }
          & { s.Max : None | <Order.Gt? s.Max s.Key> }
          & <ValidTreeRec? s.Min t.Left s.Key>
          & <ValidTreeRec? s.Key t.Right s.Max>
        }
  }

  Ранее предлагалось различать функции-предикаты, чистые функции и процедуры. В данном расширении
откаты отсутствуют, поэтому предикаты не актуальны. Но различать чистые функции и процедуры
по-прежнему можно.

  В новом синтаксисе неочевидно, как записывать вложенные функции. Множитель может быть блоком
и может начинаться с результатного выражения (перестройка, условие), поэтому просто так записывать
вложенные функции, как в Рефале-7 или Рефале-5λ не получится. Возможен синтаксис &{ … } (типа,
указатель на блок-функцию) или *{ … } (тоже самое, если заменить синтаксис указателей на функции
в стиле Рефала-6). Для вложенных именованных функций можно использовать запись $func Имя { … },
для предикатов, соответственно, — $func Имя? { … }.

  В определениях функций можно разрешить опускать внешние фигурные скобки:

  Функция Тело;     /* e.Argument : Тело :: e.Result */
  Предикат? Тело;   /* e.Argument : Тело */

  Однако, мне бы хотелось, наоборот, запретить этот синтаксис — сделать фигурные скобки
обязательными. В этом случае в место между именем и «{» можно поместить какую-то полезную
информацию, вроде описания формата функции.

  Для обычной функции к телу приписываются «e.Argument :» и «:: e.Result», для предиката только
первое. Можно ввести «сырые» функции, к которым ничего не приписывается. Синтаксис:

  Имя $RAW {
    ТелоФункции
  }

  Тело функции представляет собой блок, не подвергнутый никакой факторизации. В нём допустимо
использовать переменные $arg и $res, переменная $arg — e-переменная, хранящая аргумент, $res имеет
«бесконечный» уровень экспорта и должна экспортироваться из тела. Если тело функции вычисляется
в ложь, программа завершается аварийно. Пример сырой функции:

  DropFirst $RAW {
    $arg : t.Drop $res
  }

  Можно придумать сырой предикат:

  AllSpaces? $RAW {
    ' ' $arg : $arg ' '
  }

  Если исключить условия при открытых переменных, то описанный синтаксис можно рассахаривать
в базисный Рефал. Также можно рассахаривать в Рефал с условиями — все три back-end’а условия
поддерживают (с C++/SR надо повозиться, а с остальными проще).

  P.S. Идея появилась где-то год назад, сейчас я её решил зафиксировать.


