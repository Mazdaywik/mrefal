====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.


====================================================================================================
  [TODO] Удалить MRefalRTS::Put
====================================================================================================

  [TODO] 02.02.2008 - 17:55:52,95

  См. выше, почему это не особо критично.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Можно и удалить. Ведь, если необходимо, всегда можно добавить. На данный момент функцией MSelfDi\
ag::Log-T я пользуюсь довольно редко. Чаще я с целью трассировки функции Func пишу следующий код:

// До трассировки

Func {
  // Тело функции Func. Формат функции такой: <Func t.X e.Y (e.Z)> == ...
}

// После трассировки

Func
  t.X e.Y (e.Z) =
    <MSelfDiag::Log>
    <MSelfDiag::Log '<Func>'>
    <MSelfDiag::Log '  t.X = ' t.X>
    <MSelfDiag::Log '  e.Y = ' e.Y>
    <MSelfDiag::Log '  e.Z = ' e.Z>
    <?Func t.X e.Y (e.Z)>;

?Func {
  // Тело функции Func.
}

  Очевидно, что вместо этого лучше включить в язык/компилятор нормальное средство трассировки, но
я сейчас не буду описывать это как TODO. Т.к. (а) до выхода версии 0.2 я не собираюсь изменять син-
таксист, (б) запись прямо здесь этого как TODO сделает его приоритетным. Пункт (б) не критичен, т.к.
описать TODO можно и после закрывающей скобки.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках в журнале проекта
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.02.2009 - 21:42:25,09

  К версии 0.2 непосредстенно не относится.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 26.04.2009 - 12:56:39,09

  Сегодняшняя реализация на Модульном Рефале потенциально способна работать с именами модулей, па-
кетов или квалифицированными именами любой длины. Однако создать модуль с килобайтным именем. Слиш-
ком длинные квалифицированные имена невозможны из-за ограничений файловой системы: максимальная дли-
на пути в Windows равна 260 байтам. Поэтому при попытке создать модуль с очень длинным именем, мы
всего лишь столкнёмся с ошибкой невозможности открытия файла: программа рухнет.
  В дальнейшей перспективе при переходе на Unicode можно будет использовать UNC-имена, т.к. для та-
ких имён практически не существует ограничения на длину (максимальная длина имени -- 64К unicode-
символа, что на практике дофига).
  Поэтому необходимо продумать проверку корректности имени файлов front- и back-end'ов (с точки
зрения длины) на уровне поиска модулей, а для подобной проверки создать платформенно-зависимую
функцию проверки корректности имени (т.к. на POSIX-системах другие ограничения). В таком случае
модули с длинными именами ко входным и выходным файлам будут просто игнорироваться при поиске
(не будут найдены, даже если они есть) и обрушений программ при открытии подобных файлов можно будет
избежать.


====================================================================================================
  [TOTHINK] Ограничения на MODULEPATH
====================================================================================================

  [TOTHINK] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.


====================================================================================================
  [TODO] Продумать back-end C++
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Завершено исследование конверсии Рефала в Си++. Был создан простой диалект Simple Refal, который
как раз ориентирован на генерацию кода на Си: отсутствие модульности и использование объявлений
внешних функций. Его можно объединить с Модульным Рефалом, даже двумя способами. Во-первых, можно
генерировать выходной код примерно также, как это делается для Рефала 5. А можно интегрировать код
Простого Рефала в Модульный. А можно пока не торопиться с интеграцией -- генератор кода C++ напи-
сать с нуля.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Если я буду представлять версию 0.2 широкой общественности (списку рассылки Рефала), то реализо-
вать генерацию сишного кода необходимо. Удобнее, конечно, вариант с генерацией самим компилятором
Модульного Рефала Си++-файлов, но вариант с генерацией файлов Простого Рефала проще в реализации
(хотя для этого придётся расширять Простой Рефал аналогом квалифицированных имён, АТД, статическими
ящиками). Как обычно, ничто не мешает совмещать оба подхода в разных back-end'ах.
  Поэтому надо продумать необходимость этого средства в версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 26.04.2009 - 21:59:57,53

  Независимо от того, как будет осуществляться генерация кода на Си++ -- напрямую компилятором с
"пришитым" генератором от Простого Рефала (генератор Простого Рефала состоит из модуля создания "ал-
горитма" -- команд языка сборки промежуточного представления предложения и модуля собственно генера-
ции) или путём генерации исходных текстов Простого Рефала, в любом случае надо пополнить Простой Ре-
фал средствами, необходимыми для Модульного Рефала:
  1. Идентификаторы (имена, метки, compound-символы). Далее по тексту "идентификаторы". Идентифика-
торы представляют собой элементы глобального множества, смысл которых состоит только в возможности
сравнения на равенство/неравенство средствами сопоставления с образцом с известным идентификатором
или между собой.
  2. Квалифицированные имена Модульного Рефала, т.е. имена, составленные из сегментов. Сегмент под-
чиняется правилам Модульного Рефала. т.е. может содержать символы типа '!', '?', '_', '-', причём
последние два различаются.
  3. Абстрактные типы данных.
  4. Статические ящики.
  5. Инициализация и финализация.
  Все задачи, относящиеся к генерации C++-кода, будут иметь префикс C++.


====================================================================================================
  [TODO] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [TODO] ‚в 21.04.2009 - 13:02:07.17

  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.


====================================================================================================
  [TOTHINK] C++: Имена Модульного Рефала в Простом Рефале
====================================================================================================

  [TOTHINK] 27.04.2009 - 16:34:27,25

  Способ, которым можно представить имена (сегменты квалифицированного имени) в Простом Рефале,
прост: достаточно выбрать систему кодирования дополнительных символов. Наиболее подходящий способ
такой: символы '!', '?', '_', '-' заменяются соответственно на 'B_', 'Q_', 'U_', 'D_', остальные
символы остаются без изменений. Данное кодирование обладает следующими преимуществами:
  (+) Оно взаимно однозначно.
  (+) Кодированное имя не содержит двух соседних прочерков, не может начинаться на прочерк. Это яв-
ляется преимуществом, т.к. имена, начинающиеся на прочерк и содержащие два прочерка внутри являются
зарезервированными для Стандартной библиотеки Си++.
  (+) Имена, начинающиеся на '!' или '?', после кодирования будут начинаться с большой буквы -- имя
будет соответствовать правилам имён Простого Рефала.
  (+) По кодированному имени легко понять оригинал.
  Явных недостатков такой способ не имеет.
  Квалифицированные имена можно реализовать двумя способами: простым и сложным.
  Простой способ заключается в том, что вводится дополнительная управляющая последовательность,
представляющая собой разделитель квалификаторов, например 'P_'. Таким образом имя InOut::WriteLine
будет выглядеть как 'InOutP_WriteLine'.
  (+) Способ довольно простой.
  (+) Ничего не нужно менять в компиляторе Простого Рефала.
  (-) Слишком длинные имена таким способом кодировать нельзя слишком длинные имена (ограничение на
максимальную длину в Си++ составляет примерно 200 символов, дальше компилятор обрезает).
  Сложный способ заключается в том, что сущности, кодированные квалифицированными именами, будут
находиться в соответствующих пространствах имён. Таким образом, сгенерированный сишный код для имени
Std::InOut::WriteLine будет иметь вид:
  namespace Std {
  namespace InOut {
  refalrts::FnResult WriteLine( аргументы ) {
  }
  }
  }
  (+) Можно получить выигрыш в максимальной общей длине квалифицированного имени: на Visual Studio
2005 длинное квалифицированное имя не обрезается.
  (+) Пространства имён являются неотъемлемой возможностью Си++.
  (+) Такой способ интереснее
  (-) Необходимо изменять кодогенератор, формирователь конца функции должен знать имя функции, чтобы
поставить нужное число закрывающих фигурных скобок.
  (-) Не все компиляторы сохраняют в объектных файлах столь длинные имена. Borland C++ Builder 6,
например, имена в объектных файлах обрезает по 260-и символам.
  Надо заметить, что очень длинные квалифицированные имена мне встречались довольно редко (пока).
Однако, если в дальшейшем будет реализовываться синтаксис, основанный на действиях и с функциями
высших порядков, автоматически генерируемые промежуточные функции могут получать внутренние имена
вида ИмяРодительскойФункции::Какой-либоИдентификаторНапримерНомер. Конечно, в этом случае нужно по-
заботиться о том, чтобы имена автоматически генерируемых функций были короче.

  Синтаксис квалифицированных имён. Синтаксис в целом может быть похож на синтаксис квалифицирован-
ных имён в Модульном Рефале. В качестве разделителя имён можно использовать хоть точку, хоть двоето-
чие, хоть квадратик (два двоеточия).


====================================================================================================
  [TOTHINK] C++: Идентификаторы в Простом Рефале
====================================================================================================

  [TOTHINK] 27.04.2009 - 16:34:27,25

  Идентификаторы представляют собой элементы глобального множества, смысл которых состоит только в
возможности сравнения на равенство/неравенство средствами сопоставления с образцом с известным иден-
тификатором или между собой. Упорядочивание (сравнение на '<', '>', '==') иденификаторов не определе-
но, требуется лишь, чтобы выполнялись следующие законы:
  (1) Если s.A:s.B (отображается путём сопоставления с образцом), то s.A == s.B.
  (2) Выполняется только одно из трёх соотношений: s.A < s.B, s.A == s.B, s.A > s.B.
  (3) Если s.A < s.B и s.B < s.C, то s.A < s.C.
  Допустимо, если все идентификаторы будут считаться равными (как это сейчас сделано в back-end'е
Рефала 5). В идеале идентификаторы должны сравниваться по их текстовому представлению, т.к. подобное
поведение интуитивно понятно пользователю.
  Сравнение на равенство/неравенство средствами сопоставления с образцом должны выполняться эффек-
тивно, т.е. выполняться за постоянное время.

  Идентификаторы можно реализовать несколькими способами, их можно разделить на статические (пред-
ставления идентификаторов задаются на этапе компиляции) и динамические (представления задаются на
этапе выполнения), поддерживающие раздельную компиляцию (не требуют явного дополнительного прохода
на этапе компоновки) и не поддерживающие (требуют оного).

  1. Представление идентификаторов в виде функций заданного формата, размещаемых в специальной сек-
ции объектного файла. Статический, поддерживает раздельную компиляцию. Идея состоит в том, что су-
ществуют секции объектного файла, дублирующиеся элементы которых в разных единицах трансляции устра-
няются компоновщиком. В качестве типа можно выбрать функцию, не принимающую никаких аргументов и
возвращающую const char *. В качестве возвращаемого значения можно использовать текстовое представ-
ление идентификатора, что упростит вывод на экран.
  Пример.
  // Файл Module1.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F1( .... ) {
    .... & Success ....
  }

  // Файл Module2.cpp
  #pragma хитрая_прагма
  const char* Success() { return "Success"; }

  refalrts::FnResult F2( .... ) {
    .... & Success ....
  }

  В итоге за счёт использования особой секции файла (секция указывается в директиве #pragma), компо-
новщик. видя в двух объектных файлах идентичные определения, одно из них устранит и в исполнимом
файле окажется только одно определение функции Success, на которое будут ссылаться функции F1 и F2.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы.
  (*) Указатели на функции можно сравнивать на равенство и неравенство.
  (*) Сравнение двух указателей выполняется за постоянное время.

  Оценка.
  (+) Способ статический -- не требуется динамических расходов во время выполнения программы.
  (+) Не требуется явного дополнительного прохода на стадии компоновки (неявный проход делает компо-
новщик Си++).
  (+) Способ работает как в Си, так и в Си++ (если понадобится написать генератор кода языка Си).
  (+) Доступно текствое представление на этапе времени выполнения: это облегчает отладку, позволяя
выводить идентификаторы на экран.
  (+) Возможность упорядочить по текстовому представлению.
  (-) Способ непереносим -- требуемая прагма зависит от компилятора, некоторые компиляторы могут та-
кую прагму не предоставлять.
  (-) Затруднена загрузка динамических библиотек: динамические библиотеки будут использовать свои
адреса к функциям-представлениям идентификаторов. В этом случае или интерфейс динамической библиоте-
ки не должен использовать идентификаторы (из-за чего пострадает или ясность программы -- обмен будет
осуществляться буквами либо цифрами, либо быстродействие -- обмен будет осуществляться целыми слова-
ми, либо удобство -- если в интерфейсе будут участвовать пустые функции -- по образцу $EENUM), или
идентификаторы должны будут сравниваться по текстовому представлению (что может снизить быстродей-
cтвие).
  Таким образом, при использовании динамической загрузки цель будет не достигнута.

  2. Представление идентификаторов в виде статических функций шаблонного класса. Статический, под-
держивает раздельную компиляцию. Аналогичен предыдущему, с тем отличием что идентификаторы представ-
ляются так:
  // Файл Module1.cpp
  template<typename T>
  class Success {
    static const char* name { return "Success"; }
  };
  refalrts::FnResult F1( .... ) {
    .... & Success<int>::name ....
  }

  Идея состоит в том, что шаблоны по умолчанию помещяются в секцию, описанную в первом способе.

  Цель достигнута -- см. способ №1.

  Оценка.
  Достоинства в целом те же, что и в способе №1, с тем исключением, что способ работает только в
Си++. На тех компиляторах, на которых я его проверял (g++ под Линукс, BCC 5.5 и Visual Studio 2005
под Windows) этот способ работает. Требует ли того Стандарт, я не знаю, т.к. в Стандарт не глядел.
  Недостатки в целом тоже те же, только с оговоркой на переносимость -- шаблоны являются неотъем-
лемым средством Си++, а вот объединяются ли они на любом компиляторе?..

  3. Создание перечисления идентификаторов. Статический, требует дополнительного прохода. Идея сос-
тоит в том, что идентификаторы представляются целыми числами, ссылки на идентификатор в сгенериро-
ванном тексте ссылки выглядят заметными для автоматического анализа, например как ident::Success,
в каждом сгенерированном файле присутствует ссылка на заголовок "idents.h", перед передачей сгене-
рированных файлов компилятору C++, выходные файлы будут сканироваться на предмет наличия идентифи-
каторов, после чего будет создаваться файл "idents.h" с таким содержимым:
  // Файл idents.h
  namespace ident {
    enum {
      ...
      Success,
      ...
    };
  }

  extern const char* textual(unsigned id);

и файл "idents.cpp" с таким содержанием
  // Файл idents.cpp

  const char* idents[] = {
    ...
    "Success",
    ...
  };

  const char* textual(unsigned id)
  {
    return idents[ id ];
  }

  Если текстовое представление идентификаторов на этапе выполнения не требуется, то на этапе компо-
новки будет подключаться не сгенерированный файл idents.cpp, а на заранее заготовленный файл
noidents.cpp:
  // Файл noidents.cpp
  const char* textual(unsigned id)
  {
    // Возврат например "?" или число id в текством представлении, например "42"
  }

  Очевидно, что имена в определении enum и в массиве должны следовать в одинаковом порядке. Если
идентификаторы располагать в enum в алфавитном порядке, то будет возможность упорядочивания иденти-
фикаторов по текстову представлению путём лишь сравнения числовых значений.

  Цель достигнута:
  (*) Идентификаторы глобальны для всей программы -- файл idents.h един для всех единиц трансляции.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка:
  (+) Способ статический -- не требуется затрат во время выполнения программы.
  (+) Возможность отключать текстовое представление, когда этого не нужно.
  (+) Сравнение по текстовому представлению.
  (+) Способ работает как в Си, так и в Си++.
  (-) Требует дополнительного прохода на стадии компоновки.
  (-) Сложность с размещением файла "idents.h", если отдельные модули располагаются в разных папках.
Директива #include "idents.h" может по умолчанию искать файл idents.h в той же папке, что и файл ис-
ходного текста. Если файл idents.h присутствует в той же папке, что и исходник, то глобальный файл
может быть не найден.
  (-) Так же как и в способах №1 и №2, затруднена загрузка динамических библиотек. Если для динами-
ческих библиотек генерировать код тем же путём, что и для программы, совершенно разные идентификато-
ры будут получать одинаковые числовые представления, что потенциально способно привести к хаосу.
Если же изменить генерацию кода так, чтобы ссылки на идентификатор имели вид:
  refalrts::FnResult F(...) {
    ... ident::Success + g_offset ...
  }
где g_offset -- глобальная переменная, для основной программы равная нулю, при загрузке динамической
библиотеки наращиваемая на количество известных идентификаторов. В этом случае идентификаторы с оди-
наковым текстовым представлением в главной программе и библиотеке численно эквивалентны не будут.
  В этом случае недостатки способа по отношению к динамической загрузке будут те же, что и в спосо-
бах №1 и №2.
  Упорядочивание по численным значениям не будет эквивалентно упорядочиванию по текстовым представ-
лениям.
  При использовании динамической загрузки цель достигнута не будет.

  4. Динамическая таблица идентификаторов. Динамический, поддерживает раздельную компиляцию. Идея
следующая.
  // Функция, осуществляющая поиск в таблице и если необходимо добавление
  unsigned lookup( const char *name );

  // Некоторая сгенерированная функция
  refalrts::FnResult F(...) {
    const static unsigned Success = lookup("Success");
    const static unsigned Fails = lookup("Fails");
    ......
  }

  Идея заключается в том, что в Си++ инициализация статических переменных выполняется при первом
выполнении функции, на протяжении оставшегося времени программы переменные Success и Fails будут
хранить значения, соответствующие данным идентификаторам.
  В программе присутствует динамическая таблица, связывающая текстовое представление с числовым.
Функция lookup проверяет наличие отображения Текст <--> Число для данной текстовой строки, если
его нет, возвращается следующее числовое значение, которое ассоциируется с данным идентификато-
ром, если есть -- возвращается число.

  Цель достигнута:
  (*) Таблица глобальна для всей программы.
  (*) Целые числа можно сравнивать на равенство/неравенство.
  (*) Сравнение целых чисел выполняется эффективно.

  Оценка
  (+) Не требуется прохода на стадии компоновки.
  (+) Работает как на Си, так и на Си++
  (+) Полностью совместим с динамическими библиотеками -- указатель на таблицу можно передать в ди-
намическую библиотеку, идентичные идентификаторы получат одинаковые числовые значения.
  (+) Текстовое представление доступно во время выполнения.
  (+) Есть возможность расширять множество идентификаторов, используемых в программе, пользователем
(точно также, как и в Рефал 5 -- фунцией типа Implode). Однако, для уничтожения неиспользованных
идентификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Затраты времени выполнения на инициализацию: каждая функция при первом вызове будет подторма-
живать, хотя и незначительно.
  (-) В каждой функции, использующией идентификатор, будет упоминаться текстовая строка, его пред-
ставляющая. Компиляторы могут не объединять дубликаты текстовых строк, отсюда возможно распухание
объёма исполнимого файла (хотя он и так распухает от кода).
  (-) Наиболее простой метод упорядочивания -- по числовым значениям, т.е. упорядочивает не в алфа-
витном порядке.

  Если отказаться от требования сравнения на равенство за постоянное время, то можно рассмотреть ещё
один способ. Самый простой и самый очевидный.

  (5.) Си-строки. Идея в том, что идентификаторы следует представлять в виде обычных Си-строк, т.е.
указателей на char. Выглядит это так:
  refalrts::FnResult F(...) {
    ..... "Success" ...
  }
  Сравнение на равенство осуществляется функцией strcmp языка Си.

  Цель не достигнута:
  (*) Текстовое представление инвариантно, т.к. представляет самого себя.
  (*) Текстовые строки можно сравнивать на равенство/неравенство.
  (!) Сравнение текстовых строк осуществляется за время O( min( length(s1, s2) ) ), т.е. пропорцио-
нально длине строк, причём максимальное время достигается при одинаковых идентификаторах. (Для опре-
деления неравенства идентификаторов Success и Fails требуется одно сравнение, для определения равен-
ства Success и Success требуется 7 сравнений (включая завершающий ноль.)

  Оценка.
  (+) Способ статический -- не требуется затрат на время выполнения.
  (+) Не требует прохода на стадии компоновки.
  (+) Полностью совместим с динамической загрузкой библиотек.
  (+) Чрезвычайная простота реализации.
  (+) Возможность расширения пользователем набора идентификаторов на стадии выполнения. Для этого
достаточно распределить в динамической памяти новую строку. Однако для удаления неиспользуемых иден-
тификаторов требуется сборка мусора или подсчёт ссылок.
  (-) Расход памяти на используемые идентификаторы -- на каждое упоминание идентификатора требуется
одна Си-строка, В Простом Рефале, как показывает внутренний осмотр исполнимого файла, достаточно
много места занимают имена функций, Си-строки, которые используются для инициализации атомов-функ-
ций. Атомы-функции содержат строковое представление для удобства отладки -- для того, что бы можно
было проанализировать дамп поля зрения. Хотя, надо заметить, расход памяти на нерациональную гене-
рацию кода гораздо больше.
  (-) Как уже было сказано, требуется расход времени на сравнение двух строк. На самом деле сравне-
ние иногда можно оптимизировать, сравнивая сначала указатели на равенство, а затем уже сравнивая
содержимое.

  Синтаксис идентификаторов. Чтобы отличать идентификаторы от имён функций, можно идентификаторы об-
рамлять двойными кавычками (тогда потенциально можно разрешить в идентификаторах использовать многие
другие символы, а значит и расширить их систему кодирования) -- "Name", можно обрамлять слешами --
/Name/ как в Рефале 2, можно начинать с какого-либо символа, например, с # -- #Name, как это сделано
в Smalltalk.


====================================================================================================
  [TODO] C++: Абстрактные типы данных в Простом Рефале
====================================================================================================

  [TODO] 27.04.2009 - 16:34:27,25

  Абстрактные типы данных сравнительно несложно реализовать. Синтаксис можно позаимствовать из Мо-
дульного Рефала, в качестве метки АТД можно использовать имя $ENUM или даже $EENUM (для экспортиру-
емых АТД в перспективе). Синтаксис:
  PatternAbstractTerm ::= '[' Name Pattern']' .
  ResultAbstractTerm ::= '[' Name Result ']' .
  Проверку "приклеенности" имён функций к квадратным скобкам можно проводить за отдельный проход
после проверки парности скобок или в одном проходе с оной парности.


