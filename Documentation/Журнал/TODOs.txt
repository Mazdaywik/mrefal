====================================================================================================
  [TODO] RASL и интерпретатор
====================================================================================================

  [TODO] 29.09.2007 - 20:25:52,85

  Разработать (продумать и реализовать) собственный RASL (Refal Assembly Language) и собственный
интерпретатор, чтобы сделать компилятор независимым от компилятора Рефала-5.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Использование интерпретируемых файлов на языке сборки (будь то бинарных, будь то текстовых), по-
лезно для переносимости компилятора и программ, т.к. достаточно перенести только интерпретатор.
  Можно на манер SFX-архивов сделать интепретатор, который ищет интепретируемый код в конце самого
исполнимого файла. Если подобный интепретатор перенесён на некоторую платформу X, то это позволит
компилятору самостоятельно (т.е. в полном цикле, не обращаясь затем к другим инструментам для полу-
чения конечного исполнимого файла) создавать самостоятельные приложения (т.е. исполнимые файлы
платформы X, не требующие особого интерпретатора для своего исполнения).
  Эта задача требует много времени и размышнений, если её сделать приоритетной, то выпуск версии
0.2 оттянется на долгий срок.


====================================================================================================
  [TODO] Удалить MRefalRTS::Put
====================================================================================================

  [TODO] 02.02.2008 - 17:55:52,95

  См. выше, почему это не особо критично.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Можно и удалить. Ведь, если необходимо, всегда можно добавить. На данный момент функцией MSelfDi\
ag::Log-T я пользуюсь довольно редко. Чаще я с целью трассировки функции Func пишу следующий код:

// До трассировки

Func {
  // Тело функции Func. Формат функции такой: <Func t.X e.Y (e.Z)> == ...
}

// После трассировки

Func
  t.X e.Y (e.Z) =
    <MSelfDiag::Log>
    <MSelfDiag::Log '<Func>'>
    <MSelfDiag::Log '  t.X = ' t.X>
    <MSelfDiag::Log '  e.Y = ' e.Y>
    <MSelfDiag::Log '  e.Z = ' e.Z>
    <?Func t.X e.Y (e.Z)>;

?Func {
  // Тело функции Func.
}

  Очевидно, что вместо этого лучше включить в язык/компилятор нормальное средство трассировки, но
я сейчас не буду описывать это как TODO. Т.к. (а) до выхода версии 0.2 я не собираюсь изменять син-
таксист, (б) запись прямо здесь этого как TODO сделает его приоритетным. Пункт (б) не критичен, т.к.
описать TODO можно и после закрывающей скобки.


====================================================================================================
  [TODO] Продумать упрощение структуры Lexer'а и Parser'а
====================================================================================================

  [TODO] 12.02.2008 - 20:14:38,84

  Возможно, стоит переписать лексический анализатор так, чтобы он на входе имел не имя файла, а
сразу всё его содержимое, а на выходе выдавал лексическую свёртку. Точно также можно изменить и син-
таксический анализатор: чтобы он принимал на входе лексическую свёртку. Это позволит (а) упростить
их структуру, (б) можно написать генератор кода для Lexer'а, что упростит его дальнейшую разработку,
(в) сделает соответствующие модули "функционально чистыми". Последний пункт красив идеологически, но
в данной версии Модульного Рефала он бессмысленен, поскольку никаких преимуществ ни по быстродейст-
вию, ни по качеству генерируемого кода не даёт.
  Сегодняшний вариант сделан из соображений экономии памяти: без лишних затрат памяти он может спо-
койно обработать файл, содержащий мегабайт пустых строк или мегабайт строк с одной точкой с запятой.
Однако, это вырожденный случай. При работе линковщика в память загружаются целиком rout-файлы, кото-
рые по объёму больше чем соответствующие им модули исходного текста, -- и ничего, работает.
  В заголовке я написал "продумать". Это значит, что если нет острой необходимости, то менять ниче-
го не надо. На сегодняшний день lexer и parser написаны достаточно культурно в плане кода, как мне
кажется, почти без ошибок (хотя недавно одну исправил).
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Обдумать введение видов для квалифицированных имён
====================================================================================================

  [TODO] 20.06.2008 - 20:59:14,30

  В программе обычно квалифицированное имя обозначает некоторую конкретную сущность: модуль, фун-
кцию, swap, импорт, АТД. В дальнейшем к ним должен присоединиться пакет. Поэтому возможно стоит этот
тип хранить в самом квалифицированном имени. Обоснования толком дать не могу, зачем это надо, но,
думаю, не вредно. Поэтому в заголовке я написал "обдумать". Когда обдумаю, я напишу в DONE результат
размышлений. Если решу этот вопрос положительно, то вместе с DONE появится новое TODO.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Модули уже давно поддерживаются, хотя и с недоделками.
  Пока я не вижу мест в программе, где виды квалифицированных имён сыграли бы значительную роль.
Однако, они были бы полезны для гарантирования надёжности программы.


====================================================================================================
  [TODO] Продумать генераторы лексического и синтаксического анализаторов
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Как показала практика -- генерация кода лексического анализатора -- это очень удобная вещь. В
перспективе полезно было бы разработать хотя бы генератор лексического анализатора для Модульного
Рефала.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать двухуровневую структуру синтаксического анализа
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.


====================================================================================================
  [TODO] Продумать изменения в лексике и комментариях
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Можно расширить лексику следующим образом: разрешить имена с маленькой буквы (будут проблемы толь-
ко если модуль имеет имя s, t или e -- в конце модуля ведь точка, и при импорте функций тоже). Можно
с большой буквы оставить имена только модулей или каких-либо других имён, разрешаемых точкой. Также
полезно избавиться от анахронизма -- комментариев, начинающихся со звёздочки. И так язык прекрасно
поддерживает комментарии C++ '//'. А звёздочку можно использовать для передачи функции по ссылке --
вместо амперсенда.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Опять же, изменения в лексике не являются приоритетным для версии 0.2.
  Изменения, связанные с именами с маленькой буквы я считаю сомнительными, а исключение комментари-
ев, начинающихся со звёздочки, я считаю вполне разумным.


====================================================================================================
  [TOTHINK] Отдельно собирать информацию об ошибках в журнале проекта
====================================================================================================

  [TOTHINK] 07.12.2008 - 20:30:08,12

  Утилита TODO_list обновлена таким образом, что позволяет извлекать из файла журнала больше инфор-
мации: извлекает помимо краткого списка с заголовками незакрытых TODO, ERROR и (new!) TOTHINK, два
полных списка соответственно с информацией о закрытых и о незакрытых тегах. Однако есть пока сырая
мысль по мотивам списка незакрытых тегов сделать отдельно список незакрытых ошибок. Но ошибок пока
мало (речь идёт только об обнаруженных и при этом вынесенных в журнал ошибках), поэтому выносить
о них сведения не критично.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.02.2009 - 21:42:25,09

  К версии 0.2 непосредстенно не относится.


====================================================================================================
  [TODO] //== Список приоритетных TODO ==\\
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

  Выполнив все эти TODO, я увеличу номер версии до 0.2.

  [TODO] Механизм поиска модулей
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  По-прежнему, если я решу нижеперечисленные задачи, увеличу номер версии до 0.2.
  Основными особенностями версии 0.2 должна стать полноценная поддержка модулей, пакетов, поддержка
нескольких front-end'ов и back-end'ов. Глобальных изменений синтаксиса по сравнению с сегодняшим
состоянием (1 февраля 2009 года -- см. отметку даты-времени), а также синтаксического анализатора
быть не должно (синтаксис файлов исходного текста на Модульном Рефале и файлов интерфейсов и так
достаточно успешно поддерживает иерархическую модульную структуру).
  Возможно развитие и пересмотр стандартной библиотеки, в том числе упорядочивание средств имеющих-
ся модулей, расширение математической библиотеки, выбор имени пакета для библиотечных модулей.
  Те задачи, которые имеют в своём теге знак '+', не будут перемещены.


====================================================================================================
  [TODO] Продумать максимальную длину имени модуля
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  Имя модуля или пакета (т.е. всех сегментов квалифицированного имени модуля) не должно начинаться
со знака '?'. Надо также решить вопрос с ограничением длины имени модуля/пакета и, соответственно,
файла/каталога. Например, ограничить 255 символами.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Очевидно, это необходимо выполнить до (для) выхода версии 0.2.
----------------------------------------------------------------------------------------------------
  [TODO] 26.04.2009 - 12:56:39,09

  Сегодняшняя реализация на Модульном Рефале потенциально способна работать с именами модулей, па-
кетов или квалифицированными именами любой длины. Однако создать модуль с килобайтным именем. Слиш-
ком длинные квалифицированные имена невозможны из-за ограничений файловой системы: максимальная дли-
на пути в Windows равна 260 байтам. Поэтому при попытке создать модуль с очень длинным именем, мы
всего лишь столкнёмся с ошибкой невозможности открытия файла: программа рухнет.
  В дальнейшей перспективе при переходе на Unicode можно будет использовать UNC-имена, т.к. для та-
ких имён практически не существует ограничения на длину (максимальная длина имени -- 64К unicode-
символа, что на практике дофига).
  Поэтому необходимо продумать проверку корректности имени файлов front- и back-end'ов (с точки
зрения длины) на уровне поиска модулей, а для подобной проверки создать платформенно-зависимую
функцию проверки корректности имени (т.к. на POSIX-системах другие ограничения). В таком случае
модули с длинными именами ко входным и выходным файлам будут просто игнорироваться при поиске
(не будут найдены, даже если они есть) и обрушений программ при открытии подобных файлов можно будет
избежать.


====================================================================================================
  [TOTHINK] Ограничения на MODULEPATH
====================================================================================================

  [TOTHINK] 01.02.2009 - 21:42:25,09

  Надо продумать: важны ли ограничения на то, что папки в MODULEPATH не могут быть вложенными и
ссылки вверх ('..') запрещены. А в остальном это TODO/TOTHINK остаётся тем же.


====================================================================================================
  [TODO] ПИ:Хранить в контексте также информацию о пакетах
====================================================================================================

  [TODO] 14.06.2008 -  1:28:52,75

  В контексте хранить информацию также и о пакетах. На сегодняшнем этапе компилятор ещё не поддер-
живает никаких пакетов, хотя некоторые модули пытаются поддерживать квалифицированные имена. Соответ-
ствие имени файла без учёта регистра и имени модуля достигается за счёт используемой ОС и файловой
системы. Необходимость хранить имя пакета связана с тем, что нужно проверять совпадение имён пакетов,
вычленяемых из каждого файла исходного текста/символической информации.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Надо хранить не только пакеты, но проверять их имена и выдавать при этом адекватные сообщения об
ошибках.


====================================================================================================
  [TODO] Стандартные модули контейнеров и распространённых функций
====================================================================================================

  [TODO] 20.10.2007 - 19:08:06,05

  Было бы полезно создать модуль для работы с ящиками (пока только статическими), реализующие
распространённые операции с контейнерами: добавление терма в начало, конец, чтение с начала, конца,
ассоциативный поиск по ключу, значению, дисциплины FIFO, LIFO. Функции должны принимать указатели на
статические ящики и специфическую информацию (добавлямый терм, ключ...). В дальнейшем их можно будет
расширить и для поддержки динамических ящиков.
  А также создать модуль, реализующий наиболее распространённые функции: Nil, OneOf, Apply (выпол-
няет операцию над каждым термом выражения (см. пример на указатели на функции), генерирование после-
довательности чисел от и до (<NumSeq 1 5> == 1 2 3 4 5) и др.
----------------------------------------------------------------------------------------------------
  [TODO] Џ­ 08.12.2008 - 19:19:37.31

  Теперь TODO "Стандартные модули контейнеров и распространённых функций" будет про стандартную би-
блиотеку. Просто я не хотел ещё одно заводить TODO с похожим смыслом.
  Теперь, когда компилятор наконец поддерживает пакеты, нужно разработать стандартную библиотеку для
Модульного Рефала. В принципе, всё то, что описано в данном TODO выше, у меня уже реализовано.
  Для поддержки статических ящиков создан модуль MSwapSupport, который мало используется (ну не
пользуюсь я глобальными переменными). Создавать динамические ящики я в ближайшее время не намерен,
т.к. выработал привычку оперировать с данными как с объектами первого класса.
  "Распространённые операции" -- из тех, которые перечислены, уже реализованы в модуле MLambda или
MString, за исключением операции OneOf (которая хороша в Рефале с неуспехами, но неуклюжа в данной
версии Модульного Рефала) -- она реализована в Types.mref. В принципе, модули FileIO, InOut, Math,
MDosWinRecoder, MFileSystem, MLambda, MOrder, MOS, MRefalRTS, MSelfDiag, MStrings, MSwapSupport,
Types выложены в каталоге MR-Home, которая по умолчанию включена в MODULEPATH и их уже можно
считать готовой библиотекой.
  Однако, эта библиотека мне не нравится по ряду причин, а именно:
  (*) Создавалась спонтанно, без дополнительного проектирования (за исключением модуля MLambda).
  (*) Некоторые модули создавались в то время, когда я не имел достаточного опыта и знаний в прог-
раммировании на Рефале.
  (*) Математическая библиотека (модуль Math) вообще находится в за(й)чаточном состоянии.
  (*) Имеющаяся библиотека плохо приспособлена для перенесения её под другие back-end'ы -- необходи-
мо её разделить на переносимую часть, написанную на Рефале для всех back-end'ов, и непереносимую,
которая пишется для каждого back-end'а в отдельности. В принципе, непереносимой частью условно мож-
но считать модуль MRefalRTS, но набор функций в нём крайне беден и не смог бы задействовать потен-
циальные преимущества, например back-end'а C++.
  Поэтому есть над чем подумать. Можно считать это TODO как TOTHINK.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Необходимо продумать ряд деталей, таких как:
  (1) Проработка математической библиотеки, хотя бы расширение её операциями умножения, деления и
взятия остатка.
  (2) Разделение на переносимую и непереносимую части.
  (3) Выбор имени пакета для библиотечных модулей. Проект "Модульный Рефал" пока молодой, библиоте-
ка будет эволюционировать, причём ряд возможностей в процессе эволюции может исключаться. Поэтому
фиксировать яркое имя типа Std или Lib я считаю неприемлемым хотя бы до выпуска версии 1.0.


====================================================================================================
  [TODO] \\== Вот список приоритетных TODO ==//
====================================================================================================

  [TODO] 05.02.2008 -  1:22:49,77

----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Когда я выполню эти задачи, я повышу номер версии до 0.2.


====================================================================================================
  [TODO] Продумать блоки $INIT и $FINAL
====================================================================================================

  [TODO] 23.09.2008 - 12:50:36,46

  Вместо использования функций с именами Init и Final предполагается использовать блоки с примерно
таким синтаксисом:
  InitBlock = '$INIT' ResultExpression ';' .
  FinalBlock = '$FINAL' ResultExpression ';' .
  Мотивация. Функции $INIT и $FINAL, безусловно нужные для инициализации и финализации модулей с по-
бочными эффектами, обладают рядом недостатков. В текущей версии компилятора их всегда можно вызвать
из пользовательского кода (запрета на это нет, хотя поведение считается неопределённым). Функции
всегда требуют пустого аргумента на входе, хотя не запрещается написать что-то вроде
  $ENTRY Init {
    A = <DoSomething>;
    s.X (e.Y) = <DoSomethingElse>;
  }
что никакой полезной нагрузки не несёт, более того, подобная функция обязательно обрушит программу.
К тому же, для подобных функций приходится выделять особые зарезервированные имена (в частности,
нельзя создать АТД с подобными именами -- поведение не определено). Ведь изначально синтаксис Рефа-
ла 5 и так построен в расчёте на то, что происходит минимальное вторжение в область пользователь-
ских определений (зарезервирована только функция Go, с которой по соглашению начинается выполнение
программы, и, к сожалению, встроенные функции). В Модульном Рефале я избавился от встроенных функ-
ций, функцию Go устранять в обозримом будущем я не собираюсь. А вот устранить Init и Final вполне
реально.
  Новый синтаксис инициализации и финализации решает все вышеперечисленные проблемы: код инициали-
зации и финализации не может быть вызван пользователем (конечно, можно написать функцию, которую
можно вызвать и из кода инициализации, и из пользовательского кода -- но это будет осознанное про-
ектное решение); нет проблемы с необычными образцами -- образцов в новом синтаксисе нет в принципе;
не загромождается область пользовательских определений.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  Маловероятно, что я буду менять синтаксис до выхода версии 0.2. Однако, создание в промежуточном
представлении IModule поддержки блоков $INIT и $FINAL я считаю возможным. Такие блоки инициализации
и финализации будут присутствовать во всех модулях, особенность будет лишь в том, что в тех модулях,
в которых инициализация/финализация явно пользователем не задана, эти блоки будут пустыми. Это поз-
волит в линковщике обрабатывать модули унифицированным образом, и, возможно, упростит решение ошиб-
ки, связанные с финализаторами и MOS::Exit (см. соответствующую ERROR).
----------------------------------------------------------------------------------------------------
  [TODO] ‚в 21.04.2009 - 13:02:07.17

  Поддержка блоков $INIT и $FINAL в промежуточном представлении IModule реализована. Не смотря на
то, что текущая версия синтаксиса эти блоки не поддерживает, остальная часть компилятора (синтакси-
ческий анализатор, промежуточное представление, генераторы и компоновщики) эти блоки поддерживает.
  Помимо поддержки блоков инициализации и финализации, также поддерживается стартовый код для го-
ловного модуля. Синтаксический анализатор, при обнаружении в головном модуле функции $ENTRY Go или
в регулярном модуле функций $ENTRY Init и $ENTRY Final, добавляет в код точек входа (соотв. в стар-
товый код или код инициализации и финализации) вызовы этих функций. За счёт этого остальная часть
программы не зависит от имён этих функций (стартовой, инициализации и финализации), что существенно
упрощает её (при переработке совокупный код компоновщика back-end'а Рефала 5 уменьшился на один мо-
дуль, как раз и отвечающий за поиск функций с именами Go, Init и Final).
  А, собственно, поддержку блоков $INIT и $FINAL я оставляю как TODO, т.к. надеюсь их увидеть в сле-
дующей версии синтаксиса.


====================================================================================================
  [TODO] Реализовать back-end C++
====================================================================================================

  [TODO] 26.04.2009 - 21:59:57,53

  Собственно, всё продумано, приступаем к реализации.
  Независимо от того, как будет осуществляться генерация кода на Си++ -- напрямую компилятором с
"пришитым" генератором от Простого Рефала (генератор Простого Рефала состоит из модуля создания "ал-
горитма" -- команд языка сборки промежуточного представления предложения и модуля собственно генера-
ции) или путём генерации исходных текстов Простого Рефала, в любом случае надо пополнить Простой Ре-
фал средствами, необходимыми для Модульного Рефала:
  1. Идентификаторы (имена, метки, compound-символы). Далее по тексту "идентификаторы". Идентифика-
торы представляют собой элементы глобального множества, смысл которых состоит только в возможности
сравнения на равенство/неравенство средствами сопоставления с образцом с известным идентификатором
или между собой.
  2. Квалифицированные имена Модульного Рефала, т.е. имена, составленные из сегментов. Сегмент под-
чиняется правилам Модульного Рефала. т.е. может содержать символы типа '!', '?', '_', '-', причём
последние два различаются.
  3. Абстрактные типы данных.
  4. Статические ящики.
  5. Инициализация и финализация.
  Все задачи, относящиеся к генерации C++-кода, будут иметь префикс C++.


====================================================================================================
  [TODO] Командная строка: дополнительная параметризация back-end'ов
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Следует разрешить генераторам входных и выходных файлов (вместо ранее использованного термина
"внутреннее понятие back-end'а") параметризоваться дополнительными своими опциями (например, для
компилятора Си++ -- это путь к компилятору, дополнительные опции и др.). А если смотреть шире, то
помимо обработчика дефолтовых зависимых от самой опции команд группы, должен быть и обработчик
зависимых от значения опции команд группы.


====================================================================================================
  [TODO] Командная строка: упорядочить метаданные -- список back-end'ов и зависимые перехватчики
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Хотя сейчас метаданные (дефолтовые расширения и папки вынесены) в отдельный файл, они там совер-
шенно не упорядочены -- одно и то же расширение упоминается несколько раз. Кроме того, компоновка
набора выходных файлов в единый back-end должна осуществляться также независимо от обработчика
командной строки. Кроме того, независимо от обработчика информация о выбранных опциях (в конкрет-
ном случае -- это командная строка вызова компилятора Си++) должна передаваться в функции генерато-
ра и компоновщика.


====================================================================================================
  [TOTHINK] Имя и путь целевого файла
====================================================================================================

  [TOTHINK] 19.05.2009 - 22:23:09,31

  Под целевым файлом будем понимать или исполнимый файл, или файл, обобщающий какую либо информацию
по всей программе (перекрёстные связи, отладочная информация, та или иная статистика о программе).
На данный момент в компоновщик передаётся только конечный сегмент имени головного модуля (так на-
пример, если головной файл имеет имя Packet::Module, то сгенерированный исполнимый файл будет распо-
лагаться в текущей папке с именем Module. Для целевого файла таблицы перекрёстных связей XLinx про-
водится в компоновщике дополнительная обработка имени файла и тот оказывается в каталоге .Info в те-
кущей папке.
  Back-end Рефала 5 помимо "исполнимого" файла -- исходного текста на Рефале 5, компилируемого в
единый .rsl-файл, создаётся файл отладочной информации в каталоге .Info с именем Aliases.als и файл
со списком нескомпонованных функций в том же каталоге с именем Not linked.txt. Если одновременно
компилируется несколько проектов, то последний компилируемый проект перезапишет эти файлы.
  Следует продумать несколько вариантов.
  (1) В качестве каталога с целевым файлом всегда использовать текущую папку.
  (2) В качетсве каталога с целевым использовать MP-каталог головного модуля.
  (3-4) В качетсве каталога с целевым файлом использовать имя пакета + текущий каталог или MP-ката-
лог головного модуля.
  Кроме того, каталог с целевыми файлами можно задавать как параметр командной строки, а также зада-
вать само имя целевого файла. Поскольку одновременно может компилироваться несколько проектов, то
имя целевого файла должно распространяться на ближайшее (а) имя файла-корня грозди или (б) имя го-
ловного файла. Имя файла, указанного в командной строке, не обязательно должно быть именем грозди.
  Компоновщик должен без лишних усилий, получив на входе путь к файлу (папка+собственно имя), пос-
троить из него путь с подпапкой (как в случае с каталогом .Info для XLinx), выбрать расширение.


====================================================================================================
  [TODO] C++: Устранить Library.cpp и RefalRTS
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Будем различать модули библиотеки -- модули, реализующие API для языка и поставляемые вместе с
компилятором и библиотечные модули -- модули, у которых отсутствует исходный текст.
  Генеральный план действий. Модули библиотеки содержат как низкоуровневые функции (реализуемые
ручным написанием библиотечных модулей), так и высокоуровневые, вполне реализуемые на самом Модуль-
ном Рефале (например, разбор пути к файлу в строковом представлении). Поэтому логично их разнести
в разные модули. Низкоуровневые модули, реализуемые на целевом языке, будут иметь то же имя, что
и модули-клиенты низкоуровневых функций, но будут находиться в пакете Core (как это сейчас сдела-
но для FileIO и MFileSystem, но с оговорками).


====================================================================================================
  [TODO] Устранить лишние вызовы функции MOS::System
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Устранить вызовы, используемые для создания папки, удаления файлов, получения списка переменных
среды. Реализовать эти средства или средствами языка Си, или средствами ОС.


====================================================================================================
  [TODO] Научить XLinx выводить список нескомпонованных функций
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  Как показала практика, вывод неиспользуемых функций -- весьма полезная вещь, упрощает поиск не-
ревантного кода, а также помогает найти некоторые ошибки. Однако, сейчас вывод подобного списка
привязан к back-end'у Рефала 5, от которого в ближайшей перспективе я планирую отказаться. Очевидно,
задача перекладывается на плечи XLinx, как средсва как раз и нацеленного на анализ использований
функций.


====================================================================================================
  [TODO] Научить XLinx выводить иерархический список использований модулей
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  XLinx должен уметь строить дерево зависимостей модулей как в прямом направлении (модуль исполь-
зует) с корнем в головном модуле, так и в обратном (модуль используется) -- несколько деревьев,
корнем каждого из которых является модуль, ничего не импортирующий, это как правило библиотечный
модуль реализации примитивов (теоретически, и библиотечный модуль может иметь зависимости от дру-
гих модулей, но это вырожденный случай).


====================================================================================================
  [TODO] C++: Имена функций -- идентификаторы вместо C-строк
====================================================================================================

  [TODO] 19.05.2009 - 22:23:09,31

  В качестве имени функции внутри узла-указателя на функцию, необходимо использовать идентификатор
-- указатель на статическую функцию идентификатора. Тогда, соответственно, каждый вызов функции
будет требовать идентификатор. Но этот недостаток незначителен, т.к. лишние идентификаторы устра-
няются компоновщиком языка Си++.


====================================================================================================
  [TODO] Обновить стабильную версию и поднять версию компилятора
====================================================================================================

  [TODO] 20.05.2009 - 15:28:26,81

  Требуется выбрать из имеющихся реализаций стабильно работающую, т.к. предыдущая стабильная версия
уже морально устарела: не может компилировать новый синтаксис (лексика пополнена \r). Кроме того,
компилятор потрясли значительные изменения: появилось несколько новых back-end'ов, изменилась обра-
ботка командной строки. Это стоит отметить повышением номера версии.


