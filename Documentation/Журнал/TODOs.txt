====================================================================================================
  [TOTHINK] Рефакторинг интерфейса и реализации IModule
====================================================================================================

  [TODO] 22.09.2008 - 23:27:35,87

  Сейчас компилятором по исходному коду создаётся "сырое" промежуточное представление IModule, в
котором затем производится разрешение вызовов. Новая идея такая. Вместо "сырого" IModule порождать
тупо структуру, близкую к синтаксическому дереву модуля, а уже затем на её основе порождать IModule
с разрешением внешних ссылок.
  Можно в синтаксисе затребовать, чтобы все импортируемые модули были объявлены перед их использо-
ванием. Это бы упростило создание "однопроходного" компилятора в дальнейшем, если такая дикая мысль
ко мне придёт.
----------------------------------------------------------------------------------------------------
  [TODO] 01.02.2009 - 21:42:25,09

  При создании нового синтаксиса, который будет поддерживать более широкие возможности (хотя бы
действия в смысле Рефала 6 и Рефала 7; функции, локальные для других функций и др.) я буду исполь-
зовать именно такие способы лексического и синтаксического анализа (загрузка файла целиком в память
с дальнейшим получением лексической и синтаксической свёртки; использование генератора лексического
анализатора, хотя бы подгонка генератора для Simple Refal; сначала строить синтаксическое дерево
КС-грамматики, затем строить IModule).
  Но, как сказано выше (в журнале), в задачу выхода версии 0.2 не входит ни изменение синтасиса,
ни существенная переработка Lexer'а и Parser'а.
----------------------------------------------------------------------------------------------------
  [TODO] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
  Имеющаяся структура компилятора на данный момент работает достаточно стабильно и не вызывает не-
удобств в использовании. Переделка без изменения внешнего поведения никак не повлияет на возможнос-
ти версии 0.2, но может существенно оттянуть сроки выпуска этой версии.
----------------------------------------------------------------------------------------------------
  [TODO] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [RENAME] 07.09.2010 - 23:30:08,46

  Old name is "[TODO] Продумать двухуровневую структуру синтаксического анализа"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 07.09.2010 - 23:30:08,46

  Удалено слово "продумать" ("обдумать") из заголовка, сменён тег с TODO на TOTHINK. (Переименова-
ние было проведено при первой возможности — сразу после того, как был введён тег RENAME.)
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  При дальнейшем развитии синтаксиса неизбежно возникнет вопрос адаптации имеющихся структур
данных к новым синтаксическим конструкциям. Тогда же этот вопрос и будет решён.
----------------------------------------------------------------------------------------------------
  [RENAME] 28.03.2018 - 11:33:50,24

  Old name is "[TOTHINK] Двухуровневая структура синтаксического анализатора"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Текущая реализация IModule уже «жмёт» — сначала пришлось некрасивым образом в неё добавить блоки
инициализации и финализации, а потом ещё и нативные вставки верхнего уровня.
  Изначально IModule был простой обёрткой над дважды ассоциативным массивом, «атрибутной таблицей
символов». Поддержка точек входа потребовала добавления в АТД записи t.EntryPoint (из-за чего
пришлось поменять все термы [IModule …]). Такую же масштабную правку потребовали и вставки
нативного кода. Для файлов с нативными вставками требуется сохранять их относительный порядок,
а также относительный порядок определённых функций, поэтому потребовалось в IModule хранить список
объектов «верхнего» уровня, дабы его итерировать при кодогенерации.
  Предлагаемое решение. Внешний интерфейс следует сохранить (расширив и удалив устаревшие функции).
Но внутреннюю реализацию описывать не в виде «атрибутной таблицы символов», а в виде AST.
Актуальная реализация представляет некоторые сущности в виде квалифицированного имени с набором
атрбиутов, разумно сохранить это же представление для соответствующих узлов дерева. Однако, для
узлов, которым это представление не подходит, не нужно искусственно навязывать такой подход.

  В актуальной реализации атрибуты функций запрашиваются у IModule по имени функции и атрибуту.

  <GetFunctionAttrubute t.hIModule s.Attrib t.FnName>
    == t.hIModule Found e.Value
    == t.hIModule s.ErrorStatus

  Имеет смысл продумать другой вариант: по имени запрашивается объект функции, у которого
запрашиваются атрибуты:

  <GetFunction t.hIModule t.Name>
    == t.hIModule Found t.Function
    == t.hIModule NotFound

  <GetFunctionAttribute t.Function s.Attribute>
    == Success e.Value
    == Fails

  <GetFunctionBody t.Function>
    == Sentences e.Sentences
    == Native e.Code
    == NoBody

  <UpdateFunction t.hIModule t.Function>
    == t.hIModule Success
    == t.hIModule s.Error

  Задача переименована, поскольку изначальное её описание не соответствует предлагаемому решению.
Вместо замены IModule на дерево на фазе синтаксического анализа предлагается модернизировать
IModule с новым интерфейсом и реализацией, хранящей дерево.


====================================================================================================
  [TOTHINK] Написание комплексных тестов для библиотеки
====================================================================================================

  [TOTHINK] 07.01.2010 - 23:12:41,12

  Они нужны. Осознаю их необходимость, но сформулированных мыслей у меня нет.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 01.05.2010 - 19:30:19,45

  (Ревизия 01.05.2010) Не требуется для выпуска версии 0.2.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2.
  По хорошему, надо писать не только тесты (некоторый небольшой набор тестов у меня есть), но и
средства автоматического тестирования (например, скриптом) и эти средства периодически обновлять.
  Некоторым подобием автоматического теста у меня является большой скрипт пересборки: он пересоби-
рает весь компилятор каждым исполнимым файлом, созданным некоторым профилем, с каждым профилем, что
в некоторой степени гарантирует его корректность.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В первую очередь нужно реализовать средства автоматического тестирования, а уже потом,
с их использованием, покрывать тестами и библиотеку, и компилятор. Сейчас у меня это в планах
не стоит, поэтому задача остаётся в статусе TOTHINK.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  На данный момент пока имеет смысл при расширении библиотеки ad hoc одновременно к новым функциям
писать автотесты в папке Sources/Compiler/Tests.
  При большой переработке библиотеки естественным образом добавятся тесты для вновь написанных
функций.
  P.S. Фреймворк автоматического тестирования, упоминающийся выше по задаче, уже есть и на данный
момент представляет собой упомянутую папку Sources/Compiler/Tests, тесты в которой могут
запускаться автоматически.


====================================================================================================
  [TOTHINK] Грамотная реализация библиотеки
====================================================================================================

  [TOTHINK] 10.07.2010 - 15:35:46,55

  В этой записи я хочу привести черновые мысли по поводу того, как следует организовать структуру
библиотеки Модульного Рефала.
  Модулями, предоставляющими интерфейс прикладного программирования (API) библиотеки являются моду-
ли, находящиеся в пакетах Std, Platform и BackEnd.
  Пакет Std содержит набор модулей, доступных под любой целевой платформой в широком смысле, т.е.
под любой операционной системой, под которую реализован Модульный Рефал (Windows, разновидности
POSIX) и с любым back-end'ом, способным создать исполняемые файлы (генерация кода под Си++, .NET,
RASL Рефала 5 и, возможно, какие-нибудь другие).
  Функции модулей этого пакета должны быть безопасны, т.е. не могут разрушить инварианты поля зре-
ния и вычислительной среды. Эти модули, скорее всего, написаны на Модульном Рефале и используют
средства модулей двух других пакетов.
  Пакет Platform предоставляет (не обязательно в полном объёме) средства API целевой платформы, при
этом конкретной платформе может соответствовать один или несколько модулей.
  Например, могут предостаставляться следующие возможности:
  * модуль Platform::CRuntime предоставляет средства API языка Си, например, потоки ввода-вывода из
<stdio.h> или функции из библиотеки <stdlib.h>;
  * модуль Platform::Windows предоставтяет такие возможности операционной системы, как запуск новых
процессов (функцией CreateProcess), получение атрибутов файла, характерных для Windows и т.д.;
  * модуль Platform::Posix предоставляет возможности, аналогичные возможностям модуля Platform::
Windows, хотя имена функций и их семантика могут отличаться (CreateProcess принимает имя исполняе-
мого файла и командную строку, Exec --- имя исполнимого файла и набор аргументов командной строки);
  * Platform::DotNET предоставляет свои средства;
  * Platform::Refal5 обеспечивает непосредственный вызов встроенных функций целевого языка и др.
  Модули могут как писаться на целевом языке, так и на Модульном Рефале, например, для обеспечения
более удобного интерфейса.
  Функции этого модуля не обязаны быть безопасными, они могут создавать некорректные элементы в по-
ле зрения, а также нарушать прочие инварианты вычислительной среды. Так например, Platform::Refal5
может предоставлять функции Explode, Implode и доступа к копилке, что может переломать костыли, не-
обходимые для компиляции Модульного Рефала в Рефал 5.
  Пакет BackEnd предоставляет возможности, характерные для рассматриваемого способа создания испол-
нимых файлов, не зависящих или слабо зависящих от конкретной операционной системы и не являющимися
элементами API целевой платформы.
  В качестве примера могут быть выделены следующие:
  * при компиляции в векторное или векторно-списковое представление могут предоставляться эффектив-
ные функции для получения длины выражения или N-го терма в выражении;
  * может предоставляться информация о текущем состоянии среды выполнения, такая как объём выделен-
ной памяти или число шагов;
  * легковесные потоки и управление ими;
  * принудительный вызов сборщика мусора;
  * работа с продолжениями (continuations) и другие.
  Аналогично, эти модули тоже могут писаться как на целевом языке, так и на Модульном Рефале.
  Аналогично, эти модули тоже не обязаны быть безопасными, даже более того, некоторые возможности
должны быть потенциально опасными, если они при этом являются полезными.
  Предполагается, что с использованием только модулей из пакета Std можно написать переносимую
между любыми целевыми платформами и способами компиляции. Кроме того, также предполагается, что
программист может и не пользоваться пакетом Std, т.к. пакеты должны Platform и BackEnd предостав-
лять те же средства, только в менее безопасном и менее переносимом виде.
  Следует обдумать вопрос: можно ли внутри Std предоставлять абстрагированные от конкретной платфор-
мы и способа компиляции возможности, доступные не во всех варинтах.
  Это TOTHINK оставляет открытым внутреннюю организацию библиотеки, т.е. наличие модулей во всевоз-
можных пакетах с префиксом Core (как сейчас это сделано), которые используются для упрощения пере-
носа библиотеки между разными платформами и способами компиляции.
  Это не приоритетная (для версии 0.2) задача, т.к. требует коренной переработки библиотеки, вклю-
чая интерфейс, т.е. займёт уйму времени. Поэтому это TODO я даже не снабдил префиксом СМКиРФ.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.07.2010 - 12:33:59,02

  (Ревизия 25.07.2010) Не требуется для выпуска версии 0.2, т.к. текущая версия библиотеки уже не-
плоха и вполне соответствует возможностям синтаксиса языка.
  С точки зрения грамотной реализации, текущая библиотека соответствует варианту пакета Std, но без
префикса Std и без альтернатив (Platform и BackEnd).
  Для выпуска публичной версии также не требуется, т.к. публичную версию вполне можно выпустить и с
текущей реализацией библиотеки.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея интересная, к ней следует стремиться. Но пока не актуально. Библиотеку лучше развивать
исходя из потребностей, и, время от времени, при мажорных релизах (до выпуска версии 1.0) делать
её рефакториг. Сейчас потребности перерабатывать библиотеку нет, но как часть генерального плана
развития данную задачу следует оставить.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Все вышеприведённые рассуждения остаются актуальными.
  Можно добавить, что модуль Platform::Refal5 уже был бы актуальным. Когда я реализовал нативные
вставки, я сделал частичный рефакторинг библиотеки — библиотечные модули без .mref я преобразовал
в регулярные, но со вставками на языке реализации. Для back-end’а Рефала-5 помимо обычных нативных
вставок с кодом была добавлена конструкция ALIAS, позволяющая создать псевдоним для функции
(вернее, идентификатора) Рефала-5 в целевом коде. И оказалось, что некоторые библиотечные функции
оказалось удобно переписать из нативной вставки в обычные функции Модульного Рефала, которые
вызывают встроенные функции Рефала-5 как псевдонимы. Побочным эффектом оказалось то, что многие
модули библиотеки теперь содержат псевдонимы для одних и тех же встроенных функций.
  Поэтому имеет смысл все эти псевдонимы собрать в одном месте и для этого места уже есть имя —
Platform::Refal5. Но имеет смысл это делать только при переработке библиотеки.


====================================================================================================
  [TODO] НД: Написание текста документации
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Требуется написать документацию к компиляторам и языкам Модульного и Простого Рефалов в текущей
реализации. Документация должна включать в себя следующие пункты:
  1 Описание текущей версии языка Модульный Рефал без рассмотрения особенностей конкретной реали-
зации. Включает в себя синтаксис и семантику Рефала, концепцию модульности.
  2 Описание текущей версии компилятора Модульного Рефала: представление модулей в виде исходных
и промежуточных файлов, компиляция, компоновка, расположение файлов модулей.
  3 Описание текущей версии языка Простого Рефала, при этом следует акцентировать внимание на том,
что ряд возможностей (идентификаторы, статические ящики) добавлены для совместимости с Модульным
Рефалом. Поскольку семантика управляющих конструкций Модульного и Простого Рефалов во многом сход-
ны, то их можно рассмотреть бегло.
  4 Описание текущей реализации Простого Рефала в Си++, рассмотрение интерфейса с языком Си++.
  5 Рассмотрение back-end'ов реализации Модульного Рефала, написание библиотечных модулей для
back-end'ов C++/SR и SR.
  6 (Приложение) Установка реализации Модульного Рефала на компьютер.
  7 (Приложение) Установка реализации Простого Рефала на компьютер.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: НД: Написание текста документации"
  """""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Проект Простого Рефала теперь развивается независимо от Модульного Рефала, соответственно,
документация к нему пишется независимо. А документацию к Модульному Рефалу писать надо. Следствие:
пункты 3 и 4 исключаются, остальное пока неизменно.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28): новых замечаний нет.


====================================================================================================
  [TOTHINK] Средство автоматической установки
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует продумать способ установки компиляторов на диск компьютера. Возможные варианты для
платформы Windows:
  1. Использование make-файлов.
  2. Использование специализированных средств установки типа пакетов MSI.
  3. Написание кустарного инсталлятора на базе sfx-архивов WinRAR и пакетных файлов.
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TOTHINK] ВПВ: Средство автоматической установки"
  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Задача актуальна, но не приоритетна. В рамках проекта Простого Рефала сейчас планируется создание
отдельного репозитория, в котором будут храниться полускомпилированные исходники компилятора(файлы
на C++). Сам репозиторий в некотором смысле может играть роль инсталлятора: клонирование и сборка
исполнимых файлов должны будут создавать готовый к использованию дистрибутив. Опыт работы с таким
репозиторием будет учтён в текущей задаче.
  Задача переименована, поскольку создание инсталлятора теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Неплохой вариант реализован в Рефале-5λ: для платформы Windows создаётся инсталляшка на базе
SFX-архива WinRAR со скриптом установки на Windows Script Hosting. А вот от подмодуля дистрибутива
мне уже хочется отказаться.


====================================================================================================
  [TODO] Написание документации (НД)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Выпуск публичной версии компилятора требует написания документации: описания языка и описания
конктретной реализации. Поскольку предполагается распространение Модульного и Простого Рефалов
в одном дистрибутиве, документация должна включать в себя сведения об обоих диалектах.
  Отсюда две подзадачи:
  1 Написание "контента";
  2 Выбор способа представления контента.
----------------------------------------------------------------------------------------------------
  [TODO] 16.09.2012 - 11:13:49,96

  Сначала я предполагал размещать документацию на сайте blogspot, даже уже частично написал, однако,
к некоторому моменту я потерял интерес к этому процессу. В качестве представления этот способ
оказался не слишком удобен: данные хранятся на удалённом сервере, поэтому для редактирования надо
быть в онлайне, к тому же, необходимо логиниться на сайте.
  Недавно мне пришла в голову неплохая идея: можно писать документацию в формате docx/odt — с одной
стороны, это автоматически даёт возможность получить красиво отформатированный pdf, с другой —
формат представляет собой набор зазипованных xml’ек, который, при необходимости, относительно легко
распарсить, просто выбирая только теги с понятным содержимым, а остальные игнорируя.
  Преимущество формата docx — возможности форматирования Microsoft Word, которым я умею эффективно
пользоваться.
  Преимущество формата odt — кроссплатформенность и простота для парсинга (XML более ясный, чем
у Microsoft Word).
----------------------------------------------------------------------------------------------------
  [RENAME] 18.12.2015 - 16:11:11,60

  Old name is "[TODO] ВПВ: Написание документации (НД)"
  """""""""""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Идея с использованием файлов docx или odt и конвертером, например, в текстовый формат, имеет
тот недостаток, что разница между коммитами либо не отображается, либо отображается в довольно
неудобном виде.
  Более подходящий вариант — использование изначально текстового представления. Варианты:
  * Свой конвертер. Начинал писать, дело далеко не продвинулось. Велосипед, вероятно, тупиковый
путь.
  * TeX:
    (+) Красиво отформатированный, пригодный для публикации формат.
    (−) Высокий порог вхождения, т.е. мне потребуется изучать новую среду: LaTeX или Lyx.
    (−) Тяжёлые для чтения исходники.
  * Markdown:
    (+) Лёгкость в использовании, низкий порог вхождения.
    (+) Доступно множество редакторов, конверторов. (Ни одним ещё не пользовался, но список
на Википедии длинный.)
    (+) Исходники легко читать.
    (+) Если просто хранить в подпапке набор файлов в разметке Markdown с гиперссылками друг
на друга, то в web-интерфейсе GitHub оно будет отображаться фактически как wiki-энциклопедия.
    (−) Чтобы сохранять читаемость исходников, нужно будет при редактировании каждый раз выравнивать
длины строк. Это снижает сопровождаемость (хотя в ряде текстовых редакторов (Vim, Emacs) есть
функция выравнивания строк). Соответственно, различия между коммитами будут включать много замен
строк, даже если изменилось только несколько слов. В TeX такая проблема тоже присутствует,
но исходники не предназначены для чтения.
    (−) Для ввода типографских плюшек (длинные тире, кавычки-ёлочки, неразрывные пробелы) нужно
или использовать последовательности HTML (что засоряет текст), либо специальные раскладки
клавиатуры. Кроме того, неразрывные пробелы внешне неотличимы от обычных, что тоже создаёт проблемы.
  Так что задача пока остаётся открытой. Возможен вариант использования wiki, встроенной в GitHub.
  Задача переименована, поскольку написание документации теперь более не входит в выпуск публичной
версии. Подробности в задаче, посвящённой выпуску публичной версии.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Хороший вариант — использовать Markdown. Более того, поскольку исходники теперь хранятся
в репозитории на GitHub, документация удобно читается через интерфейс сайта. И даже больше — можно
сделать сайт на GitHub Pages, написанный целиком в Markdown’е. Документацию писать буду я,
я пользуюсь раскладкой Бирмана, так что типографские знаки для меня не проблема.


====================================================================================================
  [TODO] Вложенные функции (ВФ)
====================================================================================================

  [TODO] 18.10.2010 - 16:14:47,28

  Как показала практика работы с Простым Рефалом, вложенные функции существенным образом повышают
выразительность программы и производительность программиста, даже если они и безымянные.
  Кроме того, практика показала, что если синтаксический анализ написан методом рекурсивного спуска
достаточно регулярным образом, то добавить в него вложенные безымянные функции тоже достаточно
несложно.
  Используемый рантайм (общий для Простого Рефала и back-end'а C++/SR Модульного Рефала) поддержи-
вает замыкания (представление вложенных функций во время выполнения программы).
  Версия 0.2 завершена, поэтому ничего не мешает расширению синтаксиса (на который был ранее нало-
жен запрет, дабы сконцентрировать усилия на других задачах).
  Вышеперечисленных аргументов достаточно, чтобы внедрить в язык вложенные безымянные функции
(позже можно будет придумать и именованные). Однако, есть и сложность на этом пути.
  Дело в том, что относительно безболезненно внедрить замыкания только в два профиля из трёх. Ран-
тайм профиля Рефала 5, в отличие от рантайма профилей C++/SR и SR, не поддерживает имманентно замы-
каний и, как следствие, реализация вложенных функций потребует костылей.
  Замыкание представляет собой кортеж, включающий в себя указатель на глобальную функцию и набор
связанных переменных, представляющих собой контекст замыкания. Поэтому задача состоит в том, чтобы
каким-либо образом их хранить в поле зрения. Семантически не должно быть способа разделить замыка-
ние на элементы каким-либо сопоставлением с образцом, следовательно, замыкание должно быть атомом
и сопоставляться с s-переменной.
  Под контеНтом замыкания будем подразумевать кортеж из контеКСта и указателя (имени) глобальной
функции.
  Среди способов реализации замыканий в профиле Рефала 5 можно выделить две группы: надёжные
и ненадёжные.

  I. Простые ненадёжные методы.

  1 При каждом создании замыкания создавать новый уникальный атом (например, функцией Implode),
а контент замыкания помещается в копилку с ключом в виде уникального атома. Непрямой вызов функции
представляется как вызов специальной функции, которая осуществляет проверку наличия уникального
атома в копилке и вызов контента при помощи функции Mu. При отсутствии атома в копилке функцией
Mu вызывается сам атом на входе.
  Недостаток: контенты замыканий не освобождаются, поэтому память будет непрерывно утекать.
  Достоинство: простота.

  2 По аналогии с п. 1, но используется фиксированный пул уникальных атомов. Если же пул опустошён,
то разрушается какое-то замыкание и его атом используется для создания нового замыкания.
  Недостаток: метод невозможно применять на практике, т.к. программа, использующая замыкания,
становится абсолютно ненадёжной — любое замыкание может быть похерено в любой момент.
  Достоинство: относительная простота, отсутствие утечек памяти.
  Метод тут рассматривается только для полноты картины.

  3 По аналогии с п. 1, но с замыканием ассоциируется счётчик вызовов, после которого оно становит-
ся недействительным (соответственно, контент освобождается). Соответственно, при каждом вызове
замыкания счётчик декрементируется.
  Недостаток: необходимо при создании замыкания инициализировать счётчик или специальным синтакси-
сом, или специальной библиотечной функцией, или выбирать значение счётчика по умолчанию. Если при
создании значение счётчика оказалось заниженным, то при "избыточных" вызовах получим ошибку. Если
значение счётчика оказалось заниженным, то память не освободится.
  Достоинство: способ более надёжен, чем п. 2, также способен бороться с утечками памяти.

  4 По аналогии с предыдущим пунктом с замыканием ассоциируется счётчик вызовов, но пользователь
получает возможность управлять этим счётчиком. Например, при создании ассоциируется значение 1,
при копировании замыкания пользователь явно инкрементирует счётчик, при удалении замыкания поль-
зователь должен счётчик явно декрементировать. Фактически, ручной подсчёт ссылок.
  Достоинства: способен обеспечить надёжность программы, а также избежать утечек памяти. Способ
прост. Способ эффективен.
  Недостаток: человеческий фактор. Контроль программиста за копированием напоминает управление
памятью в языках без сборки мусора (например, Си), но здесь последствия не так пагубны. Также недо-
статком является загромождение кода вызовами функций, которые ничего не делают в других профилях.

  II. Сложные надёжные методы. Данные методы всегда обеспечивают надёжность программы и ликвидируют
утечки памяти.

  5 Поскольку циклических связей между замыканиями быть не должно, можно применить подсчёт ссылок.
Т.е. в каждом предложении следует сравнивать количество переменных слева и справа: при уничтожении
переменных следует рекурсивно просматривать удаляемые переменные и декрементировать счётчики, при
копировании — аналогичным способом инкрементировать.
  Достоинство: процесс автоматизирован, надёжен.
  Недостаток: резкое снижение быстродействия.

  6 Изменение формата поля зрения. Атомы можно представлять как (s.Тип e.Значение), скобочные термы
как ((s.Тип e.Значение)). Такой формат позволяет хранить внутри атомов любые объектные выражения,
в том числе и контент замыкания.
  Достоинства: нет нужды в подсчётах ссылок и сборках мусора, утечки памяти невозможны, приличное
быстродействие.
  Недостатки: сравнение одноимённых переменных не за постоянное время, переделка всей библиотеки,
нечитаемость дампов памяти.

  7 Сборка мусора. Идея аналогична п. 2, только при исчерпании пула вызывается сборщик мусора.
  Недостаток: сложность в поддержке корневого множества (не иначе как в п. 5).
  Достоинство: метод надёжный в отличие от п. 2.

  8 Генерация кода в виде CPS (continuation-passing style). В этом случае вместо поля зрения
используется "пассивная" структура данных, в каждый момент времени в реальном поле зрения присут-
ствует только одна скобка конкретизации, поэтому корневое множество поддерживается элементарно.
  Достоинство: корневое множество доступно напрямую.
  Недостаток: это фактически написание нового back-end'а, снижение быстродействия вдвое (на каждый
вызов функции требуется по две скобки конкретизации), сложность кодогенерации.

  9 Эмуляция абстрактной рефал-машины. Можно добиться сравнительно малыми изменениями в кодогене-
рации и в реализации библиотечных модулей.
  Достоинство: доступность корневого множества, простота переделок.
  Недостатки: снижение быстродействия, фактически, написание нового back-end'а.

  Из приемлемых вариантов можно назвать п. 1, п. 4 и п. 9.
----------------------------------------------------------------------------------------------------
  [RENAME] 05.11.2010 - 21:36:08,97

  Old name is "[TODO] ВПВ: Вложенные функции (ВФ)"
  """"""""""""""""""""""""""""""""""""""""""""""""
----------------------------------------------------------------------------------------------------
  [TODO] 05.11.2010 - 21:36:08,97

  Снят префикс ВПВ в связи с тем, что их реализация не входит в приоритеты публичной версии.
  В качестве варианта реализации замыканий для back-end'а Рефала 5 предполагается использовать
модифицированный п. 1, подразумевающий создание нового атома для каждого замыкания, но с явной
операцией уничтожения. Возможна разработка специального модуля аналога MLambda, который вызывает
функцию уничтожения после выполнения требуемой операции. Функция уничтожения замыкания на других
back-end'ах не будет делать ничего.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2014 - 12:35:00,01

  Предлагаемый выше вариант вполне работоспособен, однако есть один нюанс. Замыкания могут
содержать внутри себя другие замыкания (например операции MLambda::BindLeft или MLambda::Composite).
Следовательно, явная операция удаления должна удалять замыкания рекурсивно. Но, при этом только
программист знает, когда замыкания удалять нужно, а когда не нужно. В частности, возможен случай,
когда замыкание, после вызова подлежащее удалению, замыкает контекст, содержащий другое замыкание,
пока не подлежащее удалению. Т.е. нужно что-то вроде «деструктора» замыкания.
  Если делать деструктор в соответствии с идиомой ООП, то одно из предложений функции будет
представлять собой метод, левая часть которого должна принимать аргумент, который не могут принимать
другие предложения функции. Недостатки такого подхода:
  1 Невозможно написать замыкание, которое одинаково обрабатывает любой аргумент (частный случай —
деструктор должен будет обрабатываться по особому).
  2 Любое замыкание обязано содержать специальный образец, иначе при удалении замыкания будет
происходить ошибка сопоставления.
  3 В других back-end’ах это предложение не будет иметь смысла, но может (незначительно) снижать
быстродействие.
  Этих трёх проблем можно избежать, если предложение-деструктор сделать синтаксически отличным
от регулярных предложений, например, состоять из одного символа $DELETE. В результатных частях
тот же символ $DELETE может использоваться только как Callable, т.е. после левой скобки
конкретизации. Преимущества:
  1 Выполнить это предложение вызовом <s.Closure $DELETE> невозможно, поскольку синтаксически
некорректно. Единственный способ вызвать это предложение — уничтожить замыкание (вычислив
<$DELETE s.Closure>). Следовательно, данный образец никак не конфликтует с другими образцами.
Следствие: предложение-деструктор может идти любым по счёту: первым, последним…
  2 При отсутствии предложения оно неявно подразумевается с пустой правой частью, т.е. при удалении
замыкания ничего не должно выполняться.
  3 Специальный синтаксис допускает и особый способ компиляции. В других back-end’ах эти предложения
при трансляции будут игнорироваться, равно как будут игнорироваться вызовы <$DELETE …> в правых
частях. Следствие: переносимая программа в предложениях-деструкторах не должна ничего делать, кроме
уничтожения замыканий, захваченных контекстом. Также переносимая программа не должна вкладывать
в вызовы <$DELETE …> вызовы функций с побочным эффектом. Либо, вызовы <$DELETE …> должны
компилироваться в вызовы <NIL …> при наличии скобок конкретизации внутри вызова <$DELETE …>. Такое
поведение снизит быстродействие в корректной программе, но сделает переносимым поведение
в некорректной. Способ трансляции разумно сделать управляемым параметром конфигурации.
  4 Синтаксис Модульного Рефала допускает использование функций с пустым телом, а Рефал-5 — нет.
Приходится для пустых функций добавлять предложение NF = NF (в промежуточном представлении
не существует идентификаторов NF, поэтому такой метод корректен). Использование деструктора
устраняет этот костыль: любая сгенерированная функция будет содержать предложение-деструктор.

  Дополнительные замечания.
  Функция $DELETE соответствует идеологии Модульного Рефала — использование встроенных средств
только для встроенных в язык возможностей.
  Функция $DELETE может принимать не только s-переменную, но и вообще любое объектное выражение,
что имеет смысл, когда замыканий в контексте несколько. Разумеется, передавать литералы атомов
бессмысленно (их даже можно удалять во время компиляции или выдавать предупреждение), но для
унификации синтаксиса допустимо.
  Разрешать ли передачу в $DELETE скобок, как безымянных, так и абстрактных, я пока не определился.
  Конструкции &$DELETE и $DELETE не после левой скобки вызова в результатной части следует считать
ошибочными, равно как и использование $DELETE внутри образца, за исключением образца, состоящего
из единственного символа $DELETE.
  Допустимы два варианта написания $DELETE и $delete.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  В рамках ревизии комментирую: задача низкоприоритетная, когда будет настроение, ею займусь. Новых
мыслей по ней у меня нет.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Есть интересная мысль реализовать перпендикулярный вышеописанному подход.

  В исходной постановке задачи говорится:

> Семантически не должно быть способа разделить замыкание на элементы каким-либо сопоставлением
> с образцом, следовательно, замыкание должно быть атомом и сопоставляться с s-переменной.
              ^^^^^^^^^^^^^

  Слово «следовательно» подчёркнуто специально. Потому что не следовательно. Для Рефала-7
«следовательно», для Простого Рефала — s-переменные по историческим причинам, для Модульного Рефала
существуют термы (t-переменные), которые в некоторых обстоятельствах неразложимы сопоставлением
с образцом.
  Речь идёт об АТД-термах. В «своём» модуле они синтезируются и анализируются при помощи синтаксиса
квадратных скобок, в «чужих» — они чёрные ящики.
  Так почему же не представлять вложенные функции как некоторые АТД, которые не разложимы ни в каком
модуле? В таком случае потребуется расширить синтаксис вызовом t-переменной:

  <t.Func ...>

  Реализация может быть такой. Теги абстрактных скобок в текущей реализации компилируются в пустые
функции (в профилях C++/SR и SimRef) либо просто в какие-то идентификаторы (в профиле Рефала-5).
Для (неявно создаваемых) абстрактных тегов вложенных функций можно генерировать уже непустую функцию.
  Вызов t-переменной будет, в случае, если это простой указатель на функцию, вызывать его как
и раньше, если это абстрактный терм — вызывать тег терма как функцию, передавая ей содержимое терма
и аргумент вызова. Для обычных АТД такой вызов будет приводить к фейлу — вызову пустой функции либо
к вызову несуществующей функции при помощи Mu.

  Преимущества решения перед s-переменными:
  (+) Простота реализации во всех профилях.
  (+) Нет утечек памяти. Не нужно явно разрушать замыкание.
  (+) Простое и понятное сравнение на равенство — две вложенные функции с идентичным захваченным
контекстом, построенные из одного блока, будут равны. Как равны два абстракных терма.
  (+) Возможность реализации взаимно рекурсивных именованных функций. Если каждая из вложенных
функций будет возвращать «указатель» на соседнюю, то отдельные вызовы для возврата этого указателя
будут давать один и тот же терм. Просто в силу сравнения не по ссылке, а по значению. Ссылочная
эквивалентность потребовала циклических связей на уровне структуры данных, что крайне трудоёмко
(если вообще возможно) было бы разрешать для счётчика ссылок (или ручного удаления).

  Особенности (считать ли их недостатками — вопрос открытый):
  (*) Копирование не за константное время. Вложенные функции Простого Рефала являются атомами
и всегда копируются за константное время — просто увеличивается счётчик ссылок. Платой
за эффективность копирования является неэффективность вызова — если ссылок несколько, контекст
не переносится, а копируется. Так что можно сказать, что происходит отложенное копирование
контекста.
  t-переменные всегда будут копироваться энергично, но при вызове контекст копировать не надо.
  Т.е. при таком подходе мы жертвуем механизмом отложенного копирования, который мог бы
использоваться в каких-нибудь идиомах или при оптимизации (я этим не пользовался).
  (*) Симметрично — медленная проверка на равенство. Но вообще это не проблема, поскольку мне
на практике не приходилось сравнивать на равенство два замыкания. И мне не известны сценарии,
когда это может понадобиться.

  Недостатки:
  (-) Механизм конфликтует с задачей #1 — внедрением в язык ограниченного ООП. Для реализации
последнего тоже используются теги абстрактных скобок, которые тоже трактуются как функции
с некоторой реализацией.

  Разрешить конфликт можно разными способами.
  Можно придумать более хитрую реализацию вызова методов и замыканий. Если после открывающей
скобки активации находится имя виртуальной функции, то вызов трактуется как вызов метода.
Если там располагается абстрактная скобка — это вызов замыкания. Недостаток: придётся менять
рантайм Рефала-5λ ради Модульного Рефала. Да и реализация сложна.
  Можно вызовы <t.Func ...> неявно транслировать во что-то вроде <CALL t.Func ...>, где
CALL — некоторая встроенная функция. Тогда тег абстрактного терма сможет отличать виртуальные
функции от вызова замыканий просто по имени.
  Но можно пойти ещё дальше! Можно эту функцию CALL считать виртуальной! Тогда механизм вызова
замыкания будет выражаться через механизм вызова виртуальных функций. Реализация становится
существенно проще.
  Но если существует виртуальная функция для вызова замыканий, то почему бы не дать возможность
пользователю расширять эту виртуальную функцию для своих АТД. Тогда они тоже смогут поддерживать
синтаксис вызова функций. Будут своего рода функциональными объектами.

  Первое, что мне пришло в голову — создать библиотечный модуль с определением виртуальной
функции вроде такого:

  $MODULE RUNTIME;

  $VIRTUAL CALL {
    s.Func e.Arg = <s.Func e.Arg>;
    $DATA e.Arg;
  }

  $END RUNTIME.

  Тогда, если модуль содержит вызовы <t.Func ...>, то он неявно импортирует модуль RUNTIME,
а сами вызовы заменяются на вызов <RUNTIME::CALL ...>. При этом пользователь может явно
импортировать этот модуль и расширить RUNTIME.CALL для своих АТД.

  Преимущество:
  (+) Модуль RUNTIME можно использовать для ещё чего-нибудь. Например, он может содержать
вызов функции завершения работы программы, которая вызывает все финализаторы и завершает работу.
Сейчас эта функция генерируется для Рефала-5 и подключается как файл рантайма mrefalrts в других
профилях (реализация в C++/SR сейчас довольно кривая).
  Недостаток:
  (-) Решение противоречит идеологии Модульного Рефала: встроенные средства языка не должны быть
привязаны к пользовательским определениям. Например, пользователь может переопределить модуль
RUNTIME в котором функция CALL может остутствовать, и вся механика разрушится.
  Кроме того, теперь замыкания выглядят не как фундаментальный механизм языка, а как
синтаксический сахар для создания АТД, для которых расширяется некоторая виртуальная функция.
Т.е. компилятор генерит специальный код для какого-то прикладного библиотечного модуля. Это
противоречит идеологии.
  Аналогично запись <t.Func ...> тоже оказывается синтаксическим сахаром для вызова некоторой
прикладной функции.
  Дабы подчеркнуть идеологический конфликт, представим, что <t.Func ...> заменяется
не на <RUNTIME::CALL t.Func ...>, а на <MLambda::Apply t.Func ...>!

  Разрешить это противоречие можно, сделав расширяемую виртуальную функцию «безымянной». И либо
расширить её для своих АТД пользователь не может, либо должен использовать _специальный синтаксис._
Например, так:

  $DATA MyData;

  $EXTENDS <> {
    [MyData e.Context] e.Arg = ...;
  }

  Вместо квалифицированного имени используется пара скобок активации. Такая запись чем-то
напоминает переопределения операторов в C++: operator+(…), operator Type(…), operator()(…) и т.д.
Тоже используются специальные обозначения для специальных функций.

  Очевидно, получается, что задача зависит от задачи #1.


====================================================================================================
  [TODO] Ускорение работы компилятора на слабых машинах
====================================================================================================

  [TODO] 27.12.2014 - 15:43:41,16

  На слабых машинах (например, Pentium MMX, 64 Mb RAM) становится очевидным низкое быстродействие
быстродействие компилятора, связанное как с низким быстродействием сгенерированного кода, так и
с неоптимальными алгоритмами в самом компиляторе. К примеру, цикл раскрутки компилятора требует
нескольких десятков минут.
  На момент написания TODO часть работы по оптимизации была выполнена, а именно, были сделаны
следующие выводы и оптимизации.
  * Много времени уходит на создание статистической информации XLinx — около пяти с половиной
минут. Основная причина — отжор виртуальной памяти большей, чем физически установлено на машине.
Компилятор с профилем C++/SR потребляет более 80 Мбайт оперативной памяти, в то время как без свопа
в память влезает не более ≈35 Мбайт (остальное требуется операционной системе и фоновым программам).
Виртуальная память отжиралась по причине трёхкратного копирования перекрёстной информации при
порождении 4 файлов статистики. Двум файлам статистики требовался только список модулей — он стал
формироваться без потребления дополнительной памяти во время прохода по перекрёстной информации;
функция порождения таблицы перекрёстных связей стала прозрачной — в результате копирование
переменной стало ненужным.
  * Другой причиной низкого быстродействия был ассоциативный поиск среди всех записей при
построении инверсных сведений. Было применено хеширование — для каждого имени вычислялся хеш
(число от 0 до 37) и затем применялся двухуровневый ассоциативный поиск (среди имён с данным хешем
и внутри соответствующей корзины). Таким образом сложность была снижена с N² до N*sqrt(N), т.е.
на целый корень. Также хеширование ускорило поиск неслинкованных элементов.
  * Много времени отнимало построение деревьев модулей. Путей модификации логики самого алгоритма
я не обнаружил, а вот изменение структур данных ускорило этот этап примерно вдвое (с ≈40 до ≈20
секунд). Речь идёт о замене имён модулей (e-переменных) на числовые идентификаторы (s-переменнные).
Экономия времени связана со скоростью сравнения на равенство одноимённых переменных.
  * Суммарно эти две оптимизации снизили продолжительность построения статистической информации
до 2 минут.
  * Неплохо ускоряет работу back-end’а C++/SR использование компоновщика на make-файле. При
повторной перекомпиляции даже не запускается компоновщик Си++, т.к. make видит, что исполнимый файл
не обновлён по сравнению с объектными.
  * Перекомпиляция для back-end’а Простого Рефала занимает продолжительное время (порядка 4-5
минут), режимы, ускоряющие его работу, я пока не смотрел, т.к. часто им и не пользовался.
  * Back-end Рефала-5 ещё не оптимизирован, работает сильно медленно (несколько минут), возможно,
его также спасёт хеширование.
  * Профилировщик очень полезен в деле оптимизации.
  * Также полезно наблюдение за работой программы в диспетчере задач Windows XP, т.к. он показывает
не загрузку физической памяти (как в более поздних ОС), а загрузку виртуальной. Визуально по
графикам можно определять причины проблем:
    — если сильно выросло потребление памяти, а загрузка процессора не полная — проблема в свопе;
    — если загрузка процессора полная — проблема в вычислениях.
Сейчас на всём протяжении перекомпиляции имеем практически 100%-ную загрузку процессора.
  * Сейчас уже проблема находится не в свопе, а в затратах на вычисление.
  * Функция MOrder::Sort медленная и путей её ускорения я не вижу.

  Что предстоит сделать:
  * Сделать профилировщики более интеллектуальными. См. отдельное TODO.
  * Рассмотреть вопрос оптимизации кэша. На текущий момент звенья поля зрения в back-end’ах C++/SR
и Простого Рефала имеют размер 5 слов (20 и 40 байт на x86 и amd64 соответственно), что
не оптимально с точки зрения кэша процессора. Каждое звено включает в себя ссылки вперёд и назад
(по 1 слову), поле тега (из-за выравнивания — 1 слово, хотя хватило бы и байта), поле информации
(2 слова).
  Едиственная альтернатива в поле информации, занимающая два слова — ссылка на функцию, включающая
в себя указатель на функцию и указатель на её имя. Если в поле информации хранить не пару
указателей, а указатель на структуру, хранящую эту пару указателей, то звено уже будет кратно строке
кэша. Возможно снижение производительности, связанное с дополнительной косвенной адресацией, но оно
будет пренебрежимо мало по сравнению с затратами времени на всё остальное. Другим преимуществом
будет отход от генерации идентификаторов для представления имён функций в C++/SR.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  * Оптимизировать компоновщик back-end’а Рефала 5, возможно, путём хеширования.
  * Когда исследование совместного сопоставления с образцами будет завершено, внедрить этот механизм
оптимизации.
  
----------------------------------------------------------------------------------------------------
  [TODO] 21.10.2015 - 11:41:49,72

  Из того, что сделано.
  * Профилировщики сделаны интеллектуальными. Соответствующая задача закрыта.

  Из того, что предстоит сделать.
  * Рассмотреть вопрос по оптимизации кэша. Остаётся как есть, см. выше.
  * Изыскать пути оптимизации компоновщика back-end’а Простого Рефала.
  Последние несколько месяцев проект Простого Рефала начал активно развиваться. Применительно
к текущей задаче — быстродействие компилятора заметно повысилось (приблизительно на 5…10 %). Имеет
смысл актуализировать версию Простого Рефала, входящую в проект Модульного Рефала как минимум
из соображений быстродействия.
  См. отдельное TODO.
  * Оптимизировать компоновщик back-end’а Рефала-5. Поиск путей оптимизации пока ведётся. Видятся
два варианта. Эволюционный: ищем в коде узкие места, оптимизируем их. Революционный: отказаться
от переименований функций и переменных на уровне компоновщика, вместо этого просто склеивать файлы.
Правильные имена функций и переменных давать сразу на этапе генерации «объектников».
  См. отдельное TODO.
  * Про совместное сопоставление с образцом. Ничего нового.
----------------------------------------------------------------------------------------------------
  [TODO] 06.11.2015 - 10:21:12,56

  Back-end РЕФАЛа-5 оптимизирован, остальные пункты не потеряли актуальности.
----------------------------------------------------------------------------------------------------
  [TODO] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Что касается оптимизации кэша (4-байтовые узлы), проведено такое исследование для Простого Рефала
(ветка 4bytes не в основной ветке, ветка черновая). Предварительные результаты — снижение
быстродействия на уровне статистической погрешности (около 1 %). Имеет смысл сделать, но только
ради экономии памяти.
  Оптимизация компоновщика профиля Простого Рефала имеет несколько направлений деятельности:
  * оптимизация самого компилятора Простого Рефала,
  * вызов компилятора Простого Рефала только для исходников, изменившихся с момента последней
компиляции.
  Очевидно, первый вариант следует обсуждать не тут, а в трекере самого Простого Рефала, поэтому
заметим, что в ближайшем будущем предстоит исследование некоторых оптимизаций Простого Рефала
в рамках бакалаврских квалификационных работ.
  Второй вариант также возможен и даже имеет больше смысла, ведь при неполной компиляции программы
back-end’ом компилируется весь набор исходников. Устранение избыточной компиляции принесёт большую
пользу, чем ускорение самого Простого Рефала на десятки процентов.
----------------------------------------------------------------------------------------------------
  [TODO] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Последнее время я редко пользуюсь старым ноутбуком, поэтому задача пока не актуальна. Да и вроде
уже достигнуто приемлемое быстродействие (надо подумать над этим и закрыть задачу).


====================================================================================================
  [TOTHINK] ВПВ: Opensource-лицензия
====================================================================================================

  [TOTHINK] 05.11.2010 - 21:36:08,97

  Следует выбрать opensource-лицензию. TOTHINK станет TODO когда лицензия будет выбрана. TODO
включит в себя задачу по внедрению лицензионного соглашения в исходные тексты программы.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Во-первых, компилятор коммерческой ценности не представляет, но может представлять научную или
программистскую ценность, поэтому для него следует использовать лицензию opensource.
  Во-вторых, из opensource-лицензий я предпочитаю либеральные по типу BSD, чем свободные GNU.
Дело в том, что код под либеральной лицензией можно использовать в рамках проектов под одной
из лицензий *GPL, но наоборот уже нельзя. Кроме того, BSD-лицензии разрешают использовать код
и в несвободном ПО. Таким образом, они налагают меньшее число ограничений.
  Из того, какие лицензии можно использовать. Во-первых, компилятор и библиотеки к языку следует
распространять под разными лицензиями: создание производного продукта на основе компилятора должно
требовать сохранения указания авторских прав в производном продукте, но создание производного
продукта на основе библиотеки (т.е. просто написание программы, использующей библиотеку) не должно
налагать такого ограничения.
  Для компилятора предпочтительны лицензии типа двухпунктовой BSD или MIT (они эквивалентны,
выбор — исключительно вопрос вкуса), для библиотек — «однопунктовая» BSD или Boost. В обоих случаях
распространение библиотек в исходном виде будет требовать сохранения копирайта, в двоичном виде —
нет.
  С конкретным выбором библиотек я пока не определился.
  Для Простого Рефала используется двухпунктовая BSD для компилятора и «однопунктовая» — для
библиотек.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 25.02.2016 - 11:42:56,37

  Временно выбрана двухпунктовая BSD для всего проекта. Лицензия на библиотечные компоненты будет
уточнена, возможно, позаимствована из Простого Рефала.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Пока неактуально придумывать что-то новое. Потом что-нибудь придумаю и закрою задачу.


====================================================================================================
  [TOTHINK] Серьёзное расширение синтаксиса
====================================================================================================

  [TOTHINK] 06.11.2014 - 12:35:00,01

  Обоснование.
  1 Отсутствие вложенных функций приводит как к необходимости явного написания глобальных функций,
затем явно связываемых с контекстом, так и к сложночитаемым комбинациям функций при помощи средств
модуля MLambda ← таково краткое обоснование внедрения в язык хотя бы вложенных безымянных функций.
При этом внедрение в язык только вложенных безымянных функций может привести к похожему результату,
а именно к сложночитаемым комбинациям вложенных безымянных функций (при помощи комбинатора Y,
функций Composite и Fetch). Использование именованных функций полностью обесценивает комбинатор Y,
а соответствующие синтаксические средства снижают потребность в функциях Composite, Fetch и ряде
других. Таким образом, вложенные безымянные функции есть полумера.
  2 Во многих развитых диалектах Рефала есть механизм, позволяющий задавать дополнительные
ограничения на образец в левой части — условия в Рефале-5, неуспехи в других диалектах. Механизм,
очевидно, полезный, однако имитировать его при помощи одних лишь вложенных функций (не важно,
именованных или нет) достаточно трудно (без открытых e-переменных) или даже практически невозможно
(с открытыми e-переменными). Под трудностью и практической невозможностью подразумевается тот факт,
что код в результате получится чрезвычайно сложным и нечитаемым («овчина выделки не стоит»).

  Предлагается реализовать синтаксис, являющийся средним между Рефалом-5 и Рефалом-7: из Рефала-7
берём вложенные функции и действия ":", ",", "->", "::", "=", "=>", из Рефала-5 невозможность
возврата неуспеха из функции. Таким образом, неуспехи могут порождаться только действием ":"
(действие "::" при невозможности сопоставления аварийно останавливает программу), "," и "->"
прозрачны для неуспехов, "=" и "=>" непрозрачны для неуспехов (неперехваченный неуспех после
них приводит к аварийному останову программы), образец после ":" может перехватывать неуспех
(путём удлинения открытых e-переменных), образец после "::" не может перехватывать неуспех
(сопоставление однозначно).
  Вопрос об образцах после "::" (допустимы любые образцы, либо только жёсткие) требует
дополнительной проработки.
  Некоторые переменные могут помечаться как переопределяемые символом "^". Требуют проработки
следующие вопросы: символ "^" должен идти перед переменной или после, если переменная с крышкой
повторная в данном образце, все ли экземпляры должны быть помечены или не все, какие из них.

  В дальнейшем требуется:
  1 Подробнее сформулировать синтаксис и семантику
  2 Проработать указанные выше вопросы
  3 Продумать особенности реализации.
  4 Проанализировать плюсы и минусы возврата неуспехов из функций.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 18.12.2015 - 16:11:11,60

  (Ревизия 18.12.2015)
  Есть интересные мысли, описывающие довольно цельный, но сложный и громоздкий синтаксис. Их нужно
оформить в виде отдельной спецификации, а также решить, воплощать ли их в программе.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 13.03.2016 - 23:24:12,47

  Предлагается функции делить на три вида (modes):
  1. Чистые функции. Далее — просто функции. Они не могут возвращать неуспех, всегда детерминированы
и не имеют побочных эффектов. Им соответствует символ "&"
  2. Функции, способные вернуть неуспех. Далее — функции-предикаты или просто предикаты. Они чистые,
то есть детерминированы и не имеют побочных эффектов. Им соответствует символ "?".
  3. Недетерминированные функции и/или функции с побочными эффектами. Далее — процедуры (ну не нашёл
другого подходящего слова). Они не могут возвращать неуспех. Им соответствует символ "!".

  Чистые функции могут вызывать только чистые функции и предикаты. При этом, если вызываемые
предикаты возвращают неперехваченный неуспех, происходит аварийное завершение программы. Вызвать
из чистой функции процедуру напрямую синтаксически невозможно, косвенно (по указателю) — приведёт
к тому же авосту во время выполнения.
  Предикаты могут вызывать только чистые функции и другие предикаты. Неперехваченный неуспех
из вызываемого предиката приводит к неуспеху вызывающего предиката. Вызов процедур невозможен
аналогично случаю с чистыми функциями.
  Процедуры могут функции любого вида. Неперехваченный неуспех в процедуре приводит к аварийному
завершению программы.

  Вид функции указывается в объявлении функции:

    &PureFunction {
      …
    }

    PureFunction2 {
      …
    }

    ?Predicate {
      …
    }

    !Procedure {
      …
    }

  При этом у чистых функций знак "&" можно опускать. Вызов функции оформляется аналогично:

    … <&PureFunction …> …
    … <PureFunction2 …> …
    … <?Precicate …> …
    … <!Procedure …> …

    … <& s.FnPureFunction …> …
    … <s.FnPureFunction …> …
    … <? s.FnPrecicate …> …
    … <! s.FnProcedure …> …

  Точно также, в скобках вызова чистой функции знак "&" можно опускать. Последние четыре примера
выше — косвенный запуск. В ряде случаев допустимо косвенно вызывать функцию не того вида, какой
ожидается в вызове — при этом получаем вполне ожидаемое поведение:

    ┌──────────┬───────────────────────────────────────┐
    │          │               Вызов                   │
    │ Функция  ├───────────────────────────────────────┤
    │          │  <& s.Func>   <? s.Func>   <! s.Func> │
    ├──────────┼───────────────────────────────────────┤
    │ &Func    │      ++           ++           ++     │
    │ ?Func    │      +-           ++           +-     │
    │ !Func    │      --           --           ++     │
    └──────────┴───────────────────────────────────────┘

  Обозначения:
  ++ — полностью поддерживается.
  -- — приводит к аварийному останову.
  +- — приводит к аварийному останову при возврате неуспеха вызываемой функции.

  Функция есть набор предложений, синтаксис отдельного предложения:

    Sentence = Pattern { Action }+.
    Action =
        "=" Result
      | "?=" Result
      | "," Result
      | ":" Pattern
      | "::" Pattern
      | "=>" Mode Result
      | "?=>" Mode Result
      | "->" Mode Result
      | Mode "~" Result
      | ( "\&" | "\?" | "\!" ) Pattern Action
      .
    Mode = ( "&" | "?" | "!" ).
    Mode = [ ModeReq ].

  Рассмотрим отдельно каждый из вариантов.
  1. "=" Result — результатное действие, непрозрачное для неуспехов. При возникновении
неперехваченного неуспеха справа от знака "=" происходит аварийный останов программы. Действие
допустимо в любых видах функций.
  2. "?=" Result — результатное действие, способное вернуть неуспех. При возникновении
неперехваченного неуспеха справа от знака "?=", результатом всей функции становится неуспех.
Действие допустимо только в функциях-предикатах.
  3. "," Result — результатное выражение, прозрачное для неуспехов — передаёт неуспех справа-налево.
Действие допустимо в любых видах функций.
  4. ":" Pattern — образцовое действие, способное вернуть неуспех и прозрачное для неуспехов. При
возникновении неуспеха справа от действия, осуществляется поиск нового сопоставления с образцом.
Если удалось сопоставить образец другим образом, выполнение передаётся на следующее действие
предложения. В противном случае действие возвращает неуспех. Действие допустимо в любых видах
функций.
  5. "::" Pattern — перестройка — образцовое действие, прозрачное для неуспехов, но сопоставляющееся
всегда успешно и однозначно. При невозможности сопоставления с образцом программа аварийно
завершается. При возникновении неуспеха справа от действия неуспех передаётся справа-налево.
  6. "=>" @ Result — действие-вызов, непрозрачное для неуспехов. Здесь и ниже @ заменяет "&", "?"
или "!".  Синтаксический сахар. Конструкция
    =>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 = R1 :: e.Env2 = <@ e.Env2 e.Env1>
Действие допустимо в любых видах функций.
  7. "?=>" @ Result — действие-вызов, способное вернуть неуспех. Синтаксический сахар. Конструкция
    ?=>@ R1
эквивалентна следующей конструкции:
    :: e.Env1 ?= R1 :: e.Env2 ?= <@ e.Env2 e.Env1>
Действие допустимо только в функциях-предикатах.
  8. "->" @ Result — действие-вызов, прозрачное для неуспехов. Синтаксический сахар. Конструкция
    ->@ R1
эквивалентна следующей конструкции:
    :: e.Env1, R1 :: e.Env2, <@ e.Env2 e.Env1>
  9. @ "~" Result — действие декаррирования. Прозрачно для неуспехов. Синтаксический сахар.
Конструкция
    @~R1
эквивалентная следующей конструкции:
    :: e.Env1, <@ e.Env1 R1>.
Действие допустимо функциях любых видов.
  10. "\@" Pattern Action — лямбда. Допустима только после результатных действий. Синтаксический
сахар. Конструкция
    … R1 \@ P2 sentence-tail;
эквивалентна
    … R1 @{ P2 sentence-tail; };
Конструкция допустима в любых видах функций. Конструкция может быть полезна для использования в DSL
для каких-нибудь монад или ещё чего-то.

  Вложенные функции могут быть как безымянные, так и именованные. Безымянные имеют вид:
    … &{ … } …
    … { … } …
    … ?{ … } …
    … !{ … } …
Именованные:
    … $func &Pure { … } …
    … $func Pure2 { … } …
    … $func ?Pred { … } …
    … $func !Proc { … } …
Как и ранее, знак "&" допустимо опускать.
  Указатели на глобальные функции представляют собой имена функций, предварённые символом вида:
    FnPtr = ModeReq IDENTIFIER | Mode DotQualifiedName.

  Скобки активации существенно усложнились:

    CallTerm = "<" CallInit { Action } ">".
    CallInit =
        Mode Callable Result
      | "=" Result
      .
    Callable = FunctionName | Variable | CallTerm | FnPtr.
    FunctionName = QuadQualifiedName.

  Смысл здесь в том, что в угловых скобках теперь не просто вызов функции с аргументом-результатным
выражением, а целое предложение, начальный компонент которого — либо вызов функции, либо просто
порождение результата. Список вызываемых объектов теперь включает также все виды переменных, либо
другие скобки вызова — почти всё, что угодно.
  Конструкция "=" Result инициализирует среду значением данного результатного выражения. Таким
образом, запись <= R1> будет эквивалентна просто R1. Смысл конструкции в том, чтобы можно было
писать такие конструкции:
    <=
      <CalcSomething> => {
        Success = …;
        Fails = …;
      }
    >
что эквивалентно идиоме <Fetch …> Простого Рефала:
    <Fetch
      <CalcSomething> {
        Success = …;
        Fails = …;
      }
    >


  Заключение.
  Это описание намеренно сделано нечётким, есть куча неописанных деталей. Причина — это всего лишь
черновик описания. В частности, остаются вопросы:
  1. В ряде мест конфликтуют имена, квалифицированные квадроточием, и перестройки. А не отказаться
ли нам от имён с квадроточиями вообще — перейти на точку? Или можно сделать компилятор
интеллектуальным — догадываться в каждом конкретном случае, что имел ввиду программист. Если
допустимы оба варианта, выдавать ошибку?
  2. Вопрос реализации — надо продумать, как генерить оптимальный код для этих конструкций.
  3. Остался вопрос по перестройкам — должны ли после них быть только жёсткие выражения.
  4. Никак не затронут вопрос переопределения переменных.

  А неуспехи из функций нужны. Они могут существенно поднимать выразительность кода. Но они должны
быть явно синтаксически выделены. Также полезно выделять функции с побочным эффектом. Поэтому как-то
так.
----------------------------------------------------------------------------------------------------
  [TOTHINK] 14.03.2016 -  1:06:36,70

  Дополнительные вопросы:
  5. Синтаксис оказался довольно сложен. Нужно либо обосновать сложность синтаксиса с идеологических
позиций, либо упростить.
  6. Вопрос: можно ли создать в одном модуле несколько функций с одинаковым именем и разными видами?
----------------------------------------------------------------------------------------------------
  [TOTHINK] 28.03.2018 - 11:33:50,24

  (Ревизия 2018-03-28)
  Предложенное расширение синтаксиса, если кратко, предлагает следующие цели:
  * Синтаксические конструкции Рефала-7.
  * Разделение на уровне синтаксиса для чистых функций, функций с неуспехами и нечистых.
  * Расширение синтаксиса угловых скобок — синтаксический сахар.

  Вторая цель интересна и важна — она полностью соответствует идеологии Модульного Рефала:
надёжность и контроль на стадии компиляции.
  Третья цель — удобный синтаксический сахар, на сколько полезен, ещё вопрос.

  А вот на первую цель я сейчас смотрю скептически. Дело в том, что Рефал-7 не замкнут относительно
прогонки, а значит, промежуточное представление будет отличаться от синтаксического дерева, если
я буду делать эту оптимизацию.
  Для замыкания необходимы два синтаксических средства: механизм управления неуспехами
и результатные блоки. И того, и другого во входном синтаксисе нет.
  Когда я предлагал новый синтаксис, я этого ещё не понимал, думал, что результатные блоки — это
просто удобный синтаксис, без которого, однако, можно вполне обойтись. Оказалось, что наоборот.
И чтобы писать эффективно оптимизируемые программы, программист должен мыслить в терминах
оптимизатора, а значит, результатные блоки должны быть.

  Следовательно, надо продумывать внедрение синтаксических конструкций Рефала Плюс/Рефала-6.


