    DSL описания командной строки

  Мотивация. Компилятор Модульного Рефала построен по модульному принципу: исходный текст преобра-
зуется в промежуточное представление, по которому затем генерируются выходные файлы, которые затем
ском-
поновываются в целевой файл. Каждый из этих трёх этапов имеет чётко определённый интерфейс с други-
ми этапами, но при этом его представление сравнительно независимо от остальных. Такое разделение
позволяет как выбирать разные режимы работы, так и комбинировать некоторые этапы (например, и вы-
полнять генерацию кода на целевом языке, и обобщать информацию о программе, например, строить табли-
цу перекрёстных связей). Подобная гибкость требует мощных средств конфигурирования, как для настрой-
ки реализаций различных этапов, так и для способов их комбинирования.
  На данный момент компилятор существует лишь в одной ипостаси -- компилятор командной строки (что
не отрицает в будущем создания компилятора в другой форме, например, в виде ИСР), поэтому основным
способом конфигурирования на данный момент является командная строка. Другим способом настройки мо-
гут быть конфигурационные файлы, но их использование порождает ряд вопросов:
  (а) расположение глобальных конфигурационных файлов по умолчанию; в ОС Windows можно конфигураци-
онные файлы помещать как в каталог, содержащий исполнимый файл, так и в общий для всех пользовате-
лей домашний каталог (по умолчанию \Documents and Settings\All Users); в POSIX-совместимых системах
глобальный конфигурационный файл принято располагать в каталоге /etc или /usr/etc, таким образом для
нахождения конфигурационных файлов или нужно поддерживать нескольких разных версий компилятора, или
вводить системные функции для поиска каталогов глобальных конфигурационных файлов;
  (б) расположение конфигурационных файлов -- возникают те же вопросы.
  Поэтому для данного этапа выбрано конфигурирование средствами командной строки.

  Синтаксис командной строки. Командная строка представляет из себя последовательность аргументов.
Разбиение командной строки на аргументы зависит от используемой операционной системы и back-end'а,
при помощи которого был получен исполнимый файл компилятора (например, при использовании back-end'а
Рефала 5 аргументы командной строки не могут начинаться с дефиса). Синтаксис аргумента в РБНФ пока-
зан на листинге 1.

Листинг 1.

  Аргумент = '(' | ')' | Опция | Файл | Загрузка .

  Опция = ( '+' | '-' ) ИмяАргумента [ ':' Параметр ] .

  Файл = [ ('+' | '-') 'file:' ] ИмяФайла.

  Загрузка = ('+' | '-') 'cfg:' ИмяФайла.

  ИмяАргумента = любой печатаемый символ кроме пробельного и ':'.

  Параметр = любой печатаемый символ кроме пробельного.

  ИмяФайла = любой печатаемый символ кроме пробельного.

Конец листинга.

  Таким образом аргумент командной строки может быть либо одной из скобок, либо опцией, которая
имеет необязательный парамер, либо именем файла. Если имя файла начинается с '+' или '-', то его
следует предварить префиксом '+file:' или '-file:', чтобы отличить его от параметра командной стро-
ки. До и после ':' внутри опции с параметром (а также в псевдоопциях file и cfg) могут присутство-
вать пробельные символы, а также перед именем опции и после аргумента (например, если опция введена
как " +option : param " в командном процессоре cmd.exe), эти пробелы игнорируются.
  Опция cfg обрабатывается на уровне лексического анализа и означает интерпретацию содержимого тек-
файла как списка аргументов командной строки. Аргументы командной строки, загружаемые из файла,
образуются из строк файла путём удаления пробельных символов из начала и конца каждой строки и
затем удалением из полученного списка пустых строк и комментариев -- строк, начинающихся с '#'. Ес-
ли имя файла, указываемого в текстовом файле, начинается с '#', то имя файла следует предварить
как и ранее префиксом '+file:' или '-file:'. Внутри файлов также можно использовать опцию cfg,
в случае рекурсивной зависимости сигнализируется ошибка командной строки.
  Т.к. ряд параметров, относящихся к разным реализациям этапов обработки, имеет сходный смысл (рас-
ширения и папки для промежуточных файлов), то чтобы не усложнять внешний вид отдельных параметров,
было принято решение ввести иерархическую организацию командной строки. Иерархическая организация
осуществляется путём введения т.н. групп параметров. Опция или файл, указанные в командной строке,
могут иметь группу параметров. Таким образом синтаксис описывается следующей РБНФ (листинг 2).

Листинг 2.

  КоманднаяСтрока = РасширенныйАргумент* .

  РасширенныйАргумент = ПростойАргумент [ '(' КоманднаяСтрока ')' ] .

  ПростойАргумент = ОПЦИЯ | ФАЙЛ .

Конец листинга.

  В листинге ОПЦИЯ и ФАЙЛ означают неделимые на данном уровне описания аргументы командной строки.
Очевидно, что (а) если объединить обработку синтаксиса командной строки с обработкой конкретных
опций, то получится сложный сам по себе и для сопровождения код, (б) сам по себе синтаксис доста-
точно прост и если каким-то образом семантику задавать извне, то можно написать компактную програм-
му-драйвер, обрабатывающую синтаксис и семантику. Таким образом приходим к EDSL.

  EDSL описания структуры командной строки. EDSL (embedded DSL) представляет собой обычный код на
Рефале, наполненный новым смыслом. В данной спецификации предполагается следующий синтаксис (лис-
тинг 3, листинг дан в тех обозначениях для функций и объектных выражений, которые используются
в исходных файлах Модульного Рефала, кроме того, квадратные скобки обозначают необязательный аргу-
мент).
  Предполагается, что корректность синтаксиса (сбалансированность скобок, отсутствие висячих бло-
ков (не предварённых "простым аргументом") анализируется драйвером и сведения об ошибках добавляют-
ся в список ошибок (о последнем см. ниже). Драйвер по возможности восстанавливается после ошибок,
в случае правильно разобранного расширенного аргумента, его обработка передаётся соответствующей
семантической процедуре.

Листинг 3.

  <MLambda::Apply t.FnCmdLineDescriptor>
    ==
      (
        t.FnInitCollected
        (
          (e.OptionDescr)
          t.FnOptionHandler
          t.Optional
          s.Multiply
          [ s.GroupOpt t.FnGroup [ t.FnGroupEx ] ]
        )*
      )*

  <MLambda::Apply t.FnInitCollected>
    == t.Collected

  e.OptionDescr ::=
    Naked e.OptionNames |
    Param e.OptionNames |
    ParamOpt e.OptionNames |
    Switch (e.OptionNames)*

  e.OptionNames ::= (e.OptionName)*

  e.OptionName ::= char* | File | EOG // end of group

  <MLambda::Apply t.FnOptionHandler
    t.ErrorList t.Collected t.SrcPos t.ArgParam t.ArgGroupCollected
  >
    == t.ErrorList t.Collected

  t.ArgParam ::= (e.Param) | NoParam

  t.ArgGroupCollected ::= t.GroupCollected | NoGroup

  t.Optional ::= Required | ( Optional [t.FnOptional] )

  t.FnOptional ::= t.FnOptionHandler

  s.Multiply ::= OneTime | Multiply

  s.GroupOpt ::= Required | Optional

  t.FnGroup ::= t.FnCmdLineDescriptor

  <MLambda::Apply t.FnGroupEx t.SrcPos e.Param>
    == t.FnGroup

Конец листинга.

  Таким образом EDSL представляет собой набор функций, которые возвращают набор наборов (!) аргу-
ментов командной строки. Семантика следующая. На вход некоторой функции, реализующей интерпретацию
EDSL, отправляется указатель на функцию t.FnCmdLineDescriptor, описывающую командную строку на вер-
хнем уровне и список ошибок t.ErrorList, повсеместно используемый в Модульном Рефале.

  Т.к. данный EDSL не различает собственно опции (с параметром и без) и имена файлов как аргументы
командной строки, в остальной части текста слово "опция" будет употребляться как синоним понятия
"аргумент (командной строки)".

  Данная функция вызывается без аргументов и возвращает список возможных наборов аргументов команд-
ной строки (t.FnInitCollected (e.OptionsDescr)*)*. Далее, если первый аргумент из командной строки
входит в первый набор, то для распознавания применяется только первый набор. Иначе пробуется второй
набор, затем третий и т.д. Если ни один набор не подошёл, то запись о первом аргументе добавляется
в список ошибок, первая опция удаляется из командной строки и процесс повторяется. Если ни один из
аргументов не подошёл, в список ошибок заносится запись о том, что ни один из аргументов не подошёл.
  Разделение на ортогональные наборы продиктовано предметной областью. Некоторые из опций могут на-
ходиться в командной строке только самостоятельно (например, выдача экрана справки по -h -- бессмыс-
ленно одновременно выводить справку и компилировать).
  В случае, если командная строка пуста, то предполагается, что используется первый набор в списке
возможных наборов аргументов.

  При обработке аргументов заданным набором вводится такая структура данных как "проанализированные
аргументы" t.Collected. При инициализации обработки заданным набором аргументов командной строки
структура t.Collected инициализируется функцией t.FnInitCollected. По завершении разбора командной
строки данная структура содержит требуемую информацию.

  Опции, в зависимости от способа обработки, делятся на четыре класса: всегда без параметра (Naked),
всегда с параметром (Param), с необязательным параметром (ParamOpt), опции-переключатели (Switch).
  Для naked-опций при вызове сематнической процедуры t.FnOptionHandler (см. ниже) в качестве пара-
метра передаётся пустой аргумент; для param-опций как параметр передаётся собственно параметр,
param-opt-опции являются фактически комбинацией naked- и param-опций.
  Switch-опции можно считать разновидностями одной опции -- можно считать, что эти опции во входной
строке (опции switch-опций всегда без параметра) заменяются на некоторую опцию с новым уникальным
именем, а сами имена становятся параметрами опции.
  Например, если для switch-опции, описанной как (Switch (('a')) (('b')) (('c'))) сгенерировано
уникальное имя sw1, то командную строку '-a', '-d', '-b' следует читать как '-sw1:a', '-d',
'-sw1:b'.

  Для одной опции может быть указано несколько имён, что позволяет использовать короткие псевдонимы
для длинных опций.

  Именем опции может быть собственно имя, появляющееся в командной строке, символ File, символ EOG.
Собственно имя соответствует обычной опции. Символ File соответствует появлению в командной строке
имени файла, которое передаётся в обработчик как параметр. Символ EOG соответствует концу команд-
ной строки или группы опций.

  Если в описании набора аргументов присутствует несколько описаний опций с одним именем, то прио-
ритет имеет опция, описанная ранее, таким образом наличие нескольких опций с одним именем не явля-
ется ошибкой, хотя и нелогично.

  Функцией-обработчиком данного расширенного аргумента является функция t.FnOptionHandler. Обработ-
чик имеет следующие входные и выходные параметры:
  t.ErrorList -- список ошибок, в который может заноситься информация (например, опция имеет некор-
ректный параметр);
  t.Collected -- обновляемая в процессе обработки структура данных, в которую заносится информация
о данном аргументе;
  t.SrcPos -- положение аргумента в командной строке/подгружаемом файле; используется в случае ошиб-
ки при обновлении t.ErrorList (для локализации ошибки); для EOG t.SrcPos соответствует положению
закрывающей скобки или последнему символу командной строки;
  t.ArgParam -- параметр аргумента, может быть как (e.Param), так и NoParam, что позволяет отличать
опции с пустым параметром (+opt:) и опции без параметра (+opt);
  e.Param -- параметр аргумента -- для param-опции -- это собственно параметр, для param-opt-опции
-- это если параметр присутствует -- собственно параметр, для naked-опции -- пустое выражение, для
switch-опции -- имя опции, для файла -- имя файла;
  t.ArgGroupCollected -- может принимать как значение t.GroupCollected, так и NoGroup, что позволя-
ет отличать опцию с пустой группой (+opt ( )), от опции без группы (+opt);
  t.GroupCollected -- необязательный аргумент для опций, принимающих после себя скобки, структура
t.Collected для подвыражения в скобках.

  Аргументы могут быть как обязательными, так и необязательными (опциональными). Обязательность ар-
гумента определяется параметром t.Optional. Значение Required означает, что данный аргумент обязан
появиться в командной строке. При отсутсвии обязательного аргумента при обнаружении EOG в список
ошибок будет добавлена запись об отсутствии аргумента. Значение (Optional [t.FnOptional]) означает,
что аргумент необязателен. Необязательный параметр t.FnOptional соответствует обработчику, который
будет вызван при обнаружении EOG если данный аргумент отсутствовала.

  Параметры могут появляться как однократно, так и многократно. Параметры, появляющиеся однократно,
могут определять режим работы, который достаточно указать один раз (например, полная перекомпиляция,
перекомпиляция при необходимости или только перекомпоновка). Параметры, появляющиеся многократно,
определяют набор каких-либо параметров, например, список файлов для компиляции или список каталогов
поиска. Число появлений опции определяется параметром s.Multiply, значение которого OneTime соответ-
ствует "однократной" опции и Multiply -- "многократной".

  Опции (кроме EOG-опций) могут после себя требовать группу опций, заключённую в круглые скобки
(согласно синтаксису расширенного аргумента). Зависимую группу опций описывает группа параметров
[ s.GroupOpt t.FnGroup [ t.FnGroupEx ] ]. Отсутствие этих параметров говорит о том, что аргумент не
ожидает после себя группу, наличие же описывает способ обработки группы. Параметр s.GroupOpt позво-
ляет указать, является ли группа обязательной: значение Required соответствует обязательности груп-
пы, Optional -- что после опции группы может и не быть. t.FnGroup описывает содержимое группы, ко-
торая следует за данной опцией. Данное описание может быть расширено функцией t.FnGroupEx, которая
для опций с параметром принимает значение параметра и возвращает описание содержимого группы.
  При одновременном наличии t.FnGroup и t.FnGroupEx при обработке группы после данного аргумента
используется описание, полученное конкатенацией описаний, получаемых из t.FnGroup и результата вы-
зова t.FnGroupEx с параметром опции. Если опция параметра не имеет, то использовать t.FnGroupEx
нелогично, но допустимо, в функцию t.FnGroupEx передаётся пустое выражение.