    Замена FnPtr на что-то другое

  Мотивация
  (А) Идеологически корявая. Функция FnPtr, будучи вызванной с одним аргументом, возвращает указа-
тель на любую функцию в некотором модуле, с двумя аргументами -- любую функцию (второй аргумент),
экспортируемую импортируемым модулем (первый аргумент). Т.е. потенциально можно получить указатель
на любую функцию, в том числе промежуточную (с суффиксом -Aux) или служебную, осуществляющую цикл
(префикс Do) или ветвление (префикс Sw), что смысла не имеет. Функция Mu задумывалась Турчиным, веро-
ятно, для изучения возможностей суперкомпиляции и преобразований программ. Однако здесь эти задачи
не ставятся и такая гибкость функции излишня. Чтобы получить указатель на функцию, функция FnPtr бу-
дет, скорее всего, вызываться с одним аргументом. Поэтому получение указателя на известную функцию
можно в таких случаях организовать с помощью специального синтаксиса. Если же понадобится получать
указатель на функцию по неизвестному идентификатору, то можно организовать соответствующую функцию
ветвления. Даже, когда я мотивировал необходимость в FnPtr, я в примере демонстрировал вызов FnPtr
с известным аргументом.
  Также, в самой реализации языка смешиваются два уровня представления о программе: внутренннее
(указатель на функцию, определяется реализацией) и внешнее (имя функции, доступное пользователю).
В идеале, конкретные имена объектов являются своего рода комментариями и в "машинном представлении"
должны терять свои описания во время выполнения (исключение может составлять лишь отладочная инфор-
мация, как например typeid в C++), т.е., например, связь между функцией и её именем должна во время
выполнения теряться. Однако функция FnPtr создаёт прямое отображение имён на указатели на функции.
В общем, это моё тонкое душевное ощущение, не нравится мне такое положение дел.
  Использование FnPtr с постоянным аргументом неэффективно: указатель на конкретную функцию извес-
тен в момент написания кода, но всё равно происходит лишнее вычисление. Конечно, можно было поднату-
житься и во время синтаксического разбора или разрешения вызовов распознавать такие случаи и заме-
нять их на конкретные указатели, но столь же эффективно было бы создать специальный синтаксис для
описания указателей.
  Более того, использование функции для получения указателей создаёт ассиметрию между образцовым и
результатным выражением -- в образцовом выражении нельзя описать указатель на функцию. Если необхо-
димо сравнить неизвестный указатель на функцию с известным, можно, конечно, написать две функции --
первая вызывает FnPtr для получения известного указателя, вторая сравнивает эти два указателя -- пи-
сать слои промежуточных функций для подмножества базисного Рефала дело обычное. Но введением специ-
ального синтаксиса для указателей на функцию такое сравнение можно легко упростить.
  Даже если имя функции вводится пользователем, то получение указателя на эту функцию всё равно
требует косвенного вызова для преобразования строки символов в идентификатор (такова семантика иден-
тификаторов в Модульном Рефале) -- было бы быстрее сразу получать указатель на функцию.
  Третья особенность этой функции -- она единственная автоматически генерируемая. Она незримо при-
сутствует в любом модуле, хотя пользователь может и переопределить её. Других автоматически генери-
руемых или встроенных функций в Модульном Рефале нет. Если пользователь создал свою функцию с именем
FnPtr, а затем удалил, то в локальные вызовы этой функции не станут от этого синтаксически ошибочны-
ми, программа будет компилироваться, но вести себя будет при этом иначе. В общем -- это неестествен-
ная функция.

  (Б) Ненадёжность. Если требуется получить указатель на известную функцию, требуется вызывать
FnPtr с известным аргументом. Однако, если допустить опечатку в аргументе для FnPtr, то ошибка выяс-
нится только на этапе выполнения, да и то, в непредсказумый момент времени. Использование специаль-
ного синтаксиса для указателей на функции позволяет обнаружить неверные вызовы гарантированно на
этапе компиляции.

  (В) Корявая реализация. Я сейчас переписывал модуль разрешения функций MResolver с ориентацией
на использование АТД "квалифицированные имена". Раньше я не придавал значения, но сейчас заметил, что
чтобы сгенерировать функцию FnPtr нужно иметь информацию обо всех импортируемых entry-функциях. Но,
если я хочу собирать информацию в таблице разрешений (MResolveTable) ещё до вызова разрешателя и при
этом в разрешатель не передавать явно список импортируемых функций, сгенерировать FnPtr-функцию ста-
нет труднее. Раньше, когда Resolver работал без таблицы разрешений, функция FnPtr генерировалась там.
Теперь вызов генерации оттуда выглядит корявее. В перспективе, если я вынесу заполнение таблицы раз-
решений извне модуля MResolver, то из этого же модуля придётся вынести и генерацию FnPtr. В общем,
её неудобно отдельно генерировать.
  Также она увеличивает размер генерируемых выходных файлов. Теперь, при введении компоновки по
функциям, таблицы FnPtr, если не вызываются, не добавляются в "exe-шник" (в кавычках, т.к. генери-
руется полуфабрикат exe-шника -- исходный текст для Рефала-5), но размер объектных файлов всё таки
увеличивается (объём всех .rout-файлов с функцией FnPtr составляет 469 939 байт, с вручную удалённной
фукнцией -- 337 242 байта, т.е. функция FnPtr составляет 28% процентов от объёма .rout-файлов). Также
увеличивается размер сгенерированных "exe-шников" при использовании FnPtr, хотя и не так значительно.

  TODO. Что же надо сделать.
  Неоднократно выше высказывалось предложение использовать специальный синтаксис для объявления
указателей на функцию. Можно предложить следующие подходы:

  I. Квалифицированное четыремя точками имя вне вызова функции. Для получения указателя на функцию
текущего модуля можно использовать квалификацию именем текущего модуля. На сегодняшний день квалифи-
кация именем текущего модуля в вызовах функции не поддерживается, но её не сложно разрешить.
  Преимущество. Не нужно вводить незнакомый синтасис.
  Недостатки. Если в дальнейшем расширять Модульный Рефал конструкциями из Рефала Плюс или Рефала
-6, то использование '::' внутри выражений приведёт к противоречию. Требуется квалификация текущим
модулем.

  II. Предварять имя функции специальным символом, типа * (как в Рефале-6) или & (как в Рефале
Плюс). В этом случае функцию текущего модуля не обязательно предварять именем модуля. Остаётся откры-
тым вопрос о квалифицированных именах.
  Преимущество. Параллели с известными языками, нет нужды квалифицировать текущим модулем.
  Недостаток. Введение нового символа. Другие недостатки зависят от разделителя квалификаторов.

  III. Использовать ранее неиспользовавшийся символ для разделения квалификаторов внутри указателя.
Например, можно использовать '+': InOut+WriteLine, Std+InOut+WriteLine, MThisModule+SomeFunction.
Доступ к "местным функциям" опять предваряется именем текущего модуля. Такие имена можно использо-
вать также в качестве вызываемого после '<'.
  Преимущество. Совместимость с возможным будущим синтаксисом.
  Недостатки. Введение нового символа, незнакомый синтаксис. Необходимость квалификации "местной"
функции.

  IV. То же, что и III, но с использованием точки. Типа Std.InOut.WriteLine или для "местной" функ-
ции -- ThisModule.SomeFunction.
  Преимущества. Синтаксис, схожий с известными языками (во многих языках используется квалифика-
ция точкой), совместимость с будущим синтаксисом, можно обойтись имеющимися лексемами. Также я уже
задумывался о введении квалификации точкой.
  Недостаток. Квалификация "местной" функции.

  Из перечисленных подходов мне больше всего нравится последний. Если его объединить с подходом II,
то можно избежать квалификации "местной" функции. Проблема такой квалификации состоит в том, что при-
дётся также разрешить квалификацию именем модуля и для обычных вызовов функций или же усложнить таб-
лицу разрешений. Следует всё взвесить и обдумать.