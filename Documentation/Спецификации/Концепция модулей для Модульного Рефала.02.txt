    Описание модульной концепции для Модульного Рефала

  Мотивация
  Модульная концепция, во-первых, упрощает разработку крупных приложений, т.к. способствует деком-
позиции системы на независимые части, во-вторых, даёт возможность предоставить пользователю
более богатый набор стандартных библиотечных функций, чем использование встроенных функций, как это
сделано во многих других диалектах Рефала. Набор встроенных функций по возможности должен быть орто-
гональным и компактным; функции, входящие в набор, должны быть примитивными. Набор функций библиотеч-
ных модулей не обязан быть примитивным и ортогональным -- функции могут быть даже реализо-
вываться обычными средствами Рефала (например, OneOf). Также набор библиотечных функций может быть
довольно объёмным, т.к. (1) пользователь имеет возможность выбирать библиотечные модули для импорта,
и, (2) при использовании квалифицированного доступа, конфликтов между именами функций не возникает.

  Описание
  Программа на Модульном Рефале состоит из модулей. Модули между собой могут группироваться по ие-
рархическому принципу в пакеты (как в языке Java).

  Набор модулей, которые после компиляции и связывания, образуют один исполнимый файл или одну
библиотеку, в данном документе будет называться проектом.

  Каждый из модулей и пакетов имеет некоторое имя. Имя (модуля или пакета) начинается с заглав-
ной буквы латинского алфавита или символа '!', после чего может следовать некоторое количество (воз-
можно, равное нулю) заглавных или строчных букв латинского алфавита, цифр или знаков '!', '-' или
'_'. Имя чувствительно к регистру символов, так например имена Name! и NAME! различаются. (Имя прак-
тически полностью подчиняется правилам, налагаемым на идентификаторы языка Модульный Рефал с тем
отличием, что в имени пакета или модуля символ '?' запрещён).

  В состав пакета могут входить другие модули и пакеты, при этом вложенность пакетов не может быть
циклической. В рамках одного пакета не могут находиться два модуля, два подпакета, модуль и подпакет
с одним именем, при сравнении без учёта регистра. (Это обеспечивает совместимость ОС, в которых имена
файлов чувствительны и не чувствительны к регистру). При этом в рамках одного проекта могут присут-
ствовать модули или пакеты с одинаковыми именами, но при этом они должны находиться в разных пакетах.
  Модуль или пакет не может быть одновременно включён в несколько пакетов.
  Те модули и пакеты, которые не входят в другие модули, называются корневыми.

  Квалифицированным именем пакета или модуля называется перечисление имён такое, что:
  (*) Квалифицированное имя пакета или модуля в корне состоит из одного имени этого пакета/модуля.
  (*) Квалифицированное имя пакета или модуля, входящего в некоторый пакет, состоят из квалифи-
цированного имени включающего пакета, после которого следует включённого пакета или модуля.
  В этом документе квалифицированные имена будут изображаться как перечисления имён, разделённых
точкой. Например: RootPackage.IncludedPackage.TerminalModule или Std.InOut.
  Каждый модуль или пакет, содержащийся в проекте имеет уникальное квалифицированное имя.

  Модулем называется набор программных сущностей (функции, типы данных, глобальные переменные), как
правило, объединённых логически. Модуль может использовать возможности других модулей (т.е. исполь-
зовать программные сущности, определённые в этих модулях), такое использование называется импортом.
Модуль в Модульном Рефале является единицей инкапсуляции, т.е. на уровне модуля решается, какие
программные сущности, определённые внутри модуля, могут быть доступны другим модулям извне. Такое
предоставление возможностей наружу называется экспортом. Импорт осуществляется путём ссылки на им-
портируемый модуль внутри импортирующего модуля, при этом импортирующий модуль может пользоваться
любыми экспортированными программными сущностями, предоставляемыми импортируемым модулем. О физи-
ческом представлении модулей написано в спецификации "Поиск исходников.txt".

  Модули делятся на два вида: обычные (регулярные) и головные. Регулярные модули точно отражают
определение выше, они представляют собой набор экспортированных сущностей, предназначенных для
импорта из других модулей (конечно, они могут содержать и неэкспортируемые сущности, необходимые
для реализации экспортируемых). Регулярные модули содержат код инициализации и финализации (далее,
инициализатор и финализатор), т.е. особый код, который вызывается средой выполнения языка. Если
синтаксис позволяет явно не указывать код инициализации или финализации, то предполагается, что
этот код пустой, т.е. не содержит ни одной исполняемой инструкции, но тем не менее он существует.
  О точном порядке вызова инициализаторов и финализаторов написано ниже. Код инициализации предна-
значен для подготовки модуля к работе, для формирования инварианта модуля, например, инициализация
глобальных переменных, создание каких-либо глобальных библиотечных объектов (например, открытия
файловых или сетевых дескрипторов), создания временных файлов, необходимых вовремя работы модуля.
Поэтому инициализация должна выполняться до первого обращения к экспортируемой сущности извне.
  Задача финализатора дуальна задаче инициализатора: выполняется закрытие дескрипторов объектов,
удаление временных файлов, сброс того или иного кэша и другие сходные функции. Аналогично, после
выполнения финализации не должно быть обращений к каким-либо экспортируемым сущностям модуля, т.к.
в этот момент модуль находится в неинвариантном состоянии.

  Головной модуль, в отличие от регулярного, предназначен для других целей. Головной модуль пред-
назначен для запуска программы средствами операционной системы: если программа компилируется в са-
мостоятельный исполняемый файл, то в головном модуле должна быть определена точка входа (для Рефала
традиционно это функция Go), если программа компилируется в динамическую библиотеку, то головной
модуль может иметь несколько точек входа, соответствующих импортируемым функциям библиотеки.
  Если программа компилируется в самостоятельный исполнимый файл, то головной модуль не должен со-
держать инициализаторы и финализаторы, т.к. исходя из логики они не нужны: кроме единственной точ-
ки входа никакие другие функции извне не вызываются, потому что необходимую инициализацию и финали-
зацию можно выполнить и в самой точки входа.

  В Модульном Рефале принят фиксированный детерминированный порядок инициализации и финализации мо-
дулей, т.е. независимо от хода выполнения программы порядок выполнения инициализаторов и финализа-
торов остаётся тем же (в отличие от языка Java, в котором блок статической инициализации выполняет-
ся при первом обращении к классу, поэтому если по логике программы класс может не использоваться,
своеобразный инициализатор не вызовется). Единственный способ повлиять на порядок вызова инициали-
заторов и финализаторов определён в правиле 6 (см. ниже). Порядок определяется следующими правила-
ми:
  1. Инициализаторы, код точки входа (если есть) и финализаторы выполняются последовательно (т.е.
не могут выполняться параллельно, например, в разных потоках). Если инициализатор, финализатор или
точка входа создают потоки (реальные или легковесные), то результат выполнения определяется реали-
зацией.
  2. В случае компиляции в самостоятельный исполнимый модуль, инициализаторы должны завершить своё
выполнение до начала выполнения точки входа, финализаторы запускаются после завершения выполнения
кода точки входа. Таким образом, код точки входа выполняется после полной инициализации программы
(инициализации всех модулей) и не раньше начала финализации программы (финализации всех модулей).
  3. В случае компиляции в динамически загружаемую библиотеку, инициализаторы должны выполняться
при загрузке библиотеки, финализаторы — при выгрузке библиотеки, т.е. таким образом, экспортиру-
емые функции библиотеки выполняются после инициализации и до финализации библиотеки.
  4. Если некоторый модуль импортирует другой модуль, то импортируемый модуль должен быть инициали-
зирован раньше и финализирован позже импортирующего, если импортирующий содержит инициализатор и
финализатор (т.е. не является головным модулем программы, компилируемый в самостоятельный исполни-
мый файл).
  Следствием из этого правила является то, что циклический импорт невозможен, т.к. в случае цикла
обязательно найдётся пара модулей, в которой порядок инициализации должен быть нарушен.
  Это правило является единственным правилом, которое определяет порядок вызова инициализаторов.
В случаях, когда это правило не определяет очерёдность вызова инициализаторов двух модулей (напри-
мер, в случае ромбовидного вызова: модуль A импортирует модули B и C, каждый из модулей B и C им-
портирует модуль D можно лишь утверждать, что инициализатор модуля A выполнится первым, инициали-
затор (если есть) модуля D — последним, инициализаторы B и С — между ними. Однако очерёдность вы-
зова инициализаторов B и C не определена), порядок вызова зависит от реализации. Однако он фикси-
рован и не изменяется от вызова к вызову программы.
  5. Финализаторы выполняются в обратном порядке по отношению к инициализаторам.
  6. Библиотека времени выполнения может предоставлять функции для принудительного завершения прог-
раммы (аналогично функциям exit() и abort() языков Си и Си++). Если функция принудительного завер-
шения программы предусматривает вызов финализаторов (аналогично функции exit(), подразумевающей вы-
зов обработчиков atexit и деструкторов объектов в Си++), то вызываются финализаторы только тех мо-
дулей, инициализаторы которых выполнились и завершили своё выполнение и финализаторы которых ещё
не начинали выполняться. Это означает, что если функция вызывается во время выполнения инициализа-
тора, но при этом часть модулей ещё не инициализировалась, то финализаторы этих модулей выполняться
не будут. Если функция вызывается внутри финализатора, то финализаторы уже финализированных модулей
(финализаторы которых выполнены ранее) повторно вызываться не будут, кроме того, принудительно за-
вершится выполнение текущего финализатора и начнёт выполняться следующий финализатор.
  Если функция принудительного завершения не подразумевает вызова финализаторов, то финализаторы
просто не выполняются.
  Сказанное выше справедливо лишь для программ, компилируемых в самостоятельный исполнимый модуль.
Поведение динамической библиотеки при вызове подобных функций принудительного завершения, также
как и поведение программы, загрузившей библиотеку, вызвавшую такую функцию, зависит от реализации.

  Если модуль уже финализирован (т.е. его финализатор завершил выполнение), то при использовании
сущностей, предоставляемых этим модулем не определено. В частности, механизм вызова инициализаторов
и финализаторов оставляет лазейку, позволяющую вызвать функцию уже финализированного модуля. Это
можно сделать, передав callback-функцию в импортируемый модуль, которую тот сохранит и вызовет в
своём финализаторе. Поскольку порядок вызова финнализаторов требует, чтобы финализатор импортиру-
ющего модуля вызывался раньше, чем финализатор импортируемого, callback-функция будет вызвана,
когда модуль уже финализирован. Кроме того, можно обратиться к функции уже выгруженной динамической
библиотеки. В таких случаях поведение не определено.

  Набор модулей, прямо или косвенно импортируемых некоторым конкретным модулем, называется гроздью
с корнем в этом модуле. Исходя из понятия проекта, данного в начале спецификации, можно показать,
что проект — это гроздь модулей с корнем в головном файле.
