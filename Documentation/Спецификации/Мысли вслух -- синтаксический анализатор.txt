$MODULE Parser;

$IMPORT LL1;

$ENTRY Parse
  t.ErrorList t.SymTable e.Tokens =
    <LL1::Parse
      ( t.ErrorList t.SymTable )
      & Root & Tokens e.Tokens
    >;

/*
  Нетерминал = (Альтернатива)*;
  Альтернатива = [Подготовка] Элемент* [Препросмотр] & Правило;
  Препросмотр = (& LL1.LookAhead Лексема)
  Элемент = Лексема | & Нетерминал | & LL1.Other | & LL1.EOF
  <Правило t.State t.Представление-элемента*>
    == t.State t.Представление-нетерминала

  Подготовка = (& LL1.Prepare & ФункцияПодготовки)
  <ФункцияПодготовки t.State> == t.State
*/

Tokens = Variable Char Number Name '=()<>;{},' Entry Extern;

Root = (& Declaration & Root & Root-Func);

Root-Func
  t.State () () = t.State ();

Declaration =
  (Extern & NameList & Externals-Func)
  (Entry & Body & Entry-Func)
  (& Body & Local-Func)
  (& LL1.Other & Root & UnexpectedRoot-Func);

UnexpectedRoot-Func
  (t.ErrorList t.SymTable) t.OtherToken () =
    (
      <MErrorList::AddUnexpected
        t.ErrorList t.OtherToken
        'Entry, extern or function'
      >
      t.SymTable
    )
    (e.Declarations);

Externals-Func
  t.State () = t.State ();

NameList =
  (Name & NameListTail & NameList-Func)
  (& LL1.Other & Root & UnexpectedRoot-Error);

NameList-Func
  (t.ErrorList t.SymTable) (Name t.SrcPos e.Name) =
    (t.ErrorList <MSymTable::AddName t.SymTable t.SrcPos e.Name>) ();

NameListTail =
  (',' & NameList & NameListTail-Comma-Func)
  (';' & NameListTail-Semicolon-Func)
  (& LL1.Other & Root UnexpectedRoot-Func);

NameListTail-Comma-Func
  t.State (',' t.SrcPos) () = t.State ();

NameListTail-Semicolon-Func
  t.State = t.State;

// и так далее

$END Parser.
