    Поиск исходных текстов проекта

  Программа на Модульном Рефале состоит из модулей. Каждый модуль представлен в виде одного файла
исходного текста на одном из входных языков компилятора до компиляции, в виде набора объектных фай-
лов (каждый из которых соответствует выходному языку компилятора, используемому при компиляции) и
в виде файлов с информацией о межмодульных связях после компиляции. Модули между собой могут груп-
пироваться по иерархическому принципу в пакеты (как в языке Java).

  Набор модулей, которые после компиляции и связывания, образуют один исполнимый файл или одну
библиотеку, в данном документе будет называться проектом.

  Каждый из модулей и пакетов имеет некоторое имя. Имя (модуля или пакета) начинается с заглав-
ной буквы латинского алфавита или символа '!', после чего может следовать некоторое количество (воз-
можно, равное нулю) заглавных или строчных букв латинского алфавита, цифр или знаков '!', '-' или
'_'. Имя чувствительно к регистру символов, так например имена Name! и NAME! различаются. (Имя прак-
тически полностью подчиняется правилам, налагаемым на идентификаторы языка Модульный Рефал с тем
отличием, что в имени пакета или модуля символ '?' запрещён).

  В состав пакета могут входить другие модули и пакеты, при этом вложенность пакетов не может быть
циклической. В рамках одного пакета не могут находиться два модуля, два подпакета, модуль и подпакет
с одним именем, при сравнении без учёта регистра. (Это обеспечивает совместимость ОС, в которых имена
файлов чувствительны и не чувствительны к регистру). При этом в рамках одного проекта могут присут-
ствовать модули или пакеты с одинаковыми именами, но при этом они должны находиться в разных пакетах.
  Модуль или пакет не может быть одновременно включён в несколько пакетов.
  Те модули и пакеты, которые не входят в другие модули, называются корневыми.
  Пакеты предствалены в виде каталогов файловой системы. Подпакеты и модули, включённые в некоторый
пакет, соответствуют подкаталогам и файлам каталога соответственно.

  Квалифицированным именем пакета или модуля называется перечисление имён такое, что:
  (*) Квалифицированное имя пакета или модуля в корне состоит из одного имени этого пакета/модуля.
  (*) Квалифицированное имя пакета или модуля, входящего в некоторый пакет, состоят из квалифи-
цированного имени включающего пакета, после которого следует включённого пакета или модуля.
  В этом документе квалифицированные имена будут изображаться как перечисления имён, разделённых
точкой. Например: RootPackage.IncludedPackage.TerminalModule или Std.InOut.
  Каждый модуль или пакет, содержащийся в проекте имеет уникальное квалифицированное имя.

  Точное квалифицированнное имя модуля (т.е. с учётом регистра) должно быть указано в файле исход-
ного текста (синтаксис файла исходного текста должен позволять это делать) и в файлах с информацией
о межмодульных связях (структура хотя бы одного из этих файлов должна позволять это делать).
  Точное имя пакета вычленяется из квалифицированных имён модулей, входящих в данный пакет. Квали-
фицированное имя модуля должно быть указано в файле исходного текста, представляющего данный модуль,
или в файлах с информацией о межмодульных связях. Если же несколько файлов исходного текста или меж-
модульных связей, находятся в одном каталоге, то имена, вычленяемые из каждого из них должны совпа-
дать с учётом регистра.

  Имя модуля должно совпадать с именем сооветствующего файла без расширения в зависимости от ОС:
  (*) Если ОС не различает регистр символов, то имя модуля должно совпадать с именем файла (без
расширения) без учёта регистра.
  Так, например, модуль ModuleName может быть представлен файлом MODULENAME.MREF или
modUlenAme.rout или ModuleName.rsym.
  (*) Если ОС различает регистр символов, то имя модуля должно совпадать с именем файла (без рас-
ширения) с учётом регистра за исключением совпадения регистра первой буквы.
  Например, модуль ModuleName может быть представлен файлом ModuleName.mref или moduleName.rout,
но не modulename.rsym или MODULENAME.CPP.
  Имена файлов, способные представить один модуль, называются эквивалентными вне зависимости от ОС.

  Соответствие имени пакета и имени каталога подчиняется тем же правилам, что и соответствие имени
модуля и соответствующего файла.

  Под целью и содержанием файла подразумевается следующее:
  (*) Целью и содержанием исходного файла является входной язык этого исходного файла.
  (*) Целью и содержанием файла на выходном языке является выходной язык.
  (*) Целью и содержанием файла с некоторой информацией о межмодульных связях является вид этой
информации (если имеется несколько различных видов файлов о межмодульных связях, как то информация
об экспортируемых сущностях, об экспортируемых модулях, о перекрёстных связях, о функциях, которые
можно встроить).

  Имена файлов, представляющих модули, в зависимости от цели и содержания (исходный или выходной
язык, информация о межмодульных связях), могут иметь различные расширения (но не могут не иметь
расширений вовсе). В тех операционных системах, в которых имена файлов чувствительны к регистру,
расширения файлов должны быть в нижнем регистре.

  Файлы и каталоги, представляющие модули и пакеты соответственно, могут располагаться в нескольких
различных каталогах. Упорядоченный набор этих каталогов содержится в переменной MODULEPATH. Перемен-
ная MODULEPAHT может задаваться в зависимости от реализации в качестве параметра командной строки,
в качестве переменной окружения, внутри конфигурационного файла или каким-то иным образом. Возможны
комбинированные варианты. (Переменная MODULEPATH соответствует понятию classpath языка Java).
  Каталоги переменной MODULEPATH для краткости в этом документе будут называться MP-каталогами.
Переменную MODULEPATH в этом документе будет изображаться как перечисление имён каталогов через точку
с запятой в кавычках. Например "C:\MRefalStdLib;C:\Sources;.". Последний MP-каталог в указанной пере-
менной --- это текущий каталог, обычно обозначаемый точкой.
  Поведение компилятора не опредено, если
  (а) Один из MP-каталогов является подкаталогом другого MP-каталога. Например, такая переменная
MODULEPATH "C:\Dir;C:\Dir\Dir2" ошибочна. Это ограничение относится и к путям, заданным при помощи
относительных ссылок (т.е. "." --- текущая папка и ".." --- каталог на уровень выше. Так например,
если задана переменная MODULEPATH "..\Dir1;Dir2" и при этом текущим каталогом является Dir1, то
фактическим значением переменной MODULEPATH в данном случае оказывается ".;.\Dir2", т.е. требование
нарушается, каталог .\Dir2 является вложенным в каталог в каталог . (текущая папка).
  Следствие: если среди MP-каталогов присутствует текущая папка, то относительные пути для осталь-
ных MP-каталогов недопустимы.
  Смысл этого ограничения состоит в том, что если задана переменная MODULEPATH вида "C:\Dir1;C:\Di"
"r1\Dir2", то файл C:\Dir1\Dir2\File.mref может представлять как модуль File в MP-каталоге
C:\Dir1\Dir2, так и модуль Dir2.File в MP-каталоге C:\Dir1. Если же при этом в проекте одновременно
присутствуют модули File и Dir2.File, причём они оба находятся в каталоге C:\Dir1\Dir2, и при этом
явно не указан MP-каталог, в котором следует искать модуль Dir2.File (например, указан в командной
строке без указания MP-каталога или на него ссылаются из другого модуля) (см. ниже), то будут най-
дены файлы, предсатвляющие модуль File, что приведёт к ошибке. Данное ограничение предназначено,
чтобы исключать возможность таких коллизий.
  При нарушении ограничения действие компилятора не определено, в частности компилятор может успеш-
но собрать проект (если в нём отсутствуют указанные коллизии), может нормально завершиться, выдав
при этом сообщение об ошибке, может аварийно остановиться, может отслеживать это ограничение, выво-
дя предупреждение о нарушении.
  (б) Среди MP-каталогов присутствует псевдоним на какой-либо другой MP-каталог, псевдоним на ката-
лог, являющий подкаталогом MP-каталога (этого же или другого), псевдоним на каталог, подкаталогом
которого является MP-каталог (этот же или другой). Псевдонимом может быть, например, символьная
связь или диск subst. Если же псевдоним ссылается на каталог, недоступный из других MP-каталогов,
то такой псевдоним является допустимым.
  Примечание. В приведённых выше абзацах, описывающих неопределённое поведение, под подкаталогом
подразумевается не только прямой подкаталог (Super\Sub), но и вложенный на несколько уровней вглубь
(Super\A\B\C\Sub).

  Пакет может включать в себя модули, находящиеся в различных MP-каталогах.

  Файлы и каталоги на входном языке, соответствующие корневым модулям или пакетам соответственно,
физически должны находиться в одном из каталогов, перечисленных в переменной MODULEPATH.
  Файлы и каталоги на выходном языке или содержащие информацию о межмодульных связях, соответству-
ющие корневым модулям или пакетам, могут, в зависимости от цели и содержания, находиться как непо-
средственно в одном из каталогов, перечисленных в переменной MODULEPATH, так и в подкаталоге, соот-
ветствующем цели и содержанию файла,
  Например, для модуля Std.InOut, находящемся в MP-каталоге C:\MRefalStdLib, имя выходного файла на
языке Refal5 (расширение .rout, папка ROut) будет иметь вид C:\MRefalStdLib\ROut\Std\InOut.rout.
Имя исходного файла модуля BackEnds.Refal5.Linker на языке Модульный Рефал (расширение .mref), нахо-
дящемся в MP-каталоге C:\Sources будет иметь вид C:\Sources\BackEnds\Refal5\Linker.mref. Если для
некоторого выходного языка XYZ (расширение .xyz) корневые файлы/каталоги содержатся непосредственно
в MP-каталоге, то указанные выше модули будут представлены файлами C:\MRefalStdLib\Std\InOut.xyz и
C:\Sources\BackEnds\Refal5\Linker.xyz.
  Входной и выходной языки компилятора могут совпадать. (Это может быть полезно при отладке незави-
симой от языка оптимизации, т.к. позволяет отследить преобразования структуры программы).

  Если файл или каталог, соответствующий модулю или пакету, может быть найден в нескольких различ-
ных MP-каталогах, то в проект включается тот, который указан в MP-каталоге, перечисленном раньше в
переменной MODULEPATH (которая упорядочена).

  Каждый модуль может быть представлен НЕ БОЛЕЕ ЧЕМ ОДНИМ файлом исходного текста, а также ВСЕМИ
выходными файлами (файлами на выходном языке и файлами, описывающими межмодульные связи), для которых
выполняется компиляция.
  При этом, набор входных языков, которыми может выполняться компиляция, упорядочен. Порядок опре-
деляется окружением (параметры командной строки, переменные окружения, конфигурационный файл, что-то
иное или их комбинации). Если для данного модуля имеются файлы исходного текста на нескольких языках,
то выбирается тот, который:
  (а) Расположен в перечисленном раньше MP-каталоге (см. предыдущий раздел).
  (б) Если пункт (а) не разрешает противоречия, то выбирается тот язык, который перечислен раньше
в упорядоченном наборе входных языков (см. выше).

  Если файл исходного текста найден, то соответствующие ему выходные файлы должны располагаться в
том же MP-каталоге. Такой модуль получает статус "компилируемого".

  Если файл исходного текста не найден, то производится поиск выходных файлов в MP-каталогах в со-
ответствии с порядком перечисления их в переменной MODULEPATH. При этом модуль считается найденным,
если найдены ВСЕ выходные файлы, представляющие данный модуль. Если ВСЕ выходные файлы модуля найде-
ны, то данный модуль получает статус "библиотечного". Если же ни в одном из MP-каталогов не найдены
одновременно ВСЕ выходные файлы, то модуль получает статус "не найден".

  Компилируемые модули могут зависеть от компилируемых и библиотечных модулей. Библиотечные модули
могут зависеть только от библиотечных.

  Если поиск осуществляется в ОС, не различающей регистр имён файлов, и найденный некотором MP-ка-
талоге файл исходного текста или файл с информацией о межмодульных связях имеет имя, отличное от
имени разыскиваемого модуля, то данный модуль считается не найденным вне зависимости от содержимого
последующих MP-каталогов (т.е. получает статус "не найден"). (Т.к. при использовании ОС, различающей
регистр имён файлов, мы бы тоже получили ошибку --- либо не нашли сам пакет или модуль, либо сам па-
кет или модуль был бы ошибочным -- его имя не соответствовало бы имени папки или файла соответствен-
но).

  Компиляция может выполняться только тогда, когда найдены все модули.

  Компилятор должен иметь режим, в котором все компилируемые модули должны быть перекомпилированы.

  Компилятор может предоставлять режим "быстрой перекомпиляции", в котором некоторые компилируемые
модули могут исключаться из процесса компиляции при одновременном выполнении следующих условий:
  (*) Для данного модуля присутствуют ВСЕ выходные файлы.
  (*) Выходные файлы созданы/обновлены позже исходного файла данного модуля.
  (*) Модули, от которых зависит данный модуль, либо библиотечные, либо были исключены из процесса
компилирования, хотя были компилируемыми.
  (*) Исходные тексты компилируемых модулей, от которых зависит данный модуль, созданы/обновлены
раньше, чем данный модуль.
  (*) Выходные файлы библиотечных модулей, от которых зависит даннный модуль, созданы/обновлены
раньше, чем данный модуль.
  Этот набор эвристических условий позволяет с высокой вероятностью гарантировать непротиворечи-
вость проекта.
  Если всё равно есть сомнения, то рекомендуется включать режим для полной перекомпиляции.

  Компилятор может предоставлять режим "только связывание", при котором компилируемые модули не
компилируются, а выполняется только их связывание. Этот режим возможен только если для компилируемых
модулей найдены ВСЕ исходные файлы (в противном случае связывание невозможно).

  Обработка командной строки.

  В командной строке может быть указано один или несколько модулей, подлежащих компиляции. При
этом, если модуль является головным, то после компиляции данного модуля и всех зависимых от него мо-
дулей выполняется связывание. Если модуль не является головным, то выполняется только компиляция дан-
ного модуля и всех зависимых от него модулей.

  Имя модуля может быть задано в виде пути к модулю без расширения или с расширением, соответствую-
щим одному из входных языков. Независимо от наличия расширения поиск модуля на первом этапе выполня-
ется в следующем порядке:
  (1) Если начало пути совпадает с одним из MP-каталогов, то несовпадающая часть представляет собой
квалифицированный путь к каталогу. Например:
  MODULEPATH = "C:\MRefalStdLib;C:\Sources;Extensions"
  Модуль Extensions\Parsing\Lexer =>
    MP-каталог = Extensions, квалифицированное имя Parsing.Lexer
  Модуль C:\Sources\BackEnds\Refal5\Linker.mref
    MP-каталог = C:\Sources, квалифицированное имя BackEnds.Refal5.Linker

  (2) Если такого совпадения не обнаружено и путь к модулю является относительным, имя модуля соот-
ветствует его квалифицированному имени. Модуль с заданным квалифицированным именем последовательно
ищется в списке каталогов переменной MODULEPATH.

  Набор допустимых входных языков для данного модуля определяется наличием расширения в командной
строке. Если расширение отсутствует, то допустимыми входными языками являются все языки, для которых
может выполняться компиляция (этот набор определяется окружением). Если расширение указано, то набор
допустимых входных языков состоит только из одного языка, которому соответствует данное расширение.

  Множества модулей, зависимых прямо или косвенно от модулей, перечисленных в командной строке, а
также, содержащих сами эти модули, могут пересекаться. При этом модули, принадлежащие пересечениям
должны обрабатываться однократно. Объединение указанных выше множеств, как и отдельный проект, не
может содержать пару модулей, пару пакетов, модуль и пакет, находящиеся в одном пакете или в корне,
которые имеют имена, различающиеся лишь регистром.
  В указанном объединении каждый модуль и пакет имеет уникальное квалифицированное имя.

  Каждый модуль, указанный в командной строке, зависит от набора модулей, которые он прямо или кос-
венно имипортирует. Импортируемые модули идентифицируются только по квалифицированному имени, по
умолчанию их поиск осуществляется так, как указано выше (сначала по MP-каталогам, потом по расшире-
нию). Но может так оказаться, что другие модули, указанные в командной строке, имеют те же квалифи-
цированные имена, что и импортируемые модули. В этом случае информация в командной строке имеет при-
оритет.
  Следствие 1. Определение местоположения модулей, перечисленных в командной строке, желательно вы-
полнять раньше, чем компиляцию какого-либо модуля.
  В принципе, можно каждый раз анализировать командную строку при встрече неизвестного модуля в ди-
рективе импорта, но удобнее сначала обработать командную строку.
  Следствие 2. В командной строке не могут быть указаны два модуля, имеющие потенциально разное
местоположение, но при этом имеющие одинаковое квалифицированное имя.
  Пример.
  MODULEPATH="C:\Files;D:\Libraries\SubDir"
  Модули D:\Libraries\SubDir\P\M, P\M.xmref.
  Front-end'ы (упорядоченный список): MRefal(.mref), XMRefal(.xmref)
  В принципе, в папке D:\Libraries\SubDir может быть найден модуль P.M с именем P\M.mref. Т.е. воз-
никает неоднозначность. Подобная ситуация запрещена.

  Примечание. Подобное уточнение позволяет более тонко управлять содержимым проекта. В частности,
если требуется заменить только некоторые модули, входящие в проект, то можно для них указать абсо-
лютные пути и базовые папки в переменной MODULEPATH, которые перекроют обнаруживаемые по умолчанию.