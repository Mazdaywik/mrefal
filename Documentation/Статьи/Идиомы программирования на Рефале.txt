Идиомы программирования на Рефале

=Понятие идиомы в языке программирования=

Есть ли в Си++ цикл со счётчиком? А цикл foreach? Если смотреть узко, то нет.
Строго говоря, в Си++, как и в Си, только три цикла (конструкции, порождаемые
условными инструкциями и goto, рассматривать не будем), а именно while, for
и do-while. Первые два из них являются циклами с предусловием, последний ---
с постусловием. Такая конструкция, как цикл со счётчиком, в синтаксисе
отсутствует, в отличие, скажем, от Паскаля и Бейсика. Однако один из циклов
с предусловием обладает одним интересным свойством:
цикл for позволяет помимо самого условия задавать инициализатор
и "модификатор" каждой итерации:

`for( инициализатор ; условие ; модификатор )
    тело_цикла`

Этим часто пользуются, в частности, если нужно выполнить тело цикла,
параметризованное последовательными целочисленными индексами, пишут что-то
вроде этого:

`//Листинг %listdef forcount%
for( int i = 0; i < 100; ++i )
{
  a[i] = i * i;
}`

Очевидно, данный цикл выполняет тело цикла с последовательными значениями,
т.е. в целом эквивалентен следующему циклу на Паскале:

for i := 0 to 99 do
begin
  a[i] := i * i;
end

Конструкции типа показанной в листинге %listno forcount%, очень распространены
и узнаются опытными программистами на Си с первого взгляда, в отличие, скажем,
от цикла, показанного на листинге %listno badfor%, который делает то же самое,
что и листинг %listno forcount%.

`//Листинг %listdef badfor%
for( int i = -1; ++i < 100; a[i] = i * i );`

Общепринятые конструкции, выражающие распространённые понятия, непосредственно
отсутствующие в языке программирования, называются идиомами этого языка
программирования. Например, листинг %listno forcount% является идиомой цикла
со счётчиком в си-подобных языках программирования.

Библиотека языка Си++ предоставляет пользователю набор различных по реализации
но одинаковых по интерфейсу шаблонных классов-контейнеров, таких как вектора,
списки, очереди, множества, отображения. Соответственно, при использовании
контейнеров существует потребность перебора элементов контейнеров. Можно было
бы вводить для каждого контейнера свою идиому для перебора, однако унифицированный
интерфейс библиотеки позволяет использовать стандартную идиому для обхода
контейнеров (листинг %listno stdfor%).

`//Листинг %listdef stdfor%
typedef .... MyContainer;

void printall(MyContainer& c)
{
  for(MyContainer::iterator p = c.begin(); p != c.end(); ++p)
  {
    std::cout << *c;
  }
}`

Таким образом, эта идиома (а именно, перебор при помощи итератора `ContainerName::
iterator` начиная с `obj.begin()` и до `obj.end()`) позволяет эмулировать цикл
foreach, присутствующий в синтаксисе многих других языков программирования
(в частности, в Visual Basic и C#).

Другими примерами идиом, кроме цикла со счётчиком
и имитации цикла foreach, может служить способ организации исходного кода с заголовочными
файлами (имитирует модули с экспортом и импортом, которые непосредственно представлены
в синтаксисе языка Модула-2), идиома умных указателей (может имитировать сборку мусора
при помощи подсчёта ссылок, лочить объекты в многопоточной среде и др.), метапрограммирование
шаблонов, которое можно рассматривать как целый язык построенный на тех или иных идиомах
использования шаблонов. Как высокоуровневые идиомы использования средств ООП можно
рассматривать и паттерны проектирования GoF.

Отсюда можно сделать вывод, что использование идиомы в языке программирования
фактически означает расширение языка программирования некоей высокоуровневой инструкцией,
которой нет непосредственно в языке. Как правило, в более низкоуровневых языках при
помощи идиом выражаются те понятия, которые непосредственно существуют в высокоуровневых.
Так например, функции map и filter в Scheme можно рассматривать как идиомы, ненужные
в тех языках, где есть list comprehension.

=Идиомы программирования на подмножестве базисного Рефала=

В этом разделе будут рассмотрены идиомы программирования, используемые при программировании
на достаточно узком подмножестве Рефала. Выбор подмножества базисного Рефала обусловлен
двумя причинами:

1. Подмножество базисного Рефала поддерживается всеми диалектами Рефала, поэтому
рекомендации ниже можно будет воплотить везде. Правда, не везде в них есть необходимоть.

2. Я разрабатываю самокомпиляторы Модульного и Простого Рефалов, которые как раз поддерживают
именно это подмножество (хотя Простой Рефал уже поддерживает вложенные функции --- весьма
мощное и выразительное средство, которое не только облегчает использование нижеперечисленных
идиом, но и порождает ряд новых).

Для изложения будет использоваться синтаксис Рефала 5, который обладает достаточной
выразительностью (по сравнению с Рефалом 2) и понятен большинству программистов на Рефале.
При демонстрации идиом, связанных с указателями на функции и функциями высших порядков
будут использоваться диалекты Модульного и Простого Рефала.

Для краткости в дальнейшем будем отождествлять понятия подмножества базисного Рефала и Рефал.
Если будет иметься в виду конкретный диалект Рефала или особенности, не входящие в подмножество,
это будет оговорено особо.

==Краткое описание подмножества==

===Данные, которые обрабатывает Рефал===

Основной обрабатываемой структурой данных является объектное выражение. Объектное выражение ---
это структура данных, представляющая собой последовательность переменной длины (возможно пустую)
объектных термов. Объектный терм может представлять собой либо атом --- неделимую средствами
языка Рефал (без учёта встроенных библиотечных функций) сущность, например, число, символ,
имя (идентификатор) или что-либо другое (состав атомов в разных диалектах различается), либо
т.н. скобочный терм --- терм, содержащий внутри себя другое объектное выражение. Рассмотрим
подробнее разные виды термов.

1. Атом-число. Представляет абстракцию числа в математике, в зависимости от диалекта могут
поддерживаться целые числа ограниченного диапазона, целые числа неограниченной разрядности,
действительные числа, при этом атомы целых и действительных чисел различаются.

Примеры чисел: `1`, `2222`, `1234567890`, `3.14`, `3e8`, `-273,15`.

Далее будем считать, что наш диалект поддерживает только небольшие целые числа в качестве
значений этой разновидности атомов.

2. Атом-символ. Является абстракцией печатного символа как элемента текста, также в зависимости
от диалекта может быть как ASCII-, так и UNICODE-символом. Атомы-символы будем записывать, как
символы в одинарных кавычках. Если в рефал-выражении несколько символов идут подряд, то будем
записывать их слитно, т.е. вместо `'Ж' '0' 'П' 'A'` будем записывать `'Ж0ПA'`.

3. Атом-идентификатор или атом-имя. В большинстве диалектов представляет собой некоторое имя,
представляющее само себя (хотя в некоторых диалектах, например Рефал 2 или Рефал 7, идентификатор
представляет и одноимённую функцию из той же области видимости). Как правило, атомы-имена записываются
как "слова", начинающиеся с заглавной латинской буквы, после которой следует некоторое (возможно
нулевое) количество букв, цифр, знаков _ и -. Будем считать, что регистр идентификаторов различается,
т.е. имена `Name` и `NAME` различаются.

4. Скобочный терм. Содержит внутри себя объектное выражение, записывается как объектное выражение,
окружённое круглыми скобками. Например `(Position 102 'filename.ext')` представляет собой скобочный
терм.

Другие диалекты могут поддерживать ряд других значений атомов, например, замыкания, дескрипторы
файлов или других объектов, ссылки на статические или динамические объекты. Если это будет необходимо,
расскажем об этом по-подробнее.

Объектное выражение записывается как перечисление содержащих его термов без каких-либо разделителей.
Например `Identifier (Position 102 'filename.ext') 'Name'` представляет собой выражение из 6 термов,
первый из которых является именем, второй --- скобочным термом, последние четыре --- символы. Второй
терм содержит внутри себя выражение, содержащее имя, число и 12 символов.

===Семантика выполнения программы===

Семантику Рефала принято описывать вводя понятие абстрактной рефал-машины. Рефал-машина содержит
две области памяти: поле зрения, которое содержит обрабатываемые данные и полностью описывает
состояние вычислений и поле програмы, содержащее определения всех функций программы. Структура
поля зрения описывается введением такой абстрактции, как активное рефал-выражение. 

==Общие идиомы подмножества==
===Имитация неуспешного выполнения===
===Форматы функций===
===Ассоциативные списки===
===Абстрактные типы данных===
===Промежуточные функции===
===Остаточно-рекурсивные циклы===
===Мультискобки===
==Идиомы, требующие указателей на функции==
===Сокрытие циклов в списочных морфизмах===
==Идиомы, требующие вложенных функций==
===ООП===
===Монады===
