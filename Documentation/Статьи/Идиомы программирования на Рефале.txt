Идиомы программирования на Рефале

=Понятие идиомы в языке программирования=

Есть ли в Си++ цикл со счётчиком? А цикл foreach? Если смотреть узко, то нет.
Строго говоря, в Си++, как и в Си, только три цикла (конструкции, порождаемые
условными инструкциями и goto, рассматривать не будем), а именно while, for
и do-while. Первые два из них являются циклами с предусловием, последний ---
с постусловием. Такая конструкция, как цикл со счётчиком, в синтаксисе
отсутствует, в отличие, скажем, от Паскаля и Бейсика. Однако один из циклов
с предусловием обладает одним интересным свойством:
цикл for позволяет помимо самого условия задавать инициализатор
и "модификатор" каждой итерации:

`for( инициализатор ; условие ; модификатор )
    тело_цикла`

Этим часто пользуются. Eсли нужно выполнить тело цикла,
параметризованное последовательными целочисленными индексами, пишут что-то
вроде этого:

`//Листинг %listdef forcount%
for( int i = 0; i < 100; ++i )
{
  a[i] = i * i;
}`

Очевидно, данный цикл выполняет тело цикла с последовательными значениями,
т.е. в целом эквивалентен следующему циклу на Паскале:

`for i := 0 to 99 do
begin
  a[i] := i * i;
end`

Конструкции типа показанной в листинге %listno forcount%, очень распространены
и узнаются опытными программистами на Си с первого взгляда, в отличие
от цикла, показанного на листинге %listno badfor%, который делает то же самое,
что и листинг %listno forcount%.

`//Листинг %listdef badfor%
for( int i = -1; ++i < 100; a[i] = i * i );`

Общепринятые конструкции, выражающие распространённые понятия, непосредственно
отсутствующие в языке программирования, называются идиомами этого языка
программирования. Например, листинг %listno forcount% является идиомой цикла
со счётчиком в си-подобных языках программирования.

Библиотека языка Си++ предоставляет пользователю набор различных по реализации,
но одинаковых по интерфейсу шаблонных классов-контейнеров: вектора,
списки, очереди, множества, отображения. Соответственно, при использовании
контейнеров существует потребность перебора элементов контейнеров. Можно было
бы вводить для каждого контейнера свою идиому для перебора, однако унифицированный
интерфейс библиотеки позволяет использовать стандартную идиому для обхода
контейнеров (листинг %listno stdfor%).

`//Листинг %listdef stdfor%
typedef .... MyContainer;

void printall(MyContainer& c)
{
  for(MyContainer::iterator p = c.begin(); p != c.end(); ++p)
  {
    std::cout << *c;
  }
}`

Таким образом, эта идиома (а именно, перебор при помощи итератора
`ContainerName::iterator` начиная с `obj.begin()` и до `obj.end()`) позволяет эмулировать цикл
foreach, присутствующий в синтаксисе многих других языков программирования
(в частности, в Visual Basic и C#).

Поэтому на вопрос, заданный в начале статьи, можно ответить так: "Си++ поддерживает
цикл со счётчиком и цикл foreach, но только идиоматически".

Другими примерами идиом, кроме цикла со счётчиком
и имитации цикла foreach, может служить способ организации исходного кода с заголовочными
файлами (имитирует модули с экспортом и импортом, которые непосредственно представлены
в синтаксисе языка Модула-2), идиома умных указателей (может имитировать сборку мусора
при помощи подсчёта ссылок, лочить объекты в многопоточной среде и др.), метапрограммирование
шаблонов, которое можно рассматривать как целый язык построенный на тех или иных идиомах
использования шаблонов. Как высокоуровневые идиомы использования средств ООП можно
рассматривать и паттерны проектирования GoF.

Отсюда можно сделать вывод, что использование идиомы в языке программирования
фактически означает расширение языка программирования некоей высокоуровневой инструкцией,
которой нет непосредственно в языке. Как правило, в более низкоуровневых языках при
помощи идиом выражаются те понятия, которые непосредственно существуют в высокоуровневых.
Так например, функции map и filter в Scheme можно рассматривать как идиомы, ненужные
в тех языках, где есть list comprehension.

Владение идиомами позволяет программисту быстрее писать программы, не тратя время на продумывание
и написание типичного кода (типа листингов %listno forcount% и %listno stdfor%). Кроме того,
такой код проще читать и понимать (если конечно код писал программист, владеющий идиомами),
а также отлаживать, т.к. поведение идиом хорошо известно и не требует лишней отладки.
Также опечатки в известных конструкциях, т.е. отход от общепринятого кода, бросается в глаза
и свидетельствует о возможной ошибке.

=Идиомы программирования на подмножестве базисного Рефала=

В этом разделе будет рассмотрено сам подмножество и идиомы программирования на нём.
Выбор подмножества базисного Рефала обусловлен двумя причинами:

1. Подмножество базисного Рефала поддерживается всеми диалектами Рефала, поэтому
рекомендации ниже можно будет воплотить везде. Правда, не везде в них есть необходимоть.

2. Я разрабатываю самокомпиляторы Модульного и Простого Рефалов, которые как раз поддерживают
именно это подмножество (хотя Простой Рефал уже поддерживает вложенные функции --- весьма
мощное и выразительное средство, которое не только облегчает использование нижеперечисленных
идиом, но и порождает ряд новых).

Для изложения будет использоваться синтаксис Рефала 5, который обладает достаточной
выразительностью (по сравнению с Рефалом 2) и понятен большинству программистов на Рефале.
При демонстрации идиом, связанных с указателями на функции и функциями высших порядков
будут использоваться диалекты Модульного и Простого Рефала.

Для краткости в дальнейшем будем отождествлять понятия подмножества базисного Рефала и Рефал.
Если будет иметься в виду конкретный диалект Рефала или особенности, не входящие в подмножество,
это будет оговорено особо.

=Специфические идиомы подмножества=

==Общие замечания о подмножестве базисного Рефала==

Подробное описание подмножества, а также определения применяемых ниже терминов приведены
в приложении к статье, поэтому читателям, не программировавшим ранее на Рефале, рекомендуется
изучить это описание. В дальнейшем будет предполагаться, что читатель уже знаком с языком
программирования Рефал и уже умеет писать и запускать на нём программы.

Кратко можно сказать, что программа представляет собой набор функций, каждая из которых
представляет собой набор _предложений_ --- пар _образец_ `=` _результат_. Функция принимает
единственный _аргумент_, представляющий собой _объектное выражение_ (определение разных видов
выражений см. в приложении). Аргумент сопоставляется по очереди с каждым образцом до тех пор,
пока не будет достигнуто успешное сопоставление. В случае успешного сопоставления управление
передаётся результату, выполнение которого приводит к замене _скобок вызова функции_
в _поле зрения_ (определения скобок вызова функции --- скобок конкретизации и поля зрения
см. в приложении). Т.е. выразительные средства языка оказываются крайне бедными: нет ни ветвлений
по условию (кроме ветвлений по пассивному аргументу (а активным он быть и не может)), ни циклов,
ни функций с несколькими аргументами, ни инкапсуляции (все данные в программе представляют
собой объектные выражения, которые можно проанализировать любым образцом, скрыть внутреннюю
структуру данных невозможно).

А так как полезных высокоуровневых средств непосредственно в языке нет, их приходится эмулировать
вручную --- сам программист рано или поздно разработает набор идиом для своей повседневной работы.
В данной статье я расскажу о тех приёмах, которыми я пользуюсь при программировании на Простом
и Модульном Рефалах. Часть их я узнал из различных руководств по программированию на Рефале
(в частности, из руководства Турчина по Рефалу 5), часть я разработал самостоятельно. Если идиома
основана не на моих идеях, я обязательно укажу авторство. Кроме того, будут приведены примеры
кода на более развитых диалектах, демонстрирующие, как высокоуровневые средства делают ненужными
соответствующие идиомы.

==Общие идиомы подмножества==

В этом разделе будут приведены идиомы, которые ограничиваются только подмножеством, описанным
в приложении. В последующих разделах подмножество будет расширено это подмножество указателями
на функции и вложенными функциями, т.е. средствами, существующими Модульном и Простом Рефалах.

===Форматы функций===

Источник идиомы --- руководство Турчина по Рефалу 5 %litno ref5man%,
["http://refal.net/chap3_r5.html#3.2. ФОРМАТЫ ФУНКЦИЙ" отсюда].

Одним из ограничений подмножества базисного Рефала является унарность функций --- каждая функция
принимает на входе только один аргумент и возвращает только одно значение, в то время как часто
возникает необходимость передать в функцию несколько значений. Кроме того, функция может возвращать
несколько связанных по смыслу значений. Во многих распространённых императивных языках
программирования функции могут принимать несколько аргументов, но при этом возвращают только одно
значение. Для возврата нескольких значений семантика языка предусматривает передачу параметров
по указателю или ссылке, позволяя тем самым присвоить из вызываемой функции новое значение
передаваемым параметрам. Передача по ссылке в базисном Рефале невозможна, т.к. требует наличия
операции присваивания, которой в семантике языка места не нашлось.

Решение этой проблемы даёт введение соглашений о вызовах функций, также известных как _форматы
функций_. _Форматом аргумента_ называется способ построения из нескольких логически разных
аргументов функции одного объектного выражения, в котором однозначно выделяется каждая часть,
соответствующая самостоятельному аргументу. Аналогично, _форматом результата_ называется способ
формирования _возвращаемого значения_ функции (т.е. пассивного объектного выражения, которое
образуется на месте скобки активации данной функции после выполнения необходимого числа шагов
Рефал-машины) в виде объектного выражения, содержащего однозначно выделяемые фрагменты,
соответствующие различным возвращаемым значениям (если угодно, выходным параметрам).

Как правило (входные и выходные) параметры-термы (в том числе и атомы) попадают в формат как
есть, если же нужно передать в функцию или получить из функции `N` объектных выражений переменной
длины, то как правило `(N - 1)` из них заворачивают в круглые скобки, а последнее (или первое)
передают как есть. Если при таком способе формирования форматов заменить отдельные параметры
на соответствующие переменные --- атомы, термы и выражения на, соответственно, s-, t- и
e-переменные, то полученный образец не будет содержать открытых e-переменных, а значит, будет
распознаваться за постоянное время --- за постоянное время будут выделяться отдельные подаргументы
внутри аргумента функции.

Таким образом, формат функции --- это лишь соглашение о том, каким образом вызывается функция
и какое возвращаемое значение от неё ожидать. Для документирования формата я предпочитаю
использовать комментарии, показанные на листинге %listno format-comments%.

`// Листинг %listdef format-comments%

/*
  <Fact s.N> == s.N!
*/
Fact { ... }

/*
  <Parse (s.Token e.Value)*>
    == t.ErrorList t.SyntaxTree
*/
Parse { ... }

/*
  <Zip (t.ElemA*) (t.ElemB*)>
    == (t.ElemA t.ElemB)*
*/
Zip { ... }

/*
  <Repeat s.Num e.Expr>
    == e.Expr e.Expr ... e.Expr
  Выражение e.Expr повторяется s.Num раз.
*/
Repeat { ... }

/*
  <Map s.Func t.Elem*>
    == e.Res*
  где <s.Func t.Elem> == e.Res
*/
Map { ... }

/*
  <GetFileSize e.FileName>
    == Size s.Size
    == Directory
    == FileNotFound
*/`

В данных комментариях отдельные элементы формата (атомы, термы, выражения) показаны как
переменные соответствующих типов. Для выражений, представляющих собой цепочки однородных элементов
(термов или иногда подвыражений), показана повторяемая часть, после которой следует знак `*`.
Формат аргумента функции для наглядности иллюстрируется как вид скобки конкретизации, т.е. внутри
угловых скобок с именем функции. Формат результата начинается с двойного знака равенства `==`.
Однократный знак равенства означает замену вызова функции на результат за один шаг рефал-машины,
поэтому двойной знак равенства означает достижение пассивного результата за более чем один шаг.

А теперь, чтобы не оставалось сомнений, вкратце рассмотрим форматы функций, представленные
на листинге %listno format-comments%. Функция `Fact` принимает один атом (как не трудно догадаться,
число) и один атом возвращает, а именно, факториал аргумента. Функция `Parse` получает на входе
лексическую свёртку --- последовательность скобочных термов вида `(s.Token e.Value)`, где `s.Token`
представляет собой тип токена: число, имя, знак пунктуации, а `e.Value` --- связанное с ним
значение, а возвращает список обнаруженных синтаксических ошибок и построенное синтаксическое
дерево. Функция `Zip` принимает две цепочки термов и сворачивает их в одну. Что делает функция,
в случае если цепочки `t.ElemA*` и `t.ElemB*` окажутся разной длины, в формате не описано, скорее
всего лишние термы будут отброшены. Функция `Repeat` принимает число повторений и выражение,
которое нужно размножить, возвращает размноженное выражение. Функция `Map` принимает первым термом
функцию и цепочку термов для преобразования, возвращает цепочку преобразованных термов. Формат
функции-преобразователя в комментарии показан в той же манере. В функции `GetFileSize`
мы сталкиваемся с ещё нерассмотренным случаем --- с несколькими форматами возвращаемых значений.
В таких случаях выходные форматы следует делать ортогональными, но при этом достаточно схожими.
Для этого достаточно разные выходные форматы начинать с различных атомов-имён, помечающих разный
результат функции (например, корректное или ошибочное завершение).

Под _ортогональными_ форматами здесь и далее будем понимать форматы, пересечение множеств объектных
выражений, соответствующим этим форматам, пустое. Самый простой способ сделать форматы
ортогональными --- это начинать их с разных атомов-имён, как это сделано с функцией `GetFileSize`.

Комментарии с форматом функции рекомендуется писать либо перед entry-функцией, либо перед функцией,
решающей довольно крупную подзадачу, либо перед функцией, имеющей нетривиальный формат, либо перед
функцией, которая вызывается несколько раз в пределах одного модуля и все точки её вызова находятся
на достаточно большом расстоянии от места её определения. Автор этой статьи написал программу,
которая умеет сканировать файлы исходного текста в поисках комментариев определённого вида
и записи содержимого этих комментариев в (указанный в командной строке) текстовый файл. Эти
комментарии представляют собой комментарии в стиле Си, начинающиеся с последовательности `/**`.
В таких комментариях автор статьи предпочитает записывать комментарии к entry-функциям, чтобы
затем просматривая текстовик с интерфейсами, сразу узнавать формат, не лазая по исходным текстам.

Как это часто бывает с идиомами, введение более высокоуровневых средств в язык позволяет если
не отказаться, то хотя бы упроситить использование идиомы. Так например, в диалекте Рефал Плюс
имеется поддержка форматов функций со стороны компилятора --- для каждой функции необходимо задать
её формат, для чего введён специальный синтаксис объявлений функций. Компилятор проверяет
соответствие функции заданному формату: соответствие образцов формату на входе, соответствие
завершающего результатного выражения (т.к. предложение может содержать несколько образцов
и результатов --- т.н. _действий_) формату на выходе, а также корректность вызовов функций,
образующих результатные выражения. На листинге %listno refal-plus-formats% приведён пример функции
быстрой сортировки с двумя вспомогательными функциями и явным описанием форматов каждой из них.

`/* Листинг %listdef refal-plus-formats% */

$func QSort eS = eQ;
$func Split sX eS = (eS1) (eS2) (eS3);
$func Split-Aux sX (eS1) (eS2) (eS3) eS = (eS1)(eS2)(eS3);

QSort
  eS =
    {
      eS : /* пусто */ = ;
      eS : t = eS;
      eS : sX e =
          <Split sX eS> :: (eS1)(eS2)(eS3),
          <QSort eS1> eS2 <QSort eS3>;
    };

Split
  sX eS =
    <Split-Aux sX ()()() eS>;

Split-Aux
  sX (eS1)(eS2)(eS3) eS =
    eS :
      {
        /* пусто */ = (eS1)(eS2)(eS3);

        sY eRest =
          {
            <"<" (sY)(sX)>
              = <Split-Aux sX (eS1 sY)(eS2)(eS3) eRest>;

            <">" (sY)(sX)>
              = <Split-Aux sX (eS1)(eS2)(eS3 sY) eRest>;

            /* sX == sY */
              = <Split-Aux sX (eS1)(eS2 sY)(eS3) eRest>;
          };
      };`

==Имитация неуспешного выполнения==

Данная идиома является частным случаем предыдущей идиомы, однако поскольку я часто пользуюсь этим
приёмом, позволю себе рассказать о нём отдельно.

Бывают такие случаи, когда функция в результате работы может либо возвратить некоторое значение,
либо возвратить не может. Можно привести следующие примеры:

1.Операция поиска по ключу в некотором ассоциативном массиве может либо найти значение, либо
не найти, если такого нет.

2. Операция добавления нового имени в таблицу символов может либо завершиться успешно, если такое
имя ранее отсутствовало в таблице символов, либо неудачно, если таблица уже содержит такое имя.

3. Операция синтаксического анализа может либо распознать без ошибок, либо при разборе могут
встретиться ошибки.

4. Операция загрузки данных из файла может завершиться либо успешно (данные загружены без ошибок),
либо неудачно (файл не найден, нет прав на чтение, файл в неправильном формате).

Этот список можно продолжать и дальше, но основная идея уже и так понятна. Необходимо для функции
обеспечить два ортогональных выходных формата: для представления успешного и неудачного завершения
операции. Можно в случае невозможности выполнения информации возвращать пустое выражение, но этот
вариант может быть не ортогонален, т.к. пустой результат может быть и вполне корректным результатом
(например, при поиске в ассоциативном массиве, отображающем любое объектное выражение на любое
объектное выражение). Можно корректный результат заворачивать в структурные скобки, а в случае
неуспеха --- возвращать пустое выражение. Такие форматы уже ортогональны, но не выразительны, т.к.
структурные скобки ничего не говорят об успешности (т.е. фактически представляют собой как костыль).

Воспользуемся наиболее простым способом "ортогонализации": будем начинать разные результаты
с разных атомов-имён --- успешный возврат с Success, неуспешный --- c Fails. Таким образом, формат
неуспешной (Failable) функции можно описать так, как показано на листинге %listno fail-format% (а).

`// Листинг %listdef fail-format% (а)

/*
  <Foobar некоторый-аргумент>
    == постоянная-часть Success успешный-результат
    == постоянная-часть Fails необязательный-признак-ошибки
*/

// Листинг %listno fail-format% (б)
// Реальный пример формата функции парсера командной строки

/*
  <Parse t.ErrorList t.FnCmdLineDescription e.ArgList>
    == t.ErrorList Success t.Collected
    == t.ErrorList Fails
*/`

Здесь `некоторый-аргумент` --- это аргумент функции, `постоянная-часть` --- та часть выходного
формата, которая присутствует в выходном формате, `успешный-результат` --- результат, который
выводится в случае успешного выполнения операции, `необязательный-признак-ошибки` ---
дополнительная информация, описывающая почему именно не удалась операция, часто может отсутствовать.

На листинге %listno fail-format% (б) приведён пример формата функции из компилятора Модульного
Рефала. Структура данных `t.ErrorList` --- это абстрактный тип данных (см. ниже), содержащий в себе
список обнаруженных ошибок (лексических, синтаксических, семантических...) с местоположением самих
ошибок. Этот список передаётся из функции в функцию, каждая из которых туда может добавить новую
информацию. `t.FnCmdLineDescription` --- структура данных, описывающая обработку командной строки,
содержит в себе имена допустимых опций, их особенности (наличие у опции параметра или группы
параметров) и функции их обработки, `e.ArgList` --- это список аргументов командной строки. Функция
при успешном завершении возвращает структуру данных `t.Collected`, которая фактически представляет
собой абстрактное синтаксическое дерево для данной командной строки и для данного метода обработки,
в случае неудачного завершения нет необходимости возвращать какую-либо дополнительную информацию
о том, почему не удался разбор, т.к. клиентскому коду, использующему эту функцию, не интересна
эта причина, а сами описания ошибок уже находятся в `t.ErrorList`.

Передача параметра `t.ErrorList` сквозь каждую функцию обусловлена недостатками реализации рантайма
--- необходимостью копирования переменных. При использовании реализаций, имеющих векторный или
векторно-списковый способ представления объектных выражений, копирование было бы эффективно
и необходимости в передаче из функции в функцию `t.ErrorList` не было бы. Кроме того, если бы
на момент написания этого кода была бы поддержка вложенных функций, можно было бы упрятать список
ошибок в монаду State (см. ниже) и не использовать его явно.

Высокоуровневое средство, которое имитирует эта монада --- это использование откатных функций,
имеющихся в большинстве развитых диалектов Рефала: в Рефале Плюс, в Рефале 6 и Рефале 7. Однако,
в случае использования неуспехов нет возможности возвращать вместе с неуспехом какую-либо
`постоянную-часть`, например, список обнаруженных ошибок. Любители Хаскеля в этой идиоме, скорее
всего, уже увидели монаду Maybe, которая как раз и применяется с этой целью: вернуть либо
корректное значение, либо признак "Значения нет". Возврат `Success` соответствует конструктору
`Just x`, возврат `Fails` соответствует конструктору `Nothing` монады Maybe.
Кроме того, в Рефале с вложенными функциями (Рефал 7 или Простой Рефал, в перспективе и Модульный
Рефал) можно реализовать монады Error, Continuation или IO, которые позволили бы использовать
механизм исключений для выброса исключений как альтернативу возврату Fails (про монады см. ниже).

===Ассоциативные списки===
===Абстрактные типы данных===
===Вспомогательные функции===
===Остаточно-рекурсивные циклы===
===Автоматное программирование===
===Использование скобок в качестве указателей===
===Мультискобки===
==Идиомы, требующие указатели на функции==
===Сокрытие циклов в списочных морфизмах===
==Идиомы, требующие вложенных функций==
===ООП===
===Монады===
===По следам COM-технологии===


=Литература=
%litdef ref5man%. РЕФАЛ-5 "Руководство по программированию и справочник". Турчин В.Ф.
[http://refal.net/rf5_frm.htm]