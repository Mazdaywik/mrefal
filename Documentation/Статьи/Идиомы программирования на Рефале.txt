Идиомы программирования на Рефале

=Понятие идиомы в языке программирования=

Есть ли в Си++ цикл со счётчиком? А цикл foreach? Если смотреть узко, то нет.
Строго говоря, в Си++, как и в Си, только три цикла (конструкции, порождаемые
условными инструкциями и goto, рассматривать не будем), а именно while, for
и do-while. Первые два из них являются циклами с предусловием, последний ---
с постусловием. Такая конструкция, как цикл со счётчиком, в синтаксисе
отсутствует, в отличие, скажем, от Паскаля и Бейсика. Однако один из циклов
с предусловием обладает одним интересным свойством:
цикл for позволяет помимо самого условия задавать инициализатор
и "модификатор" каждой итерации:

`for( инициализатор ; условие ; модификатор )
    тело_цикла`

Этим часто пользуются. Eсли нужно выполнить тело цикла,
параметризованное последовательными целочисленными индексами, пишут что-то
вроде этого:

`//Листинг %listdef forcount%
for( int i = 0; i < 100; ++i )
{
  a[i] = i * i;
}`

Очевидно, данный цикл выполняет тело цикла с последовательными значениями,
т.е. в целом эквивалентен следующему циклу на Паскале:

`for i := 0 to 99 do
begin
  a[i] := i * i;
end`

Конструкции типа показанной в листинге %listno forcount%, очень распространены
и узнаются опытными программистами на Си с первого взгляда, в отличие
от цикла, показанного на листинге %listno badfor%, который делает то же самое,
что и листинг %listno forcount%.

`//Листинг %listdef badfor%
for( int i = -1; ++i < 100; a[i] = i * i );`

Общепринятые конструкции, выражающие распространённые понятия, непосредственно
отсутствующие в языке программирования, называются идиомами этого языка
программирования. Например, листинг %listno forcount% является идиомой цикла
со счётчиком в си-подобных языках программирования.

Библиотека языка Си++ предоставляет пользователю набор различных по реализации,
но одинаковых по интерфейсу шаблонных классов-контейнеров: вектора,
списки, очереди, множества, отображения. Соответственно, при использовании
контейнеров существует потребность перебора элементов контейнеров. Можно было
бы вводить для каждого контейнера свою идиому для перебора, однако унифицированный
интерфейс библиотеки позволяет использовать стандартную идиому для обхода
контейнеров (листинг %listno stdfor%).

`//Листинг %listdef stdfor%
typedef .... MyContainer;

void printall(MyContainer& c)
{
  for(MyContainer::iterator p = c.begin(); p != c.end(); ++p)
  {
    std::cout << *c;
  }
}`

Таким образом, эта идиома (а именно, перебор при помощи итератора
`ContainerName::iterator` начиная с `obj.begin()` и до `obj.end()`) позволяет эмулировать цикл
foreach, присутствующий в синтаксисе многих других языков программирования
(в частности, в Visual Basic и C#).

Поэтому на вопрос, заданный в начале статьи, можно ответить так: "Си++ поддерживает
цикл со счётчиком и цикл foreach, но только идиоматически".

Другими примерами идиом, кроме цикла со счётчиком
и имитации цикла foreach, может служить способ организации исходного кода с заголовочными
файлами (имитирует модули с экспортом и импортом, которые непосредственно представлены
в синтаксисе языка Модула-2), идиома умных указателей (может имитировать сборку мусора
при помощи подсчёта ссылок, лочить объекты в многопоточной среде и др.), метапрограммирование
шаблонов, которое можно рассматривать как целый язык построенный на тех или иных идиомах
использования шаблонов. Как высокоуровневые идиомы использования средств ООП можно
рассматривать и паттерны проектирования GoF.

Отсюда можно сделать вывод, что использование идиомы в языке программирования
фактически означает расширение языка программирования некоей высокоуровневой инструкцией,
которой нет непосредственно в языке. Как правило, в более низкоуровневых языках при
помощи идиом выражаются те понятия, которые непосредственно существуют в высокоуровневых.
Так например, функции map и filter в Scheme можно рассматривать как идиомы, ненужные
в тех языках, где есть list comprehension.

Владение идиомами позволяет программисту быстрее писать программы, не тратя время на продумывание
и написание типичного кода (типа листингов %listno forcount% и %listno stdfor%). Кроме того,
такой код проще читать и понимать (если конечно код писал программист, владеющий идиомами),
а также отлаживать, т.к. поведение идиом хорошо известно и не требует лишней отладки.
Также опечатки в известных конструкциях, т.е. отход от общепринятого кода, бросается в глаза
и свидетельствует о возможной ошибке.

=Идиомы программирования на подмножестве базисного Рефала=

В этом разделе будет рассмотрено сам подмножество и идиомы программирования на нём.
Выбор подмножества базисного Рефала обусловлен двумя причинами:

1. Подмножество базисного Рефала поддерживается всеми диалектами Рефала, поэтому
рекомендации ниже можно будет воплотить везде. Правда, не везде в них есть необходимоть.

2. Я разрабатываю самокомпиляторы Модульного и Простого Рефалов, которые как раз поддерживают
именно это подмножество (хотя Простой Рефал уже поддерживает вложенные функции --- весьма
мощное и выразительное средство, которое не только облегчает использование нижеперечисленных
идиом, но и порождает ряд новых).

Для изложения будет использоваться синтаксис Рефала 5, который обладает достаточной
выразительностью (по сравнению с Рефалом 2) и понятен большинству программистов на Рефале.
При демонстрации идиом, связанных с указателями на функции и функциями высших порядков
будут использоваться диалекты Модульного и Простого Рефала.

Для краткости в дальнейшем будем отождествлять понятия подмножества базисного Рефала и Рефал.
Если будет иметься в виду конкретный диалект Рефала или особенности, не входящие в подмножество,
это будет оговорено особо.

=Специфические идиомы подмножества=

==Общие замечания о подмножестве базисного Рефала==

Подробное описание подмножества, а также определения применяемых ниже терминов приведены
в приложении к статье, поэтому читателям, не программировавшим ранее на Рефале, рекомендуется
изучить это описание. В дальнейшем будет предполагаться, что читатель уже знаком с языком
программирования Рефал и уже умеет писать и запускать на нём программы.

Кратко можно сказать, что программа представляет собой набор функций, каждая из которых
представляет собой набор _предложений_ --- пар _образец_ `=` _результат_. Функция принимает
единственный _аргумент_, представляющий собой _объектное выражение_ (определение разных видов
выражений см. в приложении). Аргумент сопоставляется по очереди с каждым образцом до тех пор,
пока не будет достигнуто успешное сопоставление. В случае успешного сопоставления управление
передаётся результату, выполнение которого приводит к замене _скобок вызова функции_
в _поле зрения_ (определения скобок вызова функции --- скобок конкретизации и поля зрения
см. в приложении). Т.е. выразительные средства языка оказываются крайне бедными: нет ни ветвлений
по условию (кроме ветвлений по пассивному аргументу (а активным он быть и не может)), ни циклов,
ни функций с несколькими аргументами, ни инкапсуляции (все данные в программе представляют
собой объектные выражения, которые можно проанализировать любым образцом, скрыть внутреннюю
структуру данных невозможно).

А так как полезных высокоуровневых средств непосредственно в языке нет, их приходится эмулировать
вручную --- сам программист рано или поздно разработает набор идиом для своей повседневной работы.
В данной статье я расскажу о тех приёмах, которыми я пользуюсь при программировании на Простом
и Модульном Рефалах. Часть их я узнал из различных руководств по программированию на Рефале
(в частности, из руководства Турчина по Рефалу 5), часть я разработал самостоятельно. Если идиома
основана не на моих идеях, я обязательно укажу авторство. Кроме того, будут приведены примеры
кода на более развитых диалектах, демонстрирующие, как высокоуровневые средства делают ненужными
соответствующие идиомы.

==Общие идиомы подмножества==

В этом разделе будут приведены идиомы, которые ограничиваются только подмножеством, описанным
в приложении. В последующих разделах подмножество будет расширено это подмножество указателями
на функции и вложенными функциями, т.е. средствами, существующими Модульном и Простом Рефалах.

===Форматы функций===

Одним из ограничений подмножества базисного Рефала является унарность функций --- каждая функция
принимает на входе только один аргумент и возвращает только одно значение, в то время как часто
возникает необходимость передать в функцию несколько значений. Кроме того, функция может возвращать
несколько связанных по смыслу значений. Во многих распространённых императивных языках
программирования функции могут принимать несколько аргументов, но при этом возвращают только одно
значение. Для возврата нескольких значений семантика языка предусматривает передачу параметров
по указателю или ссылке, позволяя тем самым присвоить из вызываемой функции новое значение
передаваемым параметрам. Передача по ссылке в базисном Рефале невозможна, т.к. требует наличия
операции присваивания, которой в семантике языка места не нашлось.

Решение этой проблемы даёт введение соглашений о вызовах функций, также известных как форматы
функций.

Если требуется передать в функцию три терма, означающих три разных аргумента, то
их можно непосредственно передать как выражение из трёх термов в фиксированном порядке.

===Имитация неуспешного выполнения===
===Ассоциативные списки===
===Абстрактные типы данных===
===Промежуточные функции===
===Остаточно-рекурсивные циклы===
===Использование скобок в качестве указателей===
===Мультискобки===
==Идиомы, требующие указатели на функции==
===Сокрытие циклов в списочных морфизмах===
==Идиомы, требующие вложенных функций==
===ООП===
===Монады===
