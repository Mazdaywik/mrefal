Идиомы программирования на Рефале

=Понятие идиомы в языке программирования=

Есть ли в Си++ цикл со счётчиком? А цикл foreach? Если смотреть узко, то нет.
Строго говоря, в Си++, как и в Си, только три цикла (конструкции, порождаемые
условными инструкциями и goto, рассматривать не будем), а именно while, for
и do-while. Первые два из них являются циклами с предусловием, последний ---
с постусловием. Такая конструкция, как цикл со счётчиком, в синтаксисе
отсутствует, в отличие, скажем, от Паскаля и Бейсика. Однако один из циклов
с предусловием обладает одним интересным свойством:
цикл for позволяет помимо самого условия задавать инициализатор
и "модификатор" каждой итерации:

`for( инициализатор ; условие ; модификатор )
    тело_цикла`

Этим часто пользуются. Eсли нужно выполнить тело цикла,
параметризованное последовательными целочисленными индексами, пишут что-то
вроде этого:

`//Листинг %listdef forcount%
for( int i = 0; i < 100; ++i )
{
  a[i] = i * i;
}`

Очевидно, данный цикл выполняет тело цикла с последовательными значениями,
т.е. в целом эквивалентен следующему циклу на Паскале:

`for i := 0 to 99 do
begin
  a[i] := i * i;
end`

Конструкции типа показанной в листинге %listno forcount%, очень распространены
и узнаются опытными программистами на Си с первого взгляда, в отличие
от цикла, показанного на листинге %listno badfor%, который делает то же самое,
что и листинг %listno forcount%.

`//Листинг %listdef badfor%
for( int i = -1; ++i < 100; a[i] = i * i );`

Общепринятые конструкции, выражающие распространённые понятия, непосредственно
отсутствующие в языке программирования, называются идиомами этого языка
программирования. Например, листинг %listno forcount% является идиомой цикла
со счётчиком в си-подобных языках программирования.

Библиотека языка Си++ предоставляет пользователю набор различных по реализации,
но одинаковых по интерфейсу шаблонных классов-контейнеров: вектора,
списки, очереди, множества, отображения. Соответственно, при использовании
контейнеров существует потребность перебора элементов контейнеров. Можно было
бы вводить для каждого контейнера свою идиому для перебора, однако унифицированный
интерфейс библиотеки позволяет использовать стандартную идиому для обхода
контейнеров (листинг %listno stdfor%).

`//Листинг %listdef stdfor%
typedef .... MyContainer;

void printall(MyContainer& c)
{
  for(MyContainer::iterator p = c.begin(); p != c.end(); ++p)
  {
    std::cout << *c;
  }
}`

Таким образом, эта идиома (а именно, перебор при помощи итератора
`ContainerName::iterator` начиная с `obj.begin()` и до `obj.end()`) позволяет эмулировать цикл
foreach, присутствующий в синтаксисе многих других языков программирования
(в частности, в Visual Basic и C#).

Поэтому на вопрос, заданный в начале статьи, можно ответить так: "Си++ поддерживает
цикл со счётчиком и цикл foreach, но только идиоматически".

Другими примерами идиом, кроме цикла со счётчиком
и имитации цикла foreach, может служить способ организации исходного кода с заголовочными
файлами (имитирует модули с экспортом и импортом, которые непосредственно представлены
в синтаксисе языка Модула-2), идиома умных указателей (может имитировать сборку мусора
при помощи подсчёта ссылок, лочить объекты в многопоточной среде и др.), метапрограммирование
шаблонов, которое можно рассматривать как целый язык построенный на тех или иных идиомах
использования шаблонов. Как высокоуровневые идиомы использования средств ООП можно
рассматривать и паттерны проектирования GoF.

Отсюда можно сделать вывод, что использование идиомы в языке программирования
фактически означает расширение языка программирования некоей высокоуровневой инструкцией,
которой нет непосредственно в языке. Как правило, в более низкоуровневых языках при
помощи идиом выражаются те понятия, которые непосредственно существуют в высокоуровневых.
Так например, функции map и filter в Scheme можно рассматривать как идиомы, ненужные
в тех языках, где есть list comprehension.

=Идиомы программирования на подмножестве базисного Рефала=

В этом разделе будут рассмотрены идиомы программирования, используемые при программировании
на достаточно узком подмножестве Рефала. Выбор подмножества базисного Рефала обусловлен
двумя причинами:

1. Подмножество базисного Рефала поддерживается всеми диалектами Рефала, поэтому
рекомендации ниже можно будет воплотить везде. Правда, не везде в них есть необходимоть.

2. Я разрабатываю самокомпиляторы Модульного и Простого Рефалов, которые как раз поддерживают
именно это подмножество (хотя Простой Рефал уже поддерживает вложенные функции --- весьма
мощное и выразительное средство, которое не только облегчает использование нижеперечисленных
идиом, но и порождает ряд новых).

Для изложения будет использоваться синтаксис Рефала 5, который обладает достаточной
выразительностью (по сравнению с Рефалом 2) и понятен большинству программистов на Рефале.
При демонстрации идиом, связанных с указателями на функции и функциями высших порядков
будут использоваться диалекты Модульного и Простого Рефала.

Для краткости в дальнейшем будем отождествлять понятия подмножества базисного Рефала и Рефал.
Если будет иметься в виду конкретный диалект Рефала или особенности, не входящие в подмножество,
это будет оговорено особо.

==Краткое описание подмножества==

===Данные, которые обрабатывает Рефал===

Основной обрабатываемой структурой данных является _объектное выражение_. Объектное выражение ---
это структура данных, представляющая собой последовательность переменной длины (возможно пустую)
_объектных термов_. Объектный терм может представлять собой либо _атом_ --- неделимую средствами
языка Рефал (без учёта встроенных библиотечных функций) сущность, например, число, символ,
имя (идентификатор) или что-либо другое (состав атомов в разных диалектах различается), либо
т.н. скобочный терм --- терм, содержащий внутри себя другое объектное выражение. Рассмотрим
подробнее разные виды термов.

1. Атом-число. Представляет абстракцию числа в математике, в зависимости от диалекта могут
поддерживаться целые числа ограниченного диапазона, целые числа неограниченной разрядности,
действительные числа, при этом атомы целых и действительных чисел различаются.

Примеры чисел: `1`, `2222`, `1234567890`, `3.14`, `3e8`, `-273,15`.

Далее будем считать, что наш диалект поддерживает только небольшие целые числа в качестве
значений этой разновидности атомов.

2. _Атом-символ_. Является абстракцией печатного символа как элемента текста, также в зависимости
от диалекта может быть как ASCII-, так и UNICODE-символом. Атомы-символы будем записывать, как
символы в одинарных кавычках. Если в рефал-выражении несколько символов идут подряд, то будем
записывать их слитно, т.е. вместо `'Ж' '0' 'П' 'A'` будем записывать `'Ж0ПA'`.

3. _Атом-идентификатор_ или _атом-имя_. В большинстве диалектов представляет собой некоторое имя,
представляющее само себя (хотя в некоторых диалектах, например Рефал 2 или Рефал 7, идентификатор
представляет и одноимённую функцию из той же области видимости). Как правило, атомы-имена записываются
как "слова", начинающиеся с заглавной латинской буквы, после которой следует некоторое (возможно
нулевое) количество букв, цифр, знаков `_` и `-`. Будем считать, что регистр идентификаторов
различается, т.е. имена `Name` и `NAME` различаются.

4. _Скобочный терм_. Содержит внутри себя объектное выражение, записывается как объектное выражение,
окружённое круглыми скобками. Например `(Position 102 'filename.ext')` представляет собой скобочный
терм.

Другие диалекты могут поддерживать ряд других значений атомов, например, замыкания, дескрипторы
файлов или других объектов, ссылки на статические или динамические объекты. Если это будет необходимо,
расскажем об этом по-подробнее.

Объектное выражение записывается как перечисление содержащих его термов без каких-либо разделителей.
Например `Identifier (Position 102 'filename.ext') 'Name'` представляет собой выражение из 6 термов,
первый из которых является именем, второй --- скобочным термом, последние четыре --- символы. Второй
терм содержит внутри себя выражение, содержащее имя, число и 12 символов.

Само по себе понятие объектного выражения статично, поэтому для описания выполнения программы
в динамике вводятся два расширения: введение _активных термов_ и введение _переменных_, заменяющих
некоторые неизвестные части объектного выражения.

Объектное выражение, пополненное активными термами, называется _активным выражением_, объектное
выражение, пополненное переменными, называется _образцовым выражением_, объектное выражение,
пополненное и тем и другим, называется _результатным выражением_. Множество объектных выражений
является подмножеством множеств активных, образцовых и результатных выражений, множества активных
и образцовых выражений являются подмножествами множества результатных выражений.

Активным термом называется конструкция записи вызова функции, записывается
как активное (или результатное) выражение, слева от которого находится открывающая угловая скобка
и имя функции, записанное непосредственно за ней, а справа --- закрывающая угловая скобка.
Угловые скобки называются _скобками активации_, _скобками конкретизации_ или _скобками вызова функции_.
Выражение, находящееся между скобками активации, является аргументом функции.
Примеры активных термов: `<Factorial 100>`, `<Length 'Some string'>`, `<Mul 10 <Fact <Sub 10 1>>>`.

Активное или результатное выражение, будем называть _пассивным_, если оно не содержит скобок активации.

Переменные --- это специальный вид термов, который может заменять некоторые части выражения. Обычно
вводится 3 вида переменных: e-переменные, которые могут принимать значения любого объектного
выражения, t-переменные, способные принимать значения любого объектного терма и s-переменные,
способные принимать значения любого атома. Некоторые диалекты вводят v-переменные, которые
могут принимать значения только непустого (содержащего не менее одного терма) выражения.
В примерах кода ниже мы не будем пользоваться v-переменными.
Переменная записывается как `вид.имя`, где `имя` --- непустая последовательность латинских букв, цифр
и знаков '-` и '_`. Таким образом `t.1`, `s.Number`, `e.Begin` и `t.SymTable` являются именами
переменных.

При подстановке вместо переменных соответствующих значений из образцового выражения получается
объектное выражение, из результатного выражения --- активное выражение. Например, при подстановке
в образцовое выражение `e.Begin 'мыла' e.End` значений переменных `e.Begin == 'Мама '` и
`e.End == ' раму'`, получим объектное выражение `'Мама мыла раму'`. При подстановке в результатное
выражение `<Mul s.N <Fact <Dec s.N>>>` вместо переменной s.N значения 10 получим активное выражение
`<Mul 10 <Fact <Dec s.N>>>`.

===Семантика выполнения программы===

Семантику Рефала принято описывать вводя понятие _абстрактной рефал-машины_. Рефал-машина содержит
две области памяти: поле зрения, которое содержит обрабатываемые данные и полностью описывает
состояние вычислений и поле програмы, содержащее определения всех функций программы. Структура
поля зрения представляет собой активное выражение. Рефал-машина производит вычисление за ряд
дискретных _шагов_. За один шаг рефал-машина выбирает крайне левый терм активации, не содержащий
внутри себя других термов активации (т.е. пассивное рефал-выражение) и вызывает функцию, которая
находится справа от открывающей скобки активации с аргументом, находящимся внутри этого терма.
Такой терм называется первичным. В результате выполнения функция возвращает некоторое активное
выражение, на которое и заменяется терм активации фукнции. На этом шаг заканчивается. Как не трудно
догадаться, рефал-машина производит вычисления до тех пор, пока поле зрения не станет пассивным.

А теперь, про то, как выполняются функции. _Функция_ на Рефале (как и прежде, здесь под Рефалом
понимается подмножество базисного Рефала), представляет собой набор _предложений_, причём под
предложением понимается пара вида `образец = результат`, где _образец_ и _результат_ --- это,
соответственно, образовое и результатное выражение. Далее по тексту для определения функций
будем использовать запись, показанную на листинге %listno funsyntax%, т.е. предложения
отделяются друг от друга точкой с запятой, последовательность выражений заключена в фигурные
скобки. На имя функции накладываются те же ограничения, что и на атом-имя.

`/* Листинг %listdef funsynax% */

ИмяФункции {
  Образец1 = Результат1;
  Образец2 = Результат2;
  ......................
  ОбразецN = РезультатN
}`

Семантика выполнения функции основана на понятиях сопоставления с образцом и замены на результат.
Под сопоставлением объектного выражения `OE` с образцовым выражением `PE` (обозначается `OE : PE`)
называется поиск таких
значений переменных из `PE`, которые при подстановке в образец `PE` превратят его в `OE`. Если
таких значений переменных не существует, то говорят, что сопоставление невозможно. Распространена
ситуация, когда существует несколько различных подстановок значений переменных в `PE`, дающих
в результате `OE`. В таком случае выбирается та подстановка, при котором крайняя левая переменная
принимает кратчайшее значение. Если это условие не разрешает противоречия, выбирается следующяя по
счёту подстановка.

Пример.

`20 '-' 12 '-' 3 '-' 1 : e.1 '-' e.2 '-' e.3`

даёт 3 разных подстановки

`e.1 == 20,        e.2 == 12,       e.3 = 3 '-' 1
e.1 == 20,        e.2 == 12 '-' 3, e.3 = 1
e.1 == 20 '-' 12, e.2 == 3,        e.3 = 1`

Кратчайшим значением переменной `e.1` (которая является самой левой) является значение `20`,
но это не разрешает противоречия, т.к. в этом случае остаются два варианта подстановки.
Выбирая кратчайшее значение `12` для второй слева переменной `e.2` получаем единственную
подстановку `e.1 == 20, e.2 == 12, e.3 = 3 '-' 1`.

Выполнение функции выполняется в следующем порядке. Область видимости функции инициализируется
пустым множеством. Выполняется сопоставление аргумента функции с первым образцом. При успешном
сопоставлении с образцом область видимости пополняется переменными образца и производится
подстановка найденных значений переменных в результат. Таким образом, в результате не могут
находиться переменные, отсутствующие в области видимости (в случае базисного Рефала ---
в образце данного выражения). Активное выражение, полученное в результате подстановки,
становится результатом выполнения функции.
Если сопоставление с первым образцом завершилось неуспешно, аналогичным образом происходит
выполнение второго предложение -- сопоставление со вторым образцом и в случае успешного
сопоставление --- подстановка переменных во второй результат. Аналогичным образом
обрабатываются и остальные предложения функции.

В случае неуспешности выполнения всех образцов функции генерируется ошибка невозможности
распознавания, которая приводит к остановке всей рефал-машины. Ряд диалектов Рефала (Рефал 2,
Рефал 5, Модульный и Простой Рефалы) в этой ситуации делают дамп всего поля зрения, чтобы
программист мог найти ошибку в программе.

Описание сопоставления выше (подбор таких значений переменных, подстановка которых в образец
даёт аргумент функции) ничего не говорит ни о конкретном порядке вычислений, ни об эффективности
осуществления тех или иных сопоставлений с образцом. Поэтому приведём ниже чёткий алгоритм
сопоставления объектного выражения с образцом (алгоритм позаимствован из руководства к языку
Рефал 5, но подходит и для нашего случая; авторский курсив сохранён; _атомы_ в руководстве
по Рефалу 5 _символами_).

====Алгоритм сопоставления с образцом====

Вхождения символов, скобок и переменных будут называться _элементами_ выражений.
Пропуски между элементами будут называться _узлами_. Сопоставление `Е : Р` определяется
как процесс _отображения_, или _проектирования_, элементов и узлов образца `Р` на элементы и узлы
объектного выражения `Е`.

====Общие требования к отображению `Р` на `Е` (сопоставлению `Е : Р`)====

Следующие очевидные требования должны проверяться на каждой стадии сопоставления:

1. Если узел `N2` расположен в `Р` правее узла `N1`, то проекция `N2` в `Е` может либо совпадать
с проекцией `N1`, либо располагаться справа от неё (линии проектирования не могут пересекаться).

2. Скобки и символы должны совпадать со своими проекциями.

3. Проекции переменных должны удовлетворять синтаксическим требованиям их значений;
т.е., быть символами, термами или произвольными выражениями для s-, t- и e-переменных
соответственно. Различные вхождения одной переменной должны иметь одинаковые проекции. 

Предполагается, что в начале сопоставления граничные узлы `Р` отображаются в граничные узлы `Е`.
Процесс отображения описывается при помощи следующих шести правил. На каждом шаге отображения
правила 1-4 определяют следующий элемент, подлежащий отображению; таким образом, каждый элемент
из `Р` получает при отображении уникальный номер. 

====Правила отображения====

1. После того, как отображена скобка, следующей подлежит отображению парная ей скобка. 

2. Если в результате предыдущих шагов оба конца вхождения некоторой e-переменной уже отображены,
но эта переменная еще не имеет значения (ни одно другое ее вхождение не было отображено), то эта
переменная отображается следующей. Такие вхождения называются _закрытыми_ e-переменными. Две закрытые
e-переменные могут появиться одновременно; в этом случае та, что слева, отображается первой. 

3. Вхождение переменной, которая уже получила значение, является _повторным_. Скобки, символы,
s-переменные, t-переменные и повторные вхождения e-переменных в `Р` являются _жёсткими_ элементами.
Если один из концов жесткого элемента отображен, проекция второго конца определена однозначно.
Если Правила 1 и 2 неприменимы, и имеется несколько жёстких элементов с одним спроектированным концом,
то из них выбирается самый левый. Если возможно отобразить этот элемент, не вступая в противоречие
с общими требованиями  1-3, приведенными выше, тогда он отображается, и процесс продолжается дальше.
В противном случае объявляется _тупиковая ситуация_.

4. Если Правила 1-3 неприменимы и имеются несколько e-переменных с отображённым левым концом,
то выбирается самая левая из них. Она называется _открытой_ e-переменной. Первоначально она получает
пустое значение, т.е., ее правый конец проектируется на тот же узел, что и левый. Другие значения могут
присваиваться открытым переменным через удлинение (см. Правило 6). 

5. Если все элементы `Р` отображены, это значит, что процесс сопоставления успешно завершён.

6. В тупиковой ситуации процесс возвращается назад к последней открытой
e-переменной (т.е., к той, что имеет максимальный номер проекции), и ее значение _удлиняется_;
т.е., проекция ее правого конца в `Е` подвигается на один терм вправо.
После этого процесс возобновляется. Если переменную нельзя удлинить (из-за Общих требований 1-3),
удлиняется предшествующая открытая переменная, и т.д.
Если не имеется подлежащих удлинению открытых переменных, процесс сопоставления не удался.
_(Конец цитаты.)_

Введём дополнительно следующие понятия: _вес_ и _длина_ объектного выражения.

`Len(obj) = | 0, если obj --- пустое выражение
           | Len(subobj) + 1, если obj == t.X + subobj

W(obj) = Wt(obj[1]) + Wt(obj[2]) + ... + Wt(obj[Len(obj)]), где

Wt(term) = | C1, если term --- атом
           | С2 + Len(obj), если term == (obj)`

Здесь `obj[i]` --- i-й терм объектного выражения `obj`, `Wt` --- вспомогательная функция, вычисляющая
вес терма, С1 и С2, константы, зависящие от постановки задачи. Можно сказать, что `W(obj) = O(Na) + O(Nb)`,
где `Na` и `Nb` --- это соответственно общее количество атомов и скобок в объектном выражении.

Анализируя алгоритм, можно заключить, что если атомы и скобки отождествляются за постоянное время,
то сопоставление одноимённых t- и e-переменных может потребовать неявного рекурсивного анализа всей
внутренней структуры этих переменных со сложностью O(W(переменная)), где W(obj) --- вес объектного
выражения, сканирование по каждой e-переменной имеет сложность O(maxlen(e-переменная)), где функция
maxlen определяет максимальную длину, которую способна принять e-переменная в процессе сканирования,
сложность сопоставления всего образца равна произведению сложностей сопоставления каждого элемента образца.

==Общие идиомы подмножества==
===Имитация неуспешного выполнения===
===Форматы функций===
===Ассоциативные списки===
===Абстрактные типы данных===
===Промежуточные функции===
===Остаточно-рекурсивные циклы===
===Использование скобок в качестве указателей===
===Мультискобки===
==Идиомы, требующие указатели на функции==
===Сокрытие циклов в списочных морфизмах===
==Идиомы, требующие вложенных функций==
===ООП===
===Монады===
