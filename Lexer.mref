$MODULE Lexer;

$IMPORT SymStream;
$IMPORT Types;
$IMPORT MError;
$IMPORT Refal5;

$ENTRY NewLexer {
	e.FileName = (<SymStream::NewSymStream e.FileName>);
}

/*
	Обработка ведётся по цепочке:
	Blanks - Comment - NotIdent - Ident - Macro
	Blanks -- удаляет начальные символы пустого пространства (если они есть);
	Comment -- Если далее комментарий -- удаляет его и перебрасывает на начало
цепочки, т.к. после комментария могут следовать пробелы;
	NotIdent -- пытается извлечь из потока служебные символы, директивы и
закавыченные элементы (слова ("words") и литералы ('literals')), если находит,
то возвращает их как следующую лексему, в противном случае передаёт вычисления
далее по цепочке;
	Ident -- пытается прочесть из потока идентификатор (разновидность символа
или имя функции), в противном случае передаёт вычисление по цепочке;
	Macro -- считывает макроцифру; при попытке считывания слишком большого чис-
ла генерируется ошибка; при неудачном считывании также генерируется ошибка.
*/

$ENTRY NextToken {
	(t.SymStream) =
		<NextToken-Chain-Blanks
			<SymStream::ExtractsFromSet t.SymStream ( ' \t\n' CrLf )>
		>;
	(t.SymStream t.Token e.Tokens) = (t.SymStream e.Tokens) t.Token;
}

$ENTRY UnGetToken {
	(t.SymStream e.UnGetTokens) t.Token =
		(t.SymStream t.Token e.UnGetTokens);
}

$ENTRY CloseLexer {
	(t.SymStream e.UnGetTokens) =
		<SymStream::CloseStream t.SymStream>;
}

NextToken-Chain-Blanks {
	t.SymStream e.Blanks =
		<NextToken-Chain-Comment <SymStream::ExtractFromSet t.SymStream ('/')> >;
}

NextToken-Chain-Comment {
	t.SymStream =
		<NextToken-Chain-NotIdent t.SymStream>;
	t.SymStream s.StartComment =
		<ParseComment s.StartComment <SymStream::ExtractFromSet t.SymStream ( '/*' )> >;
}

ParseComment {
	/* s.StartComment t.SymStream s.SecondChar */

	/* Комментарий в стиле C++ */
	'/' t.SymStream '/' =
		<EatCPPOneLineComment t.SymStream>;

	/* Комментарий в стиле C */
	'/' t.SymStream '*' =
		<EatCMultiLineComment t.SymStream>;

	/* Первые два символа не являются началом комментария.
	Возвращаем их в поток и движемся далее по цепочке.
	*/
	s.StartComment t.SymStream s.SecondChar =
		<NextToken-Chain-NotIdent
			<SymStream::UnGetChar
				<SymStream::UnGetChar t.SymStream s.SecondChar>
				s.StartComment
			>
		>;
}

EatCPPOneLineComment {
	t.SymStream =
		<DoEatOneLineComment <SymStream::NextChar t.SymStream>>;
}

DoEatOneLineComment {
	/* Прочитали строку */
	t.SymStream CrLf =
		<NextToken (t.SymStream)>;

	/* Достигли конца файла */
	t.SymStream EOF =
		<NextToken (<SymStream::UnGetChar t.SymStream EOF>)>;

	t.SymStream s.X =
		<DoEatOneLineComment <SymStream::NextChar t.SymStream>>;
}

LineNumberOnly {
	t.SymStream s.LineNumber = s.LineNumber;
}

EatCMultiLineComment {
	t.SymStream =
		<DoEatCMultiLineComment
			<LineNumberOnly <SymStream::LineNumber t.SymStream>>
			<SymStream::NextChar t.SymStream>
		>;
}

DoEatCMultiLineComment {
	s.LineNumber t.SymStream EOF =
		<MError::Error
			<SymStream::ExtractFileName t.SymStream>
			s.LineNumber
			'Unclosed comment'
		>;
	s.LineNumber t.SymStream '*' =
		<EndEatCMultiLineComment
			<SymStream::ExtractFromSet t.SymStream ('/')>
		>;
	s.LineNumber t.SymStream s.X =
		<EatCMultiLineComment t.SymStream>;
}

EndEatCMultiLineComment {
	t.SymStream '/' =
		<NextToken (t.SymStream)>;
	t.SymStream =
		<EatCMultiLineComment t.SymStream>;
}

AppendLineNumber {
	t.SymStream s.LineNumber =
		<InsertLineNumberToToken
			s.LineNumber
			<SwNextToken-Chain-NotIdent
				<SymStream::ExtractFromSet t.SymStream ( EOF 'tes$\'\"(){}<>=;,&:.' ) >
			>
		>;
}

InsertLineNumberToToken {
	s.LineNumber (t.SymStream) (s.TokenName e.Content) =
		(t.SymStream)
		(s.TokenName (LineNumber s.LineNumber) e.Content);
}

NextToken-Chain-NotIdent {
	t.SymStream =
		<AppendLineNumber
			<SymStream::LineNumber t.SymStream>
		>;
}

SwNextToken-Chain-NotIdent {
	t.SymStream EOF = (t.SymStream) (EndOfText);
	t.SymStream 't' = <Variable TVar t.SymStream>;
	t.SymStream 'e' = <Variable EVar t.SymStream>;
	t.SymStream 's' = <Variable SVar t.SymStream>;
	t.SymStream '$' = <Directive t.SymStream>;
	t.SymStream '\'' = <Literal t.SymStream>;
	t.SymStream '\"' = <DQWord t.SymStream>;
	t.SymStream '(' = (t.SymStream) (LeftBrac);
	t.SymStream ')' = (t.SymStream) (RigthBrac);
	t.SymStream '{' = (t.SymStream) (OpenBlock);
	t.SymStream '}' = (t.SymStream) (CloseBlock);
	t.SymStream '<' = (t.SymStream) (OpenFnCall);
	t.SymStream '>' = (t.SymStream) (CloseFnCall);
	t.SymStream '=' = (t.SymStream) (Replaces);
	t.SymStream ';' = (t.SymStream) (EndSent);
	t.SymStream ',' = (t.SymStream) (Comma);
	t.SymStream ':' = <Colon t.SymStream>;
	t.SymStream '&' = (t.SymStream) (Ampersand);
	t.SymStream '.' = (t.SymStream) (Dot);
	t.SymStream =
		<NextToken-Chain-Ident <SymStream::ExtractFromSet t.SymStream (<Types::UpAlph>)> >;
}

Colon {
	t.SymStream =
		<SwColon <SymStream::ExtractFromSet t.SymStream (':')> >;
}

SwColon {
	t.SymStream ':' =
		(t.SymStream) (DoubleColon);
	t.SymStream =
		(t.SymStream) (Colon);
}

NextToken-Chain-Ident {
	t.SymStream s.FirstChar =
		<Identifier
			s.FirstChar
			<SymStream::ExtractsFromSet
				t.SymStream (<Types::UpAlph><Types::LoAlph><Types::Digits>'-_')
			>
		>;
	t.SymStream =
		<NextToken-Chain-Macro
			<LineNumberOnly <SymStream::LineNumber t.SymStream>>
			<SymStream::ExtractsFromSet t.SymStream (<Types::Digits>)>
		>;
}

CharOnly {
	t.SymStream = <SwCharOnly <SymStream::NextChar t.SymStream>>;
}

SwCharOnly {
	t.SymStream s.Char = s.Char;
}

NextToken-Chain-Macro {
	s.LineNumber t.SymStream =
		<MError::Error
			<SymStream::ExtractFileName t.SymStream>
			s.LineNumber
			'Unknown symbol `' <CharOnly t.SymStream> '`'
		>;
	s.LineNumber t.SymStream e.Digits =
		(t.SymStream) (Macro <ParseMacro s.LineNumber e.Digits>);
}

Variable {
	s.VarType t.SymStream =
		<SwVariable
			s.VarType
			<SymStream::ExtractFromSet t.SymStream (<Types::UpAlph><Types::LoAlph><Types::Digits>'.')>
		>;
}

SwVariable {
	s.VarType t.SymStream '.' =
		<OutVar
			s.VarType
			<SymStream::ExtractsFromSet t.SymStream (<Types::UpAlph><Types::LoAlph><Types::Digits> '-_')>
		>;
	s.VarType t.SymStream s.Index =
		(t.SymStream) (s.VarType s.Index);

	s.VarType t.SymStream =
		<MError::Error 'S' 'Unknown variable index' >;
}

OutVar {
	s.VarType t.SymStream e.Index =
		(t.SymStream) (s.VarType '.' e.Index);
}

/* Директивы $ENTRY, $EXTERN, $EXTERNAL, $EXTRN, $MODULE, $IMPORT, $END. */
Directive {
	t.SymStream =
		<SwDirective
			<LineNumberOnly <SymStream::LineNumber t.SymStream>>
			<SymStream::ExtractsFromSet t.SymStream (<Types::UpAlph><Types::LoAlph>)>
		>;
}

SwDirective {
	s.LineNumber t.SymStream 'ENTRY' = (t.SymStream)(Directive Entry);
	s.LineNumber t.SymStream 'entry' = (t.SymStream)(Directive Entry);
	s.LineNumber t.SymStream 'EXTERN' = (t.SymStream)(Directive External);
	s.LineNumber t.SymStream 'EXTRN' = (t.SymStream)(Directive External);
	s.LineNumber t.SymStream 'EXTERNAL' = (t.SymStream)(Directive External);
	s.LineNumber t.SymStream 'MODULE' = (t.SymStream)(Directive Module);
	s.LineNumber t.SymStream 'module' = (t.SymStream)(Directive Module);
	s.LineNumber t.SymStream 'END' = (t.SymStream)(Directive End);
	s.LineNumber t.SymStream 'end' = (t.SymStream)(Directive End);
	s.LineNumber t.SymStream 'IMPORT' = (t.SymStream)(Directive Import);
	s.LineNumber t.SymStream 'import' = (t.SymStream)(Directive Import);
	s.LineNumber t.SymStream e.Other =
		<MError::Error
			<SymStream::ExtractFileName t.SymStream>
			s.LineNumber
			'Unknown directive `' e.Other'`'
		>;
}

Literal {
	t.SymStream =
		<Quoted Literal '\'' <SymStream::LineNumber t.SymStream>>;
}

DQWord {
	t.SymStream =
		<Quoted DQWord '\"' <SymStream::LineNumber t.SymStream>>;
}

Quoted {
	s.QName s.Quote t.SymStream s.LineNumber =
		<OutQuoted
			s.QName
			<DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>
		>;
}

OutQuoted {
	s.QName e.QLine t.SymStream = (t.SymStream) (s.QName e.QLine);
}

DoQuoted {
	s.Quote s.LineNumber t.SymStream '\\' =
		<Quoted-Escape s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream EOF =
		<MError::Error
			<SymStream::ExtractFileName t.SymStream>
			s.LineNumber
			'Unexpected EOF: not closed quote'
		>;
	s.Quote s.LineNumber t.SymStream CrLf =
		<MError::Error <SymStream::ExtractFileName t.SymStream> s.LineNumber 'Unexpected end of line: not closed quote'>;
	/* Конец рекурсии */
	s.Quote s.LineNumber t.SymStream s.Quote =
		t.SymStream;
	s.Quote s.LineNumber t.SymStream s.Char =
		s.Char <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
}

Quoted-Escape {
	s.Quote s.LineNumber t.SymStream '\\' =
		'\\' <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream 't' =
		'\t' <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream 'n' =
		'\n' <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream '\'' =
		'\'' <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream '\"' =
		'\"' <DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	/* Разобьём строку также, как и в C */
	s.Quote s.LineNumber t.SymStream CrLf =
		<DoQuoted s.Quote s.LineNumber <SymStream::NextChar t.SymStream>>;
	s.Quote s.LineNumber t.SymStream EOF =
		<MError::Error
			<SymStream::ExtractFileName t.SymStream>
			s.LineNumber
			'Unexpected end of file in quoted expression'
		>;
	s.Quote s.LineNumber t.SymStream s.Other =
		<MError::Warning s.LineNumber 'Unknown escape sequence \\' s.Other>;
}

* Максимальное значение макрочисла 4 294 967 295
ParseMacro {
	s.LineNumber e.Digits =
		<ParseMacro-CheckLength
			s.LineNumber <ValidLen <Refal5::Lenw e.Digits> >
		>;
}

ValidLen {
	s.Len e.Val = <ValidLen1 s.Len> e.Val;
}

ValidLen1 {
	1 = T; 2 = T; 3 = T; 4 = T; 5 = T;
	6 = T; 7 = T; 8 = T; 9 = T;
	10 = Ten;
	s.N = F;
}

ParseMacro-CheckLength {
	s.LineNumber T e.Digits = <Refal5::Numb e.Digits>;
	s.LineNumber F e.Digits =
		<MError::Error
			s.LineNumber 'Number is very big (' e.Digits ' > 4 294 968 295)'
		>;
	s.LineNumber Ten e.Digits-head s.Last =
		<ParseMacro-CheckLength-Ten
			s.LineNumber
			<Refal5::Compare <Refal5::Numb e.Digits-head> 429496829>
			e.Digits-head
			s.Last
		>;
}

ParseMacro-CheckLength-Ten {
	s.LineNumber '-' e.Digits = <Refal5::Numb e.Digits>;
	s.LineNumber '0' e.Digits-head s.Last =
		<ParseMacro-CheckLength-Limit
			s.LineNumber e.Digits-head s.Last <Types::OneOf s.Last ('012345')>
		>;
	s.LineNumber '+' e.Digits =
		<MError::Error
			s.LineNumber 'Number is very big (' e.Digits ' > 4 294 968 295)'
		>;
}

ParseMacro-CheckLength-Limit {
	s.LineNumber e.Digits T = <Refal5::Numb e.Digits>;
	s.LineNumber e.Digits F =
		<MError::Error
			s.LineNumber 'Number is very big (' e.Digits ' > 4 294 968 295)'
		>;
}

Identifier {
	s.First t.SymStream e.Identifier-tail =
		(t.SymStream) (Identifier s.First e.Identifier-tail);
}

$END Lexer.
