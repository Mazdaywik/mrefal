$MODULE Linker;

$IMPORT Context;
$IMPORT FileIO;
$IMPORT MError;
$IMPORT InOut;
$IMPORT MOS;
$IMPORT Math;
$IMPORT MStrings;
$IMPORT MSymModule;
$IMPORT MOrder;

$ENTRY Link {
	t.Context =
		<InOut::WriteLine 'Linking...'>
		<RealLink
			<Context::GetProgName t.Context>
		>;
}

RealLink {
	t.Context e.ProgName =
		<PutStartCaller
			<PutModules
				<FileIO::Open 'w' e.ProgName '.ref'>
				<NewAliasesTable>
				<NewStartInfo>
				<Context::ExtractModulesList t.Context>
			>
		> <MOS::System 'refc ' e.ProgName '.ref'>;
}

PutModules {
	t.FOut t.Aliases t.StartInfo t.Context
	(e.NextName) e.Tail =
		<PutModules
			<PutModule
				t.FOut t.Aliases t.StartInfo
				(e.NextName)
				<Context::ExtractOption
					t.Context
					Out
					e.NextName
				>
			>
			e.Tail
		>;

	t.FOut t.Aliases t.StartInfo t.Context =
		t.FOut t.Aliases t.StartInfo t.Context;
}



PutModule {
	t.FOut t.Aliases t.StartInfo (e.ModuleName) t.Context Found e.OutName =
		<TypeContent
			t.FOut
			t.Aliases
			<FileIO::Open 'r' e.OutName>
		> <UpdateStartInfo
			t.StartInfo
			t.Context
			e.ModuleName
		>;
}

PutStartCaller {
	t.FOut t.Aliases t.StartInfo t.Context =
		t.Context
		<TypeStart
			t.StartInfo
			t.FOut
			<OutAliases t.Aliases>
		>;
}

/*------------------------------------------------------------------------------
 Построчное препроцессирование .rout-файлов с их добавлением в выходной файл.

 Последующие Type-функции выполняют построчное препроцессирование .rout-файлов.
 Поскольку содержимое этих файлов сгенерировано автоматически, то можно ожидать,
 что вызовы функций и переменные написаны одноформатно, а вручную создаваемые
 библиотечные файлы написаны с особым вниманием.
------------------------------------------------------------------------------*/

TypeContent {
	t.FOut t.Aliases t.FIn =
		<DoTypeContent
			t.Aliases (<DefLim> t.FOut) ( <FileIO::ReadLine t.FIn> )
		>;
}

Dec {
	Limit = Limit;
	0 = Limit;
	1 = Limit;
	s.Num = <Math::Sub s.Num 1>;
}

DefLim = 64;

DoTypeContent {
	t.Aliases (s.Size t.FOut e.Converted) (t.FIn) =
		<DoTypeContent
			t.Aliases
			( <DefLim> <FileIO::WriteLine t.FOut e.Converted> )
			( <HideQuotes <FileIO::ReadLine t.FIn>> )
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn 0) =
		<FileIO::WriteLine t.FOut e.Converted>
		t.Aliases <FileIO::Close t.FIn>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		<DoTypeContent
			<SwTypeContent
				t.Aliases
				(s.Size t.FOut e.Converted)
				(t.FIn e.Raw)
			>
		>;
}

HideQuotes {
	t.FIn e.Line =
		t.FIn <DoHideQuotes e.Line>;
}

DoHideQuotes {
	'\'' e.Tail = <StartHidingQuote ('\'') e.Tail>;
	'\"' e.Tail = <StartHidingQuote ('\"') e.Tail>;
	s.Other e.Tail = s.Other <DoHideQuotes e.Tail>;
	= ;
}

StartHidingQuote {
	(s.Quote e.Hidden) '\\' s.Escaped e.Tail =
		<StartHidingQuote (s.Quote e.Hidden '\\' s.Escaped) e.Tail>;

	(s.Quote e.Hidden) s.Quote e.Tail =
		(s.Quote e.Hidden) <DoHideQuotes e.Tail>;

	(s.Quote e.Hidden) s.Other e.Tail =
		<StartHidingQuote (s.Quote e.Hidden s.Other) e.Tail>;

	(s.Quote e.Hidden) =
		<MError::LinkError
			'May be unballanced quote in StartHidingQoute'
		>;
}

SwTypeContent {
	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '\t' e.Raw) =
		t.Aliases (s.Size t.FOut e.Converted) (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted)
	(t.FIn (s.Quote e.HiddenQuote) e.Raw) =
		t.Aliases
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted s.Quote)
			(s.Quote e.HiddenQuote)
		> (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut) (t.FIn e.FnName ' {' e.Raw) =
		<TypeFnHeader
			<LookupAlias t.Aliases e.FnName>
			(s.Size t.FOut)
			(t.FIn e.Raw)
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '.' e.Index ' ' e.Raw) =
		<TypeIndex
			<LookupAlias t.Aliases '.' e.Index>
			(<Dec s.Size> t.FOut e.Converted)
			(t.FIn ' ' e.Raw)
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '<' e.FnName ' ' e.Raw) =
		<TypeFnCall
			<LookupAlias t.Aliases e.FnName>
			(<Dec s.Size> t.FOut e.Converted)
			(t.FIn ' ' e.Raw)
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '$$' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted '$') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '$' e.FnName '$' e.Raw) =
		<TypeFnPtr
			<LookupAlias t.Aliases e.FnName>
			(<Dec s.Size> t.FOut e.Converted)
			(t.FIn ' ' e.Raw)
		>;

	t.Aliases (Limit t.FOut e.Converted) (t.FIn ' ' e.Raw) =
		t.Aliases
		( <DefLim> <FileIO::WriteLine t.FOut e.Converted> )
		(t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' =' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted '=') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' <' e.Raw) =
		t.Aliases (s.Size t.FOut e.Converted) (t.FIn '<' e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' ;' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted ';') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' (' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted '(') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn s.Other e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted s.Other) (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn s.Other e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted s.Other) (t.FIn e.Raw);
}

TypeFnHeader {
	t.Aliases e.FnAlias (s.Size t.FOut) (t.FIn e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.FnAlias ' {') (t.FIn e.Raw);
}

TypeIndex {
	t.Aliases e.IndexAlias (Limit t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <DefLim> <FileIO::WriteLine t.FOut e.Converted e.IndexAlias> )
		(t.FIn e.Raw);

	t.Aliases e.IndexAlias (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <Dec s.Size> t.FOut e.Converted e.IndexAlias)
		(t.FIn e.Raw);
}

TypeFnCall {
	t.Aliases e.FnAlias (Limit t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <DefLim> <FileIO::WriteLine t.FOut e.Converted '<' e.FnAlias> )
		(t.FIn e.Raw);

	t.Aliases e.FnAlias (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		(<Dec s.Size> t.FOut e.Converted '<' e.FnAlias)
		(t.FIn e.Raw);
}

TypeFnPtr {
	t.Aliases e.FnAlias (Limit t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <DefLim> <FileIO::WriteLine t.FOut e.Converted ' ' e.FnAlias ' '> )
		( t.FIn e.Raw );

	t.Aliases e.FnAlias (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <Dec s.Size> t.FOut e.Converted ' ' e.FnAlias ' ' )
		( t.FIn e.Raw );
}

TypeQuoted {
	/* Не рассматриваем символ за бэкслешем, а сразу же его переносим */
	(s.Size t.FOut e.Converted) (s.Quote '\\' s.Escaped e.Tail) =
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted '\\' s.Escaped)
			(s.Quote e.Tail)
		>;

	/* Заменяем $$ на $ */
	(s.Size t.FOut e.Converted) (s.Quote '$$' e.Tail) =
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted '$')
			(s.Quote e.Tail)
		>;


	/* Извращаемся, чтобы разрезать текст в кавычках и не оставить на
	отдельной строке '' или "" */
	(Limit t.FOut e.Converted '\\' s.Quote) (s.Quote) =
		( <DefLim> <FileIO::WriteLine t.FOut e.Converted '\\' s.Quote s.Quote> );

	(Limit t.FOut e.Converted '\\' s.Quote) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim>
				<FileIO::WriteLine t.FOut e.Converted '\\' s.Quote s.Quote>
				s.Quote
			) (s.Quote e.Tail)
		>;

	(Limit t.FOut e.Converted s.Quote) (s.Quote) =
		<MError::LinkError
			'Unexpected quote position ??? `' e.Converted s.Quote '`'
		>;

	(Limit t.FOut e.Converted s.Quote) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim> <FileIO::WriteLine t.FOut e.Converted> s.Quote)
			(s.Quote e.Tail)
		>;

	(Limit t.FOut e.Converted) (s.Quote) =
		(<DefLim> <FileIO::WriteLine t.FOut e.Converted s.Quote>);

	(Limit t.FOut e.Converted) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim> <FileIO::WriteLine t.FOut e.Converted s.Quote> s.Quote)
			(s.Quote e.Tail)
		>;

	(s.Size t.FOut e.Converted) (s.Quote) =
		(<Dec s.Size> t.FOut e.Converted s.Quote ' ');

	(s.Size t.FOut e.Converted) (s.Quote s.Other e.Tail) =
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted s.Other)
			(s.Quote e.Tail)
		>;
}

*-------------------------------------------------------------------------------
* Хранилще информации о точках запуска модулей (функций Go, Init и Final)
*-------------------------------------------------------------------------------

NewStartInfo {
	= ( (/* InitList */) (/* Go */) (/* FinalList */) );
}

/**
	<UpdateStartInfo t.StartInfo t.Context>
		== t.StartInfo t.Context
*/
UpdateStartInfo {
	t.StartInfo t.Context e.ModuleName =
		<UpdateInitList
			t.StartInfo
			<MSymModule::LoadInfo t.Context () e.ModuleName>
		>;
}

UpdateInitList {
	( (e.InitList) t.GoInfo t.FinalList )
	t.Context
	( Module () e.ModuleName )
	( Functions e.Fn-B ('Init') e.Fn-E )
	( Imports e.Imports ) =
		<UpdateGoInfo
			( (e.InitList (e.ModuleName '::Init::Entry')) t.GoInfo t.FinalList )
			( e.ModuleName )
			( Functions e.Fn-B e.Fn-E )
		> t.Context;

	t.StartInfo t.Context
	( Module () e.ModuleName )
	( Functions e.FnList )
	( Imports e.Imports ) =
		<UpdateGoInfo
			t.StartInfo
			( e.ModuleName )
			( Functions e.FnList )
		> t.Context;
}

UpdateGoInfo {
	( t.Inits () t.Finals )
	( e.ModuleName )
	( Functions e.Fn-B ('Go') e.Fn-E ) =
		<UpdateFinalList
			( t.Inits (e.ModuleName '::Go::Entry') t.Finals )
			( e.ModuleName )
			( Functions e.Fn-B e.Fn-E )
		>;

	( t.Inits (e.OtherGo) t.Finals )
	( e.ModuleName )
	( Functions e.Fn-B ('Go') e.Fn-E ) =
		<MError::LinkError
			'Found two Go functions: ' e.OtherGo ' and '
			e.ModuleName '::Go::Entry'
		>;

	( t.Inits (e.GoInfo) t.Finals )
	( e.ModuleName )
	( Functions e.FnList ) =
		<UpdateFinalList
			( t.Inits (e.GoInfo) t.Finals )
			( e.ModuleName )
			( Functions e.FnList )
		>;
}

UpdateFinalList {
	( t.Inits t.GoInfo (e.Finals) )
	( e.ModuleName )
	( Functions e.Fn-B ('Final') e.Fn-E ) =
		// Финализаторы выполняются в порядке, обратном инициализаторам
		( t.Inits t.GoInfo ((e.ModuleName '::Final::Entry') e.Finals) );

	( t.Inits t.GoInfo t.Finals )
	( e.ModuleName )
	( Functions e.FnList ) =
		( t.Inits t.GoInfo t.Finals );
}

TypeStart {
	( t.InitFuncs () t.FinalFuncs ) t.FOut t.Aliases =
		<MError::LinkError 'Startfunction not found'>;

	( (e.InitFuncs) t.GoFunction (e.FinalFuncs) ) t.FOut t.Aliases =
		<TypeCallSeq
			t.FOut
			t.Aliases
			e.InitFuncs t.GoFunction e.FinalFuncs
		>;
}

TypeCallSeq {
	t.FOut t.Aliases e.FunList =
		<DoTypeCallSeq
			<TypeOpenBlock t.FOut>
			t.Aliases e.FunList
		>;
}

TypeOpenBlock {
	t.FOut = <FileIO::WriteLine <FileIO::WriteLine t.FOut> '$ENTRY Go { = '>;
}

DoTypeCallSeq {
	t.FOut t.Aliases (e.NextFunc) e.FunList =
		<DoTypeCallSeq
			<TypeOneCall t.FOut <LookupAlias t.Aliases e.NextFunc>>
			e.FunList
		>;

	t.FOut t.Aliases =
		<CloseAliases t.Aliases>
		<FileIO::Close <FileIO::WriteLine t.FOut ';}'>>;
}

TypeOneCall {
	t.FOut t.Aliases e.FnAlias =
		<FileIO::WriteLine t.FOut '\t<' e.FnAlias '>'>
		t.Aliases;
}

/*------------------------------------------------------------------------------
 Таблица псевдонимов для замены имён функций и индексов переменных на более
 короткие (для индексов переменных это не особо актуально, а вот для имён
 функций необходимо, т.к. Рефал-5 не переваривает строки длиннее 260 символов,
 а квалифицированные имена функций достаточно длинны).
 Формат таблицы псевдонимов ( (s.Num) (e.Name(e.Alias))* )
	s.Num -- номер, преписываемый следующему псевдониму,
	e.Name -- оригинальное имя (типа 'NextToken' или '.Context')
	e.Alias -- псевдоним (для функций 'Fnnn', для индексов '.innn').
 Поскольку все имена пользовательских функций оканчиваются на '--Local' и на
 '--Entry' (системные функции самого Рефала нужно явно прописывать в .rout-фай-
 лах), то их легко отличить от встроенных и не заменять их на псевдонимы.
------------------------------------------------------------------------------*/

NewAliasesTable {
	= ( (1 1 1 1) );
}

LookupAlias {
	( t.Num e.Aliases-B ( e.Name (e.Alias) ) e.Aliases-E )
	e.Name =
		( t.Num ( e.Name (e.Alias) ) e.Aliases-B e.Aliases-E )
		e.Alias;

	( t.Num e.Aliases ) e.Name =
		<LookupAlias
			( <NewAlias t.Num e.Name> e.Aliases )
			e.Name
		>;
}

NewAlias {
	/* Индекс */
	(s.ENum s.LNum s.INum s.SNum) '.' e.Name =
		(s.ENum s.LNum <Math::Inc s.INum> s.SNum)
		( '.' e.Name ( '.i' <MStrings::Symb s.INum> ) );

	/* Пользовательские имена функций */
	(s.ENum s.LNum s.INum s.SNum) e.Name '::Local' =
		(s.ENum <Math::Inc s.LNum> s.INum s.SNum)
		( e.Name '::Local' ( 'L' <MStrings::Symb s.LNum> ) );

	(s.ENum s.LNum s.INum s.SNum) e.Name '::Entry' =
		(<Math::Inc s.ENum> s.LNum s.INum s.SNum)
		( e.Name '::Entry' ( 'E' <MStrings::Symb s.ENum> ) );

	(s.ENum s.LNum s.INum s.SNum) e.Name '::Swap' =
		(s.ENum s.LNum s.INum <Math::Inc s.SNum>)
		( e.Name '::Swap' ( 'S' <MStrings::Symb s.SNum> ) );

	/* Пользовательские имена функций */
	(s.ENum s.LNum s.INum s.SNum) e.Name '--Local' =
		(s.ENum <Math::Inc s.LNum> s.INum s.SNum)
		( e.Name '--Local' ( 'L' <MStrings::Symb s.LNum> ) );

	(s.ENum s.LNum s.INum s.SNum) e.Name '--Entry' =
		(<Math::Inc s.ENum> s.LNum s.INum s.SNum)
		( e.Name '--Entry' ( 'E' <MStrings::Symb s.ENum> ) );

	/* Встроенные в язык функции */
	t.Num e.Name =
		t.Num ( e.Name (e.Name) );
}

OutAliases {
	( t.Num e.Aliases ) =
		( t.Num e.Aliases )
		<UserTypeAliases
			<FileIO::Open 'w' 'Info/Aliases.als'>
			<SortAliases e.Aliases>
		>;
}

SortAliases
	e.Aliases =
		<DoDecode <MOrder::Sort <DoCode e.Aliases>>>;

DoCode {
	t.Next e.Tail =
		<Code t.Next> <DoCode e.Tail>;

	= ;
}

Code {
	( e.Name ( '.i' e.Index ) ) = ( ('.i' <MStrings::Numb e.Index>) e.Name );

	( e.Name ( 'E' e.FnName ) ) = ( ('E' <MStrings::Numb e.FnName>) e.Name );

	( e.Name ( 'L' e.FnName ) ) = ( ('L' <MStrings::Numb e.FnName>) e.Name );

	( e.Name ( 'S' e.FnName ) ) = ( ('S' <MStrings::Numb e.FnName>) e.Name );

	// Builtin-функция
	( e.Name ( e.Builtin ) ) = ( ('B' e.Builtin) e.Name );
}

DoDecode {
	t.Next e.Tail =
		<Decode t.Next> <DoDecode e.Tail>;

	= ;
}

Decode {
	( ( 'E' s.FnAlias ) e.Name ) = ( e.Name ('E' <MStrings::Symb s.FnAlias>) );

	( ( 'L' s.FnAlias ) e.Name ) = ( e.Name ('L' <MStrings::Symb s.FnAlias>) );

	( ( 'S' s.FnAlias ) e.Name ) = ( e.Name ('S' <MStrings::Symb s.FnAlias>) );

	( ( '.i' s.IndAlias ) e.Name ) = ( e.Name ('.i' <MStrings::Symb s.IndAlias>) );

	( ( 'B' e.Builtin ) e.Name ) = ( e.Name (e.Builtin) );
}

UserTypeAliases {
	// Индексы не печатаем
	t.FAli ('.' e.Name (e.Alias)) e.Tail =
		<UserTypeAliases t.FAli e.Tail>;

	t.FAli (e.Name (e.Alias)) e.Tail =
		<UserTypeAliases
			<FileIO::WriteLine t.FAli e.Alias ' --> ' e.Name>
			e.Tail
		>;

	t.FAli =
		<FileIO::Close t.FAli>;
}

CloseAliases {
	( (s.ENum s.LNum s.INum s.SNum) e.Aliases ) = ;
}

$END Linker.
