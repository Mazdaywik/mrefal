*$FROM Context
$EXTERN GetProgName, ExtractModulesList, ExtractOption;

*$FROM FileIO
$EXTERN FOpen, FReadLine, FWriteLine, FClose;

*$FROM Error
$EXTERN Error;

*$FROM Modules
$EXTERN OutName;

$ENTRY Link {
	t.Context =
		<RealLink
			<GetProgName t.Context>
		>;
}

Nil { e.Arg = ; }

RealLink {
	t.Context e.ProgName =
		<PutStartCaller
			<PutModules
				<FOpen 'w' e.ProgName '.ref'>
				<NewAliasesTable>
				<NewStartInfo>
				<ExtractModulesList t.Context>
			>
		> <Nil <System 'refc ' e.ProgName '.ref'>>;
}

PutModules {
	t.FOut t.Aliases t.StartInfo t.Context
	(e.NextName) e.Tail =
		<PutModules
			<PutModule
				t.FOut t.Aliases t.StartInfo t.Context
				(e.NextName)
			>
			e.Tail
		>;

	t.FOut t.Aliases t.StartInfo t.Context =
		t.FOut t.Aliases t.StartInfo t.Context
}

PutModule {
	t.FOut t.Aliases t.StartInfo t.Context (e.ModuleName) =
		<TypeContent
			t.FOut
			t.Aliases
			<FOpen 'r' <OutName e.ModuleName>>
		> <UpdateStartInfo
			t.StartInfo
			t.Context
			e.ModuleName
		>;
}

PutStartCaller {
	t.FOut t.Aliases t.StartInfo t.Context =
		t.Context
		<TypeStart
			t.StartInfo
			t.FOut
			<OutAliases t.Aliases>
		>;
}

/*------------------------------------------------------------------------------
 Построчное препроцессирование .rout-файлов с их добавлением в выходной файл.

 Последующие Type-функции выполняют построчное препроцессирование .rout-файлов.
 Поскольку содержимое этих файлов сгенерировано автоматически, то можно ожидать,
 что вызовы функций и переменные написаны одноформатно, а вручную создаваемые
 библиотечные файлы написаны с особым вниманием.
------------------------------------------------------------------------------*/

TypeContent {
	t.FOut t.Aliases t.FIn =
		<DoTypeContent
			t.Aliases (<DefLim> t.FOut) ( <FReadLine t.FIn> )
		>;
}

Dec {
	Limit = Limit;
	0 = Limit;
	1 = Limit;
	s.Num = <Sub s.Num 1>;
}

DefLim { = 65; }

DoTypeContent {
	t.Aliases (s.Size t.FOut e.Converted) (t.FIn) =
		<DoTypeContent
			t.Aliases
			( <DefLim> <FWriteLine t.FOut e.Converted> )
			( <HideQuotes <FReadLine t.FIn>> )
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn 0) =
		<FWriteLine t.FOut e.Converted> t.Aliases <FClose t.FIn>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		<DoTypeContent
			<SwTypeContent
				t.Aliases
				(s.Size t.FOut e.Converted)
				(t.FIn e.Raw)
			>
		>;
}

HideQuotes {
	t.FIn e.Line =
		t.FIn <DoHideQuotes e.Line>;
}

DoHideQuotes {
	'\'' e.Tail = <StartHidingQuote ('\'') e.Tail>;
	'\"' e.Tail = <StartHidingQuote ('\"') e.Tail>;
	s.Other e.Tail = s.Other <DoHideQuotes e.Tail>;
	= ;
}

StartHidingQuote {
	(s.Quote e.Hidden) '\\' s.Escaped e.Tail =
		<StartHidingQuote (s.Quote e.Hidden '\\' s.Escaped) e.Tail>;

	(s.Quote e.Hidden) s.Quote e.Tail =
		(s.Quote e.Hidden) <DoHideQuotes e.Tail>;

	(s.Quote e.Hidden) s.Other e.Tail =
		<StartHidingQuote (s.Quote e.Hidden s.Other) e.Tail>;

	(s.Quote e.Hidden) =
		<Error
			'L' 'May be unballanced quote in StartHidingQoute'
		>;
}

SwTypeContent {
	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '\t' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted) (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted)
	(t.FIn (s.Quote e.HiddenQuote) e.Raw) =
		t.Aliases
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted s.Quote)
			(s.Quote e.HiddenQuote)
		> (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut) (t.FIn e.FnName ' {' e.Raw) =
		<TypeFnHeader
			<LookupAliase t.Aliases e.FnName>
			(s.Size t.FOut)
			(t.FIn e.Raw)
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '.' e.Index ' ' e.Raw) =
		<TypeIndex
			<LookupAliase t.Aliases '.' e.Index>
			(<Dec s.Size> t.FOut e.Converted)
			(t.FIn ' ' e.Raw)
		>;

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn '<' e.FnName ' ' e.Raw) =
		<TypeFnCall
			<LookupAliase t.Aliases e.FnName>
			(<Dec s.Size> t.FOut e.Converted)
			(t.FIn ' ' e.Raw)
		>;

	t.Aliases (Limit t.FOut e.Converted) (t.FIn ' ' e.Raw) =
		t.Aliases
		( <DefLim> <FWriteLine t.FOut e.Converted> )
		(t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' =' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted '=') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' <' e.Raw) =
		t.Aliases (s.Size t.FOut e.Converted) (t.FIn '<' e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' ;' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted ';') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn ' (' e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted '(') (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn s.Other e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted s.Other) (t.FIn e.Raw);

	t.Aliases (s.Size t.FOut e.Converted) (t.FIn s.Other e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.Converted s.Other) (t.FIn e.Raw);
}

TypeFnHeader {
	t.Aliases e.FnAliase (s.Size t.FOut) (t.FIn e.Raw) =
		t.Aliases (<Dec s.Size> t.FOut e.FnAliase ' {') (t.FIn e.Raw);
}

TypeIndex {
	t.Aliases e.IndexAliase (Limit t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <DefLim> <FWriteLine t.FOut e.Converted e.IndexAliase> )
		(t.FIn e.Raw);

	t.Aliases e.IndexAliase (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <Dec s.Size> t.FOut e.Converted e.IndexAliase)
		(t.FIn e.Raw);
}

TypeFnCall {
	t.Aliases e.FnAliase (Limit t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		( <DefLim> <FWriteLine t.FOut e.Converted '<' e.FnAliase> )
		(t.FIn e.Raw);

	t.Aliases e.FnAliase (s.Size t.FOut e.Converted) (t.FIn e.Raw) =
		t.Aliases
		(<Dec s.Size> t.FOut e.Converted '<' e.FnAliase)
		(t.FIn e.Raw);
}

TypeQuoted {
	/* Не рассматриваем символ за бэкслешем, а сразу же его переносим */
	(s.Size t.FOut e.Converted) (s.Quote '\\' s.Escaped e.Tail) =
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted '\\' s.Escaped)
			(s.Quote e.Tail)
		>;
	/* Извращаемся, чтобы разрезать текст в кавычках и не оставить на
	отдельной строке '' или "" */
	(Limit t.FOut e.Converted '\\' s.Quote) (s.Quote) =
		( <DefLim> <FWriteLine t.FOut e.Converted '\\' s.Quote s.Quote> );

	(Limit t.FOut e.Converted '\\' s.Quote) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim>
				<FWriteLine t.FOut e.Converted '\\' s.Quote s.Quote>
				s.Quote
			) (s.Quote e.Tail)
		>;

	(Limit t.FOut e.Converted s.Quote) (s.Quote) =
		<Error
			'L' 'Unexpected quote position ??? `' e.Converted s.Quote '`'
		>;

	(Limit t.FOut e.Converted s.Quote) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim> <FWriteLine t.FOut e.Converted> s.Quote)
			(s.Quote e.Tail)
		>;

	(Limit t.FOut e.Converted) (s.Quote) =
		(<DefLim> <FWriteLine t.FOut e.Converted s.Quote>);

	(Limit t.FOut e.Converted) (s.Quote e.Tail) =
		<TypeQuoted
			(<DefLim> <FWriteLine t.FOut e.Converted s.Quote> s.Quote)
			(s.Quote e.Tail)
		>;

	(s.Size t.FOut e.Converted) (s.Quote) =
		(<Dec s.Size> t.FOut e.Converted s.Quote ' ');

	(s.Size t.FOut e.Converted) (s.Quote s.Other e.Tail) =
		<TypeQuoted
			(<Dec s.Size> t.FOut e.Converted s.Other)
			(s.Quote e.Tail)
		>;
}

*-------------------------------------------------------------------------------
* Хранилще информации о точках запуска модулей (функций Go и Init)
*-------------------------------------------------------------------------------

NewStartInfo {
	= ( (/* InitList */) (/* Go */) );
}

UpdateStartInfo {
	t.StartInfo t.Context e.ModuleName =
		<UpdateInitList
			t.StartInfo
			(e.ModuleName)
			<ExtractOption t.Context InitPoint e.ModuleName>
		>;
}

UpdateInitList {
	t.StartInfo ( e.ModuleName ) t.Context Found None =
		<UpdateGoInfo
			t.StartInfo
			<ExtractOption t.Context StartPoint e.ModuleName>
		>;

	( (e.Inits) t.GoInfo )
	( e.ModuleName )
	t.Context Found e.InitName =
		<UpdateGoInfo
			( (e.Inits (e.InitName)) t.GoInfo )
			<ExtractOption t.Context StartPoint e.ModuleName>
		>;
}

UpdateGoInfo {
	t.StartInfo t.Context Found None =
		t.StartInfo t.Context;

	( t.Inits () ) t.Context Found e.GoName =
		( t.Inits (e.GoName) ) t.Context;

	( t.Inits (e.OtherGo) ) t.Context Found e.GoName =
		<Error
			'L' 'Found two startfunctions: '
			e.OtherGo ' and ' e.GoName
		>;
}

TypeStart {
	( t.InitFuncs () ) t.FOut t.Aliases =
		<Error
			'L' 'Startfunction not found'
		>;

	( ( e.InitFuncs ) t.GoFunction ) t.FOut t.Aliases =
		<TypeCallSeq
			t.FOut
			t.Aliases
			e.InitFuncs t.GoFunction
		>;
}

TypeCallSeq {
	t.FOut t.Aliases e.FunList =
		<DoTypeCallSeq
			<TypeOpenBlock t.FOut>
			t.Aliases e.FunList
		>;
}

TypeOpenBlock {
	t.FOut = <FWriteLine <FWriteLine t.FOut> '$ENTRY Go { = '>;
}

DoTypeCallSeq {
	t.FOut t.Aliases (e.NextFunc) e.FunList =
		<DoTypeCallSeq
			<TypeOneCall t.FOut <LookupAliase t.Aliases e.NextFunc>>
			e.FunList
		>;

	t.FOut t.Aliases =
		<CloseAliases t.Aliases>
		<FClose <FWriteLine t.FOut ';}'>>;
}

TypeOneCall {
	t.FOut t.Aliases e.FnAliase =
		<FWriteLine t.FOut '\t<' e.FnAliase '>'>
		t.Aliases;
}

/*------------------------------------------------------------------------------
 Таблица псевдонимов для замены имён функций и индексов переменных на более
 короткие (для индексов переменных это не особо актуально, а вот для имён
 функций необходимо, т.к. Рефал-5 не переваривает строки длиннее 260 символов,
 а квалифицированные имена функций достаточно длинны).
 Формат таблицы псевдонимов ( (s.Num) (e.Name(e.Aliase))* )
	s.Num -- номер, преписываемый следующему псевдониму,
	e.Name -- оригинальное имя (типа 'NextToken' или '.Context')
	e.Alias -- псевдоним (для функций 'Fnnn', для индексов '.innn').
 Поскольку все имена пользовательских функций оканчиваются на '--Local' и на
 '--Entry' (системные функции самого Рефала нужно явно прописывать в .rout-фай-
 лах), то их легко отличить от встроенных и не заменять их на псевдонимы.
------------------------------------------------------------------------------*/

NewAliasesTable {
	= ( (1) );
}

QGuard {
	e.Begin '\'' e.End =
		<Error
			'L' 'Quote in function name: `' e.Begin '\'' e.End '`'
		>;

	e.Begin '\"' e.End =
		<Error
			'L' 'Double quote in function name: `' e.Begin '\"' e.End '`'
		>;
	e.Other = e.Other;
}

LookupAliase {
	t.Table e.Name = <LookupAliase1 t.Table <QGuard e.Name>>;
}

LookupAliase1 {
	( (s.Num) e.Aliases-B ( e.Name (e.Aliase) ) e.Aliases-E )
	e.Name =
		( (s.Num) ( e.Name (e.Aliase) ) e.Aliases-B e.Aliases-E )
		e.Aliase;

	( (s.Num) e.Aliases ) e.Name =
		<LookupAliase
			( (<Add s.Num 1>)
				<NewAliase s.Num e.Name> e.Aliases
			) e.Name
		>;
}

NewAliase {
	/* Индекс */
	s.Num '.' e.Name =
		( '.' e.Name ( '.i' <Symb s.Num> ) );

	/* Пользовательские имена функций */
	s.Num e.Name '--Local' =
		( e.Name '--Local' ( 'F' <Symb s.Num> ) );

	s.Num e.Name '--Entry' =
		( e.Name '--Entry' ( 'F' <Symb s.Num> ) );

	/* Встроенные в язык функции */
	s.Num e.Name =
		( e.Name (e.Name) );
}

OutAliases {
	( t.Num e.Aliases ) =
		( t.Num e.Aliases )
		<UserTypeAliases
			<FOpen 'w' 'Aliases.als'> e.Aliases
		>;
}

UserTypeAliases {
	t.FAli (e.Name (e.Aliase)) e.Tail =
		<UserTypeAliases
			<FWriteLine t.FAli e.Aliase ' --> ' e.Name>
			e.Tail
		>;

	t.FAli =
		<FClose t.FAli>;
}

CloseAliases {
	( (s.Num) e.Aliases ) = ;
}