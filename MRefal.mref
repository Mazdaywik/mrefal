$PROGRAM MRefal;

// Эти модули используются
$IMPORT Compiler;
$IMPORT MContext;
$IMPORT MError;
$IMPORT InOut;
$IMPORT MLambda;
$IMPORT MLinker;
$IMPORT Modules;
$IMPORT MModules;
$IMPORT MOS;
$IMPORT Math;
$IMPORT MQualifiedName;
$IMPORT MQualifiedSupport;
$IMPORT MStrings;
$IMPORT MVersion;

$IMPORT MSelfDiag;

// Эти модули должны быть инициализированы
$IMPORT MBackEnd_Refal5_init;
$IMPORT MFrontEnd_MRefal;

$ENTRY Go =
  <MVersion::Show>
  <CompileList <MContext::Create> <LoadModuleList> >;

Results {
  t.Context Success =
    <MContext::Destroy t.Context>;

  t.Context Fails =
    <MContext::Destroy t.Context>
    <MError::Fatal 'Unknown error'>;
}

LoadModuleList
  = <SwLoadModuleList <MOS::ArgList>>;

SwLoadModuleList {
  (e.ProgName) =
    <MError::Fatal 'Command line error: use MRefal module1 module2 ...'>;

  (e.ProgName) e.Modules = e.Modules;
}

ModuleOrFile
  (e.Module) =
    <SwModuleOrFile (<MStrings::Lower e.Module>) e.Module>;

SwModuleOrFile {
  ( e.FnameName '.mref' ) e.FnameNameExtCase s.Dot s.M s.R s.E s.F =
    (Module e.FnameNameExtCase);

  ( e.ModNameLower ) e.ModNameCase =
    (Module <Modules::CanonicalModuleName e.ModNameCase>);
}

PrepareMP
  e.ModulePath =
    <DeleteEmpty
      <DoPrepareMP e.ModulePath>
    >;

DoPrepareMP {
  e.Part ';' e.Tail = (e.Part) <DoPrepareMP e.Tail>;

  e.Part = (e.Part);
}

DeleteEmpty {
  e.Begin () e.End = e.Begin <DeleteEmpty e.End>;

  e.NotEmpty = e.NotEmpty;
}

CompileList {
  t.hContext ('+new+') (e.ModulePath) e.Modules =
    <CheckFoundResult
      <MLambda::MapReduce
        <MLambda::Composite
          & MLambda.UnBracket-H
          <MLambda::Parallel-H
            & MLambda.Bracket-H
            <MLambda::BindLeft-H
              & MModules.LookupCmdLineModule
              (<PrepareMP e.ModulePath>)
            >
          >
          & MLambda.Bracket-H
        >
        t.hContext
        e.Modules
      >
    >;

  t.hContext ('+old+') e.Modules =
    <Results
      <MLinker::LinkAll
        <CompileModulesFromList
          t.hContext
          <MLambda::Map & ModuleOrFile e.Modules>
        >
      >
    >;

  t.hContext e.Modules =
    <CompileList t.hContext ('+old+') e.Modules>;
}

CheckFoundResult {
  t.hContext e.Results-B ( (e.Module) NotFound ) e.Results-E =
    <MContext::Destroy t.hContext>
    <MLambda::Map
      & PrintNotFound
      e.Results-B ( (e.Module) NotFound ) e.Results-E
    >;

  t.hContext e.ResultsFound =
    <MLambda::TerminateAccumulator
      & FinishMake
      <MLambda::Reduce
        (Success t.hContext <MError::CreateErrList>)
        & Make
        e.ResultsFound
      >
    >;
}

PrintNotFound {
  ( (e.Module) NotFound ) =
    <InOut::WriteLine
      'CMDLINE ERROR: module ' e.Module ' not found'
    >;

  ( (e.Module) Found t.QualifiedName s.FrontEnd e.BaseDirectory ) =
    <InOut::WriteLine
      'FOUND: ' e.Module ' '
      <MQualifiedName::Parse t.QualifiedName>
      ' ' s.FrontEnd ' ' e.BaseDirectory
    >;
}

Make {
  (Success t.hContext t.hErrorList)
  ( (e.Module) Found t.QualifiedName s.FrontEnd e.BaseDirectory ) =
    <InOut::WriteLine
      'MAKE: ' e.Module '('
      <MQualifiedName::Parse t.QualifiedName>
      ' ' s.FrontEnd ' ' e.BaseDirectory ')'
    >
    (Success t.hContext t.hErrorList);

  (Fails t.hContext t.hErrorList)
  ( (e.Module) Found t.QualifiedName s.FrontEnd e.BaseDirectory ) =
    (Fails t.hContext t.hErrorList);
}

FinishMake {
  ( Success t.hContext t.hErrorList ) =
    <MContext::Destroy t.hContext>
    <MError::PrintErrorsAndStop t.hErrorList>;

  ( Fails t.hContext t.hErrorList ) =
    <MContext::Destroy t.hContext>
    <MError::PrintErrorsAndStop t.hErrorList>;
}

CompileModulesFromList {
  t.Context (Module e.ModName) e.Modules =
    <CompileModulesFromList
      <Compiler::CompileByModuleName t.Context e.ModName> e.Modules
    >;

  t.Context =
    t.Context;
}

$END MRefal.
