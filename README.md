# Компилятор Модульного Рефала
Модульный Рефал — ещё один диалект Рефала. Отличается от других диалектов системой модулей
в духе Оберона, возможностью расширения внешними функциями на C++ и временной неразвитостью
выразительных возможностей :-).

# Цели проекта
Цели написаны в произвольном порядке. Каждую цель сопровождает список решений дизайна,
проистекающих из неё.

1. **Язык Рефал — язык символьных вычислений.** Язык должен продолжать классическую линейку
   реализаций Рефала, языка основанном на конкатенации цепочек, сопоставлении с образцом и семантике
   поля зрения. Но при этом язык должен быть не менее выразительным, чем другие диалекты. Следствия:
   * на текущем этапе используется классическое списковое представление данных, в дальнейшем
     планируется использование других представлений, допускающих эффективную конкатенацию и семантику
     поля зрения,
   * используется синтаксис, схожий с синтаксисом РЕФАЛа-5,
   * указатели на глобальные функции, планируется реализация и вложенных функций,
   * планируется синтаксис, подобный Refal-7, но явно выделяющий функции, генерирующие неуспехи
     и недетерминированные/с побочными эффектами.
2. **Максимум контроля на наиболее ранней стадии:**
   * разрешение импортируемых функций на стадии компиляции — исключение ошибок компоновки типа
     «unresolved external reference»,
   * абстрактные типы данных = именованные скобки — реализуют инкапсуляцию данных на уровне
     модулей,
   * множество идентификаторов фиксируется на момент компиляции — отсутствие функций типа `Implode`
     РЕФАЛа-5,
   * указатели на функции вместо функции `Mu` РЕФАЛа-5.
3. **Наличие FFI с другими языками программирования:**
   * компиляция в язык C++ (напрямую и косвенно через Простой Рефал), благодаря чему можно написать
     внешние функции на целевом языке и подключить при компоновке.
4. **Эффективность** — компилятор должен выполняться и его разработка должна вестись относительно
   комфортно даже на древних машинах (например, Pentium I):
   * компиляция в язык C++ вместо интерпретации RASL’а,
   * система модулей, потенциально позволяющая на стадии компиляции иметь информацию
     об импортируемых модулях, дабы использовать её при оптимизации (например, могут появиться
     форматы функций),
   * оптимизации (они сейчас ведутся в родственном проекте — [Простом Рефале][1]
   Надо признать, что эта цель пока далека от достижения.
5. **Модульная архитектура:**
   * архитектура компилятора допускает использование нескольких различных back-end’ов
     и front-end’ов,
   * сейчас уже реализованы 3 разных back-end’а (в РЕФАЛ-5, в Простой Рефал и в C++, использующий
     Простой Рефал),
   * в библиотеке заложена (пока не реализованная) возможность переносимости на другие платформы.
6. **Переносимость** — пока не реализована.

Приоритета среди целей нет, если цели противоречат друг другу, конфликт разрешается ситуативно.

[1]: https://github.com/bmstu-iu9/simple-refal