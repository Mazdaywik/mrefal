$MODULE BE-CppSR::Generator;

$IMPORT Math = MMath;
$IMPORT MEscape;
$IMPORT MLambda;
$IMPORT MStrings;
$IMPORT MQualifiedName;

QNameCode {
  t.Name = <DoQNameCode <MQualifiedName::Parse t.Name>>;
}

DoQNameCode {
  (e.First) = <NameCode e.First>;

  (e.First) (e.Second) =
    <NameCode e.First> 'P_' <NameCode e.Second>;

  (e.First) (e.Second) e.Tail =
    <NameCode e.First> 'P_' <DoQNameCode (e.Second) e.Tail>;
}

NameCode {
  e.Name = <MLambda::Map & NameCodeChar e.Name>;
}

NameCodeChar {
  '!' = 'B_';
  '?' = 'Q_';
  '_' = 'U_';
  '-' = 'D_';
  Entry = 'E_';
  FuncName = 'N_';
  Go = 'Entry_Go';
  s.Other = s.Other;
}

FuncArguments {
  = 'refalrts::Iter arg_begin, refalrts::Iter arg_end';
}

NakedArguments {
  = 'refalrts::Iter, refalrts::Iter';
}

TextFromMemoryClass {
  Local = 'static '; Entry = ; InitFinal = ;
}

SwGenFnStart {
  s.MemoryClass s.FnArguments t.Name =
    (
      <TextFromMemoryClass s.MemoryClass>
      'refalrts::FnResult '
      <QNameCode t.Name>
      '(' <s.FnArguments> ') {'
    )
    ('  refalrts::this_is_generated_function();');
}

$ENTRY GenInitCounter {
  InitFinal =
    ('  static unsigned s_counter = 0;')
    ('  refalrts::use_counter(s_counter);');

  s.Other = ;
}

$ENTRY GenFnStart {
  s.MemoryClass t.Name =
    <SwGenFnStart s.MemoryClass & FuncArguments t.Name>;
}

$ENTRY GenFnEnd {
  = ('  return refalrts::cRecognitionImpossible;') ('}') ();
}

$ENTRY GenEEnum {
  t.Name = <SwGenFnStart Entry & NakedArguments t.Name> <GenFnEnd>;
}

$ENTRY GenEnum {
  t.Name = <SwGenFnStart Local & NakedArguments t.Name> <GenFnEnd>;
}

$ENTRY GenExtern {
  t.Name =
    (
      'extern refalrts::FnResult '
      <QNameCode t.Name>
      '(' <FuncArguments> ');'
    )
    ();
}

$ENTRY GenForward {
  t.Name =
    (
      'static refalrts::FnResult '
      <QNameCode t.Name>
      '(' <FuncArguments> ');'
    )
    ();
}

//$ENTRY GenESwap {
//  t.Name = <GenSwap-Aux Entry t.Name>;
//}

$ENTRY GenSwap {
  t.Name = <GenSwap-Aux Local t.Name>;
}

GenSwap-Aux {
  s.MemoryClass t.Name =
    <GenFnStart s.MemoryClass t.Name>
    ('  refalrts::Iter func_name = arg_begin;')
    ()
    ('  refalrts::move_left( func_name, arg_end );')
    ()
    ('  refalrts::Iter info_b = func_name;')
    ('  refalrts::Iter info_e = arg_end;')
    ()
    ('  refalrts::move_left( info_b, info_e );')
    ('  refalrts::move_right( info_b, info_e );')
    ()
    (
      '  static refalrts::Iter s_head = '
      'refalrts::initialize_swap_head( func_name );'
    )
    ()
    ('  refalrts::Iter saved_b;')
    ('  refalrts::Iter saved_e;')
    ()
    ('  refalrts::swap_info_bounds( saved_b, saved_e, s_head );')
    ('  refalrts::splice_evar( arg_begin, saved_b, saved_e );')
    ('  refalrts::swap_save( s_head, info_b, info_e );')
    ('  refalrts::splice_to_freelist( arg_begin, arg_end );')
    ()
    ('  return refalrts::cSuccess;')
    ('}')
    ();
}

$ENTRY GenIdent {
  t.Name =
    <GenIdent-Aux
      (<MQualifiedName::ToPrintable-Dot t.Name>)
      <QNameCode t.Name>
    >;
}

$ENTRY GenIdent-FuncName {
  t.Name =
    <GenIdent-Aux
      (<MQualifiedName::ToPrintable-Dot t.Name>)
      <QNameCode t.Name> 'N_'
    >;
}

GenIdent-Aux {
  (e.ExternalName) e.InternalName =
    ('#ifndef ' e.InternalName 'DEFINED_R_')
    ('#define ' e.InternalName 'DEFINED_R_')
    ()
    ('//$LABEL ' e.ExternalName)
    ('template <typename refal_param_int>')
    ('struct ' e.InternalName ' {')
    ('  static const char *name() {')
    ('    return "' e.ExternalName '";')
    ('  }')
    ('};')
    ()
    ('#endif // ' e.InternalName 'DEFINED_R_')
    ();
}

$ENTRY GenCommonHeaders {
  = ('// Automatically generated file. Don\'t edit!')
  ('#include "refalrts.h"') () ();
}


$ENTRY GenSentence {
  e.Algorithm =
    <GenSentence-TerminateAccumulator
      <MLambda::MapReduce
        & GenCommand
        (('  ' /* fused indent */) (/* evar indent */))
        e.Algorithm
      >
    >;
}

GenSentence-TerminateAccumulator {
  ((e.FusedIndent) (e.EvarIndent)) e.Generated =
    e.Generated;
}

BracketsVar-B {
  s.BracketNum s.Nested =
    'bb_' <MStrings::Symb s.BracketNum> '_' <MStrings::Symb s.Nested>;
}

BracketsVar-E {
  s.BracketNum s.Nested =
    'be_' <MStrings::Symb s.BracketNum> '_' <MStrings::Symb s.Nested>;
}

BracketsVar-OE {
  s.BracketNum s.Nested =
    'boe_' <MStrings::Symb s.BracketNum> '_' <MStrings::Symb s.Nested>;
}

/*
  Величина отступа также определяет режим работы. Отступ в 4 пробела --
  вне цикла по открытой e-переменной, отступ больше -- внутри оного
  цикла.
*/

PrintStkBracket {
  e.Indent (s.StkBracket s.Nested) =
    (e.Indent
      'refalrts::Iter '
      <BracketsVar-B s.StkBracket <Math::Inc s.Nested>> ' = '
      <BracketsVar-B s.StkBracket s.Nested> ';'
    )
    (e.Indent
      'refalrts::Iter '
      <BracketsVar-E s.StkBracket <Math::Inc s.Nested>> ' = '
      <BracketsVar-E s.StkBracket s.Nested> ';'
    );
}

Indent
  ((e.FusedIndent) (e.EvarIndent)) = e.FusedIndent e.EvarIndent;

GenCommand {
  t.Indent (CmdStartSentence) =
    <IncrementFusedIndent t.Indent>
    (<Indent t.Indent> 'do {')
    (
      <Indent t.Indent> '  refalrts::Iter '
      <BracketsVar-B 0 0> ' = arg_begin;'
    )
    (
      <Indent t.Indent> '  refalrts::Iter '
      <BracketsVar-E 0 0> ' = arg_end;'
    )
    (
      <Indent t.Indent> '  refalrts::move_left( '
      <BracketsVar-B 0 0> ', ' <BracketsVar-E 0 0> ' );'
    )
    (
      <Indent t.Indent> '  refalrts::move_left( '
      <BracketsVar-B 0 0> ', ' <BracketsVar-E 0 0> ' );'
    )
    (
      <Indent t.Indent> '  refalrts::move_right( '
      <BracketsVar-B 0 0> ', ' <BracketsVar-E 0 0> ' );'
    );

  t.Indent (CmdComment e.Text) =
    t.Indent (<Indent t.Indent> '//' e.Text);

  t.Indent (CmdDeclareEVar e.VarInfo) =
    t.Indent
    (<Indent t.Indent> 'refalrts::Iter ' <PrintEVar-B e.VarInfo> ';')
    (<Indent t.Indent> 'refalrts::Iter ' <PrintEVar-E e.VarInfo> ';');

  t.Indent (CmdDeclareVar e.VarInfo) =
    t.Indent
    (<Indent t.Indent> 'refalrts::Iter ' <PrintVar e.VarInfo> ';');

  t.Indent (CmdChar s.Direction s.BracketNum s.Nested s.Char) =
    t.Indent
    <PrintMatchChar t.Indent s.Direction s.BracketNum s.Nested s.Char>;

  t.Indent (CmdNumber s.Direction s.BracketNum s.Nested s.Number) =
    t.Indent
    <PrintMatchNumber
      t.Indent s.Direction s.BracketNum s.Nested s.Number
    >;

  t.Indent (CmdName s.Direction s.BracketNum s.Nested t.Name) =
    t.Indent
    <PrintMatchName t.Indent s.Direction s.BracketNum s.Nested t.Name>;

  t.Indent (CmdIdent s.Direction s.BracketNum s.Nested t.Name) =
    t.Indent
    <PrintMatchIdent
      t.Indent s.Direction s.BracketNum s.Nested t.Name
    >;

  t.Indent
  (CmdBrackets s.Direction s.BracketNum s.Nested s.InnerBrackets) =
    t.Indent
    (
      <Indent t.Indent> 'refalrts::Iter '
      <BracketsVar-B s.InnerBrackets 0> ' = 0;'
    )
    (
      <Indent t.Indent> 'refalrts::Iter '
      <BracketsVar-E s.InnerBrackets 0> ' = 0;'
    )
    <PrintMatchBrackets
      t.Indent s.Direction s.BracketNum s.Nested s.InnerBrackets
    >;

  t.Indent
  (CmdADT s.Direction s.BracketNum s.Nested s.InnerBrackets e.Name) =
    t.Indent
    (
      <Indent t.Indent> 'refalrts::Iter '
      <BracketsVar-B s.InnerBrackets 0> ' = 0;'
    )
    (
      <Indent t.Indent> 'refalrts::Iter '
      <BracketsVar-E s.InnerBrackets 0> ' = 0;'
    )
    <PrintMatchADT
      t.Indent s.Direction s.BracketNum s.Nested s.InnerBrackets e.Name
    >;

  t.Indent (CmdEmpty s.BracketNum s.Nested) =
    t.Indent
    <PrintMatchEmpty t.Indent s.BracketNum s.Nested>;

  t.Indent (CmdVar s.Direction s.BracketNum s.Nested s.Mode e.Info) =
    t.Indent
    <PrintMatchSTVar
      t.Indent s.Direction s.BracketNum s.Nested s.Mode e.Info
    >;

  t.Indent (CmdRepeated s.Direction s.BracketNum s.Nested e.VarInfo) =
    t.Indent
    <PrintMatchRepeated
      t.Indent s.Direction s.BracketNum s.Nested e.VarInfo
    >;

  t.Indent (CmdClosedE AlgLeft s.BracketNum s.Nested 'e' e.Index) =
    t.Indent
    (<Indent t.Indent>
      <PrintEVar-B 1 'e' e.Index> ' = '
      <BracketsVar-B s.BracketNum s.Nested> ';'
    )
    (
      <Indent t.Indent>
      'refalrts::use( ' <PrintEVar-B 1 'e' e.Index> ' );'
    )
    (<Indent t.Indent>
      <PrintEVar-E 1 'e' e.Index> ' = '
      <BracketsVar-E s.BracketNum s.Nested> ';'
    )
    (
      <Indent t.Indent>
      'refalrts::use( ' <PrintEVar-E 1 'e' e.Index> ' );'
    );

  t.Indent
  (CmdOpenedE
    AlgLeft s.BracketNum s.Nested 'e' e.Index (e.BracketsForSave)
  ) =
    <IncrementEvarIndent t.Indent>
    (<Indent t.Indent> 'for(')
    (<Indent t.Indent>
      '  refalrts::Iter ' <BracketsVar-OE s.BracketNum s.Nested>
      ' = ' <BracketsVar-B s.BracketNum s.Nested> ';'
    )
    (<Indent t.Indent> '  '
      '! refalrts::empty_seq( ' <BracketsVar-OE s.BracketNum s.Nested> ', '
      <BracketsVar-E s.BracketNum s.Nested> ' );'
    )
    (<Indent t.Indent> '  '
      'refalrts::next_term( ' <BracketsVar-OE s.BracketNum s.Nested> ', '
      <BracketsVar-E s.BracketNum s.Nested> ' )'
    )
    (<Indent t.Indent> ') {')
    /*
      Объявление и инициализация "внутренних" переменных для цикла.
      Эти переменные (с индексом вложенности на единицу бОльшим)
      используются внутри цикла как границы распознавания подвыражений.
      Поскольку при неудачном сопоставлении в рамках заданной итерации
      нужно попробовать следующий вариант сопоставления, т.е. необходимо
      восстановить предыдущее до сопоставления, мы создаём копию
      состояния, с которой и работаем в рамках итерации.
    */
    <MLambda::Map
      <MLambda::BindLeft
        & PrintStkBracket <Indent t.Indent> '  '
      >
      e.BracketsForSave
    >
    (<Indent t.Indent> '  '
      <BracketsVar-B s.BracketNum <Math::Inc s.Nested>>
      ' = ' <BracketsVar-OE s.BracketNum s.Nested> ';'
    )
    (<Indent t.Indent> '  '
      <PrintEVar-B 1 'e' e.Index> ' = '
      <BracketsVar-B s.BracketNum s.Nested> ';'
    )
    (<Indent t.Indent> '  '
      <PrintEVar-E 1 'e' e.Index> ' = '
      <BracketsVar-OE s.BracketNum s.Nested> ';'
    )
    (<Indent t.Indent>
      '  refalrts::move_right( ' <PrintEVar-B 1 'e' e.Index> ', '
      <PrintEVar-E 1 'e' e.Index> ' );'
    );

  t.Indent (CmdEmptyResult) =
    t.Indent
    ()
    (<Indent t.Indent> 'refalrts::reset_allocator();');

  t.Indent (CmdCopyVar s.ElemNumber s.Mode e.Index) =
    t.Indent
    <PrintAllocateCopyVar t.Indent s.ElemNumber s.Mode e.Index>;

  t.Indent (CmdAllocateElem s.ElemNumber e.ElemInfo) =
    t.Indent
    (
      <Indent t.Indent>
      'refalrts::Iter ' <PrintElemVar s.ElemNumber> ' = 0;'
    )
    <PrintAllocateElem t.Indent s.ElemNumber e.ElemInfo>;

  t.Indent
  (CmdAllocateString s.BeginNumber s.EndNumber s.Len e.String) =
    t.Indent
    (
      <Indent t.Indent>
      'refalrts::Iter ' <PrintElemVar s.BeginNumber> ' = 0;'
    )
    (
      <Indent t.Indent>
      'refalrts::Iter ' <PrintElemVar s.EndNumber> ' = 0;'
    )
    (<Indent t.Indent> 'if( ! refalrts::alloc_chars( '
      <PrintElemVar s.BeginNumber> ', ' <PrintElemVar s.EndNumber> ', '
      '\"' <MLambda::Map & MEscape.EscapeChar-Oct e.String> '\", '
      <MStrings::Symb s.Len> ' ) )'
    )
    (<Indent t.Indent> '  return refalrts::cNoMemory;');

  t.Indent (CmdCorrectAllocCopyEVar s.ElemNumber s.AltPrev) =
    t.Indent
    (<Indent t.Indent>
      'if ( ' <PrintElemVar s.ElemNumber> ' == 0 )'
      ' ' <PrintElemVar s.ElemNumber> ' ='
      ' ' <PrintPrev s.AltPrev> '; // CORRECT'
    );

  t.Indent (CmdLinkBrackets s.Left s.Right) =
    t.Indent
    (<Indent t.Indent>
      'refalrts::link_brackets( '
      <PrintElemVar s.Left> ', ' <PrintElemVar s.Right>
      ' );'
    );

  t.Indent (CmdPushStack s.ElemNumber) =
    t.Indent
    (
      <Indent t.Indent>
      'refalrts::push_stack( ' <PrintElemVar s.ElemNumber> ' );'
    );

  t.Indent (CmdInsertEVarBefore s.Prev s.Usings 'e' e.Index) =
    t.Indent
    (<Indent t.Indent>
      'refalrts::splice_evar( ' <PrintPrev s.Prev> ', '
      <PrintEVar-B s.Usings 'e' e.Index> ', '
      <PrintEVar-E s.Usings 'e' e.Index> ' );'
    );

  t.Indent (CmdInsertSTVarBefore s.Prev s.Usings s.Mode e.Index) =
    t.Indent
    (<Indent t.Indent>
      'refalrts::splice_stvar( ' <PrintPrev s.Prev> ', '
      <PrintVar s.Usings s.Mode e.Index> ' );'
    );

  t.Indent (CmdSpliceFromFreeList) =
    t.Indent
    (<Indent t.Indent> 'refalrts::splice_from_freelist( arg_begin );');

  t.Indent (CmdReturnResult) =
    t.Indent
    (
      <Indent t.Indent>
      'refalrts::splice_to_freelist( arg_begin, arg_end );'
    )
    (<Indent t.Indent> 'return refalrts::cSuccess;');

  t.Indent (CmdStartEntryCode s.EntryType) =
    // Тут не важно, какой отступ увеличивать
    <IncrementEvarIndent t.Indent>
    (<Indent t.Indent> 'if( ' <EntryCondition s.EntryType> ' ) {');

  t.Indent (CmdEndEntryCode) =
    <DecrementEvarIndent t.Indent>
    (<Indent <DecrementEvarIndent t.Indent>> '}');

  t.Indent (CmdOpenedE-EndCycle) =
    <DecrementEvarIndent t.Indent>
    (<Indent <DecrementEvarIndent t.Indent>> '}');

  t.Indent (CmdEndSentence) =
    <DecrementFusedIndent t.Indent>
    (<Indent <DecrementFusedIndent t.Indent>> '} while ( 0 );') ();
}

IncrementEvarIndent
  ((e.FusedIndent) (e.EvarIndent)) =
    ((e.FusedIndent) (e.EvarIndent '  '));

DecrementEvarIndent
  ((e.FusedIndent) (e.EvarIndent '  ')) =
    ((e.FusedIndent) (e.EvarIndent));

IncrementFusedIndent
  ((e.FusedIndent) (e.EvarIndent)) =
    ((e.FusedIndent '  ') (e.EvarIndent));

DecrementFusedIndent
  ((e.FusedIndent '  ') (e.EvarIndent)) =
    ((e.FusedIndent) (e.EvarIndent));

EntryCondition {
  Init = '(s_counter ++) == 0';
  Final = '(-- s_counter) == 0';
}

PrintVar {
  s.Usings s.Mode e.Index =
    s.Mode <NameCode e.Index> '_' <MStrings::Symb s.Usings>;
}

PrintEVar-B {
  s.Usings s.Mode e.Index =
    s.Mode <NameCode e.Index> '_b_' <MStrings::Symb s.Usings>;
}

PrintEVar-E {
  s.Usings s.Mode e.Index =
    s.Mode <NameCode e.Index> '_e_' <MStrings::Symb s.Usings>;
}

PrintMatchChar {
  t.Indent s.Direction s.BracketNum s.Nested s.Char =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('char') '\'' <MEscape::EscapeChar-Hex s.Char> '\''
    >;
}

PrintMatchNumber {
  t.Indent s.Direction s.BracketNum s.Nested s.Number =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('number') <MStrings::Symb s.Number> 'UL'
    >;
}

PrintMatchName {
  t.Indent s.Direction s.BracketNum s.Nested t.Name =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('function') '& ' <QNameCode t.Name>
    >;
}

PrintMatchIdent {
  t.Indent s.Direction s.BracketNum s.Nested t.Name =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('ident') ' & ' <QNameCode t.Name> '<int>::name'
    >;
}

PrintMatchBrackets {
  t.Indent s.Direction s.BracketNum s.Nested s.InnerNum =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('brackets')
      <BracketsVar-B s.InnerNum 0> ', ' <BracketsVar-E s.InnerNum 0>
    >;
}

PrintMatchADT {
  t.Indent s.Direction s.BracketNum s.Nested s.InnerNum t.Name =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('adt')
      <BracketsVar-B s.InnerNum 0> ', '
      <BracketsVar-E s.InnerNum 0> ', '
      '& ' <QNameCode t.Name>
    >;
}

BreakerFromIndent {
  t.Indent =
    (<Indent t.Indent> '  ' <BreakerFromIndent-Aux t.Indent>);
}

BreakerFromIndent-Aux {
  (('  ') ()) = 'return refalrts::cRecognitionImpossible;';

  (('    ' e.FusedIndent) ()) = 'break;';

  ((e.FusedIndent) (e.EvarIndent)) = 'continue;';
}

PrintMatchEmpty {
  t.Indent s.BracketNum s.Nested =
    (<Indent t.Indent>
      'if( ! refalrts::empty_seq( ' <BracketsVar-B s.BracketNum s.Nested> ', '
      <BracketsVar-E s.BracketNum s.Nested> ' ) )'
    )
    <BreakerFromIndent t.Indent>;
}

StrFromDirection {
  AlgLeft = 'left'; AlgRight = 'right';
}

VarMatchFunction { 's' = 'svar'; 't' = 'tvar'; }

PrintMatchSTVar {
  t.Indent s.Direction s.BracketNum s.Nested s.Mode e.Index =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      (<VarMatchFunction s.Mode>) <PrintVar 1 s.Mode e.Index>
    >;
}

PrintMatchRepeated {
  t.Indent s.Direction s.BracketNum s.Nested s.Usings 'e' e.Index =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('repeated_evar')
      <PrintEVar-B s.Usings 'e' e.Index> ', '
      <PrintEVar-E s.Usings 'e' e.Index> ', '
      <PrintEVar-B <Math::Dec s.Usings> 'e' e.Index> ', '
      <PrintEVar-E <Math::Dec s.Usings> 'e' e.Index>
    >;

  t.Indent s.Direction s.BracketNum s.Nested s.Usings s.Mode e.Index =
    <PrintMatch
      t.Indent s.Direction s.BracketNum s.Nested
      ('repeated_stvar') <PrintVar s.Usings s.Mode e.Index>
      ', ' <PrintVar <Math::Dec s.Usings> s.Mode e.Index>
    >;
}

PrintMatch {
  t.Indent s.Direction s.BracketNum s.Nested (e.Function) e.TextRep =
    (<Indent t.Indent>
      'if( ! refalrts::' e.Function '_' <StrFromDirection s.Direction>
      '( ' e.TextRep ', ' <BracketsVar-B s.BracketNum s.Nested> ', '
      <BracketsVar-E s.BracketNum s.Nested> ' ) )'
    )
    <BreakerFromIndent t.Indent>;
}

PrintElemVar {
  s.Number = 'n' <MStrings::Symb s.Number>;
}

PrintPrev {
  BEGIN = 'arg_begin';
  s.Counter = <PrintElemVar s.Counter>;
}

PrintAllocateCopyVar {
  t.Indent s.ElemNumber 'e' e.Index =
    (<Indent t.Indent> 'refalrts::Iter ' <PrintElemVar s.ElemNumber> ' = 0;')
    (<Indent t.Indent>
      'if( ! refalrts::alloc_copy_evar( '
      <PrintElemVar s.ElemNumber> ', '
      <PrintEVar-B 1 'e' e.Index> ', '
      <PrintEVar-E 1 'e' e.Index>
      ' ) )'
    )
    (<Indent t.Indent> '  return refalrts::cNoMemory;');

  t.Indent s.ElemNumber s.Mode e.Index =
    (<Indent t.Indent> 'refalrts::Iter ' <PrintElemVar s.ElemNumber> ' = 0;')
    (<Indent t.Indent>
      'if( ! refalrts::alloc_copy_' s.Mode 'var( '
      <PrintElemVar s.ElemNumber> ', '
      <PrintVar 1 s.Mode e.Index> ' ) )'
    )
    (<Indent t.Indent> '  return refalrts::cNoMemory;');
}

PrintAllocateElem {
  t.Indent s.ElemNumber s.ElementType e.Info =
    <PrintAllocate_Aux
      t.Indent s.ElemNumber
      ( <SwAllocator s.ElementType> )
      ( <SwInfo s.ElementType e.Info> )
    >
    (<Indent t.Indent> '  return refalrts::cNoMemory;');
}

PrintAllocate_Aux {
  t.Indent s.ElemNumber (e.Constructor) (e.Value) =
    (<Indent t.Indent>
      'if( ! refalrts::' e.Constructor '( ' <PrintElemVar s.ElemNumber>
      e.Value ' ) )'
    );
}

SwAllocator {
  ElChar = 'alloc_char';
  ElName = 'alloc_name';
  ElNumber = 'alloc_number';
  ElIdent = 'alloc_ident';

  ElOpenADT = 'alloc_open_adt';
  ElCloseADT = 'alloc_close_adt';

  ElOpenBracket = 'alloc_open_bracket';
  ElCloseBracket = 'alloc_close_bracket';

  ElOpenCall = 'alloc_open_call';
  ElCloseCall = 'alloc_close_call';
}

SwInfo {
  ElChar s.Char = ', ' '\'' <MEscape::EscapeChar-Hex s.Char> '\'';

  ElName t.Name =
    ', & ' <QNameCode t.Name>
    ', & ' <QNameCode t.Name> 'N_<int>::name';

  ElNumber s.Number = ', ' <MStrings::Symb s.Number> 'UL';

  ElIdent t.Name = ', & ' <QNameCode t.Name> '<int>::name';

  // Остальное -- скобки
  s.Other = ;
}

$END BE-CppSR::Generator.

