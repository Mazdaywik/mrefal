$MODULE BE-CppSR::MCompiler;

$IMPORT Algorithm = BE-CppSR::Algorithm;
$IMPORT Generator = BE-CppSR::Generator;
$IMPORT MLambda;
$IMPORT MMath;
$IMPORT MPredeclGenerator;
$IMPORT MQualifiedName;
$IMPORT MStrings;

$IMPORT MProfiler;

/**
  <Generate t.hIModule e.OutName>
    == t.hIModule
*/
$ENTRY Generate
  t.hIModule e.OutName =
    <MProfiler::Quantify &Profiling-Generate t.hIModule e.OutName>;

Profiling-Generate
  t.hIModule e.OutName =
    <MPredeclGenerator::Generate-Generic
      & Generate-Properties t.hIModule e.OutName
    >;

Generate-Properties {
  GenSwap = & Generator.GenSwap;
  SwitchEnum Entry = & Generator.GenEEnum;
  SwitchEnum Local = & Generator.GenEnum;
  GenCommonHeaders = <Generator::GenCommonHeaders>;
  GenerateLabelForFunction = Yes & Generator.GenIdent-FuncName;
  GenIdent = & GenIdent;
  GenFunction-Decl = & GenFunction-Decl;
  Generate-EntryCode-Go = & Generate-EntryCode-Go;
  Generate-EntryCode-InitFinal = & Generate-EntryCode-InitFinal;
  GenFunction-Code = & GenFunction-Code;
}

GenIdent
  e.Name = <Generator::GenIdent <MQualifiedName::Create (e.Name)>>;

GenFunction-Decl {
  Entry t.FunctionName =
    <Generator::GenExtern t.FunctionName>;

  Local t.FunctionName =
    <Generator::GenForward t.FunctionName>;

  ADT t.FunctionName =
    <Generator::GenEnum t.FunctionName>;

  Swap t.FunctionName =
    <Generator::GenForward t.FunctionName>;
}

GenFunction-Code {
  t.FuncName s.ScopeClass e.Sentences =
    <Generator::GenFnStart s.ScopeClass t.FuncName>
    <Generator::GenInitCounter s.ScopeClass>
    <MProfiler::Quantify & GenSentences e.Sentences>
    <Generator::GenFnEnd>;
}

GenSentences
  e.Sentences = <MLambda::Map & GenSentence e.Sentences>;

GenSentence
  ((Pattern e.Pattern) (Result e.Result)) =
    <GenSentence-Aux
      ( <PrepareExpr e.Pattern> )
      ( <OptimizeStrings <PrepareExpr e.Result>> )
    >;

GenSentence-Aux
  (e.PatternExpr) (e.ResultExpr) =
    <MProfiler::Quantify
      & Generator.GenSentence
      <MProfiler::Quantify
        & Algorithm.MakeAlgorithm
        (e.PatternExpr) (e.ResultExpr)
      >
    >;

PrepareExpr
  e.Expr =
    <DoPrepareExpr 1 e.Expr '$'>;

DoPrepareExpr {
  s.BracketNum (Identifier t.SrcPos e.Name) e.Tail t.MultiBracket =
    (TkIdentifier <MQualifiedName::Create (e.Name)>)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (EVar e.Index) e.Tail t.MultiBracket =
    (TkVariable 'e' e.Index)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (TVar e.Index) e.Tail t.MultiBracket =
    (TkVariable 't' e.Index)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (SVar e.Index) e.Tail t.MultiBracket =
    (TkVariable 's' e.Index)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (Literal e.Content) e.Tail t.MultiBracket =
    <PrepareLiteral e.Content>
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (Macro s.Value) e.Tail t.MultiBracket =
    (TkNumber s.Value)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum (FnPtr (s.CallType t.SrcPos t.Name))
  e.Tail t.MultiBracket =
    (TkName t.Name)
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  /*
    Фокус! При генерации кода порядок команд инвертируется.
    Для скобок это безразлично, а вот для кода инициализации ...
  */
  s.BracketNum (EntryCode s.CodeType e.InBrackets)
  e.Tail t.MultiBracket =
    (EndEntryCode)
    <DoPrepareExpr
      s.BracketNum
      e.InBrackets
      ((EntryCode s.CodeType) e.Tail t.MultiBracket)
    >;

  s.BracketNum (Structure e.InBrackets) e.Tail t.MultiBracket =
    (TkOpenBracket s.BracketNum)
    <DoPrepareExpr
      <MMath::Inc s.BracketNum>
      e.InBrackets
      ((TkCloseBracket s.BracketNum) e.Tail t.MultiBracket)
    >;

  s.BracketNum
  (Abstract (s.CallType t.SrcPos t.Name) e.InBrackets)
  e.Tail t.MultiBracket =
    (TkOpenADT s.BracketNum)
    (TkName t.Name)
    <DoPrepareExpr
      <MMath::Inc s.BracketNum>
      e.InBrackets
      ((TkCloseADT s.BracketNum) e.Tail t.MultiBracket)
    >;

  s.BracketNum
  (Function (s.CallType t.SrcPos t.Name) e.InBrackets)
  e.Tail t.MultiBracket =
    (TkOpenCall s.BracketNum)
    (TkName t.Name)
    <DoPrepareExpr
      <MMath::Inc s.BracketNum>
      e.InBrackets
      ((TkCloseCall s.BracketNum) e.Tail t.MultiBracket)
    >;

  s.BracketNum
  (IndirectCall (SVar e.Index) e.InBrackets)
  e.Tail t.MultiBracket =
    (TkOpenCall s.BracketNum)
    (TkVariable 's' e.Index)
    <DoPrepareExpr
      <MMath::Inc s.BracketNum>
      e.InBrackets
      ((TkCloseCall s.BracketNum) e.Tail t.MultiBracket)
    >;

  s.BracketNum (t.CloseBracket e.Tail t.MultiBracket) =
    t.CloseBracket
    <DoPrepareExpr s.BracketNum e.Tail t.MultiBracket>;

  s.BracketNum '$' = ;
}

PrepareLiteral {
  s.First e.Tail = (TkChar s.First) <PrepareLiteral e.Tail>;

  = ;
}

OptimizeStrings {
  (TkChar s.First) (TkChar s.Second) e.Tail =
    <OptimizeStrings-Collect (2 s.First s.Second) e.Tail>;

  t.Other e.Tail = t.Other <OptimizeStrings e.Tail>;

  = ;
}

OptimizeStrings-Collect {
  (s.Len e.String) (TkChar s.Char) e.Tail =
    <OptimizeStrings-Collect
      (<MMath::Inc s.Len> e.String s.Char) e.Tail
    >;

  (s.Len e.String) e.Tail =
    (TkString s.Len e.String) <OptimizeStrings e.Tail>;
}

Generate-EntryCode-Go
  s.FnProperties t.ModuleName (e.Result) e.Imports =
    <MPredeclGenerator::GenFunction
      s.FnProperties
      <MQualifiedName::Create (Go)>
      Entry
      (
        (Pattern)
        (Result
          <MLambda::Map & GenInitImport e.Imports>
          e.Result
          (Function
            (Entry NoPos <MQualifiedName::Create ('Exit' Entry)>)
            (Macro 0) // код возврата
          )
        )
      )
    >
    <MPredeclGenerator::GenFunction
      s.FnProperties
      <MQualifiedName::Create ('Exit' Entry)>
      Entry
      (
        (Pattern (SVar 'RetCode'))
        (Result
          <MLambda::Map
            & GenFinalImport
            <MStrings::Reverse e.Imports>
          >
          (Function
            (Entry NoPos <MQualifiedName::Create ('Exit')>)
            (SVar 'RetCode')
          )
        )
      )
    >;

Generate-EntryCode-InitFinal
  s.FnProperties t.ModuleName t.InitSeq t.FinalSeq e.Imports =
    <MPredeclGenerator::GenFunction
      s.FnProperties
      <MQualifiedName::AddSubName t.ModuleName 'Init' Entry>
      InitFinal
      (
        (Pattern (Identifier NoPos 'Init'))
        (Result
          <MLambda::Map & GenInitImport e.Imports>
          <GenEntry Init t.InitSeq>
        )
      )
      (
        (Pattern (Identifier NoPos 'Final'))
        (Result
          <GenEntry Final t.FinalSeq>
          <MLambda::Map
            & GenFinalImport
            <MStrings::Reverse e.Imports>
          >
        )
      )
    >;

GenEntry {
  s.CodeType None = ;

  s.CodeType (Result e.Result) = (EntryCode s.CodeType e.Result);
}

GenInitImport {
  t.ImportName =
    (Function
      (
        Entry NoPos
        <MQualifiedName::AddSubName t.ImportName 'Init' Entry>
      )
      (Identifier NoPos 'Init')
    );
}

GenFinalImport {
  t.ImportName =
    (Function
      (
        Entry NoPos
        <MQualifiedName::AddSubName t.ImportName 'Init' Entry>
      )
      (Identifier NoPos 'Final')
    );
}

$END BE-CppSR::MCompiler.

