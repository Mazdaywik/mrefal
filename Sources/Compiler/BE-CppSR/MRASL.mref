$MODULE BE-CppSR::MRASL;

$IMPORT BE-CppSR::Generator;
$IMPORT C-Link::MLinker;
$IMPORT Config::MHelpers;
$IMPORT MError;
$IMPORT MFileIO;
$IMPORT MFileSystem;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MMath;
$IMPORT MQualifiedName;
$IMPORT MStrings;


/**
  <Generate t.hIModule e.OutName>
    == t.hIModule
*/
$ENTRY Generate {
  t.hIModule e.OutName =
    <CreateFile
      (e.OutName)
      <MLambda::MapReduce
        & GenerateEntity
        <MIModule::GetEntityList t.hIModule>
      >
    >;
}

CreateBinary {
  (e.OutName) e.RaslCode =
    <MFileIO::Close
      <MFileIO::Write
        <MFileIO::Open 'bw' e.OutName>
        <MStrings::Chr e.RaslCode>
      >
    >;
}

CreateFile {
  (e.OutName) t.hIModule e.RaslCode =
    <CreateFile-EntryPoint
      (e.OutName)
      <GenerateEntryCode <MIModule::GetEntryPoint t.hIModule>>
      e.RaslCode
    >;
}

CreateFile-EntryPoint {
  (e.OutName) t.hIModule e.RaslCode =
    t.hIModule
    <CreateBinary
      (e.OutName)
      <GenBlock Start 'RASLCODE'>
      <GenBlock
        ConstTable
        // cookies
        <DWord 0> <DWord 0>
        // external count, ident count, number count, string count
        <DWord 0> <DWord 0> <DWord 0> <DWord 0>
        // RASL length, external size, ident size, string size
        <DWord 0> <DWord 0> <DWord 0> <DWord 0>
      >
      e.RaslCode
    >;
}

GenerateEntryCode {
  t.hIModule Go t.GoSeq =
    <MLambda::Apply
      <MLambda::Parallel-H
        <MLambda::BindLeft-H
          &GenDefinition-Absolut
          <MQualifiedName::Create (Go)> Native Entry
        >
        <MLambda::BindLeft-H
          &GenDefinition-Absolut
          <MQualifiedName::Create ('Exit' Entry)> Native Entry
        >
      >
      t.hIModule
    >;

  t.hIModule Regular t.InitSeq t.FinalSeq =
    <MLambda::Apply
      <MLambda::Parallel-H
        <MLambda::BindLeft-H
          &GenDefinition-Relative
          <MQualifiedName::Create ('Init' Entry)> Native Entry
        >
      >
      t.hIModule
    >;
}

GenerateEntity {
  t.hIModule (Function t.RelativeName) =
    <GenerateFunction t.hIModule t.RelativeName>;

  t.hIModule (ADT t.RelativeName) =
    <GenDefinition-Relative t.hIModule t.RelativeName Empty Local>;

  t.hIModule (NativeInsertion e.NativeCode) = t.hIModule;
}

GenerateFunction {
  t.hIModule t.RelativeName =
    <GenerateFunction-Aux
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute ScopeClass t.RelativeName
          >
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute Body t.RelativeName
          >
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute NativeBody t.RelativeName
          >
        >
        t.hIModule
      >
      t.RelativeName
    >;
}

GenerateFunction-Aux {
  t.hIModule Found Swap NoAttrib NoAttrib t.RelativeName =
    <GenDefinition-Relative t.hIModule t.RelativeName Swap Local>;

  t.hIModule Found s.ScopeClass Found (/* пусто */) NoAttrib t.RelativeName =
    <GenDefinition-Relative t.hIModule t.RelativeName Empty s.ScopeClass>;

  t.hIModule Found s.ScopeClass Found (e.Sentences) NoAttrib t.RelativeName =
    <GenDefinition-Relative t.hIModule t.RelativeName Native s.ScopeClass>;

  t.hIModule Found s.ScopeClass NoAttrib Found e.NativeData t.RelativeName =
    <GenDefinition-Relative t.hIModule t.RelativeName Native s.ScopeClass>;
}

GenDefinition-Relative {
  t.hIModule t.RelativeName s.Type s.ScopeClass =
    <GenDefinition-Absolut
      <MIModule::AbsolutName t.hIModule t.RelativeName> s.Type s.ScopeClass
    >;
}

GenDefinition-Absolut {
  t.hIModule t.AbsolutName s.Type s.ScopeClass =
    t.hIModule
    <GenBlock
      s.Type
      <MarkerFromScopeClass s.ScopeClass>
      <BE-CppSR::Generator::MakeExternalName t.AbsolutName> '\0'
    >;
}

CodeFromType {
  Start = 1;
  ConstTable = 2;
  Native = 4;
  Empty = 5;
  Swap = 6;
}

MarkerFromScopeClass {
  Local = '#'; Entry = '*';
}

GenBlock {
  s.Type e.Bytes = <CodeFromType s.Type> <CalcLen e.Bytes>;
}

CalcLen {
  e.Bytes = <CalcLen-Aux <MStrings::Length-T e.Bytes>>;
}

CalcLen-Aux {
  s.Len e.Bytes = <DWord s.Len> e.Bytes;
}

DWord {
  s.1 s.2 s.3 s.4 = s.1 s.2 s.3 s.4;

  s.Low e.High = <DWord <MMath::Mod s.Low 256> <MMath::Div s.Low 256> e.High>;
}


/**
  <Link t.L-Config (e.PtProgName) (t.ModuleName e.OutName)*>
    == Success
    == Fails
*/
$ENTRY Link {
  t.L-Config (e.PtProgName) e.Modules =
    <Link-ExistTarget
      t.L-Config
      (<FindTargets <MFileSystem::StrFromPath e.PtProgName>>)
      e.Modules
    >;
}

FindTargets {
  e.StrProgName =
    <FindTargets-SwExist
      (e.StrProgName)
      (<MFileSystem::ExistFile-T e.StrProgName>)
      (<MFileSystem::ExistFile-T e.StrProgName '.exe'>)
    >;
}

FindTargets-SwExist {
  (e.StrProgName) e.Targets-B (True e.TargetName) e.Targets-E = e.TargetName;

  (e.StrProgName) e.Targets =
    <MError::LinkError
      'RASL linker: target file ' e.StrProgName ' is not found'
    >;
}

Link-ExistTarget {
  t.Config (e.StrProgName) e.Modules =
    <Link-GetFileList
      (e.StrProgName)
      <MLambda::Map & PrepareName e.Modules>
      <GetRunTimeFiles (e.StrProgName) t.Config>
    >;
}

PrepareName {
  (t.ModuleName e.FileName) = (e.FileName);
}

GetRunTimeFiles
  (e.TargetName) t.Config =
    <MLambda::Map
      <MLambda::BindLeft & PrepareRtsName e.TargetName>
      <C-Link::MLinker::LookupRuntimeFiles
        (('rasl'))
        (<Config::MHelpers::ConfigExtract t.Config RunTimeDirs>)
        <Config::MHelpers::ConfigExtract t.Config RunTimeFiles>
      >
    >;

PrepareRtsName {
  e.TargetName (NotFound e.PtNotFound) =
    <MFileSystem::RemoveFile e.TargetName>
    <MError::LinkError
      'Run-time file '
      <MFileSystem::StrFromPath e.PtNotFound>
      ' not found'
    >;

  e.TargetName (Found (e.Ext) e.PtFullPath) =
    (<MFileSystem::StrFromPath e.PtFullPath>);
}

Link-GetFileList {
  (e.TargetName) e.Files =
    Success
    <MFileIO::Close
      <MFileIO::Write
        <PrepareAlignedTarget e.TargetName>
        <MLambda::Map
          <MLambda::Composite
            & MLambda.UnBracket
            & MFileIO.LoadBinary
          >
          e.Files
        >
      >
    >;
}

PrepareAlignedTarget {
  e.TargetName =
    <PrepareAlignedTarget-Mod
      <MFileSystem::FileAttribute Size e.TargetName>
      <MFileIO::Open 'ba' e.TargetName>
    >;
}

PrepareAlignedTarget-Mod {
  (s.FileSize) t.hTarget =
    <PrepareAlignedTarget-WriteAlign t.hTarget <MMath::Mod s.FileSize 4096>>;
}

PrepareAlignedTarget-WriteAlign {
  t.hTarget 0 = t.hTarget;
  t.hTarget s.NotAligned =
    <MFileIO::Write
      t.hTarget <MStrings::Repeat <MMath::Sub 4096 s.NotAligned> '@'>
    >;
}

$END BE-CppSR::MRASL.
