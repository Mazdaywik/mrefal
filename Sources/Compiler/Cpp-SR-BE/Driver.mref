$MODULE Driver;$IMPORT Library;
  

$IMPORT Lexer;
 

 

/**
  <CompileFile (e.SrcName) e.OutputName>
    == Success e.OutputName
    == Fails
*/
$ENTRY CompileFile {
  (e.SrcName) e.OutputName =
    <& ParseAndGenerate
      (e.OutputName)
      <& Lexer.LexFolding e.SrcName>
    >;
}

$IMPORT LibraryEx;
  

 
   

/*
  Несмотря на то, что формально грамматика Простого Рефала контекстно-
  свободная, она близка к автоматной. Можно её полностью свести к автомату,
  если проверку парности скобок вынести как отдельную семантическую процедуру.
  Таким образом автомат будет иметь вид.

  TranslationUnit = Element* .

  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$FORWARD' NameList |
    '$SWAP' NameList |
    '$ESWAP' NameList |
    '$LABEL' NameList |
    '$ENTRY' Function |
    Function .

  NameList = Name ',' NameList | Name ';' .

  Function =
    Name '{' Sentence* '}'

  Sentence = Pattern '=' Result ';' .

  Pattern = PatternTerm* .

  PatternTerm = Char |
    OpenBracket | CloseBracket |
    OpenADT | CloseADT |
    Number | Name | Variable | '#' Ident.

  Result = ResultTerm* .

  ResultTerm = PatternTerm | OpenCall | CloseCall .

  Стратегия обработки ошибок. Выделяем только одну функцию, проглатывающую
  неожиданные лексемы. Остальные функции при обнаружении неожиданной лексемы
  должны её оставить в лексической свёртке перейдя в одно из состояний уровнем
  выше. Данная стратегия обработки ошибок может нарушаться, но при этом должно
  выполняться условие, что TkEOF передаётся в ParseElements.
*/

$IMPORT SymTable;
    

$IMPORT Error;
     
    

  

/*
  TranslationUnit = Element* .
*/

$IMPORT Generator;
 

ParseAndGenerate {
  (e.OutputName) e.LexFolding =
    <& WriteGenerated
      (e.OutputName)
      <& Generator.GenCommonHeaders>
      <& ParseElements
        <& Error.EL_Create> <& SymTable.ST_Create> e.LexFolding
      >
    >;
}

WriteGenerated {
  (e.OutputName) e.Lines & Error.EL_NoErrors =
    <& LibraryEx.SaveFile (e.OutputName) e.Lines>
    & Library.Success e.OutputName;

  (e.OutputName) e.Lines & Error.EL_HasErrors = & Library.Fails;
}

/*
  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$FORWARD' NameList |
    '$SWAP' NameList |
    '$ESWAP' NameList |
    '$LABEL' NameList |
    '$ENTRY' Function |
    Function .
*/

 

  
         
   

  

 
  

ParseElements {
  t.ErrorList t.SymTable (& Lexer.TkEOF s.LnNum) =
    <& Error.EL_IsEmpty <& Error.EL_Print t.ErrorList>>;

  t.ErrorList t.SymTable (& Lexer.TkDirective s.LnNum s.Directive) e.Tail =
    <& ParseElement_SwDirective
      t.ErrorList t.SymTable s.Directive e.Tail
    >;

  t.ErrorList t.SymTable (& Lexer.TkName s.LnNum e.Name) e.Tail =
    <& ParseFunction
      & Generator.GN_Local (e.Name)
      <& SymTable.ST_AddDefined t.ErrorList t.SymTable & Generator.GN_Local s.LnNum e.Name>
      e.Tail
    >;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'directive or name'>
      t.SymTable e.Tail
    >;
}

 
       

 

GenFunctionsFromDirective {
  & Lexer.EEnum   = & Generator.GenEEnum   & SymTable.ST_AddDefined  & Generator.GN_Entry;
  & Lexer.Enum    = & Generator.GenEnum    & SymTable.ST_AddDefined  & Generator.GN_Local;
  & Lexer.Extern  = & Generator.GenExtern  & SymTable.ST_AddDeclared & Generator.GN_Entry;
  & Lexer.Forward = & Generator.GenForward & SymTable.ST_AddDeclared & Generator.GN_Local;
  & Lexer.ESwap   = & Generator.GenESwap   & SymTable.ST_AddDefined  & Generator.GN_Entry;
  & Lexer.Swap    = & Generator.GenSwap    & SymTable.ST_AddDefined  & Generator.GN_Local;
  // Для меток не важно: entry или local.
  & Lexer.Ident   = & Generator.GenIdent   & SymTable.ST_AddIdent    & Generator.GN_Entry;
}

ParseElement_SwDirective {
  t.ErrorList t.SymTable & Lexer.Entry (& Lexer.TkName s.LnNum e.Name) e.Tail =
    <& ParseFunction
      & Generator.GN_Entry (e.Name)
      <& SymTable.ST_AddDefined t.ErrorList t.SymTable & Generator.GN_Entry s.LnNum e.Name>
      e.Tail
    >;

  t.ErrorList t.SymTable & Lexer.Entry t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'function name'>
      t.SymTable t.Unexpected e.Tail
    >;

  t.ErrorList t.SymTable s.Directive e.Tail =
    <& ParseNameList
      t.ErrorList t.SymTable
      <& GenFunctionsFromDirective s.Directive>
      e.Tail
    >;
}

/*
  NameList = Name ',' NameList | Name ';' .
*/

 
  

 

ParseNameList {
  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lexer.TkName s.LnNum e.Name) e.Tail =
    <s.GenFunc e.Name>
    <& ParseNameList_Tail
      <s.TableChangeFunc t.ErrorList t.SymTable s.ScopeClass s.LnNum e.Name>
      s.GenFunc s.TableChangeFunc s.ScopeClass
      e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'function name'>
      t.SymTable t.Unexpected e.Tail
    >;
}

ParseNameList_Tail {
  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lexer.TkComma s.LnNum) e.Tail =
    <& ParseNameList
      t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lexer.TkSemicolon s.LnNum) e.Tail =
    <& ParseElements
      t.ErrorList t.SymTable e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'comma or semicolon'>
      t.SymTable t.Unexpected e.Tail
    >;
}

/*
  Function = Name '{' Sentence* '}'
*/

 
  

 
   

 

ParseFunction {
  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  (& Lexer.TkOpenBlock s.LnNum) e.Tail =
    <& Generator.GenFnStart s.ScopeClass e.Name>
    <& ParseSentences
      t.ErrorList t.SymTable e.Tail
    >;

  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'open brace'>
      t.SymTable t.Unexpected e.Tail
    >;
}

  

/*
  Sentence = Pattern '=' Result ';' .
*/

ParseSentences {
  t.ErrorList t.SymTable (& Lexer.TkCloseBlock s.LnNumber) e.Tail =
    <& Generator.GenFnEnd>
    <& ParseElements
      t.ErrorList t.SymTable e.Tail
    >;

  t.ErrorList t.SymTable e.Tail =
    <& ParseSentences_Result
      t.ErrorList t.SymTable
      <& ParsePattern (/* Pattern */) e.Tail>
    >;
}

 
    
     

$IMPORT Algorithm;
 

/*
  Pattern = PatternTerm* .

  PatternTerm = Char |
    OpenBracket | CloseBracket |
    OpenADT | CloseADT |
    Number | Name | Variable | '#' Name .
*/

ParsePattern {
  (e.Pattern) (& Lexer.TkChar s.LnNum s.Char) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkChar s.Char)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkOpenBracket s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkOpenBracket s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkCloseBracket s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkCloseBracket s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkOpenADT s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkOpenADT s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkCloseADT s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkCloseADT s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkIdentMarker s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkIdentMarker s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkNumber s.LnNum s.Number) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkNumber s.Number)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkName s.LnNum e.Name) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkName s.LnNum e.Name)) e.Tail
    >;

  (e.Pattern) (& Lexer.TkVariable s.LnNum e.ModeIndex) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lexer.TkVariable s.LnNum e.ModeIndex)) e.Tail
    >;

  (e.Pattern) e.Tail = (e.Pattern) e.Tail;
}

 
   

  

ParseSentences_Result {
  t.ErrorList t.SymTable (e.Pattern) (& Lexer.TkReplace s.LnNum) e.Tail =
    <& ParseSentence_Finish
      t.ErrorList t.SymTable (e.Pattern)
      <& ParseResult (/* Result */) e.Tail>
    >;

  t.ErrorList t.SymTable (e.Pattern) (& Lexer.TkEOF s.LnNum) =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList (& Lexer.TkEOF s.LnNum) '"="'>
      t.SymTable (& Lexer.TkEOF s.LnNum)
    >;

  t.ErrorList t.SymTable (e.Pattern) t.Unexpected e.Tail =
    <& ParseSentences
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected '"="'>
      t.SymTable e.Tail
    >;
}

 

/*
  Result = ResultTerm* .

  ResultTerm = PatternTerm | OpenCall | CloseCall .
*/

ParseResult {
  /*
    Термы, входящие в результатное выражение, включают в себя термы, входящие
    в образцовое выражение. Формат результата у функций ParsePattern и
    ParseResult одинаковый. Поэтому воспользуемся функцией ParsePattern.
  */

  (e.Result) e.Tail =
    <& ParseResult_Aux
      <& ParsePattern (e.Result) e.Tail>
    >;
}

ParseResult_Aux {
  (e.Result) (& Lexer.TkOpenCall s.LnNum) e.Tail =
    <& ParseResult
      (e.Result (& Lexer.TkOpenCall s.LnNum)) e.Tail
    >;

  (e.Result) (& Lexer.TkCloseCall s.LnNum) e.Tail =
    <& ParseResult
      (e.Result (& Lexer.TkCloseCall s.LnNum)) e.Tail
    >;

  (e.Result) e.Tail = (e.Result) e.Tail;
}

  

ParseSentence_Finish {
  t.ErrorList t.SymTable (e.Pattern) (e.Result)
  (& Lexer.TkSemicolon s.LnNum) e.Tail =
    <& CheckAndGenerateSentence
      (e.Result) <& CheckPaired t.ErrorList t.SymTable e.Pattern> e.Tail
    >;

  t.ErrorList t.SymTable (e.Pattern) (e.Result)
  t.Unexpected e.Tail =
    <& ParseElements
      <& Error.EL_AddUnexpected t.ErrorList t.Unexpected 'semicolon'>
      t.SymTable t.Unexpected e.Tail
    >;
}

 
  

 Brackets { }

StrFromBracket {
  & Lexer.TkOpenBracket = '('; & Lexer.TkCloseBracket = ')';
  & Lexer.TkOpenCall = '<'; & Lexer.TkCloseCall = '>';
  & Lexer.TkOpenADT = '['; & Lexer.TkCloseADT = ']';
}

CoBracket {
  & Lexer.TkOpenADT = & Lexer.TkCloseADT;
  & Lexer.TkOpenBracket = & Lexer.TkCloseBracket;
  & Lexer.TkOpenCall = & Lexer.TkCloseCall;
  & Lexer.TkCloseADT = & Lexer.TkOpenADT;
  & Lexer.TkCloseBracket = & Lexer.TkOpenBracket;
  & Lexer.TkCloseCall = & Lexer.TkOpenCall;
}

DoCheckPaired {
  t.ErrorList t.SymTable t.MultiBracket e.Scanned ( (& Lexer.TkChar s.Char) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned (& Lexer.TkChar s.Char) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkNumber s.Number) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned (& Lexer.TkNumber s.Number)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkName s.LnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& SymTable.ST_CheckDeclared t.ErrorList t.SymTable s.LnNum e.Name>
      t.MultiBracket e.Scanned (& Lexer.TkName e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkVariable s.LnNum e.ModeIndex) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned
      (& Lexer.TkVariable s.LnNum e.ModeIndex) ( e.Expr )
    >;

  // Проверка для #
  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkIdentMarker s.MrkLnNum) (& Lexer.TkName s.NameLnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& SymTable.ST_CheckIdent t.ErrorList t.SymTable s.NameLnNum e.Name>
      t.MultiBracket e.Scanned (& Algorithm.TkIdentifier e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkIdentMarker s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Error.EL_AddErrorAt t.ErrorList s.LnNum 'Missed name after \'#\''>
      t.SymTable t.MultiBracket e.Scanned ( e.Expr )
    >;

  /*
    Все нетерминалы просмотрены. Обрабатываем только скобки.
  */

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkOpenBracket s.LnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable
      ((t.MultiBracket & Lexer.TkOpenBracket & Lexer.TkCloseBracket s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkOpenCall s.LnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable
      ((t.MultiBracket & Lexer.TkOpenCall & Lexer.TkCloseCall s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkOpenADT s.BracketLnNum) (& Lexer.TkName s.NameLnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& SymTable.ST_CheckDeclared t.ErrorList t.SymTable s.NameLnNum e.Name>
      ((t.MultiBracket & Lexer.TkOpenADT & Lexer.TkCloseADT s.BracketLnNum) e.Scanned)
      (& Lexer.TkName e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lexer.TkOpenADT s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Expected name after "["'
      >
      t.SymTable
      ((t.MultiBracket & Lexer.TkOpenADT & Lexer.TkCloseADT s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  /*
    Идея обработки ошибок такая. Если мы встречаем не ту закрывающую скобку,
    то считаем, что "та" скобка была пропущена.
    Если мы находим одинокую скобку типа ')' или '>', то считаем, что соответ-
    ствующая ей скобка была пропущена в начале выражения. Аналогично для скобок
    '(' или '<' считаем, что соответствующая ей пропущена в конце выражения.
  */

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( (s.CloseBracket s.RightLnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( (s.OtherCloseBracket s.RightLnNum) e.Expr ) =
    <& DoCheckPaired
      <& Error.EL_AddErrorAt
        t.ErrorList s.RightLnNum 'Unballanced bracket '
        <& StrFromBracket s.OtherCloseBracket>
      >
      t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket)
      ( (s.OtherCloseBracket s.RightLnNum) e.Expr )
    >;

  /*
    Случаи открывающих скобок проанализированы. Здесь будет лишняя
    закрывающая скобка.
  */
  t.ErrorList t.SymTable '$' e.Scanned
  ( (s.CloseBracket s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Unballanced bracket ' <& StrFromBracket s.CloseBracket>
      >
      t.SymTable
      '$' (& Brackets <& CoBracket s.CloseBracket> e.Scanned s.CloseBracket)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable '$' e.Scanned ( ) =
    t.ErrorList t.SymTable (e.Scanned);

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( ) =
    <& DoCheckPaired
      <& Error.EL_AddErrorAt
        t.ErrorList s.LeftLnNum 'Unballanced bracket ' <& StrFromBracket s.OpenBracket>
      >
      t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket) ( )
    >;
}

CheckPaired {
  t.ErrorList t.SymTable e.Expr =
    <& DoCheckPaired t.ErrorList t.SymTable '$' (e.Expr)>;
}

  

CheckAndGenerateSentence {
  (e.Result) t.ErrorList t.SymTable (e.ScannedPattern) e.Tail =
    <& CheckAndGenerateSentence_Aux
      ( <& NumerateBrackets e.ScannedPattern> )
      <& CheckPaired t.ErrorList t.SymTable e.Result>
      e.Tail
    >;
}

 
 

  

CheckAndGenerateSentence_Aux {
  (e.NumeratedPattern) t.ErrorList t.SymTable (e.ScannedResult) e.Tail =
     <& GenerateSentenceAndContinue
       <& CheckVariables
         t.ErrorList
         ( e.NumeratedPattern )
         ( <& NumerateBrackets e.ScannedResult> )
       >
       t.SymTable e.Tail
     >;
}

GenerateSentenceAndContinue {
  t.ErrorList ( e.Pattern ) ( e.Result ) t.SymTable e.Tail =
    <& Generator.GenSentence
      <& Algorithm.MakeAlgorithm (e.Pattern) (e.Result)>
    >
    <& ParseSentences t.ErrorList t.SymTable e.Tail>;
}

  

CheckVariables {
  t.ErrorList ( e.Pattern ) ( e.Result ) =
    <& CheckVariables_Result
      <& CheckVariables_Pattern
        t.ErrorList ( /* Variables */ ) () e.Pattern
      >
      () e.Result
    >;
}

CheckVariables_Pattern {
  t.ErrorList ( e.Variables ) (e.Pattern) =
    t.ErrorList ( e.Variables ) (e.Pattern);

  t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
  (e.Pattern) (& Lexer.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
      (e.Pattern (& Lexer.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables_B (s.Mode1 e.Index) e.Variables_E )
  (e.Pattern) (& Lexer.TkVariable s.LnNum s.Mode2 e.Index) e.Tail =
    <& CheckVariables_Pattern
      <& Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Variables ' s.Mode1 '.' e.Index ' and '
        s.Mode2 '.' e.Index ' hase different modes'
      >
      ( e.Variables_B (s.Mode1 e.Index) e.Variables_E )
      (e.Pattern) e.Tail
    >;

  t.ErrorList ( e.Variables )
  (e.Pattern) (& Lexer.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables (s.Mode e.Index) )
      (e.Pattern (& Lexer.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern) t.OtherTerm e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables ) (e.Pattern t.OtherTerm) e.Tail
    >;
}

CheckVariables_Result {
  t.ErrorList ( e.Variables ) (e.Pattern) (e.Result) =
    t.ErrorList (e.Pattern) (e.Result);

  t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
  (e.Pattern) (e.Result) (& Lexer.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Result
      t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
      (e.Pattern) (e.Result (& Lexer.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern)
  (e.Result) (& Lexer.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Result
      <& Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Variable ' s.Mode '.' e.Index
        ' is undefined'
      >
      ( e.Variables ) (e.Pattern) (e.Result) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern)
  (e.Result) t.OtherTerm e.Tail =
    <& CheckVariables_Result
      t.ErrorList ( e.Variables ) (e.Pattern) (e.Result t.OtherTerm) e.Tail
    >;
}

 
 

DoNumerateBrackets {
  s.Number e.Expr_B
  (& Brackets & Lexer.TkOpenADT (& Lexer.TkName e.Name) e.Inner & Lexer.TkCloseADT)
  e.Expr_E =
    <& DoNumerateBrackets
      <& LibraryEx.Inc s.Number>
      e.Expr_B (& Lexer.TkOpenADT s.Number)
      (& Lexer.TkName e.Name) e.Inner
      (& Lexer.TkCloseADT s.Number) e.Expr_E
    >;

  s.Number e.Expr_B (& Brackets & Lexer.TkOpenADT e.Inner & Lexer.TkCloseADT) e.Expr_E =
    <& DoNumerateBrackets
      <& LibraryEx.Inc s.Number>
      e.Expr_B (& Lexer.TkOpenBracket s.Number) e.Inner
      (& Lexer.TkCloseBracket s.Number) e.Expr_E
    >;

  s.Number e.Expr_B (& Brackets s.Open e.Inner s.Close) e.Expr_E =
    <& DoNumerateBrackets
      <& LibraryEx.Inc s.Number>
      e.Expr_B (s.Open s.Number) e.Inner (s.Close s.Number) e.Expr_E
    >;

  s.Number e.Expr = e.Expr;
}

NumerateBrackets {
  e.Expr = <& DoNumerateBrackets 1 e.Expr>;
}

$END Driver.
