$MODULE SymTable; TSymTable { }
/*
  При препроцессировании этого файла в Модульный Рефал в качестве имени модуля
  берётся имя файла без расширения. Для данного файла имя модуля устанавливается
  в SymTable. Поэтому в качестве метки для типа данных пришлось выбрать имя
  TSymTable. К сожалению, это ограничение препроцессора.
*/

$ENTRY ST_Create {
  = (& TSymTable);
}

/*
  Внутренний формат
  t.SymTable ::= (TSymTable e.Names)
  e.Names ::= t.Name*
  t.Name ::= (Declared s.ScopeClass e.Name) | (Defined s.ScopeClass e.Name)
*/

 Declared { } Defined { } Identifier { }

$IMPORT Generator;
  

$IMPORT Error;
 

/**
  <ST-AddDe****
    t.ErrorList t.SymTable s.ScopeClass s.LnNum e.Name
  >
    == t.ErrorList t.SymTable
*/

$ENTRY ST_AddDefined {
  t.ErrorList
  (& TSymTable e.Names_B (& Defined s.OtherScopeClass e.Name) e.Names_E)
  s.ScopeClass s.LnNum e.Name =
    <& Error.EL_AddErrorAt t.ErrorList s.LnNum 'Function ' e.Name ' already defined'>
    (& TSymTable e.Names_B (& Defined s.OtherScopeClass e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Declared s.ScopeClass e.Name) e.Names_E)
  s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names_B (& Defined s.ScopeClass e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Declared & Generator.GN_Entry e.Name) e.Names_E)
  & Generator.GN_Local s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy declared as Entry'
    >
    (& TSymTable e.Names_B (& Defined & Generator.GN_Entry e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Declared & Generator.GN_Local e.Name) e.Names_E)
  & Generator.GN_Entry s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy declared as Local'
    >
    (& TSymTable e.Names_B (& Defined & Generator.GN_Local e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names) s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names (& Defined s.ScopeClass e.Name));
}

$ENTRY ST_AddDeclared {
  /*
    Можно повторно объявить имя не зависимо от того, было ли оно до этого
    объявлено или определено.
  */
  t.ErrorList (& TSymTable e.Names_B (& Declared s.ScopeClass e.Name) e.Names_E)
  s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names_B (& Declared s.ScopeClass e.Name) e.Names_E);

  t.ErrorList (& TSymTable e.Names_B (& Defined s.ScopeClass e.Name) e.Names_E)
  s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names_B (& Defined s.ScopeClass e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Declared & Generator.GN_Entry e.Name) e.Names_E)
  & Generator.GN_Local s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy declared as Entry'
    >
    (& TSymTable e.Names_B (& Declared & Generator.GN_Entry e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Declared & Generator.GN_Local e.Name) e.Names_E)
  & Generator.GN_Entry s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy declared as Local'
    >
    (& TSymTable e.Names_B (& Declared & Generator.GN_Local e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Defined & Generator.GN_Entry e.Name) e.Names_E)
  & Generator.GN_Local s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy defined as Entry'
    >
    (& TSymTable e.Names_B (& Defined & Generator.GN_Entry e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names_B (& Defined & Generator.GN_Local e.Name) e.Names_E)
  & Generator.GN_Entry s.LnNum e.Name =
    <& Error.EL_AddErrorAt
      t.ErrorList s.LnNum 'Function ' e.Name ' alredy defined as Local'
    >
    (& TSymTable e.Names_B (& Defined & Generator.GN_Local e.Name) e.Names_E);

  t.ErrorList (& TSymTable e.Names) s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names (& Declared s.ScopeClass e.Name));
}

$ENTRY ST_AddIdent {
  t.ErrorList
  (& TSymTable e.Names_B (& Identifier s.ScopeClass e.Name) e.Names_E)
  s.OtherScopeClass s.LnNum e.Name =
    <& Error.EL_AddErrorAt t.ErrorList s.LnNum 'Identifier ' e.Name ' alredy defined'>
    (& TSymTable e.Names_B (& Identifier s.ScopeClass e.Name) e.Names_E);

  t.ErrorList
  (& TSymTable e.Names) s.ScopeClass s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names (& Identifier s.ScopeClass e.Name));
}

$ENTRY ST_CheckDeclared {
  t.ErrorList (& TSymTable e.Names_B (& Declared s.ScopeClass e.Name) e.Names_E)
  s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names_B (& Declared s.ScopeClass e.Name) e.Names_E);

  t.ErrorList (& TSymTable e.Names_B (& Defined s.ScopeClass e.Name) e.Names_E)
  s.LnNum e.Name =
    t.ErrorList (& TSymTable e.Names_B (& Defined s.ScopeClass e.Name) e.Names_E);

  t.ErrorList t.SymTable s.LnNum e.Name =
    <& Error.EL_AddErrorAt t.ErrorList s.LnNum 'Function ' e.Name ' not declared'>
    t.SymTable;

}

$ENTRY ST_CheckIdent {
  t.ErrorList (& TSymTable e.Names_B (& Identifier s.ScopeClass e.Name) e.Names_E)
  s.LnNum e.Name =
    t.ErrorList
    (& TSymTable e.Names_B (& Identifier s.ScopeClass e.Name) e.Names_E);

  t.ErrorList t.SymTable s.LnNum e.Name =
    <& Error.EL_AddErrorAt t.ErrorList s.LnNum 'Identifier ' e.Name ' not declared'>
    t.SymTable;
}
$END SymTable.
