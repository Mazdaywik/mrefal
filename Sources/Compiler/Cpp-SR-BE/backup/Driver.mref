$MODULE Cpp-SR-BE::Driver;$IMPORT Cpp-SR-BE::Library;
  

$IMPORT Lx = Cpp-SR-BE::Lexer;
 

 

/**
  <CompileFile (e.SrcName) e.OutputName>
    == Success e.OutputName
    == Fails
*/
$ENTRY CompileFile {
  (e.SrcName) e.OutputName =
    <& ParseAndGenerate
      (e.OutputName)
      <& Lx.LexFolding e.SrcName>
    >;
}

$IMPORT Cpp-SR-BE::LibraryEx;
  

 
   

/*
  Несмотря на то, что формально грамматика Простого Рефала контекстно-
  свободная, она близка к автоматной. Можно её полностью свести к автомату,
  если проверку парности скобок вынести как отдельную семантическую процедуру.
  Таким образом автомат будет иметь вид.

  TranslationUnit = Element* .

  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$FORWARD' NameList |
    '$SWAP' NameList |
    '$ESWAP' NameList |
    '$LABEL' NameList |
    '$ENTRY' Function |
    Function .

  NameList = Name ',' NameList | Name ';' .

  Function =
    Name '{' Sentence* '}'

  Sentence = Pattern '=' Result ';' .

  Pattern = PatternTerm* .

  PatternTerm = Char |
    OpenBracket | CloseBracket |
    OpenADT | CloseADT |
    Number | Name | Variable | '#' Ident.

  Result = ResultTerm* .

  ResultTerm = PatternTerm | OpenCall | CloseCall .

  Стратегия обработки ошибок. Выделяем только одну функцию, проглатывающую
  неожиданные лексемы. Остальные функции при обнаружении неожиданной лексемы
  должны её оставить в лексической свёртке перейдя в одно из состояний уровнем
  выше. Данная стратегия обработки ошибок может нарушаться, но при этом должно
  выполняться условие, что TkEOF передаётся в ParseElements.
*/

$IMPORT Cpp-SR-BE::SymTable;
    

$IMPORT Cpp-SR-BE::Error;
     
    

  

/*
  TranslationUnit = Element* .
*/

$IMPORT Cpp-SR-BE::Generator;
 

ParseAndGenerate {
  (e.OutputName) e.LexFolding =
    <& WriteGenerated
      (e.OutputName)
      <& Cpp-SR-BE.Generator.GenCommonHeaders>
      <& ParseElements
        <& Cpp-SR-BE.Error.EL_Create> <& Cpp-SR-BE.SymTable.ST_Create> e.LexFolding
      >
    >;
}

WriteGenerated {
  (e.OutputName) e.Lines & Cpp-SR-BE.Error.EL_NoErrors =
    <& Cpp-SR-BE.LibraryEx.SaveFile (e.OutputName) e.Lines>
    & Cpp-SR-BE.Library.Success e.OutputName;

  (e.OutputName) e.Lines & Cpp-SR-BE.Error.EL_HasErrors = & Cpp-SR-BE.Library.Fails;
}

/*
  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$FORWARD' NameList |
    '$SWAP' NameList |
    '$ESWAP' NameList |
    '$LABEL' NameList |
    '$ENTRY' Function |
    Function .
*/

 

  
         
   

  

 
  

ParseElements {
  t.ErrorList t.SymTable (& Lx.TkEOF s.LnNum) =
    <& Cpp-SR-BE.Error.EL_IsEmpty <& Cpp-SR-BE.Error.EL_Print t.ErrorList>>;

  t.ErrorList t.SymTable (& Lx.TkDirective s.LnNum s.Directive) e.Tail =
    <& ParseElement_SwDirective
      t.ErrorList t.SymTable s.Directive e.Tail
    >;

  t.ErrorList t.SymTable (& Lx.TkName s.LnNum e.Name) e.Tail =
    <& ParseFunction
      & Cpp-SR-BE.Generator.GN_Local (e.Name)
      <& Cpp-SR-BE.SymTable.ST_AddDefined t.ErrorList t.SymTable & Cpp-SR-BE.Generator.GN_Local s.LnNum e.Name>
      e.Tail
    >;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'directive or name'>
      t.SymTable e.Tail
    >;
}

 
       

 

GenFunctionsFromDirective {
  & Lx.EEnum   = & Cpp-SR-BE.Generator.GenEEnum   & Cpp-SR-BE.SymTable.ST_AddDefined  & Cpp-SR-BE.Generator.GN_Entry;
  & Lx.Enum    = & Cpp-SR-BE.Generator.GenEnum    & Cpp-SR-BE.SymTable.ST_AddDefined  & Cpp-SR-BE.Generator.GN_Local;
  & Lx.Extern  = & Cpp-SR-BE.Generator.GenExtern  & Cpp-SR-BE.SymTable.ST_AddDeclared & Cpp-SR-BE.Generator.GN_Entry;
  & Lx.Forward = & Cpp-SR-BE.Generator.GenForward & Cpp-SR-BE.SymTable.ST_AddDeclared & Cpp-SR-BE.Generator.GN_Local;
  & Lx.ESwap   = & Cpp-SR-BE.Generator.GenESwap   & Cpp-SR-BE.SymTable.ST_AddDefined  & Cpp-SR-BE.Generator.GN_Entry;
  & Lx.Swap    = & Cpp-SR-BE.Generator.GenSwap    & Cpp-SR-BE.SymTable.ST_AddDefined  & Cpp-SR-BE.Generator.GN_Local;
  // Для меток не важно: entry или local.
  & Lx.Ident   = & Cpp-SR-BE.Generator.GenIdent   & Cpp-SR-BE.SymTable.ST_AddIdent    & Cpp-SR-BE.Generator.GN_Entry;
}

ParseElement_SwDirective {
  t.ErrorList t.SymTable & Lx.Entry (& Lx.TkName s.LnNum e.Name) e.Tail =
    <& ParseFunction
      & Cpp-SR-BE.Generator.GN_Entry (e.Name)
      <& Cpp-SR-BE.SymTable.ST_AddDefined t.ErrorList t.SymTable & Cpp-SR-BE.Generator.GN_Entry s.LnNum e.Name>
      e.Tail
    >;

  t.ErrorList t.SymTable & Lx.Entry t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'function name'>
      t.SymTable t.Unexpected e.Tail
    >;

  t.ErrorList t.SymTable s.Directive e.Tail =
    <& ParseNameList
      t.ErrorList t.SymTable
      <& GenFunctionsFromDirective s.Directive>
      e.Tail
    >;
}

/*
  NameList = Name ',' NameList | Name ';' .
*/

 
  

 

ParseNameList {
  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lx.TkName s.LnNum e.Name) e.Tail =
    <s.GenFunc e.Name>
    <& ParseNameList_Tail
      <s.TableChangeFunc t.ErrorList t.SymTable s.ScopeClass s.LnNum e.Name>
      s.GenFunc s.TableChangeFunc s.ScopeClass
      e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'function name'>
      t.SymTable t.Unexpected e.Tail
    >;
}

ParseNameList_Tail {
  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lx.TkComma s.LnNum) e.Tail =
    <& ParseNameList
      t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  (& Lx.TkSemicolon s.LnNum) e.Tail =
    <& ParseElements
      t.ErrorList t.SymTable e.Tail
    >;

  t.ErrorList t.SymTable s.GenFunc s.TableChangeFunc s.ScopeClass
  t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'comma or semicolon'>
      t.SymTable t.Unexpected e.Tail
    >;
}

/*
  Function = Name '{' Sentence* '}'
*/

 
  

 
   

 

ParseFunction {
  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  (& Lx.TkOpenBlock s.LnNum) e.Tail =
    <& Cpp-SR-BE.Generator.GenFnStart s.ScopeClass e.Name>
    <& ParseSentences
      t.ErrorList t.SymTable e.Tail
    >;

  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'open brace'>
      t.SymTable t.Unexpected e.Tail
    >;
}

  

/*
  Sentence = Pattern '=' Result ';' .
*/

ParseSentences {
  t.ErrorList t.SymTable (& Lx.TkCloseBlock s.LnNumber) e.Tail =
    <& Cpp-SR-BE.Generator.GenFnEnd>
    <& ParseElements
      t.ErrorList t.SymTable e.Tail
    >;

  t.ErrorList t.SymTable e.Tail =
    <& ParseSentences_Result
      t.ErrorList t.SymTable
      <& ParsePattern (/* Pattern */) e.Tail>
    >;
}

 
    
     

$IMPORT Cpp-SR-BE::Algorithm;
 

/*
  Pattern = PatternTerm* .

  PatternTerm = Char |
    OpenBracket | CloseBracket |
    OpenADT | CloseADT |
    Number | Name | Variable | '#' Name .
*/

ParsePattern {
  (e.Pattern) (& Lx.TkChar s.LnNum s.Char) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkChar s.Char)) e.Tail
    >;

  (e.Pattern) (& Lx.TkOpenBracket s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkOpenBracket s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lx.TkCloseBracket s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkCloseBracket s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lx.TkOpenADT s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkOpenADT s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lx.TkCloseADT s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkCloseADT s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lx.TkIdentMarker s.LnNum) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkIdentMarker s.LnNum)) e.Tail
    >;

  (e.Pattern) (& Lx.TkNumber s.LnNum s.Number) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkNumber s.Number)) e.Tail
    >;

  (e.Pattern) (& Lx.TkName s.LnNum e.Name) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkName s.LnNum e.Name)) e.Tail
    >;

  (e.Pattern) (& Lx.TkVariable s.LnNum e.ModeIndex) e.Tail =
    <& ParsePattern
      (e.Pattern (& Lx.TkVariable s.LnNum e.ModeIndex)) e.Tail
    >;

  (e.Pattern) e.Tail = (e.Pattern) e.Tail;
}

 
   

  

ParseSentences_Result {
  t.ErrorList t.SymTable (e.Pattern) (& Lx.TkReplace s.LnNum) e.Tail =
    <& ParseSentence_Finish
      t.ErrorList t.SymTable (e.Pattern)
      <& ParseResult (/* Result */) e.Tail>
    >;

  t.ErrorList t.SymTable (e.Pattern) (& Lx.TkEOF s.LnNum) =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList (& Lx.TkEOF s.LnNum) '"="'>
      t.SymTable (& Lx.TkEOF s.LnNum)
    >;

  t.ErrorList t.SymTable (e.Pattern) t.Unexpected e.Tail =
    <& ParseSentences
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected '"="'>
      t.SymTable e.Tail
    >;
}

 

/*
  Result = ResultTerm* .

  ResultTerm = PatternTerm | OpenCall | CloseCall .
*/

ParseResult {
  /*
    Термы, входящие в результатное выражение, включают в себя термы, входящие
    в образцовое выражение. Формат результата у функций ParsePattern и
    ParseResult одинаковый. Поэтому воспользуемся функцией ParsePattern.
  */

  (e.Result) e.Tail =
    <& ParseResult_Aux
      <& ParsePattern (e.Result) e.Tail>
    >;
}

ParseResult_Aux {
  (e.Result) (& Lx.TkOpenCall s.LnNum) e.Tail =
    <& ParseResult
      (e.Result (& Lx.TkOpenCall s.LnNum)) e.Tail
    >;

  (e.Result) (& Lx.TkCloseCall s.LnNum) e.Tail =
    <& ParseResult
      (e.Result (& Lx.TkCloseCall s.LnNum)) e.Tail
    >;

  (e.Result) e.Tail = (e.Result) e.Tail;
}

  

ParseSentence_Finish {
  t.ErrorList t.SymTable (e.Pattern) (e.Result)
  (& Lx.TkSemicolon s.LnNum) e.Tail =
    <& CheckAndGenerateSentence
      (e.Result) <& CheckPaired t.ErrorList t.SymTable e.Pattern> e.Tail
    >;

  t.ErrorList t.SymTable (e.Pattern) (e.Result)
  t.Unexpected e.Tail =
    <& ParseElements
      <& Cpp-SR-BE.Error.EL_AddUnexpected t.ErrorList t.Unexpected 'semicolon'>
      t.SymTable t.Unexpected e.Tail
    >;
}

 
  

 Brackets { }

StrFromBracket {
  & Lx.TkOpenBracket = '('; & Lx.TkCloseBracket = ')';
  & Lx.TkOpenCall = '<'; & Lx.TkCloseCall = '>';
  & Lx.TkOpenADT = '['; & Lx.TkCloseADT = ']';
}

CoBracket {
  & Lx.TkOpenADT = & Lx.TkCloseADT;
  & Lx.TkOpenBracket = & Lx.TkCloseBracket;
  & Lx.TkOpenCall = & Lx.TkCloseCall;
  & Lx.TkCloseADT = & Lx.TkOpenADT;
  & Lx.TkCloseBracket = & Lx.TkOpenBracket;
  & Lx.TkCloseCall = & Lx.TkOpenCall;
}

DoCheckPaired {
  t.ErrorList t.SymTable t.MultiBracket e.Scanned ( (& Lx.TkChar s.Char) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned (& Lx.TkChar s.Char) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkNumber s.Number) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned (& Lx.TkNumber s.Number)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkName s.LnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.SymTable.ST_CheckDeclared t.ErrorList t.SymTable s.LnNum e.Name>
      t.MultiBracket e.Scanned (& Lx.TkName e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkVariable s.LnNum e.ModeIndex) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned
      (& Lx.TkVariable s.LnNum e.ModeIndex) ( e.Expr )
    >;

  // Проверка для #
  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkIdentMarker s.MrkLnNum) (& Lx.TkName s.NameLnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.SymTable.ST_CheckIdent t.ErrorList t.SymTable s.NameLnNum e.Name>
      t.MultiBracket e.Scanned (& Cpp-SR-BE.Algorithm.TkIdentifier e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkIdentMarker s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.Error.EL_AddErrorAt t.ErrorList s.LnNum 'Missed name after \'#\''>
      t.SymTable t.MultiBracket e.Scanned ( e.Expr )
    >;

  /*
    Все атомы просмотрены. Обрабатываем только скобки.
  */

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkOpenBracket s.LnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable
      ((t.MultiBracket & Lx.TkOpenBracket & Lx.TkCloseBracket s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkOpenCall s.LnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable
      ((t.MultiBracket & Lx.TkOpenCall & Lx.TkCloseCall s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkOpenADT s.BracketLnNum) (& Lx.TkName s.NameLnNum e.Name) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.SymTable.ST_CheckDeclared t.ErrorList t.SymTable s.NameLnNum e.Name>
      ((t.MultiBracket & Lx.TkOpenADT & Lx.TkCloseADT s.BracketLnNum) e.Scanned)
      (& Lx.TkName e.Name) ( e.Expr )
    >;

  t.ErrorList t.SymTable t.MultiBracket e.Scanned
  ( (& Lx.TkOpenADT s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Expected name after "["'
      >
      t.SymTable
      ((t.MultiBracket & Lx.TkOpenADT & Lx.TkCloseADT s.LnNum) e.Scanned)
      ( e.Expr )
    >;

  /*
    Идея обработки ошибок такая. Если мы встречаем не ту закрывающую скобку,
    то считаем, что "та" скобка была пропущена.
    Если мы находим одинокую скобку типа ')' или '>', то считаем, что соответ-
    ствующая ей скобка была пропущена в начале выражения. Аналогично для скобок
    '(' или '<' считаем, что соответствующая ей пропущена в конце выражения.
  */

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( (s.CloseBracket s.RightLnNum) e.Expr ) =
    <& DoCheckPaired
      t.ErrorList t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( (s.OtherCloseBracket s.RightLnNum) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.RightLnNum 'Unballanced bracket '
        <& StrFromBracket s.OtherCloseBracket>
      >
      t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket)
      ( (s.OtherCloseBracket s.RightLnNum) e.Expr )
    >;

  /*
    Случаи открывающих скобок проанализированы. Здесь будет лишняя
    закрывающая скобка.
  */
  t.ErrorList t.SymTable '$' e.Scanned
  ( (s.CloseBracket s.LnNum) e.Expr ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Unballanced bracket ' <& StrFromBracket s.CloseBracket>
      >
      t.SymTable
      '$' (& Brackets <& CoBracket s.CloseBracket> e.Scanned s.CloseBracket)
      ( e.Expr )
    >;

  t.ErrorList t.SymTable '$' e.Scanned ( ) =
    t.ErrorList t.SymTable (e.Scanned);

  t.ErrorList t.SymTable
  ((t.MultiBracket s.OpenBracket s.CloseBracket s.LeftLnNum) e.Scanned)
  e.Inner ( ) =
    <& DoCheckPaired
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.LeftLnNum 'Unballanced bracket ' <& StrFromBracket s.OpenBracket>
      >
      t.SymTable t.MultiBracket e.Scanned
      (& Brackets s.OpenBracket e.Inner s.CloseBracket) ( )
    >;
}

CheckPaired {
  t.ErrorList t.SymTable e.Expr =
    <& DoCheckPaired t.ErrorList t.SymTable '$' (e.Expr)>;
}

  

CheckAndGenerateSentence {
  (e.Result) t.ErrorList t.SymTable (e.ScannedPattern) e.Tail =
    <& CheckAndGenerateSentence_Aux
      ( <& NumerateBrackets e.ScannedPattern> )
      <& CheckPaired t.ErrorList t.SymTable e.Result>
      e.Tail
    >;
}

 
 

  

CheckAndGenerateSentence_Aux {
  (e.NumeratedPattern) t.ErrorList t.SymTable (e.ScannedResult) e.Tail =
     <& GenerateSentenceAndContinue
       <& CheckVariables
         t.ErrorList
         ( e.NumeratedPattern )
         ( <& NumerateBrackets e.ScannedResult> )
       >
       t.SymTable e.Tail
     >;
}

GenerateSentenceAndContinue {
  t.ErrorList ( e.Pattern ) ( e.Result ) t.SymTable e.Tail =
    <& Cpp-SR-BE.Generator.GenSentence
      <& Cpp-SR-BE.Algorithm.MakeAlgorithm (e.Pattern) (e.Result)>
    >
    <& ParseSentences t.ErrorList t.SymTable e.Tail>;
}

  

CheckVariables {
  t.ErrorList ( e.Pattern ) ( e.Result ) =
    <& CheckVariables_Result
      <& CheckVariables_Pattern
        t.ErrorList ( /* Variables */ ) () e.Pattern
      >
      () e.Result
    >;
}

CheckVariables_Pattern {
  t.ErrorList ( e.Variables ) (e.Pattern) =
    t.ErrorList ( e.Variables ) (e.Pattern);

  t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
  (e.Pattern) (& Lx.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
      (e.Pattern (& Lx.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables_B (s.Mode1 e.Index) e.Variables_E )
  (e.Pattern) (& Lx.TkVariable s.LnNum s.Mode2 e.Index) e.Tail =
    <& CheckVariables_Pattern
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Variables ' s.Mode1 '.' e.Index ' and '
        s.Mode2 '.' e.Index ' hase different modes'
      >
      ( e.Variables_B (s.Mode1 e.Index) e.Variables_E )
      (e.Pattern) e.Tail
    >;

  t.ErrorList ( e.Variables )
  (e.Pattern) (& Lx.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables (s.Mode e.Index) )
      (e.Pattern (& Lx.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern) t.OtherTerm e.Tail =
    <& CheckVariables_Pattern
      t.ErrorList ( e.Variables ) (e.Pattern t.OtherTerm) e.Tail
    >;
}

CheckVariables_Result {
  t.ErrorList ( e.Variables ) (e.Pattern) (e.Result) =
    t.ErrorList (e.Pattern) (e.Result);

  t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
  (e.Pattern) (e.Result) (& Lx.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Result
      t.ErrorList ( e.Variables_B (s.Mode e.Index) e.Variables_E )
      (e.Pattern) (e.Result (& Lx.TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern)
  (e.Result) (& Lx.TkVariable s.LnNum s.Mode e.Index) e.Tail =
    <& CheckVariables_Result
      <& Cpp-SR-BE.Error.EL_AddErrorAt
        t.ErrorList s.LnNum 'Variable ' s.Mode '.' e.Index
        ' is undefined'
      >
      ( e.Variables ) (e.Pattern) (e.Result) e.Tail
    >;

  t.ErrorList ( e.Variables ) (e.Pattern)
  (e.Result) t.OtherTerm e.Tail =
    <& CheckVariables_Result
      t.ErrorList ( e.Variables ) (e.Pattern) (e.Result t.OtherTerm) e.Tail
    >;
}

 
 

DoNumerateBrackets {
  s.Number e.Expr_B
  (& Brackets & Lx.TkOpenADT (& Lx.TkName e.Name) e.Inner & Lx.TkCloseADT)
  e.Expr_E =
    <& DoNumerateBrackets
      <& Cpp-SR-BE.LibraryEx.Inc s.Number>
      e.Expr_B (& Lx.TkOpenADT s.Number)
      (& Lx.TkName e.Name) e.Inner
      (& Lx.TkCloseADT s.Number) e.Expr_E
    >;

  s.Number e.Expr_B (& Brackets & Lx.TkOpenADT e.Inner & Lx.TkCloseADT) e.Expr_E =
    <& DoNumerateBrackets
      <& Cpp-SR-BE.LibraryEx.Inc s.Number>
      e.Expr_B (& Lx.TkOpenBracket s.Number) e.Inner
      (& Lx.TkCloseBracket s.Number) e.Expr_E
    >;

  s.Number e.Expr_B (& Brackets s.Open e.Inner s.Close) e.Expr_E =
    <& DoNumerateBrackets
      <& Cpp-SR-BE.LibraryEx.Inc s.Number>
      e.Expr_B (s.Open s.Number) e.Inner (s.Close s.Number) e.Expr_E
    >;

  s.Number e.Expr = e.Expr;
}

NumerateBrackets {
  e.Expr = <& DoNumerateBrackets 1 e.Expr>;
}

$END Cpp-SR-BE::Driver.
