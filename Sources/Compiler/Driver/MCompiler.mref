$MODULE Driver::MCompiler;

/*
  На блок-схеме показаны основные этапы обработки модулей.

  Make --> ScanSubModule (определение состояния модуля)
                               |
                               V
                 Compile (загрузка IModule) [1]
                               |
                               V
      Compile-Aux (загрузка и анализ импортируемых модулей)
                               |
                               V
           Рекурсивный анализ импортируемых модулей
           (путём вызова ScanSubModule для каждого)
                               |
                               V
               Synthesis (анализ вызовов функций
          из импортируемых модулей и генерация кода) [2]
                               |
                               V
          Compile-Cache (кэширование списка импорта)
                               |
                               V
         UpdateContext (сохранение финального состояния)

  [1] В зависимости от состояния модуля (s.Type) выполняется загрузка
  промежуточного представления представления или по файлу исходного текста,
  или по файлу интерфейса модуля ("символическая информация").

  [2] В зависимости от состояния модуля (s.Type) или выполняется анализ
  импортируемых функций и генерация кода, или ничего не делается.
*/

$IMPORT Driver::MResolver;
$IMPORT MConfig = Driver::MConfig;
$IMPORT MContext = Driver::MContext;
$IMPORT MError;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MOutModuleStatus;
$IMPORT MSelfDiag;
$IMPORT MSymModule = Driver::MSymModule;
$IMPORT MQualifiedName;

/**
  <Make t.hContext t.hErrorList t.Config t.SrcPos t.RootModuleName>
    == t.hContext t.hErrorList Success
    == t.hContext t.hErrorList Fails
*/
$ENTRY Make
  t.hContext t.hErrorList t.Config t.SrcPos t.RootModuleName =
    <Make-SwResult
      t.Config t.RootModuleName
      <ScanSubModule
        Recompile
        () t.Config t.hContext t.hErrorList
        t.SrcPos t.RootModuleName
      >
    >;

Make-SwResult {
  t.Config t.RootModuleName
  t.hContext t.hErrorList Success t.hIModule Main =
    <MIModule::Destroy t.hIModule>
    <Make-Aux
      <MConfig::Link t.Config t.hContext t.RootModuleName>
      t.hErrorList
    >;

  t.Config t.RootModuleName
  t.hContext t.hErrorList Success t.hIModule Regular =
    <MIModule::Destroy t.hIModule>
    <MOutModuleStatus::Flush>
    t.hContext t.hErrorList Success;

  t.Config t.RootModuleName
  t.hContext t.hErrorList Fails t.ModuleName =
    t.hContext t.hErrorList Fails;
}

Make-Aux
  t.hContext s.Result t.hErrorList =
    t.hContext t.hErrorList s.Result;

//------------------------------------------------------------------------------

/**
  <ScanSubModule
    s.Type (e.Stack)
    t.Config t.hContext t.hErrorList t.SrcPos t.ImportName
  >
    == t.hContext t.hErrorList Success t.hIModule s.ModuleType
    == t.hContext t.hErrorList Fails t.RealName
    == t.hContext t.hErrorList NotFound t.RealName
    == t.hContext t.hErrorList IsNotLibrary t.RealName
  s.Type ::= Recompile | Updated | Library
*/
ScanSubModule {
  s.Type (e.Stack-B t.ImportName e.Stack-E)
  t.Config t.hContext t.hErrorList t.SrcPos t.ImportName =
    t.hContext
    <MError::AddRecursiveLoop
      t.hErrorList t.SrcPos t.ImportName e.Stack-E t.ImportName
    >
    Fails t.ImportName;

  s.Type (e.Stack)
  t.Config t.hContext t.hErrorList t.SrcPos t.ImportName =
    <ScanSubModule-SwNeedRecompile
      s.Type (e.Stack) t.Config
      <MConfig::CheckNeedCompile
        t.hErrorList t.hContext t.Config t.ImportName
      >
    >;
}

ScanSubModule-SwNeedRecompile {
  s.TypeMode (e.Stack) t.Config
  t.hErrorList t.hContext t.ModuleName
  Success s.Status s.Type =
    <ScanSubModule-SwSelect
      s.Status <ScanSubModule-Select s.TypeMode s.Type>
      (e.Stack) t.Config t.hErrorList t.hContext
      t.ModuleName
    >;

  s.TypeMode (e.Stack) t.Config
  t.hErrorList t.hContext t.ModuleName
  Fails MismatchCase =
    t.hContext t.hErrorList Fails t.ModuleName;
}

ScanSubModule-Select {
  s.TypeMode Errors    = Error   Fails        ;

  Updated    Recompile = Error   Fails        ;
  Library    Recompile = Error   IsNotLibrary ;

  Library    Updated   = Error   IsNotLibrary ;

  s.TypeMode s.Type    = Compile s.Type       ;
}

ScanSubModule-SwSelect {
  Cluster Error Fails
  (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName =
    t.hContext t.hErrorList NotFound t.ModuleName;

  s.Status Error s.ErrorType
  (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName =
    t.hContext t.hErrorList s.ErrorType t.ModuleName;

  Cluster Compile s.Type
  (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName =
    <Compile
      s.Type
      (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName
    >;

  Ready Compile s.Type
  (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName =
    <Compile-OnSuccessCompiled
      t.ModuleName
      <MSymModule::LoadInfo t.hContext t.hErrorList t.ModuleName>
    >;
}

Compile-OnSuccessCompiled {
  t.ModuleName t.hContext t.hErrorList Success s.Errors t.hSymIModule =
    t.hContext t.hErrorList
    <MakeSuccessResult
      <MIModule::GetModuleAttribute t.hSymIModule ModuleType>
    >;

  t.ModuleName t.hContext t.hErrorList Fails =
    /*
      Compile-OnSuccessCompiled вызывается только на стадии Ready,
      это значит, что стадия грозди была выполнена успешно,
      а на ней считывается информация о межмодульных связях.
      Поэтому ошибочное прочтение тут совершенно неожиданно.
    */
    <MSelfDiag::Error
      'Compile-OnSuccessCompiled-Aux:\n'
      '  Unexpected fail on reading module interface information (MII).\n'
      '  Glitch appears while loading MII in module '
      <MQualifiedName::ToPrintable-Dot t.ModuleName> '.'
    >;
}

MakeSuccessResult
  t.hIModule Found s.ModuleType =
    Success t.hIModule s.ModuleType;

//------------------------------------------------------------------------------

/**
  <Compile
    s.Type
    (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName
  >
    == t.hContext t.hErrorList Success t.hIModule s.ModuleType
    == t.hContext t.hErrorList Fails t.ModuleName

  s.Type ::= Updated | Library
*/
Compile {
  s.Type
  (e.Stack) t.Config t.hErrorList t.hContext t.ModuleName =
    <OutModuleStatus-Start-ByType s.Type t.ModuleName>
    <UpdateContext
      s.Type
      <Compile-Aux
        s.Type
        (e.Stack) t.Config t.ModuleName
        <MLambda::Apply
          <LoadInfo-ByType s.Type>
          t.Config t.hContext t.hErrorList t.ModuleName
        >
      >
    >;
}

LoadInfo-ByType {
  Recompile = & Parse;
  s.Other   = & LoadInfo;
}

OutModuleStatus-Start-ByType {
  Recompile t.ModuleName = <MOutModuleStatus::Compiling-Q t.ModuleName>;
  s.Other   t.ModuleName = /* ничего */;
}

/**
  <Compile-Aux
    s.Type
    (e.Stack) t.Config t.ModuleName
    t.hContext t.hErrorList Success s.Errors t.hSymIModule / Fails
  >
    == t.hContext t.hErrorList Success t.hIModule s.ModuleType
    == t.hContext t.hErrorList Fails t.ModuleName

  s.Type ::= Recompile | Updated | Library
*/
Compile-Aux {
  s.Type
  (e.Stack) t.Config t.ModuleName
  t.hContext t.hErrorList Success s.ParseResult t.hSymIModule =
    <Compile-AnalyzeImports
      s.Type s.ParseResult t.Config (e.Stack)
      t.ModuleName t.hContext
      <GetImportList t.hErrorList t.hSymIModule>
    >;

  s.Type
  (e.Stack) t.Config t.ModuleName
  t.hContext t.hErrorList Fails =
    (t.hContext t.hErrorList) Fails t.ModuleName;
}

Compile-AnalyzeImports {
  s.Type s.ParseResult t.Config (e.Stack)
  t.ModuleName t.hContext
  s.ModuleListResult t.hErrorList t.hSymIModule e.Imports =
    <Compile-Cache
      <Synthesis
        s.Type t.Config t.ModuleName t.hSymIModule
        <MLambda::MapReduce
          <MLambda::BindLeft
            & CallScanSubModule
            s.Type (e.Stack t.ModuleName) t.Config
          >
          (
            t.hContext
            <MultiplyResult s.ParseResult s.ModuleListResult>
            t.hErrorList
          )
          e.Imports
        >
      >
    >;
}

MultiplyResult {
  Errors s.Result2 = Errors;
  s.Result1 Errors = Errors;
  Warnings s.Result2 = Warnings;
  s.Result1 Warnings = Warnings;
  Success Success = Success;
}

CallScanSubModule {
  s.Type (e.Stack) t.Config
  (t.hContext s.Result t.hErrorList) (t.SrcPos t.AliasName t.RealName) =
    <CallScanSubModule-Aux
      s.Type t.AliasName t.SrcPos s.Result
      <ScanSubModule
        s.Type (e.Stack) t.Config
        t.hContext t.hErrorList t.SrcPos t.RealName
      >
    >;
}

CallScanSubModule-Aux {
  s.Type t.AliasName t.SrcPos s.Result
  t.hContext t.hErrorList
  Success t.hIModule Regular =
    (t.hContext s.Result t.hErrorList) (t.AliasName t.hIModule);

  s.Type t.AliasName t.SrcPos s.Result
  t.hContext t.hErrorList
  Success t.hIModule Main =
    <MIModule::Destroy t.hIModule>
    (
      t.hContext
      Errors
      <MError::AddImportHead t.hErrorList t.SrcPos t.AliasName>
    )
    (t.AliasName BrokenModule);

  s.Type t.AliasName t.SrcPos s.Result
  t.hContext t.hErrorList
  Fails t.RealName =
    (
      t.hContext
      Errors
      <MError::AddBrokenImport t.hErrorList t.SrcPos t.RealName>
    )
    (t.AliasName BrokenModule);

  s.Type t.AliasName t.SrcPos s.Result
  t.hContext t.hErrorList
  NotFound t.RealName =
    (
      t.hContext
      Errors
      <MError::AddModuleNotFound t.hErrorList t.SrcPos t.RealName>
    )
    (t.AliasName BrokenModule);

  Library t.AliasName t.SrcPos s.Result
  t.hContext t.hErrorList
  IsNotLibrary t.RealName =
    (
      t.hContext
      Errors
      <MError::DependedFromSource t.hErrorList t.SrcPos t.RealName>
    )
    (t.AliasName BrokenModule);
}

/**
  <Synthesis
    s.Type t.Config t.ModuleName t.hContext s.Result
    (t.hErrorList t.hRawModule)
    (t.SubModuleAlias t.hISubModule)*
  >
    == t.hContext t.hErrorList t.hIModule e.ValidScannedImports
    == t.hContext t.hErrorList Fails t.ModuleName
*/
Synthesis {
  Recompile t.Config t.ModuleName t.hRawIModule
  (t.hContext s.Result t.hErrorList) e.ImportInfo =
    <Synthesis-Generate
      t.Config t.ModuleName t.hContext
      <Resolve
        t.hRawIModule t.hErrorList s.Result e.ImportInfo
      >
    >;

  s.Type t.Config t.ModuleName t.hSymIModule
  (t.hContext s.Result t.hErrorList) e.ImportInfo =
    <SwNotCompilingModules
      t.hContext t.ModuleName
      (t.hErrorList t.hSymIModule s.Result)
      <MLambda::Map & OnlyIModule e.ImportInfo>
    >;
}

OnlyIModule {
  (t.Alias BrokenModule) = /* пусто */;

  (t.Alias t.hSymIModule) = t.hSymIModule;
}  

Synthesis-Generate {
  t.Config t.ModuleName t.hContext
  t.hIModule t.hErrorList Errors e.Imports =
    <MLambda::Map & MIModule.Destroy t.hIModule e.Imports>
    t.hContext t.hErrorList Fails t.ModuleName;

  t.Config t.ModuleName t.hContext
  t.hIModule t.hErrorList s.SuccessOrWarnings e.Imports =
    <Synthesis-SwGenerate
      t.hErrorList t.ModuleName
      <MConfig::Generate t.Config t.hContext t.hIModule t.ModuleName>
      e.Imports
    >;
}

Synthesis-SwGenerate {
  t.hErrorList t.ModuleName
  t.hContext t.hIModule Success e.Imports =
    t.hContext t.hErrorList <MSymModule::SymReduce t.hIModule> e.Imports;

  t.hErrorList t.ModuleName
  t.hContext t.hIModule Fails e.Imports =
    <MIModule::Destroy t.hIModule e.Imports>
    t.hContext t.hErrorList Fails t.ModuleName;
}

SwNotCompilingModules {
  t.hContext t.ModuleName
  (t.hErrorList t.hSymIModule Errors)
  e.InvalidScannedImports =
    t.hContext t.hErrorList Fails t.ModuleName
    <MIModule::Destroy t.hSymIModule>
    <MLambda::Map & MIModule.Destroy e.InvalidScannedImports>;

  t.hContext t.ModuleName
  (t.hErrorList t.hSymIModule s.SuccessOrWarnings)
  e.ValidScannedImports =
    t.hContext t.hErrorList t.hSymIModule e.ValidScannedImports;
}

/**
  <Compile-Cache
    t.hContext t.hErrorList t.hIModule e.ValidScannedImports
  >
  <Compile-Cache
    t.hContext t.hErrorList Fails t.ModuleName
  >
*/
Compile-Cache {
  t.hContext t.hErrorList Fails t.ModuleName =
    t.hContext t.hErrorList Fails t.ModuleName;

  t.hContext t.hErrorList t.hIModule e.ValidScannedImports =
    <Compile-Cache-ModuleName
      t.hContext t.hErrorList
      <MIModule::GetModuleName t.hIModule>
      e.ValidScannedImports
    >;
}

Compile-Cache-ModuleName {
  t.hContext t.hErrorList t.hIModule t.ModuleName e.ValidScannedImports =
    <Compile-Cache-ModuleType
      t.hErrorList
      <MIModule::GetModuleAttribute t.hIModule ModuleType>
      <MContext::SetCachedImports_
        t.hContext t.ModuleName
        <MLambda::Map
          <MLambda::Composite
            & MIModule.GetModuleName
            & DestroySymModule
          >
          e.ValidScannedImports
        >
      >
    >;
}

DestroySymModule {
  t.hSymIModule t.ModuleName =
    <MIModule::Destroy t.hSymIModule>
    t.ModuleName;
}

Compile-Cache-ModuleType {
  t.hErrorList
  t.hSymIModule Found s.ModuleType
  t.hContext Success =
    t.hContext t.hErrorList Success t.hSymIModule s.ModuleType;
}

//------------------------------------------------------------------------------

/**
  <UpdateContext s.Type e.CompileResult>
    == e.CompileResult
  e.CompileResult ::=
    t.hContext t.hErrorList e.SubResult
  e.SubResult ::= Success t.hIModule s.ModuleType | Fails t.ModuleName
*/

UpdateContext {
  s.Type
  t.hContext t.hErrorList Success t.hIModule s.ModuleType =
    <UpdateContext-Aux
      s.Type (t.hContext t.hErrorList) s.ModuleType
      <MIModule::GetModuleName t.hIModule>
    >;

  s.Type
  t.hContext t.hErrorList Fails t.ModuleName =
    <MOutModuleStatus::Fails-Q t.ModuleName>
    <GuardUpdate
      <MContext::FinishModule_
        t.hContext t.ModuleName Regular Errors
      >
    >
    t.hErrorList
    Fails t.ModuleName;
}

GuardUpdate
  t.hContext Success = t.hContext;

UpdateContext-Aux {
  s.Type (t.hContext t.hErrorList) s.ModuleType
  t.hIModule t.ModuleName =
    <OutModuleStatus-Finish-ByType s.Type t.ModuleName>
    <UpdateContext-AfterUpdate
      t.hErrorList t.hIModule s.ModuleType
      <MContext::FinishModule_
        t.hContext t.ModuleName s.ModuleType s.Type
      >
    >;
}

UpdateContext-AfterUpdate
  t.hErrorList t.hIModule s.ModuleType t.hContext Success =
    t.hContext t.hErrorList Success t.hIModule s.ModuleType;

OutModuleStatus-Finish-ByType {
  Recompile t.ModuleName = <MOutModuleStatus::Compiled-Q t.ModuleName>;
  Updated   t.ModuleName = <MOutModuleStatus::Updated-Q  t.ModuleName>;
  Library   t.ModuleName = <MOutModuleStatus::Library-Q  t.ModuleName>;
}

//------------------------------------------------------------------------------

/**
  <Resolve
    t.hIModule t.hErrorList s.Result e.ImportInfo
  >
    == t.hIModule t.hErrorList s.Result t.hImportIModule*
  e.ImportInfo ::= (t.RelativeAlias t.hImportIModule)*
  s.Result ::= Success | Errors
*/
Resolve {
  t.hIModule t.hErrorList s.Result e.ImportInfo =
    <Resolve-Aux
      t.hErrorList s.Result
      <MLambda::MapReduce
        <MLambda::Composite
          & MLambda.UnBracket-H
          & Driver.MResolver.AddModuleInfo
        >
        <Driver::MResolver::Create>
        (NoPrefix t.hIModule) e.ImportInfo
      >
    >;
}

Resolve-Aux {
  t.hErrorList s.Result t.hResolveTable t.hIModule e.ImportModules =
    <Resolve-SwResolve
      s.Result
      <Driver::MResolver::Resolve
        t.hIModule t.hErrorList t.hResolveTable
      >
      e.ImportModules
    >;
}

Resolve-SwResolve {
  s.PrevResult t.hIModule s.Result t.hErrorList e.ImportedModules =
    t.hIModule t.hErrorList
    <MultiplyResult s.PrevResult s.Result>
    e.ImportedModules;
}

//------------------------------------------------------------------------------

/**
  <LoadInfo t.Config t.hContext t.hErrorList t.ModuleName>
    == t.hContext t.hErrorList Success s.Result t.hSymIModule
    == t.hContext t.hErrorList Fails

  s.Result ::= Success | Warnings | Errors
*/
LoadInfo {
  t.Config t.hContext t.hErrorList t.ModuleName =
    <MSymModule::LoadInfo t.hContext t.hErrorList t.ModuleName>;
}

//------------------------------------------------------------------------------

/**
  <Parse t.Config t.hContext t.hErrorList t.ModuleName>
    == t.hContext t.hErrorList Success s.Result t.hRawIModule
    == t.hContext t.hErrorList Fails

  s.Result ::= Success | Warnings | Errors
*/
Parse
  t.Config t.hContext t.hErrorList t.ModuleName =
    <Parse-SelectFE
      t.Config t.hErrorList t.ModuleName
      <MContext::GetFrontEnd t.hContext t.ModuleName>
    >;

Parse-SelectFE {
  t.Config t.hErrorList t.ModuleName t.hContext Success None =
    // Неожиданно. Вообще-то тут не может быть библиотека.
    t.hContext t.hErrorList Fails;

  t.Config t.hErrorList t.ModuleName t.hContext Success s.FEName e.Path =
    t.hContext
    <MConfig::Load t.Config s.FEName t.hErrorList t.ModuleName e.Path>;

  t.Config t.hErrorList t.ModuleName t.hContext Fails s.Reason =
    t.hContext t.hErrorList Fails;
}

//------------------------------------------------------------------------------

/**
  <GetImportList t.hErrorList t.hIModule>
    == s.Result t.hErrorList t.hIModule e.Import
  s.Result ::= Success | Fails
  e.Import ::= (t.SrcPos t.AliasName t.RealName)*
*/
GetImportList {
  t.hErrorList t.hIModule =
    <GetImportList-CheckValidNames
      t.hErrorList
      <MLambda::MapReduce
        & PrepareImportList-Aliases
        <MIModule::GetImportList-Aliases t.hIModule>
      >
    >;
}

/*
  <PrepareImportList-Aliases t.hIModule t.NextImportAlias>
    == t.hIModule (t.NextImport t.RealName)
*/
PrepareImportList-Aliases
  t.hIModule t.NextImport =
    <PrepareImportList-RealName
      t.NextImport
      <MIModule::GetImportAttribute-AliasName
        t.hIModule RealName t.NextImport
      >
    >;

PrepareImportList-RealName {
  t.NextImport t.hIModule Found t.RealName =
    <PrepareImportList-SrcPos
      t.NextImport t.RealName
      <MIModule::GetImportAttribute-AliasName
        t.hIModule Position t.NextImport
      >
    >;
}

PrepareImportList-SrcPos {
  t.NextImport t.RealName t.hIModule Found t.SrcPos =
    <PrepareImportList-RelativeAliasName
      t.SrcPos t.RealName
      <MIModule::RelativeName t.hIModule t.NextImport>
    >;
}

PrepareImportList-RelativeAliasName {
  t.SrcPos t.RealName t.hIModule Success t.AliasName =
    t.hIModule (t.SrcPos t.AliasName t.RealName);
}

GetImportList-CheckValidNames {
  t.hErrorList t.hIModule e.ImportList =
    <GetImportList-CheckValidNames-UpdateResult
      <DoCheckValidNames
        Success t.hErrorList t.hIModule () e.ImportList
      >
    >;
}

GetImportList-CheckValidNames-UpdateResult {
  s.Result t.hErrorList t.hIModule e.ImportList =
    s.Result t.hErrorList t.hIModule e.ImportList;
}

DoCheckValidNames {
  s.Result t.hErrorList t.hIModule (e.Scanned)
  (t.SrcPos t.Alias t.RealName) e.Tail =
    <DoCheckValidNames-SwValid
      s.Result t.hErrorList t.hIModule (e.Scanned)
      t.SrcPos t.Alias <CheckName t.RealName>
      e.Tail
    >;

  s.Result t.hErrorList t.hIModule (e.Scanned) =
    s.Result t.hErrorList t.hIModule e.Scanned;
}

CheckName {
  t.RealName =
    <CheckName-Parsed
      <MQualifiedName::Parse-T t.RealName>
    >;
}

CheckName-Parsed {
  t.RealName e.Segments-B (e.Name-B '?' e.Name-E) e.Segments-E =
    Invalid t.RealName;

  t.RealName e.Segments =
    Valid t.RealName;
}

DoCheckValidNames-SwValid {
  s.Result t.hErrorList t.hIModule (e.Scanned)
  t.SrcPos t.Alias Valid t.RealName e.Tail =
    <DoCheckValidNames
      s.Result t.hErrorList t.hIModule
      (e.Scanned (t.SrcPos t.Alias t.RealName)) e.Tail
    >;

  s.Result t.hErrorList t.hIModule (e.Scanned)
  t.SrcPos t.Alias Invalid t.RealName e.Tail =
    <DoCheckValidNames
      Fails
      <MError::AddInvalidImportName
        t.hErrorList t.SrcPos t.RealName
      >
      t.hIModule
      (e.Scanned) e.Tail
    >;
}

$END Driver::MCompiler.
