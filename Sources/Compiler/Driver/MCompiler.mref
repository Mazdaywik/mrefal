$MODULE Driver::MCompiler;

$IMPORT Driver::MConfig;
$IMPORT Driver::MModuleIF;
$IMPORT MError;
$IMPORT MOutModuleStatus;

$IMPORT MLookupTable = Driver::Tables::MLookup;
$IMPORT MModuleTable = Driver::Tables::MModules;
$IMPORT MTables      = Driver::MTables;

/**
  <Make t.hTables t.hErrorList t.Config t.SrcPos t.RootModuleName>
    == t.hTables t.hErrorList Success
    == t.hTables t.hErrorList Fails
*/
$ENTRY Make
  t.hTables t.hErrorList t.Config t.SrcPos t.RootModuleName =
    <Make-SwResult
      t.Config t.RootModuleName
      <ExternalName
        Recompile
        () t.Config t.hTables t.hErrorList
        t.SrcPos t.RootModuleName
      >
    >;

Make-SwResult {
  t.Config t.RootModuleName
  t.hTables t.hErrorList CantLoadInterface =
    t.hTables t.hErrorList Fails;

  t.Config t.RootModuleName
  t.hTables t.hErrorList t.ModuleIF =
    <Make-SwMainModule
      t.Config t.hTables t.hErrorList t.RootModuleName
      <Driver::MModuleIF::GetModuleType t.ModuleIF>
    >;
}

Make-SwMainModule {
  t.Config t.hTables t.hErrorList t.RootModuleName Main =
    <Make-Aux
      <Driver::MConfig::Link t.Config t.hTables t.RootModuleName>
      t.hErrorList
    >;

  t.Config t.hTables t.hErrorList t.RootModuleName Regular =
    <MOutModuleStatus::Flush>
    t.hTables t.hErrorList Success;
}

Make-Aux
  t.hTables s.Result t.hErrorList =
    t.hTables t.hErrorList s.Result;

//------------------------------------------------------------------------------

/**
  <ExternalName
    s.Type (e.Stack)
    t.Config t.hTables t.hErrorList t.SrcPos t.ImportName
  >
    == t.hTables t.hErrorList t.Interface_
  s.Type ::= Recompile | Updated | Library
  t.Interface ::= t.ModuleIF | CantLoadInterface
*/
$ENTRY ExternalName {
  s.Type (e.Stack-B t.ImportName e.Stack-E)
  t.Config t.hTables t.hErrorList t.SrcPos t.ImportName =
    t.hTables
    <MError::AddRecursiveLoop
      t.hErrorList t.SrcPos t.ImportName e.Stack-E t.ImportName
    >
    CantLoadInterface;

  s.Type (e.Stack)
  t.Config t.hTables t.hErrorList t.SrcPos t.ImportName =
    <ExternalName-SwKnown
      s.Type (e.Stack) t.Config
      t.hErrorList t.SrcPos t.ImportName
      <MTables::Lookup
        t.hTables & MLookupTable.LookupResult t.ImportName
      >
    >;
}

ExternalName-SwKnown {
  s.Type (e.Stack) t.Config
  t.hErrorList t.SrcPos t.ImportName t.hTables Unknown =
    <ExternalName-OnUnknown
      s.Type (e.Stack) t.Config
      t.hTables t.hErrorList t.SrcPos t.ImportName
    >;

  s.Type (e.Stack) t.Config
  t.hErrorList t.SrcPos t.ImportName t.hTables Success =
    <ExternalName-OnKnown-StatusType
      s.Type (e.Stack)
      t.hErrorList t.SrcPos t.ImportName
      <MTables::Modules
        t.hTables &MModuleTable.GetStatusType t.ImportName
      >
    >;

  s.Type (e.Stack) t.Config
  t.hErrorList t.SrcPos t.ImportName t.hTables Error e.Error =
    t.hTables
    <ExternalName-AddImportError
      t.hErrorList t.SrcPos t.ImportName e.Error
    >
    CantLoadInterface;
}

ExternalName-AddImportError {
  t.hErrorList t.SrcPos t.ImportName CantLoadModule =
    <MError::AddModuleNotFound
      t.hErrorList t.SrcPos t.ImportName
    >;

  t.hErrorList t.SrcPos t.ImportName MismatchWithInternal t.InternalName =
    <MError::AddMismatchInternalAndExternalNames
      t.hErrorList t.SrcPos t.InternalName t.ImportName
    >;

  t.hErrorList t.SrcPos t.ImportName Tree-ModulePacket s.Conflict t.KnownName =
    <MError::AddTreeModulePacketConflict
      t.hErrorList t.SrcPos t.ImportName s.Conflict t.KnownName
    >;

  t.hErrorList t.SrcPos t.ImportName Tree-CaseError t.ValidCaseName =
    <MError::AddTreeCaseError
      t.hErrorList t.SrcPos t.ImportName t.ValidCaseName
    >;
}

ExternalName-OnKnown-StatusType {
  s.TypeMode (e.Stack) t.hErrorList t.SrcPos t.ImportName
  t.hTables Success Ready s.Type =
    <ExternalName-OnKnown-StatusType-SwTranslated
      (e.Stack) t.hTables t.hErrorList
      t.SrcPos t.ImportName <TranslateType s.TypeMode s.Type>
    >;
}

TranslateType {
  s.TypeMode Errors    = CantLoadInterface;
  Updated    Recompile = CantLoadInterface;
  Library    Recompile = IsNotLibrary;
  Library    Updated   = IsNotLibrary;
  s.TypeMode s.Type    = LoadInterface;
}

ExternalName-OnKnown-StatusType-SwTranslated {
  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName CantLoadInterface =
    t.hTables
    <MError::AddBrokenImport
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName IsNotLibrary =
    t.hTables
    <MError::DependedFromSource
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName LoadInterface =
    t.hTables t.hErrorList
    <ExternalName-CheckModuleType
      <Step-From-Stack e.Stack>
      <Driver::MModuleIF::LoadCached t.hTables t.ImportName>
      t.hErrorList t.SrcPos t.ImportName
    >;
}

Step-From-Stack {
  /* пустой стек */ = RootModule;
  e.NotEmptyStack   = ImportModule;
}

ExternalName-CheckModuleType {
  s.Step t.hTables t.ModuleIF
  t.hErrorList t.SrcPos t.ImportName =
    <ExternalName-SwCheckModuleType
      t.hTables t.hErrorList t.SrcPos t.ImportName
      s.Step <Driver::MModuleIF::GetModuleType-T t.ModuleIF>
    >;
}

ExternalName-SwCheckModuleType {
  t.hTables t.hErrorList t.SrcPos t.ImportName
  ImportModule t.ModuleIF Main =
    t.hTables
    <MError::AddImportHead
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  t.hTables t.hErrorList t.SrcPos t.ImportName
  s.Step t.ModuleIF s.ModuleType =
    t.hTables t.hErrorList t.ModuleIF;
}

//------------------------------------------------------------------------------

/**
  <ProcessModule
    (e.Stack)
    t.Config t.hTables t.hErrorList t.ModuleName
  >
    == t.hTables t.hErrorList Success s.ErrorStatus t.ModuleIF
    == t.hTables t.hErrorList Fails s.Error

  s.ErrorStatus ::= Success | Warnings | Errors
  s.Error ::= CantLoadModule
*/

$END Driver::MCompiler.
