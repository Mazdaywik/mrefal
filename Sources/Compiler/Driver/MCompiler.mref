$MODULE Driver::MCompiler;

$IMPORT Driver::MConfig;
$IMPORT Driver::MModuleFinder;
$IMPORT Driver::MModuleIF;
$IMPORT MError;
$IMPORT MIModule;
$IMPORT MOutModuleStatus;

$IMPORT MLookupTable = Driver::Tables::MLookup;
$IMPORT MModuleTable = Driver::Tables::MModules;
$IMPORT MModuleTree  = Driver::Tables::MModuleTree;
$IMPORT MTables      = Driver::MTables;

/**
  <Make t.hTables t.hErrorList t.Config t.SrcPos t.RootModuleName>
    == t.hTables t.hErrorList Success
    == t.hTables t.hErrorList Fails
*/
$ENTRY Make
  t.hTables t.hErrorList t.Config t.SrcPos t.RootModuleName =
    <Make-SwResult
      t.Config t.RootModuleName
      <ExternalName
        Recompile
        () t.Config t.hTables t.hErrorList
        t.SrcPos t.RootModuleName
      >
    >;

Make-SwResult {
  t.Config t.RootModuleName
  t.hTables t.hErrorList CantLoadInterface =
    t.hTables t.hErrorList Fails;

  t.Config t.RootModuleName
  t.hTables t.hErrorList t.ModuleIF =
    <Make-SwMainModule
      t.Config t.hTables t.hErrorList t.RootModuleName
      <Driver::MModuleIF::GetModuleType t.ModuleIF>
    >;
}

Make-SwMainModule {
  t.Config t.hTables t.hErrorList t.RootModuleName Main =
    <Make-Aux
      <Driver::MConfig::Link t.Config t.hTables t.RootModuleName>
      t.hErrorList
    >;

  t.Config t.hTables t.hErrorList t.RootModuleName Regular =
    <MOutModuleStatus::Flush>
    t.hTables t.hErrorList Success;
}

Make-Aux
  t.hTables s.Result t.hErrorList =
    t.hTables t.hErrorList s.Result;

//------------------------------------------------------------------------------

/**
  <ExternalName
    s.Type (e.Stack)
    t.Config t.hTables t.hErrorList t.SrcPos t.ImportName
  >
    == t.hTables t.hErrorList t.Interface_
  s.Type ::= Recompile | Updated | Library
  t.Interface_ ::= t.ModuleIF | CantLoadInterface
*/
$ENTRY ExternalName {
  s.Type (e.Stack-B t.ImportName e.Stack-E)
  t.Config t.hTables t.hErrorList t.SrcPos t.ImportName =
    t.hTables
    <MError::AddRecursiveLoop
      t.hErrorList t.SrcPos t.ImportName e.Stack-E t.ImportName
    >
    CantLoadInterface;

  s.Type (e.Stack)
  t.Config t.hTables t.hErrorList t.SrcPos t.ImportName =
    <ExternalName-CheckLookup
      s.Type (e.Stack)
      t.Config t.hTables t.hErrorList t.SrcPos t.ImportName
    >;
}

ExternalName-CheckLookup {
  s.Type (e.Stack)
  t.Config t.hTables t.hErrorList t.SrcPos t.ImportName =
    <ExternalName-SwSuccessModule
      <ExternalName-SwKnown
        s.Type (e.Stack) t.Config
        t.hErrorList t.SrcPos t.ImportName
        <MTables::Lookup
          t.hTables & MLookupTable.LookupResult t.ImportName
        >
      >
    >;
}

ExternalName-SwKnown {
  s.Type (e.Stack) t.Config
  t.hErrorList t.SrcPos t.ImportName t.hTables Unknown =
    s.Type (e.Stack) t.SrcPos t.ImportName
    <OnUnknown
      (e.Stack) t.Config t.hTables t.hErrorList t.ImportName
    >;

  s.Type (e.Stack) t.Config
  t.hErrorList t.SrcPos t.ImportName t.hTables e.Known =
    s.Type (e.Stack) t.SrcPos t.ImportName
    t.hTables t.hErrorList e.Known;
}

ExternalName-SwSuccessModule {
  s.Type (e.Stack) t.SrcPos t.ImportName
  t.hTables t.hErrorList Success =
    <ExternalName-OnKnown-StatusType
      s.Type (e.Stack)
      t.hErrorList t.SrcPos t.ImportName
      <MTables::Modules
        t.hTables &MModuleTable.GetStatusType t.ImportName
      >
    >;

  s.Type (e.Stack) t.SrcPos t.ImportName
  t.hTables t.hErrorList Error e.Error =
    t.hTables
    <ExternalName-AddImportError
      t.hErrorList t.SrcPos t.ImportName e.Error
    >
    CantLoadInterface;
}

ExternalName-AddImportError {
  t.hErrorList t.SrcPos t.ImportName CantLoadModule =
    <MError::AddModuleNotFound
      t.hErrorList t.SrcPos t.ImportName
    >;

  t.hErrorList t.SrcPos t.ImportName MismatchWithInternal t.InternalName =
    <MError::AddMismatchInternalAndExternalNames
      t.hErrorList t.SrcPos t.InternalName t.ImportName
    >;

  t.hErrorList t.SrcPos t.ImportName Tree-ModulePacket s.Conflict t.KnownName =
    <MError::AddTreeModulePacketConflict
      t.hErrorList t.SrcPos t.ImportName s.Conflict t.KnownName
    >;

  t.hErrorList t.SrcPos t.ImportName Tree-CaseError t.ValidCaseName =
    <MError::AddTreeCaseError
      t.hErrorList t.SrcPos t.ImportName t.ValidCaseName
    >;
}

$IMPORT MSelfDiag; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!

ExternalName-OnKnown-StatusType {
  s.TypeMode (e.Stack) t.hErrorList t.SrcPos t.ImportName
  t.hTables Success Ready s.Type =
    <MSelfDiag::Log '<ExternalName-OnKnown-StatusType> Ready'>
    <MSelfDiag::Log>
    <ExternalName-OnKnown-StatusType-SwTranslated
      (e.Stack) t.hTables t.hErrorList
      t.SrcPos t.ImportName <TranslateType s.TypeMode s.Type>
    >;

  s.TypeMode (e.Stack) t.hErrorList t.SrcPos t.ImportName
  t.hTables Success Cluster s.Type =
    <MSelfDiag::Log '<ExternalName-OnKnown-StatusType> Cluster'>
    <MSelfDiag::Log>
    <ExternalName-OnKnown-StatusType-SwTranslated
      (e.Stack) t.hTables t.hErrorList
      t.SrcPos t.ImportName <TranslateType s.TypeMode s.Type>
    >;
}

TranslateType {
  s.TypeMode Errors    = CantLoadInterface;
  Updated    Recompile = CantLoadInterface;
  Library    Recompile = IsNotLibrary;
  Library    Updated   = IsNotLibrary;
  s.TypeMode s.Type    = LoadInterface;
}

ExternalName-OnKnown-StatusType-SwTranslated {
  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName CantLoadInterface =
    t.hTables
    <MError::AddBrokenImport
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName IsNotLibrary =
    t.hTables
    <MError::DependedFromSource
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  (e.Stack) t.hTables t.hErrorList
  t.SrcPos t.ImportName LoadInterface =
    t.hTables t.hErrorList
    <ExternalName-CheckModuleType
      <Step-From-Stack e.Stack>
      <Driver::MModuleIF::LoadCached t.hTables t.ImportName>
      t.hErrorList t.SrcPos t.ImportName
    >;
}

Step-From-Stack {
  /* пустой стек */ = RootModule;
  e.NotEmptyStack   = ImportModule;
}

ExternalName-CheckModuleType {
  s.Step t.hTables t.ModuleIF
  t.hErrorList t.SrcPos t.ImportName =
    <ExternalName-SwCheckModuleType
      t.hTables t.hErrorList t.SrcPos t.ImportName
      t.ModuleIF s.Step
      <Driver::MModuleIF::GetModuleType t.ModuleIF>
    >;
}

ExternalName-SwCheckModuleType {
  t.hTables t.hErrorList t.SrcPos t.ImportName
  t.ModuleIF ImportModule Main =
    t.hTables
    <MError::AddImportHead
      t.hErrorList t.SrcPos t.ImportName
    >
    CantLoadInterface;

  t.hTables t.hErrorList t.SrcPos t.ImportName
  t.ModuleIF s.Step s.ModuleType =
    t.hTables t.hErrorList t.ModuleIF;
}

//------------------------------------------------------------------------------

/**
  <OnUnknown (e.Stack) t.Config t.hTables t.hErrorList t.ImportName>
    == t.hTables t.hErrorList e.KnownModuleState
  e.KnownModuleState ::=
    Success |
    Error Error-CantLoadModule |
    Error Error-MismatchWithInternal t.InternalName |
    Error Error-Tree-ModulePacket s.Conflict t.KnownName |
    Error Error-Tree-CaseError t.ValidCaseName
*/
OnUnknown {
  (e.Stack) t.Config t.hTables t.hErrorList t.ImportName =
    <OnUnknown-CheckModuleTree
      (e.Stack) t.Config
      <MTables::ModuleTree
        t.hTables
        & MModuleTree.CheckSpace t.ImportName
      >
      t.hErrorList t.ImportName
    >;
}

OnUnknown-CheckModuleTree {
  (e.Stack) t.Config
  t.hTables AvailSpace
  t.hErrorList t.ImportName =
    <OnUnknown-CheckLookupModule
      (e.Stack) t.Config
      <Driver::MConfig::CheckNeedCompile_NEW
        t.hErrorList t.hTables t.Config t.ImportName
      >
    >;

  (e.Stack) t.Config
  t.hTables Collision s.CollisionType t.KnownName t.InputName
  t.hErrorList t.ImportName =
    <OnUnknown-CreateErrorResult
      t.hErrorList t.hTables
      <OnUnknown-CheckModuleTree-CreateError
        t.ImportName s.CollisionType t.KnownName
      >
    >;

  // Вариант ModuleExists не рассматриваем, т.к. модуль здесь неизвестен.
}

OnUnknown-CheckModuleTree-CreateError {
  t.ImportName ModuleOverPacket t.KnownPacketName =
    (Error Error-Tree-ModulePacket)
    & MLookupTable.AddError-Tree-ModulePacket
    ModuleOverPacket t.KnownPacketName;

  t.ImportName PacketOverModule t.KnownModuleName =
    (Error Error-Tree-ModulePacket)
    & MLookupTable.AddError-Tree-ModulePacket
    PacketOverModule t.KnownModuleName;

  t.ImportName s.CaseCollisionError t.CaseValidName =
    (Error Error-Tree-CaseError)
    & MLookupTable.AddError-Tree-CaseError t.CaseValidName;
}

OnUnknown-CreateErrorResult {
  t.hErrorList t.hTables (e.ErrorResult)
  s.FnUpdateLookup e.UpdateLookupParam =
    t.hErrorList
    <MTables::Lookup
      t.hTables s.FnUpdateLookup e.UpdateLookupParam
    >
    e.ErrorResult;
}

OnUnknown-CheckLookupModule {
  (e.Stack) t.Config t.ImportName
  t.hErrorList t.hTables Success Cluster Errors =
    t.hTables t.hErrorList Error Error-CantLoadModule;

  (e.Stack) t.Config t.ImportName
  t.hErrorList t.hTables Success Cluster s.Type =
    <Compile
      s.Type (e.Stack) t.Config t.hTables t.hErrorList t.ImportName
    >;
}

/**
  <Compile
    s.Type (e.Stack) t.Config t.hTables t.hErrorList t.ModuleName
  >
    == t.hTables t.hErrorList e.KnownModuleState
  e.KnownModuleState ::=
    Success |
    Error Error-CantLoadModule |
    Error Error-MismatchWithInternal t.InternalName |
*/
Compile {
  s.Type (e.Stack) t.Config t.hTables t.hErrorList t.ImportName =
    <Compile-SwLoad
      s.Type (e.Stack) t.Config t.ImportName
      <Driver::MConfig::LoadModule
        s.Type t.Config t.hTables t.hErrorList t.ImportName
      >
    >;
}

Compile-SwLoad {
  s.Type (e.Stack) t.Config t.ModuleName
  t.hTables t.hErrorList Success s.ParseResult t.hRawIModule =
    <Compile-CompareWithPhysical
      s.Type (e.Stack) t.Config t.ModuleName
      t.hTables t.hErrorList s.ParseResult
      <MIModule::GetModuleName t.hRawIModule>
    >;

  s.Type (e.Stack) t.Config t.ModuleName
  t.hTables t.hErrorList Fails =
    <MTables::Lookup
      t.hTables
      & MLookupTable.AddError-CantLoadModule t.ModuleName
    >
    t.hErrorList Error Error-CantLoadModule;
}

Compile-CompareWithPhysical {
  s.Type (e.Stack) t.Config t.ModuleName
  t.hTables t.hErrorList s.ParseResult
  t.hRawIModule t.InternalName =
    <Compile-CompareWithPhysical-Aux
      s.Type (e.Stack) t.Config t.ModuleName t.InternalName
      t.hTables t.hErrorList s.ParseResult t.hRawIModule
      <Driver::MModuleFinder::PhysicalCompare
        t.ModuleName t.InternalName
      >
    >;
}

Compile-CompareWithPhysical-Aux {
  s.Type (e.Stack) t.Config t.ImportName t.InternalName
  t.hTables t.hErrorList s.ParseResult t.hRawIModule
  Equal =
    <Compile-CheckModuleTree
      s.Type (e.Stack) t.Config t.InternalName
      <MTables::ModuleTree
        t.hTables & MModuleTree.CheckSpace t.InternalName
      >
      t.hErrorList s.ParseResult t.hRawIModule
    >;

  s.Type (e.Stack) t.Config t.ModuleName t.InternalName
  t.hTables t.hErrorList s.ParseResult t.hRawIModule
  NotEqual =
    &!!!!;
}

Compile-CheckModuleTree {
  s.Type (e.Stack) t.Config t.InternalName
  t.hTables AvailSpace
  t.hErrorList s.ParseResult t.hRawIModule =
    <Compile-AddModuleToTreeTable
      s.Type (e.Stack) t.Config t.InternalName
      <MTables::ModuleTree
        t.hTables & MModuleTree.InsertModule t.InternalName
      >
      t.hErrorList s.ParseResult t.hRawIModule
    >;

  /*
    ModuleExist не рассматриваем, т.к. это недопустимо:
    если бы он был в дереве модулей, то мы бы сюда не попали.

    Добавление имени в дерево модулей возможно только при добавлении
    модуля в таблицу поисков (иначе нарушение инварианта).
  */

  s.Type (e.Stack) t.Config t.InternalName
  t.hTables Collision s.CollisionType t.KnownName t.InputName =
    &!!!;
}

Compile-AddModuleToTree {
  s.Type (e.Stack) t.Config t.InternalName
  t.hTables Success t.hErrorList s.ParseResult t.hRawIModule =
    <Compile-AddModuleToLookup
      s.Type (e.Stack) t.Config t.InternalName
      <MTables::Lookup
        t.hTables & MLookupTable.AddSuccessImport t.InternalName
      >
      t.hErrorList s.ParseResult t.hRawIModule
    >;

  // Других вариантов быть не должно
}

Compile-AddModuleToLookup {
  s.Type (e.Stack) t.Config t.InternalName
  t.hTables t.hErrorList s.ParseResult t.hRawIModule =
    &???????????????????????????????;
}

$END Driver::MCompiler.
