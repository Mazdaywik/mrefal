$MODULE FE-MRefal::MParser_MRefal;

$IMPORT MError;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MLexer = FE-MRefal::MLexer;
$IMPORT MParser_Common = FE-MRefal::MParser_Common;
$IMPORT MQualifiedName;
$IMPORT MStrings;
$IMPORT MVarTable = FE-MRefal::MVarTable;

$IMPORT MProfiler;

/**
  <SrcModule t.hErrorList t.QualifiedName e.FileName>
    == t.hErrorList Success s.Result t.IModule
    == t.hErrorList Fails
  s.Result ::= Success | Warnings | Errors
*/
$ENTRY SrcModule
  t.hErrorList t.QualifiedName e.FileName =
    <MProfiler::Quantify
      &Profiling-SrcModule t.hErrorList t.QualifiedName e.FileName
    >;

Profiling-SrcModule
  t.hErrorList t.QualifiedName e.FileName =
    <MParser_Common::GeneralizeInfo
      t.hErrorList
      t.QualifiedName
      <MParser_Common::Parse
        &NModuleBody e.FileName
      >
    >;

//------------------------------------------------------------------------------
// Синтаксический анализ модуля
//------------------------------------------------------------------------------

/*
  ModuleBody =
    { ImportBlock | FunctionDefinition | SwapDefinition | InitFinalBlock }* .

  <NModuleBody t.IModule t.hErrorList t.Lexer t.NextToken >
    == t.hErrorList Success t.IModule
    == t.hErrorList Fails
*/
NModuleBody {
  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Import) =
    <NModuleBody
      <MParser_Common::NImportBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Swap) =
    <NModuleBody
      <NSwapBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Entry) =
    <NModuleBody
      <NFunctionDefinition
        t.IModule
        ( Entry )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Data) =
    <NModuleBody
      <NDataBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Init) =
    <NModuleBody
      <NInitFinalBlock
        t.IModule Init t.SrcPos
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Final) =
    <NModuleBody
      <NInitFinalBlock
        t.IModule Final t.SrcPos
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NModuleBody
      <NFunctionDefinition
        t.IModule
        ( Local )
        t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident)
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    <NModuleBody
      t.IModule
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  /* Завершение рекурсии */
  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos End) =
    <MParser_Common::NModuleTailer
      <FixupEntryPoints t.IModule t.hErrorList t.SrcPos>
      t.Lexer (Directive t.SrcPos End)
    >;

  /* При обнаружении конца файла завершаем анализ */
  t.IModule
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    <MError::AddUnexpected
      t.hErrorList
      (EndOfText t.SrcPos)
      '$entry, $import, $swap or local function definition'
    >
    Success
    t.IModule
    <MLexer::Destroy t.Lexer>;

  /* Любая другая лексема пропускается */
  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    <NModuleBody
      t.IModule
      <MError::AddUnexpected
        t.hErrorList
        t.OtherToken
        '$entry, $import, $swap or local function definition'
      >
      <MLexer::NextToken t.Lexer>
    >;
}

FixupEntryPoints {
  t.hIModule t.hErrorList t.SrcPos =
    <FixupEntryPoints-SwModuleType
      <MIModule::GetModuleAttribute t.hIModule ModuleType>
      t.hErrorList t.SrcPos
    >;
}

FixupEntryPoints-SwModuleType {
  t.hIModule Found Main t.hErrorList t.SrcPos =
    <FixupEntryPoints-Go
      t.hIModule
      <MQualifiedName::Create ('Go')>
      t.hErrorList t.SrcPos
    >;

  t.hIModule Found Regular t.hErrorList t.SrcPos =
    <FixupEntryPoints-InitFinal
      <MIModule::GetEntryPoint t.hIModule>
    >
    t.hErrorList;
}

FixupEntryPoints-Go {
  t.hIModule t.GoName t.hErrorList t.SrcPos =
    <FixupEntryPoints-Go-SwExist
      <MIModule::GetKind
        <MIModule::AbsolutName t.hIModule t.GoName>
      >
      t.GoName t.hErrorList t.SrcPos
    >;
}

FixupEntryPoints-Go-SwExist {
  t.hIModule Success Function t.GoName t.hErrorList t.SrcPos =
    <FixupEntryPoints-Go-SetEntryPoint
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindLeft-H
            &MIModule.GetFunctionAttribute ScopeClass t.GoName
          >
          <MLambda::BindLeft-H
            &MIModule.GetFunctionAttribute Position t.GoName
          >
        >
        t.hIModule
      >
      t.GoName t.hErrorList t.SrcPos
    >;

  t.hIModule e.OtherKindOrFails t.GoName t.hErrorList t.SrcPos =
    t.hIModule
    <MError::AddGoNotFound t.hErrorList t.SrcPos>;
}

FixupEntryPoints-Go-SetEntryPoint {
  t.hIModule Found Entry Found t.GoSrcPos t.GoName t.hErrorList t.EndSrcPos =
    <MIModule::SetGoEntryPoint
      t.hIModule
      (Function (Qualified t.GoSrcPos t.GoName))
    >
    t.hErrorList;

  t.hIModule Found s.Other Found t.GoSrcPos t.GoName t.hErrorList t.EndSrcPos =
    t.hIModule
    <MError::AddGoNotEntry t.hErrorList t.GoSrcPos>;
}

FixupEntryPoints-InitFinal {
  t.hIModule Regular t.InitSeq t.FinalSeq =
    <MLambda::Reduce
      &FixupInitFinal
      t.hIModule
      (&MIModule.SetInitEntryPoint t.InitSeq 'Init')
      (&MIModule.SetFinalEntryPoint t.FinalSeq 'Final')
    >;
}

FixupInitFinal {
  t.hIModule (s.FnChanger None e.FuncName) =
    <FixupInitFinal-GetPosition
      s.FnChanger t.hIModule <MQualifiedName::Create (e.FuncName)>
    >;

  t.hIModule (s.FnChanger (Result e.Result) e.FuncName) =
    // Уже точка входа задана
    t.hIModule;
}

FixupInitFinal-GetPosition {
  s.FnChanger t.hIModule t.FuncName =
    <FixupInitFinal-SetEntryCode
      s.FnChanger t.FuncName
      <MIModule::GetFunctionAttribute t.hIModule Position t.FuncName>
    >;
}

FixupInitFinal-SetEntryCode {
  s.FnChanger t.FuncName t.hIModule Found t.SrcPos =
    <s.FnChanger
      t.hIModule
      (Function (Qualified t.SrcPos t.FuncName))
    >;

  s.FnChanger t.FuncName t.hIModule NoName =
    /* Нет такой функции */
    t.hIModule;
}

//------------------------------------------------------------------------------

NSwapBlock {
  t.hIModule t.hErrorList t.Lexer t.NextToken =
    <ListDeclaration-Chain
      & NSwapBlock-AddName ('swap')
      t.hIModule t.hErrorList t.Lexer t.NextToken
    >;
}

NSwapBlock-AddName {
  t.hIModule t.SrcPos t.SwapName t.hErrorList =
    <MParser_Common::AddNewFunction
      t.hIModule t.SrcPos t.SwapName
      (ScopeClass Swap)
      t.hErrorList
    >;
}

NDataBlock {
  t.hIModule t.hErrorList t.Lexer t.NextToken =
    <ListDeclaration-Chain
      & MParser_Common.AddNewADT ('data type')
      t.hIModule t.hErrorList t.Lexer t.NextToken
    >;
}

/*
  ListDeclaration = ListMarker ListDeclaration-Chain .
  ListDeclaration-Chain = IDENTIFIER ListDeclaration-AfterName .
  ListDeclaration-AfterName = ';' | ',' ListDeclaration-Chain .

  ListMarker = '$swap' | '$data' .

  <ListDeclaration-Chain
    s.AddItem (e.ListName)
    t.hIModule t.hErrorList t.Lexer t.NextToken
  >
    == t.hIModule t.hErrorList t.Lexer t.NextToken

  <s.AddItem
    t.hIModule t.SrcPos t.ItemName t.hErrorList
  >
    == t.hIModule t.hErrorList
*/
ListDeclaration-Chain {
  s.AddItem (e.ListName)
  t.hIModule
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Name) =
    <ListDeclaration-AfterName
      s.AddItem (e.ListName)
      <s.AddItem
        t.hIModule t.SrcPos
        <MQualifiedName::Create (e.Name)>
        t.hErrorList
      >
      <MLexer::NextToken t.Lexer>
    >;

  s.AddItem (e.ListName)
  t.hIModule
  t.hErrorList t.Lexer t.OtherToken =
    t.hIModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken e.ListName ' name'
    >
    t.Lexer t.OtherToken;
}

ListDeclaration-AfterName {
  s.AddItem (e.ListName)
  t.hIModule t.hErrorList t.Lexer (Comma t.SrcPos) =
    <ListDeclaration-Chain
      s.AddItem (e.ListName)
      t.hIModule t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  s.AddItem (e.ListName)
  t.hIModule t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.hIModule t.hErrorList <MLexer::NextToken t.Lexer>;

  s.AddItem (e.ListName)
  t.hIModule t.hErrorList t.Lexer t.OtherToken =
    t.hIModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'comma or semicolon'
    >
    t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

/*
  InitFinalBlock = ( "$INIT" | "$FINAL" ) ResultExpr .
*/
NInitFinalBlock {
  t.hIModule s.Type t.SrcPos t.hErrorList t.hLexer t.NextTerm =
    <NInitFinalBlock-Closing
      <NResultExpr
        <MVarTable::Create> ( '$' (t.hIModule s.Type t.SrcPos) )
        t.hErrorList t.hLexer t.NextTerm
      >
    >;
}

NInitFinalBlock-Closing {
  t.VarTable ( (Result e.Result) t.hIModule s.Type t.SrcPos )
  t.hErrorList t.hLexer t.NextToken =
    <MVarTable::Destroy t.VarTable>
    <NInitFinalBlock-Closing-Aux
      <InitFinalBlock-SetEntryCode
        <MIModule::GetEntryPoint t.hIModule> s.Type e.Result
        t.hErrorList t.SrcPos
      >
      t.hLexer t.NextToken
    >;
}

NInitFinalBlock-Closing-Aux {
  t.hIModule t.hErrorList t.hLexer t.NextToken =
    t.hIModule
    <ExpectEndSent t.hErrorList t.hLexer t.NextToken>;
}

InitFinalBlock-SetEntryCode {
  t.hIModule Go t.GoSeq s.Type e.Result
  t.hErrorList t.SrcPos =
    t.hIModule
    <MError::AddInitOrFinalInMain t.hErrorList t.SrcPos s.Type>;

  t.hIModule Regular (Result e.InitCode) t.FinalSeq Init e.Result
  t.hErrorList t.SrcPos =
    t.hIModule
    <MError::AddInitOrFinalRedeclaration t.hErrorList t.SrcPos Init>;

  t.hIModule Regular t.InitSeq (Result e.FinalCode) Final e.Result
  t.hErrorList t.SrcPos =
    t.hIModule
    <MError::AddInitOrFinalRedeclaration t.hErrorList t.SrcPos Final>;

  t.hIModule Regular t.InitSeq t.FinalSeq s.Type e.Result
  t.hErrorList t.SrcPos =
    <MLambda::Apply
      <EntrySetter s.Type> t.hIModule e.Result
    >
    t.hErrorList;
}

EntrySetter {
  Init = & MIModule.SetInitEntryPoint;
  Final = & MIModule.SetFinalEntryPoint;
}

//------------------------------------------------------------------------------

NFunctionDefinition {
  t.IModule ( s.ScopeClass )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NFunctionDefinition-Closing
      t.IModule
      <NFunctionBody
        (( (Function s.ScopeClass (e.Ident) t.SrcPos) ))
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Возвращаемся в ModuleBody, как будто спецификатора $ENTRY и не было
  в помине */
  t.IModule ( s.ScopeClass )
  t.hErrorList t.Lexer t.UnexpectedToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.UnexpectedToken 'function name'
    >
    t.Lexer t.UnexpectedToken;
}

NFunctionDefinition-Closing
  t.IModule
  ( t.FunctionBody ( Function s.ScopeClass (e.Name) t.SrcPos ) )
  t.hErrorList t.Lexer t.NextToken =
    <MParser_Common::AddNewFunction
      t.IModule t.SrcPos
      <MQualifiedName::Create (e.Name)>
      (Body t.FunctionBody)
      (ScopeClass s.ScopeClass)
      t.hErrorList
    >
    t.Lexer t.NextToken;

//------------------------------------------------------------------------------

NFunctionBody {
  ( t.ParentStack ) t.hErrorList t.Lexer (OpenBlock t.SrcPos) =
    <NBlock
      ( t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  ( t.ParentStack ) t.hErrorList t.Lexer t.StartSentence =
    <NFunctionBody
      <NSentence
        ( (OneSentence t.ParentStack) )
        t.hErrorList t.Lexer t.StartSentence
      >
    >;

  ( e.Sentence OneSentence (e.ParentStack) )
  t.hErrorList t.Lexer t.NextToken =
    ( (e.Sentence) e.ParentStack )
    t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

NBlock {
  ( e.Sentences (e.ParentStack) )
  t.hErrorList t.Lexer (CloseBlock t.SrcPos) =
    ( (<MStrings::Reverse e.Sentences>) e.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  ( e.Sentences (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    ( (<MStrings::Reverse e.Sentences>) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) 'start of pattern of closing block'
    >
    <MLexer::NextToken t.Lexer>;

  ( e.Sentences t.ParentStack )
  t.hErrorList t.Lexer t.StartSentence =
    <NBlock
      <NSentence
        ( (e.Sentences t.ParentStack) )
        t.hErrorList t.Lexer t.StartSentence
      >
    >;
}

//------------------------------------------------------------------------------

NSentence {
  ( (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) 'start of pattern'
    >
    t.Lexer (EndOfText t.SrcPos);

  ( t.ParentStack )
  t.hErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info) =
    <NSentence-ExpectReplaces
      <NPatternExpr
        <MVarTable::Create>
        ( '$' (t.ParentStack) )
        t.hErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info)
      >
    >;
}

NSentence-ExpectReplaces {
  t.VarTable ( t.Pattern t.ParentStack )
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    <NSentence-Closing
      <NResultExpr
        t.VarTable ( '$' (t.Pattern t.ParentStack) )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Игнорируем уже разобранное образцовое выражение --
  игнорируем целиком пропущенное предложение. При этом необходимо
  съесть неожиданную лексему -- эта лексема оказалась неожиданной
  для образцового выражения, а следующее предложение начинается с
  образца. */

  t.VarTable ( t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    <MVarTable::Destroy t.VarTable>
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) '\'=\''
    >
    <MLexer::NextToken t.Lexer>;

  t.VarTable ( t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer t.UnexpectedToken =
    <MVarTable::Destroy t.VarTable>
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.UnexpectedToken '\'=\''
    >
    <MLexer::NextToken t.Lexer>;
}

NSentence-Closing {
  t.VarTable ( t.Result t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer t.NextToken =
    <MVarTable::Destroy t.VarTable>
    ( (t.Pattern t.Result) e.ParentStack )
    <ExpectEndSent
      t.hErrorList t.Lexer t.NextToken
    >;
}

ExpectEndSent {
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.hErrorList <MLexer::NextToken t.Lexer>;

  /* Делаем вид, что точка с запятой была */
  t.hErrorList t.Lexer t.OtherToken =
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'semicolon'
    >
    t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

AddVariable {
  t.hErrorList t.VarTable Success
  ( e.PatternExpr t.ParentStack )
  t.Lexer (Var t.SrcPos s.VarType e.Index) =
    t.VarTable
    ( e.PatternExpr (s.VarType e.Index) t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( e.PatternExpr t.ParentStack )
  t.Lexer t.VarToken =
    t.VarTable
    ( e.PatternExpr t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NPatternExpr {
  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
    <NPatternExpr
      <AddVariable
        <MVarTable::AddVariable
          t.hErrorList t.VarTable t.SrcPos s.VarType e.Index
        >
        ( e.PatternExpr t.ParentStack )
        t.Lexer (Var t.SrcPos s.VarType e.Index)
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Identifier) =
    <NPatternExpr
      t.VarTable
      <AnyExpr-AnalyzeStartOfQualifiedName
        ( e.PatternExpr t.ParentStack )
        (t.SrcPos e.Identifier)
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Literal t.SrcPos e.Content) =
    <NPatternExpr
      t.VarTable
      (e.PatternExpr (Literal e.Content) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Macro t.SrcPos s.Value) =
    <NPatternExpr
      t.VarTable
      (e.PatternExpr (Macro s.Value) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    <NPatternExpr
      t.VarTable
      <QualifiedSuccessed
        t.SrcPos ( e.PatternExpr t.ParentStack )
        <MParser_Common::NDotQualifiedName
          t.hErrorList <MLexer::NextToken t.Lexer>
        >
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable ( (')' e.PatternExpr) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenSquare t.SrcPos) =
    <NPatternExpr
      <CallableADTName
        t.VarTable ( (']' e.PatternExpr) t.ParentStack )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Сделаем осмысленную реакцию на ошибки -- будем интерпретировать
  функциональную скобку как структурную. */
  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenFnCall t.SrcPos) =
    <NPatternExpr
      t.VarTable ( (')' e.PatternExpr) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (OpenFnCall t.SrcPos)
        'any correct passive term'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( (')' e.MultiBracket) e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBrackets) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( (']' e.MultiBracket) InvalidADT e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBrackets) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( (']' e.MultiBracket) t.Callable e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket
        (Abstract t.Callable e.InBrackets)
        t.ParentStack
      )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  /* Продолжение осмысленной реакции -- интерпретация закрывающей
  функциональной скобки как структурной*/
  t.VarTable ( (')' e.MultiBracket) e.InBracket t.ParentStack)
  t.hErrorList t.Lexer (CloseFnCall t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBracket) t.ParentStack)
      <MError::AddUnexpected
        t.hErrorList (CloseFnCall t.SrcPos)
        'any correct passive term'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.PatternExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseBrac t.SrcPos)
        'any correct term (unbalanced structure brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.PatternExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseSquare t.SrcPos)
        'any correct term (unbalanced ADT brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( '$' e.PatternExpr (e.ParentStack))
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
    t.hErrorList t.Lexer (Replaces t.SrcPos);

  t.VarTable
  ( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (Replaces t.SrcPos)
        '\'' s.BracketType '\''
      >
      t.Lexer (Replaces t.SrcPos)
    >;

  t.VarTable
  ( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer t.Unexpected =
    <NPatternExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList t.Unexpected
        '\'' s.BracketType '\''
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( '$' e.PatternExpr (e.ParentStack) )
  t.hErrorList t.Lexer t.Unexpected =
    t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.Unexpected
      'pattern expression or semicolon'
    >
    t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

AnyExpr-AnalyzeStartOfQualifiedName {
  (e.Expression t.ParentStack) (t.SrcPos e.Name)
  t.hErrorList t.Lexer (Dot t.DotSrcPos) =
    <ConcatQualified
      (e.Name)
      t.SrcPos (e.Expression t.ParentStack)
      <MParser_Common::NDotQualifiedName
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  (e.Expression t.ParentStack) (t.SrcPos e.Name)
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression (Identifier t.SrcPos e.Name) t.ParentStack)
    t.hErrorList t.Lexer t.NextToken;
}

ConcatQualified {
  (e.Name) t.SrcPos (e.Expression t.ParentStack)
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression
      (FnPtr
        (Qualified
          t.SrcPos
          <MQualifiedName::AddSuperName t.QualifiedName e.Name>
        )
      )
      t.ParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  (e.Name) t.SrcPos (e.Expression t.ParentStack)
  Fails
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression (Identifier e.Name) t.ParentStack)
    t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

QualifiedSuccessed {
  t.SrcPos ( e.Expression t.ParentStack)
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression
      (FnPtr (Qualified t.SrcPos t.QualifiedName))
      t.ParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  t.SrcPos ( e.Expression t.ParentStack )
  Fails
  t.hErrorList t.Lexer t.NextToken =
        (e.Expression t.ParentStack)
        t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

CallableADTName {
  t.VarTable ( e.Pattern t.UpParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Content) =
    t.VarTable
    ( e.Pattern
      (Qualified t.SrcPos
        <MQualifiedName::Create (e.Content)>
      ) t.UpParentStack
    ) t.hErrorList <MLexer::NextToken t.Lexer>;

  t.VarTable ( e.Pattern t.UpParentStack )
  t.hErrorList t.Lexer t.OtherToken =
    t.VarTable
    ( e.Pattern InvalidADT t.UpParentStack )
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'name of ADT'
    >
    t.Lexer t.OtherToken;

}

//------------------------------------------------------------------------------

CheckVariable {
  t.hErrorList t.VarTable Success
  ( e.ResultExpr t.ParentStack )
  t.Lexer (Var t.SrcPos s.VarType e.Index) =
    t.VarTable ( e.ResultExpr (s.VarType e.Index) t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( e.ResultExpr t.ParentStack )
  t.Lexer t.VarToken =
    t.VarTable ( e.ResultExpr t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NResultExpr {
  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
    <NResultExpr
      <CheckVariable
        <MVarTable::CheckVariable
          t.hErrorList t.VarTable t.SrcPos s.VarType e.Index
        >
        ( e.ResultExpr t.ParentStack )
        t.Lexer (Var t.SrcPos s.VarType e.Index)
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NResultExpr
      t.VarTable
      <AnyExpr-AnalyzeStartOfQualifiedName
        ( e.ResultExpr t.ParentStack )
        (t.SrcPos e.Ident)
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Literal t.SrcPos e.Content) =
    <NResultExpr
      t.VarTable
      ( e.ResultExpr (Literal e.Content) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Macro t.SrcPos s.Value) =
    <NResultExpr
      t.VarTable
      ( e.ResultExpr (Macro s.Value) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.ResultExpr t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    <NResultExpr
      t.VarTable
      <QualifiedSuccessed
        t.SrcPos ( e.ResultExpr t.ParentStack )
        <MParser_Common::NDotQualifiedName
          t.hErrorList <MLexer::NextToken t.Lexer>
        >
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenBrac t.SrcPos) =
    <NResultExpr
      t.VarTable ( ( ')' e.ResultExpr ) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenFnCall t.SrcPos) =
    <NResultExpr
      <NCallable
        t.VarTable
        ( ( ('>' e.ResultExpr) t.ParentStack ) )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenSquare t.SrcPos) =
    <NResultExpr
      <CallableADTName
        t.VarTable ( ( ']' e.ResultExpr ) t.ParentStack )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( ( ')' e.MultiBracket ) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer ( CloseBrac t.SrcPos ) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList ( CloseBrac t.SrcPos )
        'result expression or semicolon (unbalanced structure brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ( ']' e.MultiBracket ) InvalidADT e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ( ']' e.MultiBracket ) t.Callable e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (Abstract t.Callable e.InBrackets)
        t.ParentStack
      )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseSquare t.SrcPos)
        'result expression or semicolon (unbalanced ADT brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  /* В случае ошибочного callable функциональные скобки
  интерпретируем как структурные. */
  t.VarTable
  ( ('>' e.MultiBracket) InvalidCallable e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (Structure e.ResultExprFnArgument)
        t.ParentStack
      ) t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ('>' e.MultiBracket) (FnCall t.Callable) e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        ( Function t.Callable e.ResultExprFnArgument )
        t.ParentStack
      )
      t.hErrorList
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ('>' e.MultiBracket) (IndirectCall (SVar e.Index)) e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (IndirectCall (SVar e.Index) e.ResultExprFnArgument)
        t.ParentStack
      ) t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (CloseFnCall t.SrcPos) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseFnCall t.SrcPos)
        'result expression or semicolon (unbalanced function brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ('$' e.ResultExpr (e.ParentStack))
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.VarTable ( (Result e.ResultExpr) e.ParentStack )
    t.hErrorList t.Lexer (EndSent t.SrcPos);

  t.VarTable
  ( ( s.BracketType e.MultiBracket ) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer t.Unexpected =
    <NResultExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList t.Unexpected
        s.BracketType ' (unbalanced brackets)'
      >
      t.Lexer t.Unexpected
    >;

  t.VarTable ( '$' e.ResultExpr (e.ParentStack) )
  t.hErrorList t.Lexer t.Unexpected =
    t.VarTable ( (e.ResultExpr) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.Unexpected
      'result expression or \';\''
    >
    t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

NCallable {
  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Name) =
    t.VarTable
    <NCallable-ReadQualifiedName
      t.SrcPos ( t.ParentStack )
      <MParser_Common::NAnyQualifiedName
        t.hErrorList t.Lexer (Identifier t.SrcPos e.Name)
      >
    >;

  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    t.VarTable
    <NCallable-ReadQualifiedName
      t.SrcPos ( t.ParentStack )
      <MParser_Common::NDotQualifiedName
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Var t.SrcPos SVar e.Index) =
    <CheckCallableVariable
      <MVarTable::CheckVariable
        t.hErrorList t.VarTable t.SrcPos SVar e.Index
      > ( t.ParentStack )
      t.Lexer (Var t.SrcPos SVar e.Index)
    >;

  t.VarTable ( (e.ResultExpr t.UpParentStack) )
  t.hErrorList t.Lexer t.OtherToken =
    t.VarTable
    ( e.ResultExpr InvalidCallable t.UpParentStack )
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'function name or module name'
    >
    t.Lexer t.OtherToken;
}

NCallable-ReadQualifiedName {
  t.NamePos ( (e.ResultExpr t.UpParentStack) )
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    ( e.ResultExpr
      ( FnCall
        ( Qualified t.NamePos t.QualifiedName )
      ) t.UpParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  t.NamePos ( (e.ResultExpr t.UpParentStack) )
  Fails
  t.hErrorList t.Lexer t.NextToken =
    ( e.ResultExpr InvalidCallable t.UpParentStack )
    t.hErrorList t.Lexer t.NextToken;
}

CheckCallableVariable {
  t.hErrorList t.VarTable Success
  ( (e.ResultExpr t.UpParentStack) )
  t.Lexer (Var t.SrcPos SVar e.Index) =
    t.VarTable (
      e.ResultExpr
      ( IndirectCall (SVar e.Index))
      t.UpParentStack
    )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( (e.ResultExpr t.UpParentStack) )
  t.Lexer (Var t.SrcPos SVar e.Index) =
    t.VarTable
    ( e.ResultExpr InvalidCallable t.UpParentStack)
    t.hErrorList <MLexer::NextToken t.Lexer>;
}

$END FE-MRefal::MParser_MRefal.
