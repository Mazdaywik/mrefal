$MODULE FE-MRefal::MParser_MRefal;

$IMPORT MError;
$IMPORT MLexer = FE-MRefal::MLexer;
$IMPORT MParser_Common = FE-MRefal::MParser_Common;
$IMPORT MQualifiedName;
$IMPORT MStrings;
$IMPORT MVarTable = FE-MRefal::MVarTable;

/**
  <SrcModule t.hErrorList t.QualifiedName e.FileName>
    == t.hErrorList Success s.Result t.IModule
    == t.hErrorList Fails
  s.Result ::= Success | Warnings | Errors
*/
$ENTRY SrcModule
  t.hErrorList t.QualifiedName e.FileName =
    <MParser_Common::GeneralizeInfo
      t.hErrorList
      t.QualifiedName
      <MParser_Common::Parse
        &NModuleBody e.FileName
      >
    >;

//------------------------------------------------------------------------------
// Синтаксический анализ модуля
//------------------------------------------------------------------------------

/*
  ModuleBody = { ImportBlock | FunctionDefinition | SwapDefinition }* .

  <NModuleBody t.IModule t.hErrorList t.Lexer t.NextToken >
    == t.hErrorList Success t.IModule
    == t.hErrorList Fails
*/
NModuleBody {
  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Import) =
    <NModuleBody
      <MParser_Common::NImportBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Swap) =
    <NModuleBody
      <NSwapBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Entry) =
    <NModuleBody
      <NFunctionDefinition
        t.IModule
        ( Entry )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos Data) =
    <NModuleBody
      <NDataBlock
        t.IModule
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NModuleBody
      <NFunctionDefinition
        t.IModule
        ( Local )
        t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident)
      >
    >;

  t.IModule
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    <NModuleBody
      t.IModule
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  /* Завершение рекурсии */
  t.IModule
  t.hErrorList t.Lexer (Directive t.SrcPos End) =
    <MParser_Common::NModuleTailer
      t.IModule
      t.hErrorList t.Lexer (Directive t.SrcPos End)
    >;

  /* При обнаружении конца файла завершаем анализ */
  t.IModule
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    <MError::AddUnexpected
      t.hErrorList
      (EndOfText t.SrcPos)
      '$entry, $import, $swap or local function definition'
    >
    Success
    t.IModule
    <MLexer::Destroy t.Lexer>;

  /* Любая другая лексема пропускается */
  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    <NModuleBody
      t.IModule
      <MError::AddUnexpected
        t.hErrorList
        t.OtherToken
        '$entry, $import, $swap or local function definition'
      >
      <MLexer::NextToken t.Lexer>
    >;
}

//------------------------------------------------------------------------------

/*
  SwapBlock = '$swap' SwapBlock-Chain .
  SwapBlock-Chain = IDENTIFIER SwapBlock-AfterName .
  SwapBlock-AfterName = ';' | ',' Swap-Chain .
*/
NSwapBlock {
  t.IModule
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NSwapBlock-AfterName
      <MParser_Common::AddNewFunction
        t.IModule t.SrcPos
        <MQualifiedName::Create (e.Ident)>
        (ScopeClass Swap)
        (Qualified <MQualifiedName::Create (e.Ident)>)
        t.hErrorList
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'swap name'
    >
    t.Lexer t.OtherToken;
}

NSwapBlock-AfterName {
  t.IModule
  t.hErrorList t.Lexer (Comma t.SrcPos) =
    <NSwapBlock
      t.IModule
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.IModule
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.IModule
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'comma or semicolon'
    >
    t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

/*
  DataBlock = '$swap' DataBlock-Chain .
  DataBlock-Chain = IDENTIFIER DataBlock-AfterName .
  DataBlock-AfterName = ';' | ',' DataBlock-Chain .
*/
NDataBlock {
  t.IModule
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NDataBlock-AfterName
      <MParser_Common::AddNewADT
        t.IModule t.SrcPos
        <MQualifiedName::Create (e.Ident)>
        t.hErrorList
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'swap name'
    >
    t.Lexer t.OtherToken;
}

NDataBlock-AfterName {
  t.IModule
  t.hErrorList t.Lexer (Comma t.SrcPos) =
    <NDataBlock
      t.IModule
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.IModule
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.IModule
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.IModule
  t.hErrorList t.Lexer t.OtherToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'comma or semicolon'
    >
    t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

NFunctionDefinition {
  t.IModule ( s.ScopeClass )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NFunctionDefinition-Closing
      t.IModule
      <NFunctionBody
        (( (Function s.ScopeClass (e.Ident) t.SrcPos) ))
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Возвращаемся в ModuleBody, как будто спецификатора $ENTRY и не было
  в помине */
  t.IModule ( s.ScopeClass )
  t.hErrorList t.Lexer t.UnexpectedToken =
    t.IModule
    <MError::AddUnexpected
      t.hErrorList t.UnexpectedToken 'function name'
    >
    t.Lexer t.UnexpectedToken;
}

NFunctionDefinition-Closing
  t.IModule
  ( t.FunctionBody ( Function s.ScopeClass (e.Name) t.SrcPos ) )
  t.hErrorList t.Lexer t.NextToken =
    <MParser_Common::AddNewFunction
      t.IModule t.SrcPos
      <MQualifiedName::Create (e.Name)>
      (Body t.FunctionBody)
      (ScopeClass s.ScopeClass)
      (Qualified <MQualifiedName::Create (e.Name)>)
      t.hErrorList
    >
    t.Lexer t.NextToken;

//------------------------------------------------------------------------------

NFunctionBody {
  ( t.ParentStack ) t.hErrorList t.Lexer (OpenBlock t.SrcPos) =
    <NBlock
      ( t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  ( t.ParentStack ) t.hErrorList t.Lexer t.StartSentence =
    <NFunctionBody
      <NSentence
        ( (OneSentence t.ParentStack) )
        t.hErrorList t.Lexer t.StartSentence
      >
    >;

  ( e.Sentence OneSentence (e.ParentStack) )
  t.hErrorList t.Lexer t.NextToken =
    ( (e.Sentence) e.ParentStack )
    t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

NBlock {
  ( e.Sentences (e.ParentStack) )
  t.hErrorList t.Lexer (CloseBlock t.SrcPos) =
    ( (<MStrings::Reverse e.Sentences>) e.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  ( e.Sentences (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    ( (<MStrings::Reverse e.Sentences>) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) 'start of pattern of closing block'
    >
    <MLexer::NextToken t.Lexer>;

  ( e.Sentences t.ParentStack )
  t.hErrorList t.Lexer t.StartSentence =
    <NBlock
      <NSentence
        ( (e.Sentences t.ParentStack) )
        t.hErrorList t.Lexer t.StartSentence
      >
    >;
}

//------------------------------------------------------------------------------

NSentence {
  ( (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) 'start of pattern'
    >
    t.Lexer (EndOfText t.SrcPos);

  ( t.ParentStack )
  t.hErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info) =
    <NSentence-ExpectReplaces
      <NPatternExpr
        <MVarTable::Create>
        ( '$' (t.ParentStack) )
        t.hErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info)
      >
    >;
}

NSentence-ExpectReplaces {
  t.VarTable ( t.Pattern t.ParentStack )
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    <NSentence-Closing
      <NResultExpr
        t.VarTable ( '$' (t.Pattern t.ParentStack) )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Игнорируем уже разобранное образцовое выражение --
  игнорируем целиком пропущенное предложение. При этом необходимо
  съесть неожиданную лексему -- эта лексема оказалась неожиданной
  для образцового выражения, а следующее предложение начинается с
  образца. */

  t.VarTable ( t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer (EndOfText t.SrcPos) =
    <MVarTable::Destroy t.VarTable>
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList (EndOfText t.SrcPos) '\'=\''
    >
    <MLexer::NextToken t.Lexer>;

  t.VarTable ( t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer t.UnexpectedToken =
    <MVarTable::Destroy t.VarTable>
    ( e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.UnexpectedToken '\'=\''
    >
    <MLexer::NextToken t.Lexer>;
}

NSentence-Closing {
  t.VarTable ( t.Result t.Pattern (e.ParentStack) )
  t.hErrorList t.Lexer t.NextToken =
    <MVarTable::Destroy t.VarTable>
    ( (t.Pattern t.Result) e.ParentStack )
    <ExpectEndSent
      t.hErrorList t.Lexer t.NextToken
    >;
}

ExpectEndSent {
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.hErrorList <MLexer::NextToken t.Lexer>;

  /* Делаем вид, что точка с запятой была */
  t.hErrorList t.Lexer t.OtherToken =
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'semicolon'
    >
    t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

AddVariable {
  t.hErrorList t.VarTable Success
  ( e.PatternExpr t.ParentStack )
  t.Lexer (Var t.SrcPos s.VarType e.Index) =
    t.VarTable
    ( e.PatternExpr (s.VarType e.Index) t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( e.PatternExpr t.ParentStack )
  t.Lexer t.VarToken =
    t.VarTable
    ( e.PatternExpr t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NPatternExpr {
  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
    <NPatternExpr
      <AddVariable
        <MVarTable::AddVariable
          t.hErrorList t.VarTable t.SrcPos s.VarType e.Index
        >
        ( e.PatternExpr t.ParentStack )
        t.Lexer (Var t.SrcPos s.VarType e.Index)
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Identifier) =
    <NPatternExpr
      t.VarTable
      <AnyExpr-AnalyzeStartOfQualifiedName
        ( e.PatternExpr t.ParentStack )
        (t.SrcPos e.Identifier)
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Literal t.SrcPos e.Content) =
    <NPatternExpr
      t.VarTable
      (e.PatternExpr (Literal e.Content) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (DQWord t.SrcPos e.Content) =
    <NPatternExpr
      t.VarTable
      (e.PatternExpr (DQWord e.Content) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Macro t.SrcPos s.Value) =
    <NPatternExpr
      t.VarTable
      (e.PatternExpr (Macro s.Value) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    <NPatternExpr
      t.VarTable
      <QualifiedSuccessed
        t.SrcPos ( e.PatternExpr t.ParentStack )
        <MParser_Common::NDotQualifiedName
          t.hErrorList <MLexer::NextToken t.Lexer>
        >
      >
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable ( (')' e.PatternExpr) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenSquare t.SrcPos) =
    <NPatternExpr
      <CallableADTName
        t.VarTable ( (']' e.PatternExpr) t.ParentStack )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  /* Сделаем осмысленную реакцию на ошибки -- будем интерпретировать
  функциональную скобку как структурную. */
  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (OpenFnCall t.SrcPos) =
    <NPatternExpr
      t.VarTable ( (')' e.PatternExpr) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (OpenFnCall t.SrcPos)
        'any correct passive term'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( (')' e.MultiBracket) e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBrackets) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( (']' e.MultiBracket) InvalidADT e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBrackets) t.ParentStack)
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( (']' e.MultiBracket) t.Callable e.InBrackets t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket
        (Abstract t.Callable e.InBrackets)
        t.ParentStack
      )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  /* Продолжение осмысленной реакции -- интерпретация закрывающей
  функциональной скобки как структурной*/
  t.VarTable ( (')' e.MultiBracket) e.InBracket t.ParentStack)
  t.hErrorList t.Lexer (CloseFnCall t.SrcPos) =
    <NPatternExpr
      t.VarTable
      (e.MultiBracket (Structure e.InBracket) t.ParentStack)
      <MError::AddUnexpected
        t.hErrorList (CloseFnCall t.SrcPos)
        'any correct passive term'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.PatternExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseBrac t.SrcPos)
        'any correct term (unbalanced structure brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.PatternExpr t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.PatternExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseSquare t.SrcPos)
        'any correct term (unbalanced ADT brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( '$' e.PatternExpr (e.ParentStack))
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
    t.hErrorList t.Lexer (Replaces t.SrcPos);

  t.VarTable
  ( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (Replaces t.SrcPos) =
    <NPatternExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (Replaces t.SrcPos)
        '\'' s.BracketType '\''
      >
      t.Lexer (Replaces t.SrcPos)
    >;

  t.VarTable
  ( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer t.Unexpected =
    <NPatternExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList t.Unexpected
        '\'' s.BracketType '\''
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( '$' e.PatternExpr (e.ParentStack) )
  t.hErrorList t.Lexer t.Unexpected =
    t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.Unexpected
      'pattern expression or semicolon'
    >
    t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

AnyExpr-AnalyzeStartOfQualifiedName {
  (e.Expression t.ParentStack) (t.SrcPos e.Name)
  t.hErrorList t.Lexer (Dot t.DotSrcPos) =
    <ConcatQualified
      (e.Name)
      t.SrcPos (e.Expression t.ParentStack)
      <MParser_Common::NDotQualifiedName
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  (e.Expression t.ParentStack) (t.SrcPos e.Name)
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression (Identifier t.SrcPos e.Name) t.ParentStack)
    t.hErrorList t.Lexer t.NextToken;
}

ConcatQualified {
  (e.Name) t.SrcPos (e.Expression t.ParentStack)
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression
      (FnPtr
        (Qualified
          t.SrcPos
          <MQualifiedName::AddSuperName t.QualifiedName e.Name>
        )
      )
      t.ParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  (e.Name) t.SrcPos (e.Expression t.ParentStack)
  Fails
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression (Identifier e.Name) t.ParentStack)
    t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

QualifiedSuccessed {
  t.SrcPos ( e.Expression t.ParentStack)
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    (e.Expression
      (FnPtr (Qualified t.SrcPos t.QualifiedName))
      t.ParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  t.SrcPos ( e.Expression t.ParentStack )
  Fails
  t.hErrorList t.Lexer t.NextToken =
        (e.Expression t.ParentStack)
        t.hErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

CallableADTName {
  t.VarTable ( e.Pattern t.UpParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Content) =
    t.VarTable
    ( e.Pattern
      (Qualified t.SrcPos
        <MQualifiedName::Create (e.Content)>
      ) t.UpParentStack
    ) t.hErrorList <MLexer::NextToken t.Lexer>;

  t.VarTable ( e.Pattern t.UpParentStack )
  t.hErrorList t.Lexer t.OtherToken =
    t.VarTable
    ( e.Pattern InvalidADT t.UpParentStack )
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'name of ADT'
    >
    t.Lexer t.OtherToken;

}

//------------------------------------------------------------------------------

CheckVariable {
  t.hErrorList t.VarTable Success
  ( e.ResultExpr t.ParentStack )
  t.Lexer (Var t.SrcPos s.VarType e.Index) =
    t.VarTable ( e.ResultExpr (s.VarType e.Index) t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( e.ResultExpr t.ParentStack )
  t.Lexer t.VarToken =
    t.VarTable ( e.ResultExpr t.ParentStack )
    t.hErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NResultExpr {
  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
    <NResultExpr
      <CheckVariable
        <MVarTable::CheckVariable
          t.hErrorList t.VarTable t.SrcPos s.VarType e.Index
        >
        ( e.ResultExpr t.ParentStack )
        t.Lexer (Var t.SrcPos s.VarType e.Index)
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
    <NResultExpr
      t.VarTable
      <AnyExpr-AnalyzeStartOfQualifiedName
        ( e.ResultExpr t.ParentStack )
        (t.SrcPos e.Ident)
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Literal t.SrcPos e.Content) =
    <NResultExpr
      t.VarTable
      ( e.ResultExpr (Literal e.Content) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (DQWord t.SrcPos e.Content) =
    <NResultExpr
      t.VarTable
      ( e.ResultExpr (DQWord e.Content) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (Macro t.SrcPos s.Value) =
    <NResultExpr
      t.VarTable
      ( e.ResultExpr (Macro s.Value) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ( e.ResultExpr t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    <NResultExpr
      t.VarTable
      <QualifiedSuccessed
        t.SrcPos ( e.ResultExpr t.ParentStack )
        <MParser_Common::NDotQualifiedName
          t.hErrorList <MLexer::NextToken t.Lexer>
        >
      >
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenBrac t.SrcPos) =
    <NResultExpr
      t.VarTable ( ( ')' e.ResultExpr ) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenFnCall t.SrcPos) =
    <NResultExpr
      <NCallable
        t.VarTable
        ( ( ('>' e.ResultExpr) t.ParentStack ) )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >                        
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (OpenSquare t.SrcPos) =
    <NResultExpr
      <CallableADTName
        t.VarTable ( ( ']' e.ResultExpr ) t.ParentStack )
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( ( ')' e.MultiBracket ) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseBrac t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer ( CloseBrac t.SrcPos ) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList ( CloseBrac t.SrcPos )
        'result expression or semicolon (unbalanced structure brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ( ']' e.MultiBracket ) InvalidADT e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ( ']' e.MultiBracket ) t.Callable e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (Abstract t.Callable e.InBrackets)
        t.ParentStack
      )
      t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (CloseSquare t.SrcPos) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseSquare t.SrcPos)
        'result expression or semicolon (unbalanced ADT brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  /* В случае ошибочного callable функциональные скобки
  интерпретируем как структурные. */
  t.VarTable
  ( ('>' e.MultiBracket) InvalidCallable e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (Structure e.ResultExprFnArgument)
        t.ParentStack
      ) t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ('>' e.MultiBracket) (FnCall t.Callable) e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        ( Function t.Callable e.ResultExprFnArgument )
        t.ParentStack
      )
      t.hErrorList
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable
  ( ('>' e.MultiBracket) (IndirectCall (SVar e.Index)) e.ResultExprFnArgument t.ParentStack )
  t.hErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
    <NResultExpr
      t.VarTable
      ( e.MultiBracket
        (IndirectCall (SVar e.Index) e.ResultExprFnArgument)
        t.ParentStack
      ) t.hErrorList <MLexer::NextToken t.Lexer>
    >;

  t.VarTable (e.ResultExpr t.ParentStack)
  t.hErrorList t.Lexer (CloseFnCall t.SrcPos) =
    <NResultExpr
      t.VarTable ( e.ResultExpr t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList (CloseFnCall t.SrcPos)
        'result expression or semicolon (unbalanced function brackets)'
      >
      <MLexer::NextToken t.Lexer>
    >;

  t.VarTable ('$' e.ResultExpr (e.ParentStack))
  t.hErrorList t.Lexer (EndSent t.SrcPos) =
    t.VarTable ( (Result e.ResultExpr) e.ParentStack )
    t.hErrorList t.Lexer (EndSent t.SrcPos);

  t.VarTable
  ( ( s.BracketType e.MultiBracket ) e.InBrackets t.ParentStack )
  t.hErrorList t.Lexer t.Unexpected =
    <NResultExpr
      t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
      <MError::AddUnexpected
        t.hErrorList t.Unexpected
        s.BracketType ' (unbalanced brackets)'
      >
      t.Lexer t.Unexpected
    >;

  t.VarTable ( '$' e.ResultExpr (e.ParentStack) )
  t.hErrorList t.Lexer t.Unexpected =
    t.VarTable ( (e.ResultExpr) e.ParentStack )
    <MError::AddUnexpected
      t.hErrorList t.Unexpected
      'result expression or \';\''
    >
    t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

NCallable {
  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Identifier t.SrcPos e.Name) =
    t.VarTable
    <NCallable-ReadQualifiedName
      t.SrcPos ( t.ParentStack )
      <MParser_Common::NAnyQualifiedName
        t.hErrorList t.Lexer (Identifier t.SrcPos e.Name)
      >
    >;

  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Ampersand t.SrcPos) =
    t.VarTable
    <NCallable-ReadQualifiedName
      t.SrcPos ( t.ParentStack )
      <MParser_Common::NDotQualifiedName
        t.hErrorList <MLexer::NextToken t.Lexer>
      >
    >;

  t.VarTable ( t.ParentStack )
  t.hErrorList t.Lexer (Var t.SrcPos SVar e.Index) =
    <CheckCallableVariable
      <MVarTable::CheckVariable
        t.hErrorList t.VarTable t.SrcPos SVar e.Index
      > ( t.ParentStack )
      t.Lexer (Var t.SrcPos SVar e.Index)
    >;

  t.VarTable ( (e.ResultExpr t.UpParentStack) )
  t.hErrorList t.Lexer t.OtherToken =
    t.VarTable
    ( e.ResultExpr InvalidCallable t.UpParentStack )
    <MError::AddUnexpected
      t.hErrorList t.OtherToken 'function name or module name'
    >
    t.Lexer t.OtherToken;
}

NCallable-ReadQualifiedName {
  t.NamePos ( (e.ResultExpr t.UpParentStack) )
  Success t.QualifiedName
  t.hErrorList t.Lexer t.NextToken =
    ( e.ResultExpr
      ( FnCall
        ( Qualified t.NamePos t.QualifiedName )
      ) t.UpParentStack
    )
    t.hErrorList t.Lexer t.NextToken;

  t.NamePos ( (e.ResultExpr t.UpParentStack) )
  Fails
  t.hErrorList t.Lexer t.NextToken =
    ( e.ResultExpr InvalidCallable t.UpParentStack )
    t.hErrorList t.Lexer t.NextToken;
}

CheckCallableVariable {
  t.hErrorList t.VarTable Success
  ( (e.ResultExpr t.UpParentStack) )
  t.Lexer (Var t.SrcPos SVar e.Index) =
    t.VarTable (
      e.ResultExpr
      ( IndirectCall (SVar e.Index))
      t.UpParentStack
    )
    t.hErrorList <MLexer::NextToken t.Lexer>;

  t.hErrorList t.VarTable Fails
  ( (e.ResultExpr t.UpParentStack) )
  t.Lexer (Var t.SrcPos SVar e.Index) =
    t.VarTable
    ( e.ResultExpr InvalidCallable t.UpParentStack)
    t.hErrorList <MLexer::NextToken t.Lexer>;
}



$END FE-MRefal::MParser_MRefal.
