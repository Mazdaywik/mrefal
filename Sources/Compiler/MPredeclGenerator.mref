$MODULE MPredeclGenerator;

$IMPORT MError;
$IMPORT MFileIO;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MMath;
$IMPORT MQualifiedName;
$IMPORT MSrcPos;

$IMPORT MProfiler;

/**
  Generate-Properties {
    GenFunction-Code = & GenFunction-Code;
  }

  <Generate-Generic s.FnProperties t.hIModule e.OutName>
    == t.hIModule

  <<s.FnProperties GenSwap> t.AbsolutName> == e.Lines
  <<s.FnProperties SwitchEnum s.ScopeClass> t.AbsolutName> == e.Lines
  s.ScopeClass ::= Entry | Local
  <s.FnProperties GenCommonHeaders> == e.Lines
  <<s.FnProperties GenIdent> e.Name> == e.Lines
  <<s.FnProperties GenFunction-Decl> s.ScopeClass t.AbsolutName>
    == e.Lines
  <<s.FnProperties Generate-EntryCode-Go>
    s.FnProperties t.ModuleName (e.Result) e.Imports
  >
    == e.GenFunctionResult
  <<s.FnProperties Generate-EntryCode-InitFinal>
    s.FnProperties t.ModuleName t.InitSeq t.FinalSeq e.Imports
  >
    == e.GenFunctionResult
  <<s.FnProperties GenFunction-Code>
    t.AbsolutName s.ScopeClass e.Sentences
  >
    == e.Lines

  e.Lines ::= (char*)*
  e.GenFunctionResult — результат выполнения функции GenFunction
*/
$ENTRY Generate-Generic
  s.FnProperties t.hIModule e.OutName =
    <Generate-Aux
      s.FnProperties
      (e.OutName)
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindLeft & GenerateFunctions s.FnProperties>
          <MLambda::BindLeft & GenerateEntryCode s.FnProperties>
        >
        t.hIModule
      >
    >;

GenerateFunctions
  s.FnProperties t.hIModule =
    <MLambda::MapReduce
      <MLambda::BindLeft & GenerateEntity s.FnProperties>
      <MIModule::GetEntityList t.hIModule>
    >;

GenerateEntity {
  s.FnProperties t.hIModule (Function t.RelativeName) =
    <GenerateFunction
      s.FnProperties
      <MIModule::AbsolutName t.hIModule t.RelativeName> t.RelativeName
    >;

  s.FnProperties t.hIModule (ADT t.RelativeName) =
    t.hIModule /* пусто */;

  s.FnProperties t.hIModule
  (NativeInsertion s.NativeHandle t.SrcPos s.BackEndID e.Code) =
    t.hIModule
    <Declarations-Expr s.FnProperties e.Code>
    (Native <s.FnProperties GenNativeInsertion> t.SrcPos s.BackEndID e.Code);
}

/*
  <GenerateFunction
    s.FnProperties t.hIModule t.AbsolutName t.RelativeName
  >
    == t.hIModule ( (e.Definitions) (e.FunctionCode) )
*/
GenerateFunction
  s.FnProperties t.hIModule t.AbsolutName t.RelativeName =
    <GenerateFunction-Aux
      s.FnProperties
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute ScopeClass t.RelativeName
          >
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute Body t.RelativeName
          >
          <MLambda::BindLeft-H
            & MIModule.GetFunctionAttribute NativeBody t.RelativeName
          >
        >
        t.hIModule
      >
      t.AbsolutName
    >;

GenerateFunction-Aux {
  s.FnProperties
  t.hIModule Found Swap NoAttrib NoAttrib t.AbsolutName =
    t.hIModule
    (Declare
      Function
      t.AbsolutName
      (<s.FnProperties GenFunction-Decl> Swap t.AbsolutName)
    )
    (Define
      Function t.AbsolutName (<s.FnProperties GenSwap> t.AbsolutName)
    );

  s.FnProperties
  t.hIModule Found s.ScopeClass Found (/* пусто */) NoAttrib t.AbsolutName =
    t.hIModule
    (Declare
      Function
      t.AbsolutName
      (<s.FnProperties GenFunction-Decl> s.ScopeClass t.AbsolutName)
    )
    (Define
      Function t.AbsolutName
      (<s.FnProperties SwitchEnum s.ScopeClass> t.AbsolutName)
    );

  s.FnProperties
  t.hIModule Found s.ScopeClass Found (e.Sentences) NoAttrib t.AbsolutName =
    t.hIModule
    <GenFunction s.FnProperties t.AbsolutName s.ScopeClass e.Sentences>;

  s.FnProperties
  t.hIModule Found s.ScopeClass NoAttrib Found t.SrcPos Refal5 s.Type e.Native
  t.AbsolutName =
    <MError::LinkError-BadBackEndID t.SrcPos Refal5 'C++/SR or Simple Refal'>;

  s.FnProperties
  t.hIModule Found s.ScopeClass NoAttrib Found t.SrcPos s.BackEndID Code e.Code
  t.AbsolutName =
    t.hIModule
    <Declarations-Expr s.FnProperties e.Code>
    (Define
      Function
      t.AbsolutName
      (<s.FnProperties GenNativeInsertion-Body>
        t.AbsolutName s.ScopeClass t.SrcPos s.BackEndID e.Code
      )
    );
}

GenerateEntryCode
  s.FnProperties t.hIModule =
    <Generate-EntryCode-Aux
      s.FnProperties
      <MLambda::Apply
        <MLambda::Parallel-H
          & MIModule.GetModuleName
          <MLambda::Composite
            & MIModule.GetEntryPoint
            & MLambda.Bracket-H
          >
          & MIModule.GetImportList-RealNames
        >
        t.hIModule
      >
    >;

Generate-Aux
  s.FnProperties (e.OutName) t.hIModule e.FunctionsEntries =
    t.hIModule
    <MProfiler::Quantify & Profiling-MFileIO-Save
      (e.OutName)
      <MProfiler::Quantify & PatchSrcPos
        (e.OutName)
        <s.FnProperties GenCommonHeaders>
        <FilterDecls e.FunctionsEntries>
      >
    >;

Profiling-MFileIO-Save
  (e.OutName) e.Lines = <MFileIO::Save (e.OutName) e.Lines>;

Generate-EntryCode-Aux {
  s.FnProperties
  t.hIModule t.ModuleName (Go (Result e.Result)) e.Imports =
    t.hIModule
    <MLambda::Apply
      <s.FnProperties Generate-EntryCode-Go>
      s.FnProperties t.ModuleName (e.Result) e.Imports
    >;

  s.FnProperties
  t.hIModule t.ModuleName (Regular t.InitSeq t.FinalSeq) e.Imports =
    t.hIModule
    <MLambda::Apply
      <s.FnProperties Generate-EntryCode-InitFinal>
      s.FnProperties t.ModuleName t.InitSeq t.FinalSeq e.Imports
    >;
}

FilterDecls {
  e.Info = <DoFilterDecls () e.Info>;
}

DoFilterDecls {
  (e.Known-B (Declare s.Type t.Name t.Gen) e.Known-E)
  (Declare s.Type t.Name t.Gen2) e.Tail =
    <DoFilterDecls
      (e.Known-B (Declare s.Type t.Name t.Gen) e.Known-E) e.Tail
    >;

  (e.Known) (Declare s.Type t.Name t.Gen) e.Tail =
    <DoFilterDecls
      (e.Known (Declare s.Type t.Name t.Gen)) e.Tail
    >;

  (e.Known) (Define s.Type t.Name t.Gen) e.Tail =
    <DoFilterDecls
      (e.Known (Define s.Type t.Name t.Gen)) e.Tail
    >;

  (e.Known) (Native e.Info) e.Tail =
    <DoFilterDecls (e.Known (Native e.Info)) e.Tail>;

  (e.Known) =
    <GenerateElems e.Known>;
}

GenerateElems
  e.Known = <MProfiler::Quantify & Profiling-GenerateElems e.Known>;

Profiling-GenerateElems
  e.Known = <MLambda::Map & GenerateElem e.Known>;

GenerateElem {
  (Native s.FnGenNative t.SrcPos s.BackEndID e.Code) =
    <MProfiler::Quantify s.FnGenNative t.SrcPos s.BackEndID e.Code>;

  (s.DeclareDefine s.Type t.Name (s.Generator e.Arguments)) =
    <MProfiler::Quantify s.Generator e.Arguments>;
}

PatchSrcPos {
  (e.OutName) e.Lines-B PATCH-SHARP-LINE e.Lines-E =
    <DoPatchSrcPos (e.OutName) 2 e.Lines-B PATCH-SHARP-LINE e.Lines-E>;

  (e.OutName) e.Lines = e.Lines;
}

DoPatchSrcPos {
  (e.OutName) s.LineNo (e.Line) e.Lines =
    (e.Line)
    <DoPatchSrcPos (e.OutName) <MMath::Inc s.LineNo> e.Lines>;

  (e.OutName) s.LineNo PATCH-SHARP-LINE e.Lines =
    (<MSrcPos::SharpLine <MSrcPos::Create-FilePos s.LineNo e.OutName>>)
    <DoPatchSrcPos (e.OutName) <MMath::Inc s.LineNo> e.Lines>;

  (e.OutName) s.LineNo /* всё */ = /* всё */;
}

//----------------------------------------------------------------------

/**
  <GenFunction s.FnProperties t.AbsolutName s.ScopeClass e.Sentences>
    == e.GenFunctionResult

  Эту функцию можно использовать только для генерации кода точек входа.
*/
$ENTRY GenFunction
  s.FnProperties t.AbsolutName s.ScopeClass e.Sentences =
    <GenFunction-Declarations s.FnProperties e.Sentences>
    (Define
      Function
      t.AbsolutName
      (<s.FnProperties GenFunction-Code>
        t.AbsolutName s.ScopeClass e.Sentences
      )
    );

GenFunction-Declarations {
  s.FnProperties
  ( (Pattern e.PatternExpr) (Result e.ResultExpr) ) e.Tail =
    <Declarations-Expr s.FnProperties e.PatternExpr>
    <Declarations-Expr s.FnProperties e.ResultExpr>
    <GenFunction-Declarations s.FnProperties e.Tail>;

  s.FnProperties
  ( (Pattern e.PatternExpr) s.EntryCodeType (Result e.ResultExpr) ) e.Tail =
    <Declarations-Expr s.FnProperties e.PatternExpr>
    <Declarations-Expr s.FnProperties e.ResultExpr>
    <GenFunction-Declarations s.FnProperties e.Tail>;

  s.FnProperties = ;
}

Declarations-Expr {
  s.FnProperties (Structure e.InBrackets) e.Tail =
    <Declarations-Expr s.FnProperties e.InBrackets e.Tail>;

  s.FnProperties (Abstract t.Callable e.InBrackets) e.Tail =
    <Declarations-Callable s.FnProperties t.Callable>
    <Declarations-Expr s.FnProperties e.InBrackets e.Tail>;

  s.FnProperties (Function t.Callable e.InBrackets) e.Tail =
    <Declarations-Callable s.FnProperties t.Callable>
    <Declarations-Expr s.FnProperties e.InBrackets e.Tail>;

  s.FnProperties (IndirectCall (SVar e.Index) e.InBrackets) e.Tail =
    <Declarations-Expr s.FnProperties e.InBrackets e.Tail>;

  s.FnProperties (EntryCode s.CodeType e.InBracket) e.Tail =
    <Declarations-Expr s.FnProperties e.InBracket e.Tail>;

  s.FnProperties t.SimpleTerm e.Tail =
    <Declarations-Term s.FnProperties t.SimpleTerm>
    <Declarations-Expr s.FnProperties e.Tail>;

  s.FnProperties = ;
}

Declarations-Callable {
  s.FnProperties (s.CallType t.SrcPos t.QualifiedName) =
    (Declare
      Function
      t.QualifiedName
      (<s.FnProperties GenFunction-Decl> s.CallType t.QualifiedName)
    );
}

Declarations-Term {
  s.FnProperties (Identifier t.SrcPos e.Name) =
    (Declare
      Identifier <MQualifiedName::Create (e.Name)>
      (<s.FnProperties GenIdent> e.Name)
    );

  s.FnProperties (EVar e.Index) = ;
  s.FnProperties (TVar e.Index) = ;
  s.FnProperties (SVar e.Index) = ;

  s.FnProperties (Literal e.Content) = ;
  s.FnProperties (Macro s.Value) = ;

  s.FnProperties (FnPtr t.Callable) =
    <Declarations-Callable s.FnProperties t.Callable>;

  s.FnProperties (Native t.SrcPos e.Code) = ;
}

$END MPredeclGenerator.

