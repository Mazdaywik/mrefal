$MODULE MClusters;
/**=============================================================================
  Функции модуля обрабатывают "гроздь" модулей -- набор прямо или косвенно зави-
сящих модулей от некоторого модуля. Две основные фукции модуля: CheckNeedCompile
для проверки необходимости перекомпиляции данного модуля и ListForLinking для
получения списка модулей (упорядоченных в топологическом порядке), подлежащих
компоновке.
==============================================================================*/

$IMPORT MContext;
$IMPORT MFE-Mgr;
$IMPORT MFileSystem;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MModules;
$IMPORT MOrder;
$IMPORT MStrings;
$IMPORT MSymModule;

//==============================================================================

/*
  <DependencesList t.hContext t.ModuleName>
    == t.hContext Avail t.ImportedModules*
    == t.hContext NotAvail
    == t.hContext Fails
*/
DependencesList
  t.hContext t.ModuleName =
    <DependencesList-SwAvail
      t.ModuleName
      <MContext::GetStatusType
        t.hContext t.ModuleName
      >
    >;

DependencesList-SwAvail {
  t.ModuleName t.hContext Success s.Status Updated =
    <DependencesList-OnAvail
      t.hContext t.ModuleName
    >;

  t.ModuleName t.hContext Success s.Status Library =
    <DependencesList-OnAvail
      t.hContext t.ModuleName
    >;

  t.ModuleName t.hContext Success Ready Changed =
    <DependencesList-OnAvail
      t.hContext t.ModuleName
    >;

  t.ModuleName t.hContext Success s.OtherStatus s.OtherType =
    t.hContext Fails;

  t.ModuleName t.hContext Fails ModuleNotFound =
    t.hContext NotAvail;

  t.ModuleName t.hContext Fails MismatchCase =
    t.hContext NotAvail;
}

DependencesList-OnAvail
  t.hContext t.ModuleName =
    <DependencesList-OnAvail-Aux
      <MSymModule::LoadInfo t.hContext t.ModuleName>
    >;

DependencesList-OnAvail-Aux {
  t.hContext Success t.hIModule =
    <DependencesList-OnAvail-OnSuccess
      t.hContext <DependencesFromIModule t.hIModule>
    >;

  t.hContext Fails =
    t.hContext Fails;
}

DependencesList-OnAvail-OnSuccess
  t.hContext t.hIModule e.ImportedModuleNames =
    <MIModule::Destroy t.hIModule>
    t.hContext Avail e.ImportedModuleNames;

//------------------------------------------------------------------------------

/**
  <DependencesFromIModule t.hIModule>
    == t.hIModule t.ImportedModule*
*/
$ENTRY DependencesFromIModule
  t.hIModule = <MIModule::GetImportList-RealNames t.hIModule>;

//==============================================================================

/**
  <CheckNeedCompile-LinkOnly
    t.hContext t.Config t.ModuleName
  >
    == t.hContext t.ModuleName Success s.Status s.Type
    == t.hContext t.ModuleName Fails MismatchCase
*/
$ENTRY CheckNeedCompile-LinkOnly
   t.hContext t.Config t.ModuleName =
     <SwCheckNeedCompile-LinkOnly
       t.ModuleName
       <MModules::LookupImportModule
         t.hContext t.Config t.ModuleName
       >
     >;

SwCheckNeedCompile-LinkOnly {
  t.ModuleName t.hContext Success Ready s.Status =
    t.hContext t.ModuleName Success Ready s.Status;

  t.ModuleName t.hContext Success Raw s.Status =
    t.hContext t.ModuleName Success Raw s.Status;

  t.ModuleName t.hContext Success Found Errors =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Errors
    >;

  t.ModuleName t.hContext Success Found Changed =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Errors
    >;

  t.ModuleName t.hContext Success Found Updated =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Updated
    >;

  t.ModuleName t.hContext Success Found Library =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Library
    >;

  t.ModuleName t.hContext Fails MismatchCase =
    t.hContext t.ModuleName Fails MismatchCase;
}

CheckNeedCompile-UpdateStatusType
  t.hContext t.ModuleName s.NewType =
    <CheckNeedCompile-UpdateStatusType-Aux
      <MContext::SetRawType t.hContext t.ModuleName s.NewType>
      t.ModuleName s.NewType
    >;

CheckNeedCompile-UpdateStatusType-Aux {
  t.hContext Success t.ModuleName s.NewType =
    t.hContext t.ModuleName Success Raw s.NewType;

  t.hContext Fails MismatchCase t.ModuleName s.NewType =
    t.hContext t.ModuleName Fails MismatchCase;
}

//------------------------------------------------------------------------------

/**
  <CheckNeedCompile-Build
    t.hContext t.Config t.ModuleName
  >
    == t.hContext t.ModuleName Success s.Status s.Type
    == t.hContext t.ModuleName Fails MismatchCase
*/
$ENTRY CheckNeedCompile-Build
   t.hContext t.Config t.ModuleName =
     <SwCheckNeedCompile-Build
       t.ModuleName
       <MModules::LookupImportModule
         t.hContext t.Config t.ModuleName
       >
     >;

SwCheckNeedCompile-Build {
  t.ModuleName t.hContext Success Ready s.Status =
    t.hContext t.ModuleName Success Ready s.Status;

  t.ModuleName t.hContext Success Raw s.Status =
    t.hContext t.ModuleName Success Raw s.Status;

  t.ModuleName t.hContext Success Found Errors =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Errors
    >;

  t.ModuleName t.hContext Success Found Changed =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Changed
    >;

  t.ModuleName t.hContext Success Found Updated =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Changed
    >;

  t.ModuleName t.hContext Success Found Library =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Library
    >;

  t.ModuleName t.hContext Fails MismatchCase =
    t.hContext t.ModuleName Fails MismatchCase;
}

//------------------------------------------------------------------------------

/**
  <CheckNeedCompile-Make
    t.hContext t.Config t.ModuleName
  >
    == t.hContext t.ModuleName Success s.Status s.Type
    == t.hContext t.ModuleName Fails MismatchCase
*/
$ENTRY CheckNeedCompile-Make
  t.hContext t.Config t.ModuleName =
    <CheckNeedCompile-R
      (/* стек */) t.hContext t.Config t.ModuleName
    >;

/*
  Для защиты от зацикливания вследствие рекурсии будем вести
  отсчёт просматриваемых модулей в стеке.
*/
CheckNeedCompile-R
  (e.Stack)
  t.hContext t.Config t.ModuleName =
    <CheckNeedCompile-SwRoot
      (e.Stack) t.Config t.ModuleName
      <MModules::LookupImportModule
        t.hContext t.Config t.ModuleName
      >
    >;

CheckNeedCompile-SwRoot {
  (e.Stack) t.Config t.ModuleName
  t.hContext Success Ready s.Status =
    t.hContext t.ModuleName Success Ready s.Status;

  (e.Stack) t.Config t.ModuleName
  t.hContext Success Raw s.Status =
    t.hContext t.ModuleName Success Raw s.Status;

  (e.Stack) t.Config t.ModuleName
  t.hContext Success Found Errors =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Errors
    >;

  (e.Stack) t.Config t.ModuleName
  t.hContext Success Found Changed =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Changed
    >;

  (e.Stack) t.Config t.ModuleName
  t.hContext Success Found Updated =
    <CheckNeedCompile-SwOne
      (e.Stack) t.Config
      <CheckNeedCompileOne
        t.hContext t.Config t.ModuleName
      >
    >;

  (e.Stack) t.Config t.ModuleName
  t.hContext Success Found Library =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Library
    >;

  (e.Stack) t.Config t.ModuleName
  t.hContext Fails MismatchCase =
    t.hContext t.ModuleName Fails MismatchCase;
}

CheckNeedCompile-SwOne {
  (e.Stack) t.Config
  t.hContext t.ModuleName Success Found Updated =
    <CheckNeedCompile-UpdateContext
      <CheckNeedCompile-ScanImports
        (e.Stack) t.Config t.ModuleName
        <DependencesList t.hContext t.ModuleName>
      >
    >;

  (e.Stack) t.Config
  t.hContext t.ModuleName Success Found Changed =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName Changed
    >;

  (e.Stack) t.Config
  t.hContext t.ModuleName Success Raw s.Type =
    t.hContext t.ModuleName Success Raw s.Type;

  (e.Stack) t.Config
  t.hContext t.ModuleName Success Ready s.Type =
    t.hContext t.ModuleName Success Ready s.Type;

  (e.Stack) t.Config
  t.hContext t.ModuleName Fails MismatchCase =
    t.hContext t.ModuleName Fails MismatchCase;
}

CheckNeedCompile-UpdateContext
  t.hContext t.ModuleName Success s.Type =
    <CheckNeedCompile-UpdateStatusType
      t.hContext t.ModuleName s.Type
    >;

GuardUpdateContext
  t.hContext Success = t.hContext;

CheckNeedCompile-ScanImports {
  /*
    В случае циклических связей возвратим NeedRecompile, т.к.
    сюда не доходит t.hErrorList. Пускай лучше при перекомпиляции
    будет выдано сообщение об ошибке.
  */
  (e.Stack-B t.RecursiveModule e.Stack-E )
  t.Config t.ModuleName
  t.hContext Avail
  e.Imports-B t.RecursiveModule e.Imports-E =
    t.hContext t.ModuleName Changed;

  (e.Stack) t.Config t.ModuleName
  t.hContext Avail e.Imports =
    <CheckNeedCompile-ScanResults
      t.ModuleName
      <MLambda::MapReduce
        <MLambda::Composite
          <MLambda::BindLeft-H
            <MLambda::BindLeft & CheckNeedCompile-R ( e.Stack t.ModuleName )>
            t.Config
          >
          & MLambda.Bracket-H
        >
        t.hContext e.Imports
      >
    >;

  /*
    Реакция на ошибки, возможно, неразумная.
  */
  (e.Stack) t.Config t.ModuleName
  t.hContext NotAvail =
    t.hContext t.ModuleName Success Changed;

  (e.Stack) t.Config t.ModuleName
  t.hContext Fails =
    t.hContext t.ModuleName Success Changed;
}

CheckNeedCompile-ScanResults {
  t.ModuleName t.hContext
  e.Results-B (t.ImportName Success s.Status Changed) e.Results-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext
  e.Results-B (t.ImportName Success s.Status Errors) e.Results-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext
  e.Results-B (t.ImportName Fails e.FailsReason) e.Results-E =
    t.hContext t.ModuleName Success Changed;
  /*
    Оставшийся случай
    e.Results ::= (t.ImportName Success s.Status Library | Updated)*
  */
  t.ModuleName t.hContext e.Results =
    <CheckNeedCompile-CompareTimes
      t.ModuleName
      <MLambda::MapReduce
        <MLambda::Composite
          & GetTime
          & MLambda.Bracket-H
        >
        t.hContext
        t.ModuleName
        <MLambda::Map
          <MLambda::Composite
            & MLambda.UnBracket
            <MLambda::BindLeft & MStrings.First 1>
          >
          e.Results
        >
      >
    >;
}

CheckNeedCompile-CompareTimes {
  t.ModuleName t.hContext
  e.Times-B ( Fails MismatchCase ) e.Times-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext
  e.Times-B ( Success s.Status Changed e.Time ) e.Times-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext
  ( Success s.Status Updated (e.MinSrcTime) (e.MaxSrcTime) )
  e.DependedTimes =
    <CheckNeedCompile-SwCompareTimes
      t.ModuleName t.hContext
      <MLambda::Map
        <MLambda::Composite
          & MLambda.UnBracket
          <MLambda::BindLeft & MStrings.Skip 4>
          <MLambda::BindLeft & MOrder.Compare (e.MaxSrcTime)>
        >
        e.DependedTimes
      >
    >;
}

CheckNeedCompile-SwCompareTimes {
  t.ModuleName t.hContext e.Compares-B '<' e.Compares-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext e.Compares-B '=' e.Compares-E =
    t.hContext t.ModuleName Success Changed;

  t.ModuleName t.hContext e.Compares =
    t.hContext t.ModuleName Success Updated;
}

//------------------------------------------------------------------------------

/*
  <CheckNeedCompileOne
    t.hContext t.Config t.ModuleName
  >
    == t.hContext t.ModuleName Success s.Status s.Type
    == t.hContext t.ModuleName Fails MismatchCase
*/
CheckNeedCompileOne
  t.hContext t.Config t.ModuleName =
    <CheckNeedCompileOne-SwGetLastTime
      t.ModuleName
      <GetTime t.hContext t.ModuleName>
    >;

CheckNeedCompileOne-SwGetLastTime {
  t.ModuleName t.hContext
  Success s.Status s.Type Unknown =
    t.hContext t.ModuleName Success s.Status s.Type;

  t.ModuleName t.hContext
  Success s.Status s.Type (e.MinTime) (e.MaxTime) =
    t.hContext t.ModuleName Success s.Status s.Type;

  t.ModuleName t.hContext Fails MismatchCase =
    t.hContext t.ModuleName Fails MismatchCase;
}

//------------------------------------------------------------------------------

/*
  Вызывается только если s.Type == Updated | Library.

  <GetTime t.hContext t.ModuleName>
    == t.hContext Success s.Status s.Type (e.MinTime) (e.MaxTime)
    == t.hContext Fails MismatchCase
*/
GetTime
  t.hContext t.ModuleName =
    <GetLastTime-SwKnown
      t.ModuleName
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::Composite
            <MLambda::BindRight & MContext.GetStatusType t.ModuleName>
            & MLambda.Bracket-H
          >
          <MLambda::Composite
            <MLambda::BindRight & MContext.GetMinMaxTime t.ModuleName>
            & MLambda.Bracket-H
          >
        >
        t.hContext
      >
    >;

GetLastTime-SwKnown {
  t.ModuleName t.hContext ( Fails MismatchCase ) ( Fails MismatchCase ) =
    t.hContext Fails MismatchCase;

  t.ModuleName t.hContext
  ( Success s.Status Updated ) ( Success (e.MinTime) (e.MaxTime) ) =
    t.hContext Success s.Status Updated (e.MinTime) (e.MaxTime);

  t.ModuleName t.hContext
  ( Success s.Status Library ) ( Success (e.MinTime) (e.MaxTime) ) =
    t.hContext Success s.Status Library (e.MinTime) (e.MaxTime);

  t.ModuleName t.hContext ( Success s.Status s.Type ) ( Success Unknown ) =
    <GetLastTime-CalcTime
      t.ModuleName s.Type
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::Composite
            <MLambda::BindRight & MContext.GetBackEndList t.ModuleName>
            & MLambda.Bracket-H
          >
          <MLambda::Composite
            <MLambda::BindRight & MContext.GetFrontEnd t.ModuleName>
            & MLambda.Bracket-H
          >
        >
        t.hContext
      >
    >;
}

GetLastTime-CalcTime {
  t.ModuleName s.ModuleType t.hContext
  ( Fails MismatchCase ) ( Fails MismatchCase ) =
    t.hContext Fails MismatchCase;

  t.ModuleName Library t.hContext
  ( Success e.BackEnds ) ( Success None ) =
    /*
      Наличие не проверяем -- для библиотеки все файлы должны быть найдены.
    */
    <GetLastTime-MakeResult-Library
      t.ModuleName Library t.hContext
      <MOrder::Sort
        <MLambda::Map
          <MLambda::Composite
            & MLambda.UnBracket
            <MLambda::BindLeft & MStrings.Skip 1>
            <MLambda::BindLeft & MFileSystem.FileAttribute DateTime>
          >
          e.BackEnds
        >
      >
    >;

  t.ModuleName Updated t.hContext
  ( Success e.BackEnds ) ( Success s.FEName s.Init e.FrontEndName ) =
    /*
      Наличие не проверяем, т.к. функция MModules::LookupImportModule проверяет
      наличие входных файлов и возвращает Updated только когда все выходные файлы
      присутствуют.
    */
    <GetLastTime-OutTime
      t.ModuleName t.hContext
      <MFileSystem::FileAttribute DateTime s.Init e.FrontEndName>
      <MOrder::Sort
        <MLambda::Map
          <MLambda::Composite
            & MLambda.UnBracket
            <MLambda::BindLeft & MStrings.Skip 1>
            <MLambda::BindLeft & MFileSystem.FileAttribute DateTime>
          >
          e.BackEnds
        >
      >
    >;
}

GetLastTime-MakeResult-Library
  t.ModuleName Library t.hContext (e.MinTime) e.Times (e.MaxTime) =
    <GuardUpdateContext
      <MContext::SetMinMaxTime
        t.hContext t.ModuleName (e.MinTime) (e.MaxTime)
      >
    >
    Success Found Library (e.MinTime) (e.MaxTime);

GetLastTime-OutTime
  t.ModuleName t.hContext (e.SrcTime) (e.MinTime) e.Times (e.MaxTime) =
    <GetLastTime-Compare
      t.ModuleName t.hContext (e.MaxTime)
      <MOrder::Compare-T (e.SrcTime) (e.MinTime)>
    >;

GetLastTime-Compare {
  t.ModuleName t.hContext (e.MaxTime) '<' (e.SrcTime) (e.MinTime) =
    <GuardUpdateContext
      <MContext::SetMinMaxTime
        t.hContext t.ModuleName (e.SrcTime) (e.MaxTime)
      >
    >
    Success Found Updated (e.SrcTime) (e.MaxTime);

  t.ModuleName t.hContext (e.MaxTime) s.OtherOrder (e.SrcTime) (e.MinTime) =
    <GuardUpdateContext
      <MContext::SetMinMaxTime
        t.hContext t.ModuleName (e.SrcTime) (e.MaxTime)
      >
    >
    Success Found Changed (e.MinTime) (e.MaxTime);
}

//==============================================================================

/**
  <ListForLinking t.hContext t.RootModuleName>
    == t.hContext Success t.ModuleName*
    == t.hContext Fails
*/
$ENTRY ListForLinking
  t.hContext t.RootModuleName =
    <LoadDependences
      t.hContext () t.RootModuleName
    >;

/*
  <LoadDependences t.hContext (e.Loaded) e.NotLoaded>

  e.Loaded ::= ( t.Head e.Dependend )
  e.NotLoaded ::= t.ModuleName
*/
LoadDependences {
  t.hContext ( e.Loaded ) =
    t.hContext
    <TopologicalSort e.Loaded>;

  t.hContext ( e.Loaded ) t.Next e.NotLoaded =
    <LoadDependences-UpdateLoaded
      ( e.Loaded ) t.Next <DependencesList t.hContext t.Next> ( e.NotLoaded )
    >;
}

LoadDependences-UpdateLoaded {
  ( e.Loaded ) t.Next t.hContext Avail e.List ( e.NotLoaded ) =
    <LoadDependences
      t.hContext
      <DeleteDetected
        ( e.Loaded (t.Next e.List) ) <Unique e.List e.NotLoaded>
      >
    >;

  ( e.Loaded ) t.Next t.hContext NotAvail ( e.NotLinked ) =
    t.hContext Fails;

  ( e.Loaded ) t.Next t.hContext Fails ( e.NotLinked ) =
    t.hContext Fails;
}

DeleteDetected {
  ( e.Loaded-B (t.Master e.Slaves) e.Loaded-E )
  e.NotLoaded-B t.Master e.NotLoaded-E =
    <DeleteDetected
      ( e.Loaded-B (t.Master e.Slaves) e.Loaded-E )
      e.NotLoaded-B e.NotLoaded-E
    >;

  ( e.Loaded ) e.NotLoaded = ( e.Loaded ) e.NotLoaded;
}

Unique {
  e.Set-B t.Double e.Set-M t.Double e.Set-E =
    e.Set-B <Unique t.Double e.Set-M e.Set-E>;

  e.Set = e.Set;
}

/*
    Топологическая сортировка.
    Для некоторого набора элементов определено отношение t.X << t.Y (для неко-
  торых не определено), причём выполняются следующие условия:
    (1) t.X << t.Y && t.Y << t.Z => t.X << t.Z
    (2) t.X << t.Y => not( t.Y << t.X )
    как то так.

    Описание алгоритма. На входе имеем информацию: для каждого t.X из множества
  { t.X } заданы такие { t.Y } из { t.X }, для которых верно t.X << t.Y.
    Алгоритм имеет итеративную природу
    На каждой итерации:
    (1) Выбираем t.Head из { t.X } такой, что t.Head не принадлежит не одному
  { t.Y } для какого-либо t.X. Если t.Head найти не удаётся, значит в графе
  зависмостей есть циклы. Алгоритм не применим по определению.
    (2) t.Head добавляем в конец результата, удаляем t.Head из { t.X }
    (3) Алгоритм завершается, когда в { t.X } не остаётся элементов.
*/
TopologicalSort
  e.Loaded =
    <DoTopologicalSort
      ( /* Результат */ )
      ( <FindSlaves e.Loaded> )
      ( /* Неголовные */ )
      e.Loaded
    >;

FindSlaves
  e.Loaded = <Unique <MLambda::Map & Slaves e.Loaded>>;

Slaves
  (t.Master e.Slaves) = e.Slaves;

DoTopologicalSort {
  ( e.Result ) ( e.AllSlaves-B t.Master e.AllSlaves-E ) ( e.NotHead )
  ( t.Master e.Slaves ) e.Tail =
    <DoTopologicalSort
      ( e.Result )
      ( e.AllSlaves-B t.Master e.AllSlaves-E )
      ( e.NotHead (t.Master e.Slaves) )
      e.Tail
    >;

  ( e.Result ) ( e.AllSlaves ) ( e.NotHead )
  (t.Head e.Slaves) e.Tail =
    <DoTopologicalSort
      ( e.Result t.Head )
      ( <FindSlaves e.Tail e.NotHead> )
      ( /* Неголовные */ )
      e.Tail e.NotHead
    >;

  // Завершение итераций
  ( e.Result ) ( ) ( ) = Success e.Result;

  // Случай циклических связей
  ( e.Result ) ( e.AllSlaves ) ( e.NotHead ) = Fails;
}

$END MClusters.
