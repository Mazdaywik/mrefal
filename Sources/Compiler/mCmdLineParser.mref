$MODULE MCmdLineParser;

$IMPORT FileIO;
$IMPORT Math;
$IMPORT MError;
$IMPORT MLambda;
$IMPORT MSrcPos;
$IMPORT MStrings;

/**
  t.CmdLineInfo ::=
    (CmdLineInfo
      (ModulePath (e.Path)*)
      (Mode Make | Build | LinkOnly)
      (BackEnd s.BackEnd)
      (CreateXLinx True | False)
      (Files (e.FileName)*)
    )

  s.BackEnd ::= Refal5
*/


/**
  <Parse t.hErrorList (e.Argument)*>
    == t.hErrorList Success t.CmdLineInfo
    == t.hErrorList Fails
*/
$ENTRY Parse
  t.hErrorList (e.ProgName) e.Options =
    <Parse-SwPreparseErrors
      t.hErrorList <PreScan (/* стек файлов */) <Renumerate e.Options>>
    >;

Renumerate
  e.Options =
    <MStrings::Skip 1
      <MLambda::MapReduce
        & RenumerateOption 1 e.Options
      >
    >;

RenumerateOption
  s.Number (e.Option) =
    <Math::Inc s.Number>
    (<MSrcPos::Create-CmdLine s.Number> e.Option);

/*
  t.Option ::=
    (File t.SrcPos e.FileName)
    (OpenBracket t.SrcPos)
    (CloseBracket t.SrcPos)
    (Error t.SrcPos e.Message)
    (OptionParam t.SrcPos (e.Name) e.Value)
    (OptionNaked t.SrcPos e.Option)
*/

PreScan {
  t.FileStack (t.SrcPos '+' e.Option) e.Tail =
    <PreScan-Option
      t.FileStack (t.SrcPos <MStrings::Trim e.Option>) e.Tail
    >;

  t.FileStack (t.SrcPos '-' e.Option) e.Tail =
    <PreScan-Option
      t.FileStack (t.SrcPos <MStrings::Trim e.Option>) e.Tail
    >;

  t.FileStack (t.SrcPos '(') e.Tail =
    (OpenBracket t.SrcPos) <PreScan t.FileStack e.Tail>;

  t.FileStack (t.SrcPos ')') e.Tail =
    (CloseBracket t.SrcPos) <PreScan t.FileStack e.Tail>;

  t.FileStack (t.SrcPos e.FileName) e.Tail =
    (File t.SrcPos e.FileName)
    <PreScan t.FileStack e.Tail>;

  (e.Stack (e.LastConfigFile)) PopStackFile e.Tail =
    <PreScan (e.Stack) e.Tail>;

  (/* нет файлов */) /* кончились опции */ = ;
}

PreScan-Option {
  t.FileStack (t.SrcPos e.Name ':' e.Option) e.Tail =
    <PreScan-Option-Param
       t.FileStack
       t.SrcPos
       (<MStrings::Trim e.Name>)
       (<MStrings::Trim e.Option>)
       e.Tail
    >;

  t.FileStack (t.SrcPos e.Option) e.Tail =
    (OptionNaked t.SrcPos e.Option)
    <PreScan t.FileStack e.Tail>;
}

PreScan-Option-Param {
  /*
    Не смотря на то, что имя для файла может задаваться неоднозначно
    (абсолютным или относительным путём, различия в регистре, в слешах)
    мы здесь сравниваем пути к файлам на простое совпадение.

    Это связано с тем, что когда мы попадём в циклическую связь
    (петля, например, начинается с файла file.cfg),
    мы повторно прочитаем строчку загрузки в файле file.cfg
    и, соответственно, увидим точно такое же имя файла --
    циклическая связь будет обнаружена.
  */
  (e.Stack-B (e.ConfigFile) e.Stack-E)
  t.SrcPos ('cfg') (e.ConfigFile) e.Tail =
    (Error
      t.SrcPos 'Cyclic loading configuration file \'' e.ConfigFile '\''
    )
    <PreScan
      (e.Stack-B (e.ConfigFile) e.Stack-E) e.Tail
    >;

  (e.Stack) t.SrcPos ('cfg') (e.ConfigFile) e.Tail =
    <PreScan
      (e.Stack (e.ConfigFile))
      <MStrings::Skip 1
        <MLambda::MapReduce
          <MLambda::Composite
            <MLambda::MakeHandled
              <MLambda::Composite
                & MLambda.UnBracket
                & MStrings.Trim
              >
            >
            <MLambda::BindLeft
              & MakeConfigOption (e.ConfigFile)
            >
          >
          1 /* номера строк */
          <FileIO::Load e.ConfigFile>
        >
      >
      PopStackFile
      e.Tail
    >;

  t.FileStack t.SrcPos ('file') (e.FileName) e.Tail =
    (File t.SrcPos e.FileName)
    <PreScan t.FileStack e.Tail>;

  t.FileStack t.SrcPos (e.Name) (e.Value) e.Tail =
    (OptionParam
      t.SrcPos
      (<MStrings::Trim e.Name>)
      <MStrings::Trim e.Value>
    )
    <PreScan t.FileStack e.Tail>;
}

MakeConfigOption {
  (e.ConfigFile) s.LineNumber '#' e.Comment =
    <Math::Inc s.LineNumber>;

  (e.ConfigFile) s.LineNumber /* пустая строчка */ =
    <Math::Inc s.LineNumber>;

  (e.ConfigFile) s.LineNumber e.Option =
    <Math::Inc s.LineNumber>
    (<MSrcPos::Create-FilePos s.LineNumber e.ConfigFile> e.Option);
}

//------------------------------------------------------------------------------

Parse-SwPreparseErrors {
  t.hErrorList e.Options-B (Error t.SrcPos e.Message) e.Options-E =
    <MLambda::Reduce
      & AddLexerError t.hErrorList (Error t.SrcPos e.Message) e.Options-E
    >
    Fails;

  t.hErrorList e.Options =
    <Parse-BalanceBrackets
      t.hErrorList Success () () e.Options
    >;
}

AddLexerError {
  t.hErrorList (Error t.SrcPos e.Message) =
    <MError::AddCmdLineError t.hErrorList t.SrcPos e.Message>;

  t.hErrorList t.OtherOption = t.hErrorList;
}

Parse-BalanceBrackets {
  t.hErrorList s.Result
  (e.MultiBracket) (e.Scanned) (OpenBracket t.L-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket (t.L-SrcPos e.Scanned)) () e.Tail
    >;

  t.hErrorList s.Result
  (e.MultiBracket (t.L-SrcPos e.Scanned))
  (e.SubScanned) (CloseBracket t.R-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket) (e.Scanned (Group t.L-SrcPos e.SubScanned)) e.Tail
    >;

  t.hErrorList s.Result
  () (e.Scanned) (CloseBracket t.R-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      <MError::AddCmdLineError
        t.hErrorList t.R-SrcPos 'Unballanced bracket \')\''
      >
      Fails () (e.Scanned) e.Tail
    >;

  t.hErrorList s.Result
  (e.MultiBracket (t.L-SrcPos e.Scanned)) (e.SubScanned) =
    <Parse-BalanceBrackets
      <MError::AddCmdLineError
        t.hErrorList t.L-SrcPos 'Unballanced bracket \'(\''
      >
      Fails (e.MultiBracket) ()
    >;

  t.hErrorList s.Result
  (e.MultiBracket) (e.Scanned) t.NextOption e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket) (e.Scanned t.NextOption) e.Tail
    >;

  t.hErrorList Fails () (e.Scanned) =
    t.hErrorList Fails;

  t.hErrorList Success () (e.Scanned) =
    <ParseAnalyze
      t.hErrorList Success & TopLevelOptions
      (/* Собранная информация */) e.Scanned
    >;
}

ParseAnalyze {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze-File
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap EnableFile>
      (File t.SrcPos e.FileName) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze-Param
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap e.Option>
      (OptionParam t.SrcPos (e.Option) e.Value) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze-Naked
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap e.Option>
      (OptionNaked t.SrcPos e.Option) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (Group t.SrcPos e.Info) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Orphan group'
      >
      Fails t.FnOptionsMap t.Collected e.Info e.Tail
    >;

  t.hErrorList Success t.FnOptionsMap (e.Collected) =
    <ParseAnalyze-FinishCollected
      t.hErrorList
      <MLambda::Apply t.FnOptionsMap FinishCollected>
      e.Collected
    >;

  t.hErrorList Fails e.Collected =
    t.hErrorList Fails;
}

ParseAnalyze-FinishCollected {
  t.hErrorList t.FnFinishCollected e.Collected =
    <MLambda::Apply
      t.FnFinishCollected t.hErrorList e.Collected
    >;
}

ParseAnalyze-File {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (FileEnable t.FnAddFile) (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze
      t.hErrorList s.Result t.FnOptionsMap
      <MLambda::Apply t.FnAddFile t.Collected e.FileName>
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (FileDisable) (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Unexpected filename'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Param {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap
      t.Collected t.FnUpdateOption
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Single)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        s.Result t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected e.Value
        >
      >
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group-ErrorNaked
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap t.Collected
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
        >
        t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Single)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  NotFound
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Unknown ' e.Option
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Param-Group {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        Success t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected e.Value t.SubInfo
        >
      >
      e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}

ParseAnalyze-FnUpdateResult {
  s.Result t.FnOptionsMap
  t.hErrorList Success t.Collected =
    t.hErrorList s.Result t.FnOptionsMap t.Collected;

  s.Result t.FnOptionsMap
  t.hErrorList Fails t.Collected =
    t.hErrorList Fails t.FnOptionsMap t.Collected;
}

ParseAnalyze-Param-Group-ErrorNaked {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Name ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos
          'Option ' e.Name ' must haven\'t argument'
        >
        t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Naked {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Naked-Group-ErrorParam
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap t.Collected
      (OptionNaked t.SrcPos e.Option)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos 'Option ' e.Option ' must have argument'
        >
        t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Single)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Option ' must have argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Naked-Group
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap
      t.Collected t.FnUpdateOption
      (OptionNaked t.SrcPos e.Option)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Single)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        s.Result t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption t.hErrorList t.SrcPos t.Collected
        >
      >
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  NotFound
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Unknown ' e.Option
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Naked-Group {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionNaked t.SrcPos e.Option) t.G-SrcPos e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        Success t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected t.SubInfo
        >
      >
      e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionNaked t.SrcPos e.Option) t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.G-SrcPos 'Can\'t create group for option ' e.Option
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}

ParseAnalyze-Naked-Group-ErrorParam {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected
  (OptionNaked t.SrcPos e.Option) t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Option ' must have argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected
  (OptionNaked t.SrcPos e.Option) t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos
          'Option ' e.Option ' must have argument'
        >
        t.G-SrcPos 'Can\'t create group for option ' e.Option
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

//------------------------------------------------------------------------------

/**
  t.FnOptionsMap ::= {
    EnableFile = ( FileEnable t.FnAddFile ) | (FileDisable);

    e.Option =
      t.FnUpdateOption-Param-Group Param (Group t.SubFnOptionsMap) |
      t.FnUpdateOption-Param-Single Param (Single) |
      t.FnUpdateOption-Naked-Group Naked (Group t.SubFnOptionsMap) |
      t.FnUptateOption-Naked-Single Naked (Signle) |
      NotFound

    FinishCollected = t.FnFinishCollected;
  }

  t.FnUpdateOption-Param-Group ::= {
    t.hErrorList t.SrcPos t.Collected e.Value t.SubInfo =
      t.hErrorList Success t.Collected |
      t.hErrorList Fails t.Collected;
  }

  t.FnUpdateOption-Param-Singe ::= {
    t.hErrorList t.SrcPos t.Collected e.Value =
      t.hErrorList Success t.Collected |
      t.hErrorList Fails t.Collected;
  }

  t.FnUpdateOption-Naked-Group ::= {
    t.hErrorList t.SrcPos t.Collected t.SubInfo =
      t.hErrorList Success t.Collected |
      t.hErrorList Fails t.Collected;
  }

  t.FnUpdateOption-Naked-Singe ::= {
    t.hErrorList t.SrcPos t.Collected
      t.hErrorList Success t.Collected |
      t.hErrorList Fails t.Collected;
  }

  t.FnAddFile ::= {
    t.Collected e.FileName = t.Collected
  }

  t.Collected ::= (e.Collected)

  t.FnFinishCollected ::= {
    t.hErrorList e.Collection =
      t.hErrorList Success t.CmdLineInfo |
      t.hErrorList Fails 
  }
*/

TopLevelOptions {
  EnableFile = (FileEnable & AddFile);

  FinishCollected = & FinishTopLevel;

  'MP' = & AddModulePath Param (Single);

  'make' = <MLambda::BindRight & AddMakeMode Make> Naked (Single);
  'build' = <MLambda::BindRight & AddMakeMode Build> Naked (Single);
  'linkonly' = <MLambda::BindRight & AddMakeMode LinkOnly> Naked (Single);

  'be' = & AddBackEnd Param (Single);

  'xlinx' = & AddXLinx Naked (Single);

  'tune-be' = & TuneBackEnd Param (Group & BackEndGroup);

  e.Other = NotFound;
}

AddModulePath {
  t.hErrorList t.SrcPos
  (e.Options-B (ModulePath e.Paths) e.Options-E) e.Path =
    t.hErrorList Success
    (e.Options-B (ModulePath e.Paths (e.Path)) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) e.Path =
    t.hErrorList Success (e.Options (ModulePath (e.Path)));
}

AddMakeMode {
  t.hErrorList t.SrcPos
  (e.Options-B (Mode s.Mode) e.Options-E) s.NewMode =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Multiple declarations of make mode'
    >
    Fails (e.Options-B (Mode s.Mode) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) s.NewMode =
    t.hErrorList Success (e.Options (Mode s.NewMode));
}

AddBackEnd {
  t.hErrorList t.SrcPos
  (e.Options-B (BackEnd s.BackEnd) e.Options-E) e.OtherBackEnd =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Redefinition of back-end'
    >
    Fails (e.Options-B (BackEnd s.BackEnd) e.Options-E);

  t.hErrorList t.SrcPos t.Collected e.BackEndName =
    <SwAddBackEnd
      t.hErrorList t.SrcPos t.Collected <SelectBackEnd e.BackEndName>
    >;
}

SwAddBackEnd {
  t.hErrorList t.SrcPos (e.Collected) Other e.Other =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Unknown back-end selected: ' e.Other
    >
    Fails (e.Collected);

  t.hErrorList t.SrcPos (e.Options) s.BackEnd =
    t.hErrorList Success (e.Options (BackEnd s.BackEnd));
}

SelectBackEnd {
  'Refal5' = Refal5;
  'R5' = Refal5;

  e.Other = Other e.Other;
}

AddXLinx {
  t.hErrorList t.SrcPos (e.Options-B (XLinx-On) e.Options-E) =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Mutliple usings of \'-xlinx\''
    >
    Fails (e.Options-B (XLinx-On) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) =
    t.hErrorList Success (e.Options (XLinx-On));
}

AddFile {
  (e.Options-B (Files e.FileNames) e.Options-E) e.NextFileName =
    (e.Options-B (Files e.FileNames (e.NextFileName)) e.Options-E);

  (e.Options) e.NextFileName =
     (e.Options (Files (e.NextFileName)));
}

FinishTopLevel {
  t.hErrorList e.Options =
    <FinishTopLevel-SwUndefined
      t.hErrorList
      <DeleteUndefineds
        (ModulePath Mode BackEnd Files) e.Options
      >
    >;
}

DeleteUndefineds {
  (e.Tags-B s.Tag e.Tags-E)
  e.Options-B (s.Tag e.Info) e.Options-E =
    <DeleteUndefineds
      (e.Tags-B e.Tags-E)
      e.Options-B (s.Tag e.Info) e.Options-E
    >;

  (e.Tags) e.Options = (e.Tags) e.Options;
}

FinishTopLevel-SwUndefined {
  t.hErrorList () e.Options =
    t.hErrorList Success (CmdLineInfo e.Options);

  t.hErrorList (e.Tags-B ModulePath e.Tags-E) e.Options =
    <FinishTopLevel-SwUndefined
      t.hErrorList (e.Tags-B e.Tags-E)
      e.Options (ModulePath ('.'))
    >;

  t.hErrorList (e.Tags) e.Options =
    <MLambda::Reduce
      t.hErrorList & AddNotFoundOption e.Tags
    >
    Fails;
}

AddNotFoundOption
  t.hErrorList s.Tag =
    <MError::AddCmdLineError
      t.hErrorList
      <MSrcPos::Create-CmdLine-Common>
      <StrFromTag s.Tag>
    >;

StrFromTag {
  Mode = 'Not found one of options \'-make\', \'-build\' or \'-linkonly\'';

  BackEnd = 'Option \'-be:back-end\' not found';

  Files = 'Files for compiling not found';
}

//------------------------------------------------------------------------------

TuneBackEnd {
  t.hErrorList t.SrcPos t.Collected e.BackEndName t.SubInfo =
    <TuneBackEnd-SwBackEnd
      t.hErrorList t.SrcPos t.Collected t.SubInfo
      <SwSelectLowBackEnd e.BackEndName>
    >;
}

SwSelectLowBackEnd {
  'Refal5' = (Refal5BE ('~ROut') ('rout'));
  'SymInfo' = (SymInfo ('~RSym') ('rsym'));
  'XLinx' = (XLinxBE ('~XLinx') ('xlinx'));
  e.Other = Unknown;
}

TuneBackEnd-SwBackEnd {
  t.hErrorList t.SrcPos
  (e.Options-B (TuneBE s.BackEnd (e.Dir) (e.Ext)) e.Options-E)
  (e.SubInfo)
  (s.BackEnd (e.DefDir) (e.DefExt)) =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Options of this back-end alredy defined'
    >
    Fails
    (e.Options-B (TuneBE s.BackEnd (e.Dir) (e.Ext)) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) (e.SubInfo)
  (s.BackEnd (e.DefDir) (e.DefExt)) =
    t.hErrorList Success
    (e.Options
      (TuneBE
        s.BackEnd
        (<MakeOpt Dir (e.DefDir) e.SubInfo>)
        (<MakeOpt Ext (e.DefExt) e.SubInfo>)
      )
    );
}

MakeOpt {
  s.Option (e.DefOption)
  e.Options-B (s.Option e.Value) e.Options-E =
    e.Value;

  s.Option (e.DefOption) e.Options = e.DefOption;
}

BackEndGroup {
  EnableFile = (FileDisable);

  FinishCollected = & TuneBackEnd-Finish;

  'ext' = & BackEnd-Ext Param (Single);

  'dir' = & BackEnd-Dir Param (Single);

  e.Other = NotFound;
}

BackEnd-Ext {
  t.hErrorList t.SrcPos (e.Options-B (Ext e.Ext) e.Options-E) e.NewExt =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Redefinition of extension'
    >
    Fails (e.Options-B (Ext e.Ext) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) e.NewExt =
    t.hErrorList Success
    (e.Options (Ext <MStrings::Lower e.NewExt>));
}

BackEnd-Dir {
  t.hErrorList t.SrcPos (e.Options-B (Dir e.Dir) e.Options-E) e.NewDir =
    <MError::AddCmdLineError
      t.hErrorList t.SrcPos 'Redefinition of directory'
    >
    Fails (e.Options-B (Dir e.Dir) e.Options-E);

  t.hErrorList t.SrcPos (e.Options) e.NewDir =
    t.hErrorList Success (e.Options (Dir e.NewDir));
}

TuneBackEnd-Finish {
  t.hErrorList e.Options =
    t.hErrorList Success (e.Options);
}

$END MCmdLineParser.
