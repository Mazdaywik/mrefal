$MODULE MCmdLineParser;

$IMPORT FileIO;
$IMPORT Math;
$IMPORT MError;
$IMPORT MLambda;
$IMPORT MSrcPos;
$IMPORT MStrings;

/**
  t.CmdLineInfo ::=
    (CmdLineInfo
      (ModulePath (e.Path)*)
      (Mode Make | Build | LinkOnly)
      (BackEnd s.BackEnd)
      (CreateXLinx True | False)
      (Files (e.FileName)*)
    )

  s.BackEnd ::= Refal5
*/


/**
  <Parse t.hErrorList (e.Argument)*>
    == t.hErrorList Success t.CmdLineInfo
    == t.hErrorList Fails
*/
$ENTRY Parse
  t.hErrorList (e.ProgName) e.Options =
    <Parse-SwPreparseErrors
      t.hErrorList <PreScan (/* стек файлов */) <Renumerate e.Options>>
    >;

Renumerate
  e.Options =
    <MStrings::Skip 1
      <MLambda::MapReduce
        & RenumerateOption 1 e.Options
      >
    >;

RenumerateOption
  s.Number (e.Option) =
    <Math::Inc s.Number>
    (<MSrcPos::Create-CmdLine s.Number> e.Option);

/*
  t.Option ::=
    (File t.SrcPos e.FileName)
    (OpenBracket t.SrcPos)
    (CloseBracket t.SrcPos)
    (Error t.SrcPos e.Message)
    (OptionParam t.SrcPos (e.Name) e.Value)
    (OptionNaked t.SrcPos e.Option)
*/

PreScan {
  t.FileStack (t.SrcPos '+' e.Option) e.Tail =
    <PreScan-Option
      t.FileStack (<MStrings::Trim e.Option>) e.Tail
    >;

  t.FileStack (t.SrcPos '-' e.Option) e.Tail =
    <PreScan-Option
      t.FileStack (t.SrcPos <MStrings::Trim e.Option>) e.Tail
    >;

  t.FileStack (t.SrcPos '(') e.Tail =
    (OpenBracket t.SrcPos) <PreScan t.FileStack e.Tail>;

  t.FileStack (t.SrcPos ')') e.Tail =
    (CloseBracket t.SrcPos) <PreScan t.FileStack e.Tail>;

  t.FileStack (t.SrcPos e.FileName) e.Tail =
    (File t.SrcPos e.FileName)
    <PreScan t.FileStack e.Tail>;

  (e.Stack (e.LastConfigFile)) PopStackFile e.Tail =
    <PreScan (e.Stack) e.Tail>;

  (/* нет файлов */) /* кончились опции */ = ;
}

PreScan-Option {
  t.FileStack (t.SrcPos e.Name ':' e.Option) e.Tail =
    <PreScan-Option-Param
       t.FileStack
       t.SrcPos
       (<MStrings::Trim e.Name>)
       (<MStrings::Trim e.Option>)
       e.Tail
    >;

  t.FileStack (t.SrcPos e.Option) e.Tail =
    (OptionNaked t.SrcPos e.Option)
    <PreScan t.FileStack e.Tail>;
}

PreScan-Option-Param {
  /*
    Не смотря на то, что имя для файла может задаваться неоднозначно
    (абсолютным или относительным путём, различия в регистре, в слешах)
    мы здесь сравниваем пути к файлам на простое совпадение.

    Это связано с тем, что когда мы попадём в циклическую связь
    (петля, например, начинается с файла file.cfg),
    мы повторно прочитаем строчку загрузки в файле file.cfg и,
    соответственно, увидим точно такое же имя файла -- циклическая
    связь будет обнаружена.
  */
  (e.Stack-B (e.ConfigFile) e.Stack-E)
  t.SrcPos ('cfg') (e.ConfigFile) e.Tail =
    (Error
      t.SrcPos 'Cyclic loading configuration file \'' e.ConfigFile '\''
    )
    <PreScan
      (e.Stack-B (e.ConfigFile) e.Stack-E) e.Tail
    >;

  (e.Stack) t.SrcPos ('cfg') (e.ConfigFile) e.Tail =
    <PreScan
      (e.Stack (e.ConfigFile))
      <MStrings::Skip 1
        <MLambda::MapReduce
          <MLambda::Composite
            & MLambda.UnBracket
            & MStrings.Trim
            <MLambda::BindLeft
              & MakeConfigOption (e.ConfigFile)
            >
          >
          1 /* номера строк */
          <FileIO::Load e.ConfigFile>
        >
      >
      PopStackFile
      e.Tail
    >;

  t.FileStack t.SrcPos ('file') (e.FileName) e.Tail =
    (File t.SrcPos e.FileName)
    <PreScan t.FileStack e.Tail>;

  t.FileStack t.SrcPos (e.Name) (e.Value) e.Tail =
    (OptionParam
      t.SrcPos
      (<MStrings::Trim e.Name>)
      <MStrings::Trim e.Value>
    )
    <PreScan t.FileStack e.Tail>;
}

MakeConfigOption {
  (e.ConfigFile) s.LineNumber '#' e.Comment =
    <Math::Inc s.LineNumber>;

  (e.ConfigFile) s.LineNumber /* пустая строчка */ =
    <Math::Inc s.LineNumber>;

  (e.ConfigFile) s.LineNumber e.Option =
    <Math::Inc s.LineNumber>
    (<MSrcPos::Create-FilePos s.LineNumber e.ConfigFile> e.Option);
}

//------------------------------------------------------------------------------

Parse-SwPreparseErrors {
  t.hErrorList e.Options-B (Error t.SrcPos e.Message) e.Options-E =
    <MLambda::Reduce
      & AddLexerError t.hErrorList (Error t.SrcPos e.Message) e.Options-E
    >
    Fails;

  t.hErrorList e.Options =
    <Parse-BalanceBrackets
      t.hErrorList Success () () e.Options
    >;
}

AddLexerError {
  t.hErrorList (Error t.SrcPos e.Message) =
    <MError::AddCmdLineError t.hErrorList t.SrcPos e.Message>;

  t.hErrorList t.OtherOption = t.hErrorList;
}

Parse-BalanceBrackets {
  t.hErrorList s.Result
  (e.MultiBracket) (e.Scanned) (OpenBracket t.L-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket (t.L-SrcPos e.Scanned)) () e.Tail
    >;

  t.hErrorList s.Result
  (e.MultiBracket (t.L-SrcPos e.Scanned))
  (e.SubScanned) (CloseBracket t.R-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket) (e.Scanned (Group t.L-SrcPos e.SubScanned)) e.Tail
    >;

  t.hErrorList s.Result
  () (e.Scanned) (CloseBracket t.R-SrcPos) e.Tail =
    <Parse-BalanceBrackets
      <MError::AddCmdLineError
        t.hErrorList t.R-SrcPos 'Unballanced bracket \')\''
      >
      Fails () (e.Scanned) e.Tail
    >;

  t.hErrorList s.Result
  (e.MultiBracket (t.L-SrcPos e.Scanned)) (e.SubScanned) =
    <Parse-BalanceBrackets
      <MError::AddCmdLineError
        t.hErrorList t.L-SrcPos 'Unballanced bracket \'(\''
      >
      Fails (e.MultiBracket) ()
    >;

  t.hErrorList s.Result
  (e.MultiBracket) (e.Scanned) t.NextOption e.Tail =
    <Parse-BalanceBrackets
      t.hErrorList s.Result
      (e.MultiBracket) (e.Scanned t.NextOption) e.Tail
    >;

  t.hErrorList Fails () (e.Scanned) =
    t.hErrorList Fails;

  t.hErrorList Success () (e.Scanned) =
    <ParseAnalyze
      t.hErrorList Success & TopLevelOptions
      (/* Собранная информация */) e.Scanned
    >;
}

ParseAnalyze {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze-File
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap EnableFile>
      (File t.SrcPos e.FileName) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze-Param
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap e.Option>
      (OptionParam t.SrcPos (e.Option) e.Value) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze-Naked
      t.hErrorList s.Result t.FnOptionsMap t.Collected
      <MLambda::Apply t.FnOptionsMap e.Option>
      (OptionNaked t.SrcPos e.Option) e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (Group t.SrcPos e.Info) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Orphan group'
      >
      Fails t.FnOptionsMap t.Collected e.Info e.Tail
    >;

  t.hErrorList Success t.FnOptionsMap (e.Collected) =
    <ParseAnalyze-FinishCollected
      t.hErrorList
      <MLambda::Apply t.FnOptionsMap FinishCollected>
      e.Collected
    >;

  t.hErrorList Fails e.Collected =
    t.hErrorList Fails;
}

ParseAnalyze-FinishCollected {
  t.hErrorList t.FnFinishCollected e.Collected =
    <MLambda::Apply
      t.FnFinishCollected t.hErrorList e.Collected
    >;
}

ParseAnalyze-File {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (FileEnable t.FnAddFile) (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze
      t.hErrorList s.Result t.FnOptionsMap
      <MLambda::Apply t.FnAddFile t.Collected e.FileName>
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  (FileDisable) (File t.SrcPos e.FileName) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Unexpected filename'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Param {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap
      t.Collected t.FnUpdateOption
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Single)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        s.Result t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected e.Value
        >
      >
      e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group-ErrorNaked
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap t.Collected
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
        >
        t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Single)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Param-Group {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        Success t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected e.Value t.SubInfo
        >
      >
      e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}

ParseAnalyze-FnUpdateResult {
  s.Result t.FnOptionsMap
  t.hErrorList Success t.Collected =
    t.hErrorList s.Result t.FnOptionsMap t.Collected;

  s.Result t.FnOptionsMap
  t.hErrorList Fails t.Collected =
    t.hErrorList Fails t.FnOptionsMap t.Collected;
}

ParseAnalyze-Param-Group-ErrorNaked {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Name ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos
          'Option ' e.Name ' must haven\'t argument'
        >
        t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}

ParseAnalyze-Naked {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option)
  (Group t.G-SrcPos e.Info) e.Tail =
    & ???????;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    & ????????????;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Single)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    & ????????????;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option)
  (Group t.G-SrcPos e.Info) e.Tail =
    & ??????????????;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    & ????????????;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Single)
  (OptionNaked t.SrcPos e.Option) e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        s.Result t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption t.hErrorList t.SrcPos  t.Collected
        >
      >
      e.Tail
    >;
}

/*
ParseAnalyze-Param {
  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap
      t.Collected t.FnUpdateOption
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Param (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value)
  (Group t.G-SrcPos e.Info) e.Tail =
    <ParseAnalyze-Param-Group-ErrorNaked
      <ParseAnalyze
        t.hErrorList s.Result t.SubFnOptionsMap () e.Info
      >
      t.FnOptionsMap t.Collected
      (OptionParam t.SrcPos (e.Option) e.Value)
      t.G-SrcPos e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Group t.SubFnOptionsMap)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
        >
        t.SrcPos 'After option ' e.Option ' expected group'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList s.Result t.FnOptionsMap t.Collected
  t.FnUpdateOption Naked (Single)
  (OptionParam t.SrcPos (e.Option) e.Value) e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Option ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;
}

ParseAnalyze-Param-Group {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <ParseAnalyze-FnUpdateResult
        Success t.FnOptionsMap
        <MLambda::Apply
          t.FnUpdateOption
          t.hErrorList t.SrcPos t.Collected e.Value t.SubInfo
        >
      >
      e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected t.FnUpdateOption
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}

ParseAnalyze-Param-Group-ErrorNaked {
  t.hErrorList Success t.SubInfo
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        t.hErrorList t.SrcPos 'Option ' e.Name ' must haven\'t argument'
      >
      Fails t.FnOptionsMap t.Collected e.Tail
    >;

  t.hErrorList Fails
  t.FnOptionsMap t.Collected
  (OptionParam t.SrcPos (e.Name) e.Value)
  t.G-SrcPos e.Tail =
    <ParseAnalyze
      <MError::AddCmdLineError
        <MError::AddCmdLineError
          t.hErrorList t.SrcPos
          'Option ' e.Name ' must haven\'t argument'
        >
        t.G-SrcPos 'Can\'t create group for option ' e.Name
      >
      Fails t.FnOptionsMap t.Collected
      e.Tail
    >;
}
*/

//------------------------------------------------------------------------------

LookupOption {
  'MP' = Parameter & AddModulePath_;

  'make' = Single <MLambda::BindRight & AddMakeMode_ Make>;
  'build' = Single <MLambda::BindRight & AddMakeMode_ Build>;
  'linkonly' = Single <MLambda::BindRight & AddMakeMode_ LinkOnly>;

  'be' = Parameter & AddBackEnd_;

  'xlinx' = Single & AddXLinx_;

  'file' = Parameter & AddFile_;

  'cfg' = Parameter & LoadConfigFile_;
}

Scan-Exec-Valued {
  Parameter t.Action s.Result t.hErrorList t.CmdLineInfo (e.Name) e.Value =
    <MLambda::Apply t.Action s.Result t.hErrorList t.CmdLineInfo e.Value>;

  Single t.Action s.Result t.hErrorList t.CmdLineInfo (e.Name) e.Value =
    Fails
    <MError::AddCmdLineError_
      t.hErrorList 'Option \'+' e.Name '\' don\'t expect parameter'
    >
    t.CmdLineInfo;
}

Scan-Exec {
  Single t.Action s.Result t.hErrorList t.CmdLineInfo (e.Name) =
    <MLambda::Apply t.Action s.Result t.hErrorList t.CmdLineInfo>;

  Parameter t.Action s.Result t.hErrorList t.CmdLineInfo (e.Name) =
    Fails
    <MError::AddCmdLineError_
      t.hErrorList 'Option \'+' e.Name '\' expect parameter'
    >
    t.CmdLineInfo;
}

AddModulePath_ {
  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (ModulePath e.Paths) e.Options-E)
  e.ModulePath =
    s.Result t.hErrorList
    (CmdLineInfo
      e.Options-B
      (ModulePath e.Paths (e.ModulePath))
      e.Options-E
    );

  s.Result t.hErrorList (CmdLineInfo e.Options) e.ModulePath =
    s.Result t.hErrorList
    (CmdLineInfo e.Options (ModulePath (e.ModulePath)));
}

AddMakeMode_ {
  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (Mode s.Mode) e.Options-E) s.NewMode =
    Fails
    <MError::AddCmdLineError_
      t.hErrorList 'Multiple declarations of make mode'
    >
    (CmdLineInfo e.Options-B (Mode s.Mode) e.Options-E);

  s.Result t.hErrorList (CmdLineInfo e.Options) s.Mode =
    s.Result t.hErrorList
    (CmdLineInfo e.Options (Mode s.Mode));
}

AddBackEnd_ {
  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (BackEnd s.OtherBackEnd) e.Options-E)
  e.BackEnd =
    Fails
    <MError::AddCmdLineError_
      t.hErrorList 'Redefinition of back-end'
    >
    (CmdLineInfo e.Options-B (BackEnd s.OtherBackEnd) e.Options-E);

  s.Result t.hErrorList (CmdLineInfo e.Options) 'R5' =
    s.Result t.hErrorList
    (CmdLineInfo e.Options (BackEnd Refal5));

  s.Result t.hErrorList (CmdLineInfo e.Options) 'Refal5' =
    s.Result t.hErrorList
    (CmdLineInfo e.Options (BackEnd Refal5));

  s.Result t.hErrorList (CmdLineInfo e.Options) e.OtherBackEnd =
    Fails
    <MError::AddCmdLineError_
      t.hErrorList
      'Selected unknown back-end: ' e.OtherBackEnd
    >
    (CmdLine e.Options);
}

AddXLinx_ {
  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (CreateXLinx False) e.Options-E) =
    s.Result t.hErrorList
    (CmdLineInfo e.Options-B (CreateXLinx True) e.Options-E);

  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (CreateXLinx True) e.Options-E) =
    False
    <MError::AddCmdLineError_
      t.hErrorList 'Multiple using of \'+xlinx\''
    >
    (CmdLineInfo e.Options-B (CreateXLinx True) e.Options-E);
}

AddFile_ {
  s.Result t.hErrorList
  (CmdLineInfo e.Options-B (Files e.FileNames) e.Options-E)
  e.FileName =
    s.Result t.hErrorList
    (CmdLineInfo
      e.Options-B (Files e.FileNames (e.FileName)) e.Options-E
    );

  s.Result t.hErrorList (CmdLineInfo e.Options) e.FileName =
    s.Result t.hErrorList
    (CmdLineInfo e.Options (Files (e.FileName)));
}

LoadConfigFile_ {
  s.Result t.hErrorList t.CmdLineInfo e.ConfigFile =
    s.Result t.hErrorList t.CmdLineInfo
    <MLambda::Map
      <MLambda::Composite
        & MLambda.UnBracket
        & MStrings.Trim
        & FilterConfig
      >
      <FileIO::Load e.ConfigFile>
    >;
}

FilterConfig {
  // Комментарии игнорируем
  '#' e.Option = ;

  // Пустые строки игнорируем
  /* пусто */ = /* нет опций */;

  e.Option = (e.Option);
}

CheckImportantOptions
  t.hErrorList t.CmdLineInfo =
    <CheckImportant-ModulePath
      <CheckImportant-BackEnd
        <CheckImportant-Mode
          t.hErrorList t.CmdLineInfo
        >
      >
    >;

CheckImportant-Mode {
  t.hErrorList
  (CmdLineInfo e.Options-B (Mode s.Mode) e.Options-E) =
    t.hErrorList Success
    (CmdLineInfo e.Options-B (Mode s.Mode) e.Options-E);

  t.hErrorList (CmdLineInfo e.Options) =
    <MError::AddCmdLineError_
      t.hErrorList 'Option \'+mode\' not found'
    >
    Fails
    (CmdLineInfo e.Options (Mode Make));
}

CheckImportant-BackEnd {
  t.hErrorList s.Result
  (CmdLineInfo e.Options-B (BackEnd s.BackEnd) e.Options-E) =
    t.hErrorList s.Result
    (CmdLineInfo e.Options-B (BackEnd s.BackEnd) e.Options-E);

  t.hErrorList s.Result (CmdLineInfo e.Options) =
    <MError::AddCmdLineError_
      t.hErrorList 'Option \'+be:back-end\' not found'
    >
    Fails
    (CmdLineInfo e.Options (BackEnd Refal5));
}

CheckImportant-ModulePath {
  t.hErrorList Success
  (CmdLineInfo e.Options-B (ModulePath e.ModulePath) e.Options-E) =
    t.hErrorList Success
    (CmdLineInfo e.Options-B (ModulePath e.ModulePath) e.Options-E);

  t.hErrorList Success (CmdLineInfo e.Options) =
    t.hErrorList Success
    (CmdLineInfo e.Options (ModulePath ('.')));

  t.hErrorList Fails t.CmdLineInfo =
    t.hErrorList Fails;
}

$END MCmdLineParser.
