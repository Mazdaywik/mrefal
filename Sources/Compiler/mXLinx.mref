$MODULE MXLinx;

$IMPORT FileIO;
$IMPORT MConfig;
$IMPORT MCreateDirIfNeed;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MOrder;
$IMPORT MSrcPos;
$IMPORT MStrings;
$IMPORT MQualifiedName;
$IMPORT MXXIO;

$ENTRY Register
  t.Config (e.Dir) (e.Ext) =
    <MConfig::RegisterBackEnd
      t.Config
      XLinxBE
      & Generate
      & Link
      (e.Dir) (e.Ext)
    >;

//------------------------------------------------------------------------------

/*
  <Generate t.hIModule e.OutName> == t.hIModule
*/
Generate
  t.hIModule e.OutName =
    <Generate-Aux
      (e.OutName)
      <MLambda::Apply
        <MLambda::Parallel-H
          & LoadImportInfo
          & LoadADTInfo
          & LoadFunctionInfo
        >
        t.hIModule
      >
    >;

//------------------------------------------------------------------------------

/*
  <LoadImportInfo t.hIModule>
    == t.hIModule (Module t.Name t.SrcPos (Module t.Name t.SrcPos)*)
*/
LoadImportInfo
  t.hIModule =
    <LoadImportInfo-Aux
      <MLambda::Apply
        <MLambda::Parallel-H
          & MIModule.GetModuleName
          <MLambda::BindRight & MIModule.GetModuleAttribute Position>
        >
        t.hIModule
      >
    >;

LoadImportInfo-Aux
  t.hIModule t.ModuleName Found t.ModulePos =
    <LoadImportInfo-Aux2
      t.ModuleName t.ModulePos
      <MLambda::MapReduce
        <MLambda::Composite
          & CreateImportInfo
          & MLambda.Bracket-H
        >
        <MIModule::GetImportList-RealNames t.hIModule>
      >
    >;

LoadImportInfo-Aux2
  t.ModuleName t.ModulePos t.hIModule e.Imports =
    t.hIModule
    (Module t.ModuleName t.ModulePos e.Imports);

CreateImportInfo
  t.hIModule t.ImportRealName =
    <CreateImportInfo-Aux
      t.ImportRealName
      <MIModule::GetImportAttribute-RealName
        t.hIModule Position t.ImportRealName
      >
    >;

CreateImportInfo-Aux
  t.ImportRealName t.hIModule Found t.SrcPos =
    t.hIModule Module t.ImportRealName t.SrcPos;


//------------------------------------------------------------------------------

/*
  <LoadADTInfo t.hIModule>
    == t.hIModule (ADT t.Name t.SrcPos)*
*/
LoadADTInfo
  t.hIModule =
    <MLambda::MapReduce
      <MLambda::Composite
        & CreateADTInfo
        & MLambda.Bracket-H
      >
      <MIModule::GetADTList t.hIModule>
    >;

/*
  <CreateADTInfo t.hIModule t.ADTName>
    == t.hIModule ADT t.ADTName t.SrcPos
*/
CreateADTInfo
  t.hIModule t.ADTName =
    <CreateADTInfo-Aux
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindRight & MIModule.AbsolutName t.ADTName>
          <MLambda::BindRight
            & MIModule.GetADTAttribute Position t.ADTName
          >
        >
        t.hIModule
      >
    >;

CreateADTInfo-Aux
  t.hIModule t.ADTName Found t.SrcPos =
    t.hIModule ADT t.ADTName t.SrcPos;

//------------------------------------------------------------------------------

/*
  <LoadFunctionInfo t.hIModule>
    == t.hIModule t.FunctionInfo*
  t.FunctionInfo ::=
    (
      s.ScopeClass t.Name t.SrcPos
      (s.ScopeClass t.Name t.SrcPos)*
    )
  s.ScopeClass ::= Entry | Local | Swap
*/
LoadFunctionInfo
  t.hIModule =
    <MLambda::MapReduce
      <MLambda::Composite
        & CreateFunctionInfo
        & MLambda.Bracket-H
      >
      <MIModule::GetFunctionList t.hIModule>
    >;

/*
  <CreateFunctionInfo t.hIModule t.FunctionName>
    == t.hIModule
      s.ScopeClass t.Name t.SrcPos (s.ScopeClass t.Name t.SrcPos)
*/
CreateFunctionInfo
  t.hIModule t.FunctionName =
    <CreateFunctionInfo-SwScopeClass
      t.FunctionName
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindRight & MIModule.AbsolutName t.FunctionName>
          <MLambda::BindRight
            & MIModule.GetFunctionAttribute ScopeClass t.FunctionName
          >
          <MLambda::BindRight
            & MIModule.GetFunctionAttribute Position t.FunctionName
          >
        >
        t.hIModule
      >
    >;

CreateFunctionInfo-SwScopeClass {
  t.RelativeName t.hIModule t.FunctionName Found Swap Found t.SrcPos =
    t.hIModule Swap t.FunctionName t.SrcPos;

  t.RelativeName t.hIModule t.FunctionName Found s.ScopeClass Found t.SrcPos =
    <CreateFunctionInfo-Aux
      t.FunctionName s.ScopeClass t.SrcPos
      <MIModule::GetFunctionAttribute t.hIModule Body t.RelativeName>
    >;
}

CreateFunctionInfo-Aux
  t.FunctionName s.ScopeClass t.SrcPos
  t.hIModule Found (e.Sentences) =
    t.hIModule s.ScopeClass t.FunctionName t.SrcPos
    <MLambda::Map & ScanSentence e.Sentences>;

ScanSentence
  (e.Actions) =
    <MLambda::Map & ScanAction e.Actions>;

ScanAction {
  (Pattern e.Pattern) = <ScanExpression e.Pattern>;

  (Result e.Result) = <ScanExpression e.Result>;
}

ScanExpression
  e.Terms =
    <MLambda::Map & ScanTerm e.Terms>;

ScanTerm {
  (Identifier t.SrcPos e.Name) =
    (Identifier <MQualifiedName::Create (e.Name)> t.SrcPos);

  (EVar e.Index) = ;
  (SVar e.Index) = ;
  (TVar e.Index) = ;
  (Literal e.Content) = ;
  (DQWord e.Content) = ;
  (Macro s.Value) = ;

  (FnPtr t.Callable) = <ScanCallable t.Callable>;

  (Structure e.Expression) = <ScanExpression e.Expression>;

  (Abstract t.Callable e.Expression) =
    <ScanCallable t.Callable> <ScanExpression e.Expression>;

  (Function t.Callable e.Argument) =
    <ScanCallable t.Callable> <ScanExpression e.Argument>;

  (IndirectCall (SVar e.Index) e.Argument) =
    <ScanExpression e.Argument>;
}

ScanCallable
  (s.CallType t.SrcPos t.Name) = (s.CallType t.Name t.SrcPos);

//------------------------------------------------------------------------------

/*
  <Generate-Aux
    (e.OutName) t.hIModule e.EntityInfo
  >
    == t.hIModule
*/
Generate-Aux
  (e.OutName) t.hIModule e.EntityInfo =
    t.hIModule
    <GuardSuccess
      <MXXIO::Save
        (e.OutName)
        <MLambda::Map & GenerateEntity e.EntityInfo>
      >
    >;

GuardSuccess Success = ;

GenerateEntity
  (s.ScopeClass t.Name t.SrcPos e.SubEntities) =
    (
      <PrintEntity '!' s.ScopeClass t.Name t.SrcPos>
      <MLambda::Map & GenerateSubEntity e.SubEntities>
    );

PrintEntity
  s.Sign s.ScopeClass t.Name t.SrcPos =
    (s.Sign
      (<StringFromScopeClass s.ScopeClass>)
      (<MQualifiedName::ToPrintable-Quad t.Name>)
      (<MSrcPos::ToString t.SrcPos>)
    );


StringFromScopeClass {
  ADT = 'ADT'; Entry = 'Entry'; Identifier = 'Identifier';
  Import = 'Import'; Local = 'Local'; Module = 'Module'; Swap = 'Swap';
}

GenerateSubEntity
  (s.ScopeClass t.Name t.SrcPos) =
    <PrintEntity '?' s.ScopeClass t.Name t.SrcPos>;


//------------------------------------------------------------------------------

/*
  <Link t.hContext (e.OutName) (t.ModuleName e.FileName)*>
    == t.hContext Success
    == t.hContext Fails
*/
Link
  t.hContext (e.OutName) e.OutFileNames =
    <FileIO::Save
      (<MCreateDirIfNeed::CreatePathToFile 'Info/' e.OutName '.xlinx.txt'>)
      <Link-Aux
        <MLambda::Map
          <MLambda::Composite
            & MLambda.UnBracket
            <MLambda::BindLeft & MStrings.Skip 1>
            & MXXIO.Load
            <MLambda::BindLeft & MStrings.Skip 1>
            & MLambda.Bracket
          >
          <MStrings::Reverse e.OutFileNames>
        >
      >
    >
    t.hContext Success;

Link-Aux
  e.Modules =
    <Link-Aux2
      <MLambda::MapReduce
        & AddInvertedInfo
        (
          <InvertInfo
            <MLambda::Map & MLambda.UnBracket e.Modules>
          >
        )
        <MLambda::Map & ModulesUnBracket e.Modules>
      >
    >;

ModulesUnBracket
  (e.Module) = (Parser) e.Module;

InvertInfo
  e.Entities =
    <InvertInfo-Aux
      <MOrder::Sort
        <MLambda::Map & InvertEntity e.Entities>
      >
    >;

InvertEntity
  ((e.Header) e.SubEntities) =
    <MLambda::Map
      <MLambda::BindLeft & InvertSubEntity (e.Header)>
      e.SubEntities
    >;

InvertSubEntity
  (s.MainEntitySign (e.MainScopeClass) (e.MainName) (e.MainSrcPos))
  (s.SubEntitySign (e.SubScopeClass) (e.SubName) (e.SubSrcPos)) =
    ((e.SubScopeClass) (e.SubName)
      '>' (e.MainScopeClass) (e.MainName) (e.SubSrcPos)
    );

InvertInfo-Aux {
  (t.ScopeClass t.SubName e.OtherInfo1)
  (t.ScopeClass t.SubName e.OtherInfo2) e.Tail =
    <InvertInfo-Collect
      (t.ScopeClass t.SubName (e.OtherInfo1) (e.OtherInfo2))
      e.Tail
    >;

  (t.ScopeClass t.SubName e.OtherInfo) e.Tail =
    (t.ScopeClass t.SubName (e.OtherInfo))
    <InvertInfo-Aux e.Tail>;

  = ;
}

InvertInfo-Collect {
  (t.ScopeClass t.SubName e.Collected)
  (t.ScopeClass t.SubName e.Info) e.Tail =
    <InvertInfo-Collect
      (t.ScopeClass t.SubName e.Collected (e.Info)) e.Tail
    >;

  (t.ScopeClass t.SubName e.Collected) e.Tail =
    (t.ScopeClass t.SubName e.Collected)
    <InvertInfo-Aux e.Tail>;
}

AddInvertedInfo {
  (
    e.InvertedInfo-B
    (t.ScopeClass t.SubName e.Collected)
    e.InvertedInfo-E
  )
  (('!' t.ScopeClass t.SubName t.SrcPos) e.Info) =
    (e.InvertedInfo-B e.InvertedInfo-E)
    (('!' t.ScopeClass t.SubName t.SrcPos) e.Info e.Collected);

  (e.InvertedInfo) t.OtherEntity =
    (e.InvertedInfo) t.OtherEntity;
}

Link-Aux2
  (e.Inverted) e.Results =
    <MLambda::Map
      & PrintResult
      <SkipParser e.Results>
      (Parser)
      <MLambda::Map & InvertedToResults e.Inverted>
    >;

InvertedToResults {
  (t.ScopeClass t.SubName e.Info) =
    (('!' t.ScopeClass t.SubName ('UNKNOWN')) e.Info);
}

SkipParser {
  (Parser) e.Tail = <SkipParser e.Tail>;

  e.Tail = e.Tail;
}

PrintResult {
  (Parser) = (<MStrings::Repeat 80 '='>) ();

  (e.Info) =
    <MLambda::Map & PrintResult-Aux <MOrder::Sort e.Info>> ();
}

PrintResult-Aux {
  ('!' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('{' e.ScopeClass ' [/' <Dot e.EntityName> '/] (' e.SrcPos ')}');

  ('?' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('  use     ' e.ScopeClass ' [' e.EntityName '] (' e.SrcPos')');

  ('>' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('  used in ' e.ScopeClass ' [' e.EntityName '] (' e.SrcPos')');
}

Dot {
  e.Begin '::' e.End = e.Begin '.' <Dot e.End>;
  e.Line = e.Line;
}

$END MXLinx.
