$MODULE MXLinx;

$IMPORT FileIO;
$IMPORT MConfig;
$IMPORT MCreateDirIfNeed;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MOrder;
$IMPORT MSrcPos;
$IMPORT MStrings;
$IMPORT MQualifiedName;
$IMPORT MXXIO;

$ENTRY Register
  t.Config (e.Dir) (e.Ext) =
    <MConfig::RegisterBackEnd
      t.Config
      XLinxBE
      & Generate
      & Link
      (e.Dir) (e.Ext)
    >;

//------------------------------------------------------------------------------

/*
  <Generate t.hIModule e.OutName> == t.hIModule
*/
Generate
  t.hIModule e.OutName =
    <Generate-Aux
      (e.OutName)
      <MLambda::Apply
        <MLambda::Parallel-H
          & LoadImportInfo
          & LoadADTInfo
          & LoadEntryPointInfo
          & LoadFunctionInfo
        >
        t.hIModule
      >
    >;

//------------------------------------------------------------------------------

/*
  <LoadImportInfo t.hIModule>
    == t.hIModule (Module t.Name t.SrcPos (Module t.Name t.SrcPos)*)
*/
LoadImportInfo
  t.hIModule =
    <LoadImportInfo-Aux
      <MLambda::Apply
        <MLambda::Parallel-H
          & MIModule.GetModuleName
          <MLambda::BindRight & MIModule.GetModuleAttribute Position>
        >
        t.hIModule
      >
    >;

LoadImportInfo-Aux
  t.hIModule t.ModuleName Found t.ModulePos =
    <LoadImportInfo-Aux2
      t.ModuleName t.ModulePos
      <MLambda::MapReduce
        <MLambda::Composite
          & CreateImportInfo
          & MLambda.Bracket-H
        >
        <MIModule::GetImportList-RealNames t.hIModule>
      >
    >;

LoadImportInfo-Aux2
  t.ModuleName t.ModulePos t.hIModule e.Imports =
    t.hIModule
    (Module t.ModuleName t.ModulePos e.Imports);

CreateImportInfo
  t.hIModule t.ImportRealName =
    <CreateImportInfo-Aux
      t.ImportRealName
      <MIModule::GetImportAttribute-RealName
        t.hIModule Position t.ImportRealName
      >
    >;

CreateImportInfo-Aux
  t.ImportRealName t.hIModule Found t.SrcPos =
    t.hIModule Module t.ImportRealName t.SrcPos;


//------------------------------------------------------------------------------

/*
  <LoadADTInfo t.hIModule>
    == t.hIModule (ADT t.Name t.SrcPos)*
*/
LoadADTInfo
  t.hIModule =
    <MLambda::MapReduce
      <MLambda::Composite
        & CreateADTInfo
        & MLambda.Bracket-H
      >
      <MIModule::GetADTList t.hIModule>
    >;

/*
  <CreateADTInfo t.hIModule t.ADTName>
    == t.hIModule ADT t.ADTName t.SrcPos
*/
CreateADTInfo
  t.hIModule t.ADTName =
    <CreateADTInfo-Aux
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindRight & MIModule.AbsolutName t.ADTName>
          <MLambda::BindRight
            & MIModule.GetADTAttribute Position t.ADTName
          >
        >
        t.hIModule
      >
    >;

CreateADTInfo-Aux
  t.hIModule t.ADTName Found t.SrcPos =
    t.hIModule ADT t.ADTName t.SrcPos;

//------------------------------------------------------------------------------

/*
  <LoadEntryPointInfo t.hIModule>
    == t.hIModule t.RunTimeUsesInfo
  t.RunTimeUsesInfo ::=
    (
      Entry RunTime t.SrcPos
      (s.ScopeClass t.Name t.SrcPos)
    )
*/
LoadEntryPointInfo
  t.hIModule =
    <LoadEntryPoint-Aux
      <MIModule::GetEntryPoint t.hIModule>
    >;

LoadEntryPoint-Aux {
  t.hIModule Go t.EntryPoint =
    t.hIModule
    (Entry RunTime <MSrcPos::Create-RunTime>
      <PrintEntryPoint t.EntryPoint>
    );

  t.hIModule Regular t.Init t.Final =
    t.hIModule
    (Entry RunTime <MSrcPos::Create-RunTime>
      <PrintEntryPoint t.Init>
      <PrintEntryPoint t.Final>
    );
}

PrintEntryPoint {
  None = ;

  (Result e.ResultExpr) = <ScanExpression e.ResultExpr>;
}


//------------------------------------------------------------------------------

/*
  <LoadFunctionInfo t.hIModule>
    == t.hIModule t.FunctionInfo*
  t.FunctionInfo ::=
    (
      s.ScopeClass t.Name t.SrcPos
      (s.ScopeClass t.Name t.SrcPos)*
    )
  s.ScopeClass ::= Entry | Local | Swap
*/
LoadFunctionInfo
  t.hIModule =
    <MLambda::MapReduce
      <MLambda::Composite
        & CreateFunctionInfo
        & MLambda.Bracket-H
      >
      <MIModule::GetFunctionList t.hIModule>
    >;

/*
  <CreateFunctionInfo t.hIModule t.FunctionName>
    == t.hIModule
      s.ScopeClass t.Name t.SrcPos (s.ScopeClass t.Name t.SrcPos)
*/
CreateFunctionInfo
  t.hIModule t.FunctionName =
    <CreateFunctionInfo-SwScopeClass
      t.FunctionName
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::BindRight & MIModule.AbsolutName t.FunctionName>
          <MLambda::BindRight
            & MIModule.GetFunctionAttribute ScopeClass t.FunctionName
          >
          <MLambda::BindRight
            & MIModule.GetFunctionAttribute Position t.FunctionName
          >
        >
        t.hIModule
      >
    >;

CreateFunctionInfo-SwScopeClass {
  t.RelativeName t.hIModule t.FunctionName Found Swap Found t.SrcPos =
    t.hIModule Swap t.FunctionName t.SrcPos;

  t.RelativeName t.hIModule t.FunctionName Found s.ScopeClass Found t.SrcPos =
    <CreateFunctionInfo-Aux
      t.FunctionName s.ScopeClass t.SrcPos
      <MIModule::GetFunctionAttribute t.hIModule Body t.RelativeName>
    >;
}

CreateFunctionInfo-Aux
  t.FunctionName s.ScopeClass t.SrcPos
  t.hIModule Found (e.Sentences) =
    t.hIModule s.ScopeClass t.FunctionName t.SrcPos
    <MLambda::Map & ScanSentence e.Sentences>;

ScanSentence
  (e.Actions) =
    <MLambda::Map & ScanAction e.Actions>;

ScanAction {
  (Pattern e.Pattern) = <ScanExpression e.Pattern>;

  (Result e.Result) = <ScanExpression e.Result>;
}

ScanExpression
  e.Terms =
    <MLambda::Map & ScanTerm e.Terms>;

ScanTerm {
  (Identifier t.SrcPos e.Name) =
    (Identifier <MQualifiedName::Create (e.Name)> t.SrcPos);

  (EVar e.Index) = ;
  (SVar e.Index) = ;
  (TVar e.Index) = ;
  (Literal e.Content) = ;
  (DQWord e.Content) = ;
  (Macro s.Value) = ;

  (FnPtr t.Callable) = <ScanCallable t.Callable>;

  (Structure e.Expression) = <ScanExpression e.Expression>;

  (Abstract t.Callable e.Expression) =
    <ScanCallable t.Callable> <ScanExpression e.Expression>;

  (Function t.Callable e.Argument) =
    <ScanCallable t.Callable> <ScanExpression e.Argument>;

  (IndirectCall (SVar e.Index) e.Argument) =
    <ScanExpression e.Argument>;
}

ScanCallable
  (s.CallType t.SrcPos t.Name) = (s.CallType t.Name t.SrcPos);

//------------------------------------------------------------------------------

/*
  <Generate-Aux
    (e.OutName) t.hIModule e.EntityInfo
  >
    == t.hIModule
*/
Generate-Aux
  (e.OutName) t.hIModule e.EntityInfo =
    t.hIModule
    <GuardSuccess
      <MXXIO::Save
        (e.OutName)
        <MLambda::Map & GenerateEntity e.EntityInfo>
      >
    >;

GuardSuccess Success = ;

GenerateEntity
  (s.ScopeClass t.Name t.SrcPos e.SubEntities) =
    (
      <PrintEntity '!' s.ScopeClass t.Name t.SrcPos>
      <MLambda::Map & GenerateSubEntity e.SubEntities>
    );

PrintEntity
  s.Sign s.ScopeClass t.Name t.SrcPos =
    (s.Sign
      (<StringFromScopeClass s.ScopeClass>)
      (<PrintName t.Name>)
      (<MSrcPos::ToString t.SrcPos>)
    );

PrintName {
  RunTime = 'RunTime';

  t.Name = <MQualifiedName::ToPrintable-Quad t.Name>;
}


StringFromScopeClass {
  ADT = 'ADT'; Entry = 'Entry'; Identifier = 'Identifier';
  Import = 'Import'; Local = 'Local'; Module = 'Module'; Swap = 'Swap';
}

GenerateSubEntity
  (s.ScopeClass t.Name t.SrcPos) =
    <PrintEntity '?' s.ScopeClass t.Name t.SrcPos>;


//------------------------------------------------------------------------------

/*
  <Link (e.OutName) (t.ModuleName e.FileName)*>
    == Success
    == Fails
*/
Link
  (e.OutName) e.OutFileNames =
    <Link-Aux
      ( e.OutName )
      <MLambda::Map
        <MLambda::Composite
          & MLambda.UnBracket
          <MLambda::BindLeft & MStrings.Skip 1>
          & MXXIO.Load
          <MLambda::BindLeft & MStrings.Skip 1>
          & MLambda.Bracket
        >
        <MStrings::Reverse e.OutFileNames>
      >
    >
    Success;

Link-Aux
  (e.OutName) e.Modules =
    <Link-Aux-2
      (e.OutName)
      <MLambda::MapReduce
        & AddInvertedInfo
        (
          <InvertInfo
            <MLambda::Map & MLambda.UnBracket e.Modules>
          >
        )
        <CollectDirectInfo
          <MLambda::Map & ModulesUnBracket e.Modules>
        >
      >
    >;

ModulesUnBracket
  (e.Module) = (Parser) e.Module;

/*
  Данная функция нужна для того, чтобы объединить сведения
  о использовании функций поддержкой времени выполнения
  (runtime).
*/
CollectDirectInfo {
  e.Info-B ((e.Header) e.SubInfo-1)
  e.Info-M ((e.Header) e.SubInfo-2) e.Info-E =
    e.Info-B
    <CollectDirectInfo
      ((e.Header) e.SubInfo-1 e.SubInfo-2) e.Info-M e.Info-E
    >;

  e.Info = e.Info;
}

InvertInfo
  e.Entities =
    <InvertInfo-Aux
      <MOrder::Sort
        <MLambda::Map & InvertEntity e.Entities>
      >
    >;

InvertEntity
  ((e.Header) e.SubEntities) =
    <MLambda::Map
      <MLambda::BindLeft & InvertSubEntity (e.Header)>
      e.SubEntities
    >;

InvertSubEntity
  (s.MainEntitySign (e.MainScopeClass) (e.MainName) (e.MainSrcPos))
  (s.SubEntitySign (e.SubScopeClass) (e.SubName) (e.SubSrcPos)) =
    ((e.SubScopeClass) (e.SubName)
      '>' (e.MainScopeClass) (e.MainName) (e.SubSrcPos)
    );

InvertInfo-Aux {
  (t.ScopeClass t.SubName e.OtherInfo1)
  (t.ScopeClass t.SubName e.OtherInfo2) e.Tail =
    <InvertInfo-Collect
      (t.ScopeClass t.SubName (e.OtherInfo1) (e.OtherInfo2))
      e.Tail
    >;

  (t.ScopeClass t.SubName e.OtherInfo) e.Tail =
    (t.ScopeClass t.SubName (e.OtherInfo))
    <InvertInfo-Aux e.Tail>;

  = ;
}

InvertInfo-Collect {
  (t.ScopeClass t.SubName e.Collected)
  (t.ScopeClass t.SubName e.Info) e.Tail =
    <InvertInfo-Collect
      (t.ScopeClass t.SubName e.Collected (e.Info)) e.Tail
    >;

  (t.ScopeClass t.SubName e.Collected) e.Tail =
    (t.ScopeClass t.SubName e.Collected)
    <InvertInfo-Aux e.Tail>;
}

AddInvertedInfo {
  (
    e.InvertedInfo-B
    (t.ScopeClass t.SubName e.Collected)
    e.InvertedInfo-E
  )
  (('!' t.ScopeClass t.SubName t.SrcPos) e.Info) =
    (e.InvertedInfo-B e.InvertedInfo-E)
    (('!' t.ScopeClass t.SubName t.SrcPos) e.Info e.Collected);

  (e.InvertedInfo) t.OtherEntity =
    (e.InvertedInfo) t.OtherEntity;
}

Link-Aux-2
  (e.OutName) (e.Inverted) e.Results =
    <FileIO::Save
      (<MCreateDirIfNeed::InfoDir> '\\' e.OutName '.tree.txt')
      <PrintTree
        <MLambda::Map & FilterModules e.Results>
      >
    >
    <FileIO::Save
      (<MCreateDirIfNeed::InfoDir> '\\' e.OutName '.xlinx.txt')
      <MLambda::Map
        & PrintResult
        <SkipParser e.Results>
        (Parser)
        <MLambda::Map & InvertedToResults e.Inverted>
      >
    >;

//------------------------------------------------------------------------------
// Печать таблицы перекрёстных связей.

InvertedToResults {
  (t.ScopeClass t.SubName e.Info) =
    (('!' t.ScopeClass t.SubName ('UNKNOWN')) e.Info);
}

SkipParser {
  (Parser) e.Tail = <SkipParser e.Tail>;

  e.Tail = e.Tail;
}

PrintResult {
  (Parser) = <PrintParser>;

  (e.Info) =
    <MLambda::Map & PrintResult-Aux <MOrder::Sort e.Info>> ();
}

PrintParser = (<MStrings::Repeat 80 '='>) ();

PrintResult-Aux {
  ('!' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('{' e.ScopeClass ' [/' <Dot e.EntityName> '/] (' e.SrcPos ')}');

  ('?' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('  use     ' e.ScopeClass ' [' e.EntityName '] (' e.SrcPos')');

  ('>' (e.ScopeClass) (e.EntityName) (e.SrcPos) ) =
    ('  used in ' e.ScopeClass ' [' e.EntityName '] (' e.SrcPos')');
}

Dot {
  e.Begin '::' e.End = e.Begin '.' <Dot e.End>;
  e.Line = e.Line;
}

//------------------------------------------------------------------------------
// Печать таблицы перекрёстных связей.

FilterModules {
  (('!' ('Module') t.Name t.SrcPos) e.SubEntities) =
    (('!'('Module') t.Name t.SrcPos) e.SubEntities);

  t.OtherInfo = ;
}


PrintTree
  e.Modules =
    <PrintTree-Aux
      <MLambda::Map & UsingsModules e.Modules>
    >
    <PrintParser>
    <PrintTree-Aux
      <MLambda::Map & UsedsModules e.Modules>
    >;

UsingsModules
  (
    ('!' ('Module') t.Name t.SrcPos)
    e.SubEntities
  ) =
    (
      t.Name
      <MLambda::Map
        <MLambda::BindLeft & FilterDependences '?'>
        e.SubEntities
      >
    );

UsedsModules
  (
    ('!' ('Module') t.Name t.SrcPos)
    e.SubEntities
  ) =
    (
      t.Name
      <MLambda::Map
        <MLambda::BindLeft & FilterDependences '>'>
        e.SubEntities
      >
    );

FilterDependences {
  s.Sign (s.Sign ('Module') t.Name t.SrcPos) =
    (t.Name t.SrcPos);

  s.Sign t.OtherEntity = ;
}

PrintTree-Aux
  e.Modules =
    <CreateTrees
      ( <FindRoots e.Modules> ) e.Modules
    >;

FindRoots
  e.Modules =
    <MLambda::Map
      <MLambda::BindLeft & IsRoot e.Modules>
      <MLambda::Map
        <MLambda::Composite
          & MLambda.UnBracket
          <MLambda::BindLeft & MStrings.First 1>
        >
        e.Modules
      >
    >;

IsRoot {
  e.Modules-B
  (t.SuperName e.SubModules-B (t.SubName t.SrcPos) e.SubModules-E)
  e.Modules-E t.SubName =
    /* пусто */;

  e.Modules t.RootName = t.RootName;
}

CreateTrees
  (e.Roots) e.Modules =
    <MLambda::Map
      <MLambda::BindLeft & CreateTree e.Modules>
      e.Roots
    >;

CreateTree
  e.Modules (e.RootName) =
    ()
    (e.RootName ' =>')
    <DoPrintUses
      ()
      <DoCreateTree () (e.RootName) e.Modules>
    >;

DoCreateTree {
  (e.Indent)
  (e.RootName)
  e.Modules-B ((e.RootName) e.SubNames) e.Modules-E =
    <MLambda::Map
      <MLambda::BindLeft
        & DoCreateTree-Aux
        (e.Indent) e.Modules-B e.Modules-E
      >
      e.SubNames
    >;

  (e.Indent) (e.RootName) e.Modules = ;
}

DoCreateTree-Aux
  (e.Indent) e.Modules ((e.Name) (e.SrcPos)) =
    //(e.Indent ' * ' e.Name ', (' e.SrcPos ') =>')
    ((e.Indent) (e.Name) (e.SrcPos))
    <DoCreateTree
      (e.Indent '  ') (e.Name) e.Modules
    >;

DoPrintUses {
  (e.Printed-B (e.Name) e.Printed-E)
  ((e.SameIndent) (e.Name) (e.SrcPos))
  e.Skipped
  ((e.SameIndent) (e.NextName) (e.NextSrcPos))
  e.Tail =
    (e.SameIndent ' @ ' e.Name ', (' e.SrcPos ')')
    <DoPrintUses
      (e.Printed-B (e.Name) e.Printed-E)
      ((e.SameIndent) (e.NextName) (e.NextSrcPos))
      e.Tail
    >;

  (e.Printed) ((e.Indent) (e.Name) (e.SrcPos)) e.Tail =
    (e.Indent ' * ' e.Name ', (' e.SrcPos ')')
    <DoPrintUses
      (e.Printed (e.Name)) e.Tail
    >;

  (e.Printed) = <PrintParser>;
}

//CreateTrees
//  (e.Roots) e.Modules =
//    <MLambda::Map & PrintTree-Debug-PrintRoot e.Roots>
//    <PrintParser>
//    <MLambda::Map & PrintTree-Debug-Module e.Modules>;

PrintTree-Debug-PrintRoot
  (e.Name) = ('-> Root ' e.Name);

PrintTree-Debug-Module
  ((e.Name) e.SubEntities) =
    (e.Name)
    <MLambda::Map & PrintTree-Debug-Depended e.SubEntities>
    ();

PrintTree-Debug-Depended
  ((e.Name) (e.SrcPos)) =
    ('  ' e.Name ' ' e.SrcPos);

$END MXLinx.
