$MODULE MOS;

$IMPORT Core = CoreOS::MOS;
$IMPORT MStrings;
$IMPORT Math;

/**
  <System e.Command>
    == empty
*/
$ENTRY System
  e.Command =
    <Nil
      <Core::CreateProcess
        Wait
        (<Env 'ComSpec'>)
        (<Env 'ComSpec'> ' /c ' e.Command)
      >
    >;

Nil e.Arg = ;

/**
  <Arg s.Number>
    == e.Arg
    == empty
*/
$ENTRY Arg s.Num = <FindArg s.Num <ArgList>>;

FindArg {
  0 (e.Arg) e.Tail = e.Arg;

  s.Num (e.Arg) e.Tail =
    <FindArg <Math::Dec s.Num> e.Tail>;

  s.Num /* нету аргументов */ = /* пусто */;
}

/**
  <ArgList>
    == (e.Argument)*
*/
$ENTRY ArgList =
  <ScanCommandLine <Core::CommandLine>>;

/*
  Поскольку на уровне Windows командная строка приложения представляет
  собой просто строку, в отличие от ОС стандарта POSIX,
  где командная строка приложения представляет собой набор строк ---
  аргументов командной строки, а библиотека Рефала традиционно следует
  соглашениям POSIX с точки зрения обработки командной строки,
  то требуется командную строку Windows разбивать на аргументы.

  Строго говоря, можно выделить много способов разбиения строки
  на аргументы, однако среди них можно выделить один "канонический" ---
  тот, который реализуется функцией CommandLineToArgvW --- именно он
  используется компилятором для предоставления аргументов функции
  main(argc, argv).

  Хорошим вариантом было бы применение самой функции CommandLineToArgvW,
  но она юникодная, а имеющийся back-end Си++ Модульного Рефала Юникод
  не поддерживает.

  Чтением MSDN и эмпирическим анализом удалось восстановить логику
  "канонического" способа разбиения командной строки на аргументы.

  1. Особым образом обрабатываются последовательности бекслешей, за которыми
     следует двойная кавычка: \\...\", а именно,

     а) если число бекслешей чётное 2*n, они преобразуются в n бекслешей,
        а кавычка, следующая за ними, считается "особой" (число n может быть
        также равным нулю, т.е. перед кавычкой слеши отсутствуют ---
        такая кавычка тоже считается "особой");
     б) если число бекслешей нечётное 2*n+1, то эта последовательность тоже
        преобразуется в n бекслешей, но кавычка при этом считается обычным
        символом, специального значения не имеет.

  2. На втором этапе (после обработки кавычек и бекслешей) строка посимвольно
     сканируется слева-направо. При этом сканирование может осуществляться
     в двух режимах: обычном и цитированном.

     В обычном режиме разделителями аргументов являются последовательности
     пробельных символов: пробелы или символы табуляции (запустить программу
     с символом перевода строки в её командной строке при помощи функции
     языка Си system мне не удалось --- символ \n воспринимался как конец
     строки, запускать с помощью функции CreateProcess я не пробовал).

     В режиме цитирования символы свободного пространства наравне с остальными
     обычными символами помещаются в очередной аргумент.

     По умолчанию строка анализируется в обычном режиме, смена режима
     осуществляется "особыми" кавычками (выделенными на первом этапе),
     "особые" кавычки при этом не добавляются в аргумент.
*/

ScanCommandLine
  e.CommandLine =
    <ParseArguments-Space
      <ScanQuotes <FindQuotes e.CommandLine>>
    >;

// Обнаружени кавычек
FindQuotes {
  e.CommandLine-B '\"' e.CommandLine-E =
    e.CommandLine-B (Quote) <FindQuotes e.CommandLine-E>;

  e.CommandLine = e.CommandLine;
}

// Обработка кавычек с бекслешами
ScanQuotes {
  // Двойной слеш
  e.Text-B '\\' '\\' (e.Slashes Quote) e.Text-E =
    <ScanQuotes
      e.Text-B ('\\' e.Slashes Quote) e.Text-E
    >;

  /*
    Двойные слеши перед кавычками закончились.
    Теперь, внутри каждой круглой скобки у нас по чётному количеству
    обратных слешей. Если встретится одинарный слеш (т.к. двойной уже
    встретиться не сможет), то такую кавычку делаем обычной кавычкой.
    Остальные скобки будут содержать особые кавычки.
  */

  e.Text-B '\\' (e.Slashes Quote) e.Text-E =
    <ScanQuotes e.Text-B ('\\' e.Slashes '\"') e.Text-E>;

  e.Text = <UncloseBrackets e.Text>;
}

UncloseBrackets {
  e.Text-B (e.Slashes s.Quote) e.Text-E =
    e.Text-B e.Slashes s.Quote <UncloseBrackets e.Text-E>;

  e.Text = e.Text;
}

ParseArguments-Space {
  ' ' e.Tail = <ParseArguments-Space e.Tail>;
  '\t' e.Tail = <ParseArguments-Space e.Tail>;

  /* пусто */ = /* пусто */;

  e.CommandLine = <ParseArguments-Simple () e.CommandLine>;
}

ParseArguments-Simple {
  (e.Argument) ' '  e.Tail = (e.Argument) <ParseArguments-Space e.Tail>;
  (e.Argument) '\t' e.Tail = (e.Argument) <ParseArguments-Space e.Tail>;

  (e.Argument) Quote e.Tail =
    <ParseArguments-Quote (e.Argument) e.Tail>;

  (e.Argument) s.Next e.Tail =
    <ParseArguments-Simple (e.Argument s.Next) e.Tail>;

  (e.Argument) /* пусто */ = (e.Argument);
}

ParseArguments-Quote {
  (e.Argument) Quote e.Tail =
    <ParseArguments-Simple (e.Argument) e.Tail>;

  (e.Argument) s.Next e.Tail =
    <ParseArguments-Quote (e.Argument s.Next) e.Tail>;

  (e.Argument) /* пусто */ = (e.Argument);
}

/**
  <ProgName> == e.ProgName
*/
$ENTRY ProgName = <Arg 0>;

/**
  <Exit s.RetCode>
    завершение программы
*/
$ENTRY Exit s.RetCode = <Core::ForseExit s.RetCode>;

/**
  <EnvList>
    == (e.VariableName)*
*/
$ENTRY EnvList = <DoEnvList <BaseEnvList>>;

DoEnvList {
  ((e.LoVarName) (e.VarName) e.Value) e.Tail =
    (e.VarName) <DoEnvList e.Tail>;

  /* пусто */ = /* пусто */;
}

BaseEnvList = <DoBaseEnvList <Core::EnvList>>;

DoBaseEnvList {
  (e.VarName '=' e.Value) e.Tail =
    ((<MStrings::Lower e.VarName>) (e.VarName) e.Value)
    <DoBaseEnvList e.Tail>;

  /* пусто */ = /* пусто */;
}

/**
  <Env e.Name>
    == e.Value
    == empty
*/
$ENTRY Env
  e.Name = <LookupEnv (<MStrings::Lower e.Name>) <BaseEnvList>>;

LookupEnv {
  (e.LoName) e.Env-B ((e.LoName) (e.Name) e.Value) e.Env-E =
    e.Value;

  (e.LoName) e.Env = /* пусто */;
}

$END MOS.
