################################################################################
Module MBackEnd_Refal5;

<Generate-T t.IModule e.OutName>
  == t.IModule

################################################################################
Module MBE-Mgr;
=============================================================================
Параметры конкретного диспетчера:
  s.Name ::= IDENTIFIER -- имя диспетчера
  s.FnGenerator ::= { t.IModule e.FileName = t.IModule }
  <s.FnLinker t.hContext (e.OutName) (t.ModuleName e.ObjName)*>
    == t.hContext Success
    == t.hContext Fails
  e.Folder -- имя папки
  e.Ext -- расширение файла
==============================================================================

<Register s.Name s.Generator s.Linker (e.Folder) (e.Ext)>
  == empty

<Generate t.Context t.IModule t.QualifiedName>
  == t.Context t.IModule Success
  == t.Context t.IModule Fails

<Link t.Context (e.OutName) e.OrderedFiles>
  == t.Context Success
  == t.Context Fails
e.OrderedFiles ::= t.QualifiedName*

<GetList> == s.BackEndName*

<GetInfo s.FEName s.Option>
  == Success e.Option
  == Fails s.Error
s.Error ::= InvalidMgr | InvalidOption

<GetPath-T s.BEName t.QualifiedName e.BaseFolder>
  == Success t.QualifiedName e.OutPath
  == Fails t.QualifiedName

<X_GetPath-T t.Context t.QualifiedName s.BEName>
  == t.Context t.QualifiedName Success e.Path
  == t.Context t.QualifiedName Fails

################################################################################
Module MBEFE-Holder;
=============================================================================
Модуль реализует хранилище данных для диспетчеров входных и генерирующих
частей. Работает по принципу атрибутной таблицы символов. Таблица индексируются
двумя символами: именем диспетчера и именем атрибута.
==============================================================================

<UpdateEntry
  s.FnSwap
  s.MgrName
  (s.Option e.Value)*
> == empty

<GetInfo s.FnSwap s.MgrName s.OptionName>
  == Success e.Value
  == Fails s.Error
s.Error ::= InvalidMgr | InvalidOption

<GetMgrList s.FnSwap>
  == e<name>.MgrNames

################################################################################
Module MClusters;
=============================================================================
Функции модуля обрабатывают "гроздь" модулей -- набор прямо или косвенно зави-
сящих модулей от некоторого модуля. Две основные фукции модуля: CheckNeedCompile
для проверки необходимости перекомпиляции данного модуля и ListForLinking для
получения списка модулей (упорядоченных в топологическом порядке), подлежащих
компоновке.
==============================================================================

<DependencesFromIModule t.hIModule>
  == t.hIModule t.ImportedModule*

<CheckNeedCompile-LinkOnly
  t.hContext (e.ModulePath) t.ModuleName
>
  == t.hContext t.ModuleName Success s.Status s.Type
  == t.hContext t.ModuleName Fails MismatchCase

<CheckNeedCompile-Build
  t.hContext (e.ModulePath) t.ModuleName
>
  == t.hContext t.ModuleName Success s.Status s.Type
  == t.hContext t.ModuleName Fails MismatchCase

<CheckNeedCompile-Make
  t.hContext (e.ModulePath) t.ModuleName
>
  == t.hContext t.ModuleName Success s.Status s.Type
  == t.hContext t.ModuleName Fails MismatchCase

<ListForLinking t.hContext t.RootModuleName>
  == t.hContext Success t.ModuleName*
  == t.hContext Fails

################################################################################
Module MCompiler;

<Make t.hContext t.hErrorList e.ModulePath t.RootModuleName>
  == t.hContext t.hErrorList Success
  == t.hContext t.hErrorList Fails

<LinkOnly t.hContext t.hErrorList e.ModulePath t.RootModuleName>
  == t.hContext t.hErrorList Success
  == t.hContext t.hErrorList Fails

<Build t.hContext t.hErrorList e.ModulePath t.RootModuleName>
  == t.hContext t.hErrorList Success
  == t.hContext t.hErrorList Fails

# STARTCUT
Compile-AfterUpdateContext
  t.hErrorList t.hIModule s.ModuleType t.hContext Success =
    (t.hContext t.hErrorList) Success t.hIModule s.ModuleType;
# ENDCUT

<PrepareImportList-Aliases t.hIModule t.NextImportAlias>
  == t.hIModule (t.NextImport t.RealName)

<GetImportList-AnalyzeRecursiveLinks
  (e.Stack) (e.ModulePath) t.ModuleName
  t.hContext t.hErrorList t.hIModule e.Imports
>
  == FoundRecursives (e.Stack) (e.ModulePath) t.ModuleName
  t.hContext t.hErrorList t.hIModule e.NonRecursiveImports
  == NotFoundRecursives (e.Stack) (e.ModulePath) t.ModuleName
  t.hContext t.hErrorList t.hIModule e.Imports
e.Imports ::= (t.AliasName t.RealName)

<AnalyzeValidSubModule (t.hErrorList t.hIModule s.Result) t.ImportRes>
  == (t.hErrorList t.hIModule s.Result) (t.hISubModule t.SubModuleAlias)
  == (t.hErrorList t.hIModule Errors)
t.ImportRes ::=
  (t.Success t.hISubModule s.ModuleType t.Alias)
  | (Fails t.ImportName t.Alias)
  | (IsNotLibrary t.ImportName t.Alias)

################################################################################
Module MContext;

<Create> == t.Context

<Destroy t.Context> == empty

---------------------------------------------------------------------------
# STARTCUT
DefaultOptions
  =
    // Информация о входных и выходных частях
    (FrontEnd Unknowns) // Unknowns | None | s.FrontEnd e.FileName
    (BackEnds Unknowns) // e.BackEnds ::= Unknowns | (s.BackEnd e.FileName)*

    // Информация о настоящем имени модуля (контекст индексируется без учёта
    // регистра, но регистр надо проверять)
    (RealName Unknown) // Unknown | t.QualifiedName

    // Информация о статусе компилирования

    (Type Errors) // Errors | Changed | Updated | Library
    (Status Found) // Found | Raw | Ready

    /*
      Время последней модификации. Нужно для того, чтобы определить,
      необходима ли перекомпиляция: импортирующие модули должны быть
      откомпилированы позже импортируемых.
      Unknown -- информация не доступна
      (e.MinTime) (e.MaxTime) -- см. MainStructures.txt
    */
    (MinMaxTime Unknown)

    (ModuleType Main) // Main | Regular
    (CachedSym None) // None | t.IModule
    (BaseDirectory Current) // Current | e.FileName
    ;
# ENDCUT
---------------------------------------------------------------------------

<GetRealName t.hContext t.ModuleName>
  == t.hContext Success t.RealName
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails UnknownRealName

<GetStatusType t.hContext t.ModuleName>
  == t.hContext Success s.Status s.Type
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

---------------------------------------------------------------------------

Функции уровня поиска модулей.

<CreateModule
  t.hContext t.ModuleName
  (Type s.Type)
  t.FrontEndInfo
  t.BackEndInfo
  (BaseDirectory e.BaseDirectory)
>
  == t.hContext Success
  == t.hContext Fails Redefinition

t.FrontEndInfo ::=
  (FrontEnd s.FrontEnd e.PathToFrontEnd) | (FrontEnd None)
t.BackEndInfo ::=
  (BackEnds (s.BackEnd e.PathToBackEnd)*) | (BackEnds Unknowns)

<GetFrontEnd t.hContext t.ModuleName>
  == t.hContext Success None
  == t.hContext Success s.FrontEnd e.Path
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

<GetBackEndList t.hContext t.ModuleName>
  == t.hContext Success (s.BackEnd e.Path)*
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

<GetBaseDirectory t.hContext t.ModuleName>
  == t.hContext Success e.BaseDirectory
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

---------------------------------------------------------------------------

Функции "сырого" уровня.

<SetRawType t.hContext t.ModuleName s.Type>
  == t.hContext Success
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase
  == t.hContext Fails CantUpdate

<SetMinMaxTime t.hContext t.ModuleName (e.MinTime) (e.MaxTime)>
  == t.hContext Success
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

<GetMinMaxTime t.hContext t.ModuleName>
  == t.hContext Success Unknown
  == t.hContext Success (e.MinTime) (e.MaxTime)
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase

---------------------------------------------------------------------------

Функции уровня компиляции.

<FinishModule t.hContext t.RealModuleName s.ModuleType s.Type>
  == t.hContext Success
  == t.hContext Fails ModuleNotFound
  == t.hContext Fails MismatchCase
  == t.hContext Fails CantUpdate

################################################################################
Module MCreateDirIfNeed;

<Create e.DirName> == e.DirName

<InfoDir> == 'Info'

<CreatePathToFile e.FileName> == e.FileName
  e.FileName ::= e.Dir1 '\\' e.Dir2 '\\' e.FName
  '>md ' e.Dir1
  '>md ' e.Dir1 '\\' e.Dir2

################################################################################
Module MError;

<Fatal e.Message>
  == fail down (errcode 1)

<LinkError e.Message>
  == fail down (errcode 1)

<CreateErrList> == t.hErrorList

<DestroyErrList t.hErrorList> == empty

<EmptyList t.ErrorList>
  == t.ErrorList Empty
  == t.ErrorList NotEmpty

<ContentLevel t.ErrorList>
  == t.ErrorList Empty
  == t.ErrorList Warnings
  == t.ErrorList Errors

<MergeLists t.List1 t.List2>
  == t.MergedList

<AddUnexpected t.ErrorList t.UnexpToken e.ExpectedText>
  == t.UpdatedErrorList

<AddNamesMismatch
  t.ErrorList t.TailPos
  t.InHead t.InTail
>
  == t.ErrorList

<AddRecursiveLink t.hErrorList t.SrcPos t.ImportName>
  == t.hErrorList

<AddBrokenImport t.hErrorList t.SrcPos t.ImportName>
  == t.hErrorList

<DependedFromSource t.hErrorList t.SrcPos t.ImportName>
  == t.hErrorList

<AddImportHead t.hErrorList t.SrcPos t.ImportName>
  == t.hErrorList

<AddMismatchInternalAndExternalNames
  t.ErrorList t.SrcPos t.InternalName t.ExternalName
>
  == t.ErrorList

<AddRedeclaredIdentifier t.ErrorList t.SrcPos t.Identifier>
  == t.UpdatedErrorList

<AddVarTypeMismatch t.hErrorList t.SrcPos e.VarName>
  == t.hErrorList

<AddUndeclaredVariable t.hErrorList t.SrcPos s.VarType e.Index>
  == t.hErrorList

<AddUnresolvedFunction t.hErrorList t.SrcPos t.FnName>
  == t.hErrorList

<PrintErrors t.hErrorList> == empty

################################################################################
Module MExeTyper;

<Create s.Limit e.OutputName> == t.ExeTyper

<Destroy t.ExeTyper> == empty

<TypeChar t.ExeTyper s.Char> = t.ExeTyper

<TypeQuoted t.ExeTyper s.Quote e.Text> == t.ExeTyper

<TypeRenamed t.ExeTyper e.RenamedName> == t.ExeTyper

<TypeComment t.ExeTyper e.Comment> == t.ExeTyper

################################################################################
Module MFE-Mgr;

<Register s.FEName s.FnParser (e.Ext)>
  == empty

<GetPath-T s.FEName t.QualifiedName e.BaseFolder>
  == Success t.QualifiedName e.FilePath
  == Fails t.QualifiedName

<Load s.FEName t.hErrorList t.ModuleName e.PathToFile>
  == t.ErrorList Success s.Result t.IModule
  == t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

<GetList>
  == s.FrontEndName*

<GetExt-T s.FEName>
  == s.FEName e.Ext

################################################################################
Module MFileSystem;

<ExistFile e.FileName> == True | False

<ExistFile-T e.FileName>
  == True e.FileName
  == False e.FileName

<BackSlash e.FileName-B '/' e.FileName-E> == e.FileName-B '\\' e.FileName-E
<BackSlash e.FileName> == e.FileName

<MakeDir e.Directory> == empty

<FileAttribute s.Attribute e.FileName>
  == FileNotFound
  == (e.Value)

s.Attribute ::= DateTime | Size | LongName

<DirList e.DirectoryName>
  == Success (e.FileName)*
  == Fails

<FilesInfo e.Mask>
  == (
    (e.FileName)
    (DateTime e.DateTime)
    (Size s.Size)
    (LongName e.LongName)
  )*

<ParseFileName e.FileName>
  == (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
  == ('c;\\Directory\\') 'Document' ('doc')

<CanonicalPath e.Path>
  == e.Canonical

################################################################################
Module MIModule;

<Create
  t.QualifiedName
  (s.Attrib e.Value)*
>
  == t.IModule s.Status

<Destroy t.IModule> == empty

---------------------------------------------------------------------------

<GetModuleName t.IModule>
  == t.IModule t.QualifiedName

<AbsolutName t.hIModule t.RelativeName>
  == t.hIModule t.AbsolutName

<RelativeName t.hIModule t.AbsolutName>
  == t.hIModule Success t.RelativeName
  == t.hIModule Fails

---------------------------------------------------------------------------

<UpdateModule t.IModule e.Attribs>
  == t.IModule s.Status

s.Status ::=
  Success | InvalidAttrib | InvariantError

<UpdateFunction
  t.hIModule
  t.FunctionName
  (s.Attrib e.Value)
>
  == t.hIModule s.Status

<UpdateImport-X
  t.hIModule
  (Position t.Position) (RealName t.RealName) (AliasName t.AliasName)
>
  == t.hIModule s.Status

<UpdateADT t.IModule t.Name e.Attribs>
  == t.IModule s.Status

<UpdateEntity-Relative
  t.IModule s.Kind (e.ParsedName) e.Attribs
>

<UpdateEntity
  t.IModule s.Kind (e.EntityName) e.Attribs
>
  == t.IModule s.Status

s.Status ::=
  Success | InvalidKind | InvalidAttrib | InvariantError

# STARTCUT
ValidAttribs {
  Function = ScopeClass Position Body Qualified;
  ModuleName = Position ModuleType;
  ImportName = Position RealName AliasName;
  ImportAlias = Position RealName AliasName;
  ADT = Position;
}
# ENDCUT
---------------------------------------------------------------------------

<GetModuleAttribute t.IModule s.Attribute>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvariantError

<GetFunctionAttrubute t.hIModule s.Attrib t.FnName>
  == t.hIModule Found e.Value
  == t.hIModule s.ErrorStatus

<GetImportAttribute-RealName t.hIModule s.Attrib t.Import>
  == t.hIModule Found e.Value
  == t.hIMoudle s.ErrorStatus

<GetImportAttribute-AliasName t.hIModule s.Attrib t.Import>
  == t.hIModule Found e.Value
  == t.hIMoudle s.ErrorStatus

<GetADTAttributes t.IModule s.Attrib e.Name>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

<GetEntityAttribute
  t.IModule s.Kind s.Attrib e.Name
>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

<GetKind t.hIModule t.EntityName>
  == Success s.Kind
  == NoName

---------------------------------------------------------------------------

<GetFunctionList t.hIModule>
  == t.hIModule t.FunctionName*

<GetImportList-RealNames t.hIModule>
  == t.hIModule t.RealImportName*

<GetImportList-Aliases t.hIModule>
  == t.hIModule t.AliasImportName*

<GetADTList t.IModule>
  == t.IModule t.ADT*

################################################################################
Module MLambda;

<Apply t.Lambda e.Arg>
  == e.Result

<BindLeft t.Lambda e.Left>
  == t.Lambda'
<Apply t.Lambda' e.Arg>
  === <Apply t.Lambda e.Left e.Arg>

<BindLeft-H t.Lambda e.Left>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Arg>
  == <Apply t.Lambda t.Handle e.Left e.Arg>

<BindRight t.Lambda e.Right>
  == t.Lambda'
<Apply t.Lambda' e.Arg>
  === <Apply t.Lambda e.Arg e.Right>

<Composite t.Lambda_1 ... t.Lambda_N>
  == t.CompositeLambda
<Apply t.CompositeLambda e.Arg>
  ===
  <Apply
    t.Lambda_N
    <Apply
      t.Lambda_N-1
      ...
      <Apply t.Lambda_1 e.Arg>
      ...
    >
  >

<MakeHandled t.Lambda>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Arg>
  === t.Handle <Apply t.Lambda e.Arg>

<Parallel t.Lambda_1 ... t.Lambda_N>
  == t.Lambda'
<Apply t.Lambda' e.Argument>
  === <Apply t.Lambda_1 e.Argument> ... <Apply t.Lambda_N e.Argument>

<Parallel-H e.Lambda_1 ... t.Lambda_N>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Argument>:
<Apply t.Lambda t.Handle e.Argument>
  === t.Handle_1 e.Result_1
...
<Apply t.Lambda_N t.Handle_N-1 e.Result_N-1>
  === t.Handle' e.Result

<Const e.Value>
  == t.Lambda
<Apply t.Lambda e.AnyArg> === e.Value

---------------------------------------------------------------------------

<Map t.Lambda t.Src*>
  == e.Result*
<Apply t.Lambda t.Src> == e.Result

<Reduce t.Lambda t.Accum t.Src*>
  == t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<Reduce-R t.Lambda t.Accum t.Src*>
  == t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<MapReduce t.Lambda t.Accum t.Src*>
  == t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

<MapReduce-R t.Lambda t.Accum t.Src*>
  == t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

<TerminateAccumulator t.FnTerminator t.Accum e.Elems>
  == <Apply t.FnTerminator t.Accum> e.Elems

---------------------------------------------------------------------------

<UnBracket (e.Brackets)> == e.Brackets

<Bracket e.Expr> == (e.Expr)

<UnBracket-H t.Handle (e.Brackets)>
  == t.Handle e.Brackets

<Bracket-H t.Handle e.Expr>
  == t.Handle (e.Expr)

<Nil e.Any> == empty

<Identity e.Value> == e.Value

################################################################################
Module MLinker_Refal5;

<Link t.Context (e.ProgName) (t.ModuleName e.ROutName)*>
  == t.Context Success
  == t.Context Fails

<CreateStartupUnit t.Context>
  == t.Context (t.StartupUnit)

<CreateUnitStorage> == t.UnitStorage

<AddUnit t.UnitStorage t.Unit>
  == t.UnitStorage

<AddRequest t.UnitStorage e.Name>
  == t.UnitStorage

<AddLinked t.UnitStorage e.Name>
  == t.UnitStorage

<GetNextUnit t.UnitStorage>
  == t.UnitStorage t.Unit
  == t.UnitStorage None
  == t.UnitStorage Finish

<DestroyUnitStorage t.UnitStorage> == empty

<NextRequestedName-D t.UnitStorage>
  == e.Name

<NotLinkedList t.UnitStorage>
  == t.UnitStorage (e.NotLinkedUnitName)*

################################################################################
Module MModules;

<LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath
>
  == t.hContext Found
    t.QualifiedName s.FrontEndName e.BaseDirectory
  == t.hContext NotFound

<LookupImportModule
  t.hContext (e.ModulePath) t.QualifiedName
>
  == t.hContext Success s.Status s.Type
  == t.hContext Fails MismatchCase

################################################################################
Module MOrder;

Сравнение по типам:
() > Macro > Character > Other
Скобочные термы сравниваются в лексиконографическом порядке.
Макроцифры сравниваются по арифметическим правилам.
Characters сравниваются по ASCII-значениям.
Остальные символы считаются равными.

<Compare-T t.Left t.Right>
  == s.Result t.Left t.Right

s.Result ::= '<' | '=' | '>'

<Compare t.Left t.Right> == '<' | '=' | '>'

<Sort e.Sequence>
  == e.SortedSequence

<Max e.Terms> == t.MaxTerm
e.Terms != empty

<Min e.Terms> == t.MinTerm
e.Terms != empty

################################################################################
Module MOS;

<System e.Command>
  == empty

<Arg s.Number>
  == e.Arg
  == empty

<ArgList>
  == (e.Argument)*

<ProgName> == e.ProgName

<Exit s.RetCode>
  завершение программы

<EnvList>
  == (e.VariableName)*

<Env e.Name>
  == e.Value
  == empty

################################################################################
Module MParser_Common;

<Parse s.FnModuleBody e.FileName>
  == t.ErrorList Success t.IModule
  == t.ErrorList Fails

<GeneralizeInfo
  t.GenericErrorList t.QualifiedName
  t.LocalErrorList {Maybe t.IModule}
>
  == t.ErrorList Success s.ErrorsLevel t.IModule
  == t.ErrorList Fails
s.ErrorsLevel ::= Success | Warnings | Errors

-----------------------------------------------------------------------------
Функции синтаксического анализа делятся на три категории:
(1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
(2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
(3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------

AnyQualifiedName = DotQualifiedName | QuadQualifiedName .
DotQualifiedName =
  IDENTIFIER | DotQualifiedName '.' IDENTIFIER .
QuadQualifiedName =
  IDENTIFIER | QuadQualifiedName '::' IDENTIFIER .

<N***QualifiedName
  t.ErrorList t.Lexer t.NextToken
>
  == e.ScannedQName t.ErrorList t.Lexer t.NextToken

e.ScannedQName ::=
  Success t<MQualifiedName::QName>.QualifiedName | Fails

В случае ошибки на стеке оставляется первый неожиданный терм.
Если имя было частично определено, например так:
  'PackageName::ModuleName::222',
то имя считается распознанным успешно. Информация об ошибке
падает в t.ErrorList, но синтаксически инвариант соблюдётся.

################################################################################
Module MParser_MRefal;

<SrcModule t.ErrorList t.QualifiedName e.FileName>
  == t.ErrorList Success s.Result t.IModule
  == t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

################################################################################
Module MParser_Sym;

<SymModule t.ErrorList t.QualifiedName e.FileName>
  == t.ErrorList Success s.Result t.IModule
  == t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

################################################################################
Module MQualifiedName;

<Create (e.Segment)+>
  == t.QualifiedName
обратна Parse

<Destroy t.QualifiedName> == empty

---------------------------------------------------------------------------

<AddSubName t.QualifiedName e.SubName>
  == t.UpdatedQualifiedName

<AddSuperName t.QualifiedName e.SuperName>
  == t.UpdatedQualifiedName

<Append t.QualifiedAcceptor t.QualifiedForAppend>
  == t.UpdatedQualifierAcceptor

---------------------------------------------------------------------------

<Parse t.QualifiedName>
  == (e.SegmentName)*
обратна Create

<Parse-T t.QualifiedName>
  == t.QualifiedName (e.SegmentName)*

---------------------------------------------------------------------------

<ToRelativeFSPath-T t.QualifiedName>
  == t.QualifiedName
    e.Segment '/' e.Segment '/' ... '/' e.Segment

<ToPrintable-Dot t.QualifiedName>
  == e.DotName

<ToPrintable-Quad t.QualifiedName>
  == e.QuadName

<Equals-T t.QName1 t.QName2>
  == s.Result t.QName1 t.QName2
s.Result ::= True | False

################################################################################
Module MR-Extent;

<Call e.MR-Extent-Command>
  == Success e.MR-Extent-Result
  == Fails

################################################################################
Module MResolver;

<Resolve t.Module t.ErrorList t.ResolveTable>
  == t.ResolvedModule s.ErrorStatus t.UpdatedErrorList
s.ErrorStatus ::= Success | Errors

################################################################################
Module MResolveTable;

<Create> == t.ResolveTable

<Destroy t.ResolveTable> == empty

<Add t.ResolveTable
  t.InternalQualifier
  s.ScopeClass
  t.ExternalQualifier
> == t.UpdatedResolveTable

<Lookup t.ResolveTable (e.ValidScopes) t.InternalQualifier>
  == t.ResolveTable Found s.ScopeClass t.ExternalQualifier
  == t.ResolveTable NotFound NotFound t.InternalQualifier
e.ValidScopes ::= s.ScopeClass*

################################################################################
Module MSelfDiag;

<Assert-??-T (e.Result) (e.Expected) [e.Message]>
  == e.Result
  fail down

<Assert-?? (e.Result) (e.Expected) [e.Message]>
  == empty
  fail down

################################################################################
Module MStartupSeqGenerator;

<GetFnList t.hContext e.ModuleList>
  == t.hContext e.FnList
  == t.hContext GoNotFound
  == t.hContext MultipleGo e.FnList--GoFunctions
e.FnList = (e.Function)*
e.ModuleList = t.ModuleName*

<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
  == t.StartInfo t.Context

################################################################################
Module MStrings;

<Upper e.Text> == e.UpperText
<Lower e.Text> == e.LowerText

<Length e.Expr> == s.Length
<Length e.Expr> == s.Length e.Expr

<First-Parse s.Count e.Expr> ==
  (e.First) e.Tail

<First s.Count e.Expr> == e.Truncate

<Skip s.Count e.Expr> == e.Truncated

<At s.Index e.Expr> == t.ElemAt
Нумерация начинается с нуля.

<Seq s.NFirst s.NLast>
  == s.NFirst s.NFirst+1 ... s.NLast-1 s.NLast
s.NFirst и s.NLast -- числа,
причём должно быть s.NFirst <= s.NLast

<Reverse e.Line> == e.eniL

<Repeat s.Num e.Expr>
  == e.Expr e.Expr ... e.Expr
<Length <Repeat s.Num e.Expr>> == s.Num
s.Num >= 0

<Fields (e.Fields) e.Line>
  == (e.SubField)*
e.Fields = s<num>*

<Decart ( t.ElemA* ) ( t.ElemB* )>
  == (t.ElemA t.ElemB)*

Пример:
<Decart (1 2 3) (A B C D)> ==
  (1 A) (1 B) (1 C) (1 D)
  (2 A) (2 B) (2 C) (2 D)
  (3 A) (3 B) (3 C) (3 D)

<Unique e.Elems> == e.Set

<Set-Intersect (e.Set1) (e.Set2)>
  == e.Set1*Set2

<Set-Difference (e.Set1) (e.Set2)>
  == e.Set1-Set2

################################################################################
Module MSwapSupport;
=============================================================================
Модуль предоставляет функции для наиболее распространённых функций с
динамическими ящиками: чтение, запись, добавление терма в начало/конец,
чтение терма с начала/конца, операции с копилкой.
==============================================================================

<Read s.FnSwap>
	== e.Content
Содержимое ящика не изменяется.

<Write s.FnSwap e.NewContent>
	== empty
Ящик получает значение e.NewContent

<PushFront s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap t.Info <s.FnSwap>>

<PushBack s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap <s.FnSwap> t.Info>

<PopFront s.FnSwap>
	== Success t.Value
	== Fails
Если <s.FnSwap> :: t.Value e.Content То
	<s.FnSwap e.Content>
	Success t.Value
Иначе
	Fails

<PopBack s.FnSwap>
	== Success t.Value
	== Fails
См. описание функции PopFront.

<Br s.FnSwap e.Key '=' e.Value> == empty

<Bury s.FnSwap (e.Key) e.Value> == empty

<Dg s.FnSwap e.Key> == e.Value

<Cp s.FnSwap e.Key> == e.Value

<Rp s.FnSwap e.Key '=' e.Value> == empty

<Replace s.FnSwap (e.Key) e.Value> == empty

<Dgall s.FnSwap> == (e.Key '=' e.Value)*

<DigAll s.FnSwap> == ((e.Key) e.Value)*

<Cpall s.FnSwap> == (e.Key '=' e.Value)*

<CopyAll s.FnSwap> == ((e.Key) e.Value)*

################################################################################
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста.

<LoadInfo t.Context t.ModuleName>
  == t.Context Success t.IModule
  == t.Context Fails
t.ModuleName ::= t.QualifiedName

<SymReduce-T t.hIModule>
  == t.hIModule t.hISymModule

<SymReduce t.hIModule> == t.hISymModule

################################################################################
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
  == s.Char t.SymStream //Если символ из набора.
  == t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
  == t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
  == t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

################################################################################
Module MSymTable;

<Create> == t.SymTable

<AddName t.SymTable e.Name>
  == t.SymTable

<UpdateAttrib t.SymTable (e.Name) s.Attrib e.Value>
  == t.SymTable

<RemoveAttrib t.SymTable e.Name s.Attrib>
  == t.SymTable Found e.Value
  == t.SymTable NoAttrib
  == t.SymTable NoName

<GetAttrib t.SymTable e.Name s.Attrib>
  == t.SymTable Found e.Value
  == t.SymTable NoAttrib
  == t.SymTable NoName

<ExtractNames t.SymTable>
  == t.SymTable (e.Name)*

<UpdateAttribSet
  t.SymTable (e.Name)
  (s.Attrib e.Value)*
> == t.SymTable

<FindByKind t.SymTable s.Kind>
  == t.SymTable (e.Name)*

################################################################################
Module MXXIO;

<Load e.FileName>
  == Success e.LoadedExpr
  == Fails

<Save (e.FileName) e.Expr>
  == Success
  == Fails

