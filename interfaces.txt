################################################################################
Module Compiler;

<CompileByModuleName-Q t.hContext t.QualifiedName>
  == t.hContext

<LookupModule-T t.Context e.ModuleName>
  == t.Context
    s.Known s.Status
    (Sym e.SymFileName)
    (Out e.OutFileName)
    (Src e.SrcFileName)
    e.ModuleName
s.Known ::= Known | NotKnown
s.Status ::=
  if Known
    Recompiled | Updated | Library | InCompiling
  if NotKnown
    ModuleNotFound | Library | SystemLibrary | NeedRecompile | SrcNotUpdated

################################################################################
Module Context;

<UpdateModuleInfo t.Context (e.ModName) e.NewOptionsList>
  == t.UpdatedContext

<ExtractOption t.Context s.Option e.ModName>
  == t.Context Found e.Option
  == t.Context ModuleInfoNotFound
  !fail abort!

################################################################################
Module MBackEnd_Refal5;

<Generate-T t.IModule e.OutName>
  == t.IModule

################################################################################
Module MBE-Mgr;
=============================================================================
Параметры конкретного диспетчера:
  s.Name ::= IDENTIFIER -- имя диспетчера
  s.FnGenerator ::= { t.IModule e.FileName = t.IModule }
  <s.FnLinker t.hContext (e.OutName) (t.ModuleName e.ObjName)*>
    == t.hContext Success
    == t.hContext Fails
  e.Folder -- имя папки
  e.Ext -- расширение файла
==============================================================================

<Register s.Name s.Generator s.Linker (e.Folder) (e.Ext)>
  == empty

<Generate t.Context t.IModule t.QualifiedName>
  == t.Context t.IModule Success
  == t.Context t.IModule Fails

<Link t.Context (e.OutName) e.OrderedFiles>
  == t.Context Success
  == t.Context Fails
e.OrderedFiles ::= t.QualifiedName*

<GetList> == s.BackEndName*

<GetInfo s.FEName s.Option>
  == Success e.Option
  == Fails s.Error
s.Error ::= InvalidMgr | InvalidOption

<GetPath-T s.BEName t.QualifiedName e.BaseFolder>
  == Success t.QualifiedName e.OutPath
  == Fails t.QualifiedName

<X_GetPath-T t.Context t.QualifiedName s.BEName>
  == t.Context t.QualifiedName Success e.Path
  == t.Context t.QualifiedName Fails

################################################################################
Module MBEFE-Holder;
=============================================================================
Модуль реализует хранилище данных для диспетчеров входных и генерирующих
частей. Работает по принципу атрибутной таблицы символов. Таблица индексируются
двумя символами: именем диспетчера и именем атрибута.
==============================================================================

<UpdateEntry
  s.FnSwap
  s.MgrName
  (s.Option e.Value)*
> == empty

<GetInfo s.FnSwap s.MgrName s.OptionName>
  == Success e.Value
  == Fails s.Error
s.Error ::= InvalidMgr | InvalidOption

<GetMgrList s.FnSwap>
  == e<name>.MgrNames

################################################################################
Module MClusters;
=============================================================================
Функции модуля обрабатывают "гроздь" модулей -- набор прямо или косвенно зави-
сящих модулей от некоторого модуля. Две основные фукции модуля: CheckNeedCompile
для проверки необходимости перекомпиляции данного модуля и ListForLinking для
получения списка модулей (упорядоченных в топологическом порядке), подлежащих
компоновке.
==============================================================================

<DependencesFromIModule t.hIModule>
  == t.hIModule t.ImportedModule*

<CheckNeedCompile
  t.hContext (e.ModulePath) t.ModuleName
>
  == t.hContext t.QualifiedName s.Result

s.Result ::=
  NeedRecompile | Updated | Library | NotFound | SuccessCompiled | Errors

<ListForLinking t.hContext t.RootModuleName>
  == t.hContext Success t.ModuleName*
  == t.hContext Fails

################################################################################
Module MCompiler;

<Make t.hContext t.hErrorList e.ModulePath t.RootModuleName>
  == t.hContext t.hErrorList Success
  == t.hContext t.hErrorList Fails

################################################################################
Module MContext;

<Create> == t.Context

<Destroy t.Context> == empty

<UpdateInfo t.hContext t.QualifiedName e.NewOptionList>
  == t.hUpdatedContext Success
  == t.hContext Fails s.Error
s.Error ::= UnknownOption | MismatchCase

---------------------------------------------------------------------------
# STARTCUT
DefaultOptions
  =
    /*
      Информация о входных и выходных частях (старое)
      Формат: None | e.FileName
    */
    (Sym None) (Out None) (Src None)

    // Информация о входных и выходных частях
    (FrontEnd Unknowns) // Unknowns | None | s.FrontEnd e.FileName
    (BackEnds Unknowns) // e.BackEnds ::= Unknowns | (s.BackEnd e.FileName)*

    // Информация о настоящем имени модуля (контекст индексируется без учёта
    // регистра, но регистр надо проверять)
    (RealName Unknown) // Unknown | t.QualifiedName

    // Информация о статусе компилирования

    // Библиотека или файл с исходником
    (Type Unknown) // Unknown | Library | Source

    /*
      Был ли обработан?
      * Unknown -- если не инициализровано;
      * Found -- модуль только обнаружен;
      * SuccessCompiled -- успешно откомпилирован,
      имеет смысл только для исходника;
      * LocalUpdated
        * для исходника -- выходные файлы корректны, не компилировался;
        * для библиотечного модуля -- выходные файлы корректны;
        (если возможна проверка корректности для back-end;
        гарантируется, что корректна хотя бы SymInfo);
      * GlobalUpdated
        * для исходников и библиотечных модулей аналогично LocalUpdated
        с тем отличием, что GlobalUpdated также рекурсивно установлен
        у всех импортируемых модулей;
      * NeedRecompile -- имеет смысл только для исходника,
        означает, что модуль нужно перекомпилировать;
      * Errors -- в процессе обработки произошла ошибка:
        * для исходника -- ошибки в процессе компиляции;
        * для библиотечного модуля -- выходные файлы повреждены.
    */
    (Status_NEW Unknown)

    /*
      Время последней модификации. Нужно для того, чтобы определить,
      необходима ли перекомпиляция: импортирующие модули должны быть
      откомпилированы позже импортируемых.
      Unknown -- информация не доступна
      e.DateTime -- см. MainStructures.txt
    */
    (LastTime Unknown)

    (ModuleType Program) // Program | Module
    (CachedSym None) // None | t.IModule
    (BaseDirectory Current) // Current | e.FileName
    /*
      Объединяло Type и Status_NEW, устаревшее.
      Unknown | InCompiling | Library | Recompiled | Updated
    */
    (Status Unknown)
    ;
# ENDCUT
---------------------------------------------------------------------------

<ExtractOption t.hContext t.QualifiedName s.Option>
  == t.hContext Found e.Option
  == t.hContext OptionNotFound
  == t.hContext ModuleNotFound
  == t.hContext MismatchCase

################################################################################
Module MCreateDirIfNeed;

<Create e.DirName> == e.DirName

<InfoDir> == 'Info'

################################################################################
Module MError;

<Fatal e.Message>
  == fail down (errcode 1)

<LinkError e.Message>
  == fail down (errcode 1)

<CreateErrList> == t.hErrorList

<DestroyErrList t.hErrorList> == empty

<EmptyList t.ErrorList>
  == t.ErrorList Empty
  == t.ErrorList NotEmpty

<ContentLevel t.ErrorList>
  == t.ErrorList Empty
  == t.ErrorList Warnings
  == t.ErrorList Errors

<MergeLists t.List1 t.List2>
  == t.MergedList

<AddUnexpected t.ErrorList t.UnexpToken e.ExpectedText>
  == t.UpdatedErrorList

<AddNamesMismatch
  t.ErrorList t.TailPos
  t.InHead t.InTail
>
  == t.ErrorList

<AddMismatchInternalAndExternalNames
  t.ErrorList t.SrcPos t.InternalName t.ExternalName
>
  == t.ErrorList

<AddRedeclaredIdentifier t.ErrorList t.SrcPos e.Identifier>
  == t.UpdatedErrorList

<AddVarTypeMismatch t.hErrorList t.SrcPos e.VarName>
  == t.hErrorList

<AddUndeclaredVariable t.hErrorList t.SrcPos s.VarType e.Index>
  == t.hErrorList

<AddUnresolvedFunction t.hErrorList t.SrcPos s.ScopeClass e.FnName>
  == t.hErrorList

<PrintErrorsAndStop t.hErrorList>
  == fail down (errcode 1)

<PrintErrors t.hErrorList> == empty

################################################################################
Module MExeTyper;

<Create s.Limit e.OutputName> == t.ExeTyper

<Destroy t.ExeTyper> == empty

<TypeChar t.ExeTyper s.Char> = t.ExeTyper

<TypeQuoted t.ExeTyper s.Quote e.Text> == t.ExeTyper

<TypeRenamed t.ExeTyper e.RenamedName> == t.ExeTyper

<TypeComment t.ExeTyper e.Comment> == t.ExeTyper

################################################################################
Module MFE-Mgr;

<Register s.FEName s.FnParser (e.Ext)>
  == empty

<GetPath-T s.FEName t.QualifiedName e.BaseFolder>
  == Success t.QualifiedName e.FilePath
  == Fails t.QualifiedName

<X_GetPath-T t.Context t.QualifiedName s.FEName>
  == t.Context t.QualifiedName Success e.FileName
  == t.Context t.QualifiedName Fails

<Load s.FEName t.ErrorList t.QualifiedName e.BaseDir>
  == t.ErrorList Success s.Result t.IModule
  == t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

<GetList>
  == s.FrontEndName*

<GetExt-T s.FEName>
  == s.FEName e.Ext

################################################################################
Module MFileSystem;

<ExistFile e.FileName> == True | False

<ExistFile-T e.FileName>
  == True e.FileName
  == False e.FileName

<FilesInfo e.Mask>
  == (
    (e.FileName)
    (DateTime e.DateTime)
    (Size s.Size)
    (LongName e.LongName)
  )

<FileAttribute s.Attribute e.FileName>
  == FileNotFound
  == (e.Value)

s.Attribute ::= DateTime | Size | LongName

<ParseFileName e.FileName>
  == (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
  == ('c;\\Directory\\') 'Document' ('doc')

################################################################################
Module MIModule;

<Create
  t.QualifiedName
  (s.Attrib e.Value)*
>
  == t.IModule s.Status

<Destroy t.IModule> == empty

---------------------------------------------------------------------------

<GetModuleName t.IModule>
  == t.IModule t.QualifiedName

---------------------------------------------------------------------------

<UpdateModule t.IModule e.Attribs>
  == t.IModule s.Status

s.Status ::=
  Success | InvalidAttrib | InvariantError

<UpdateFunction
  t.IModule
  (e.FunctionName)
  (s.Attrib e.Value)*
>
  == t.IModule s.Status

s.Status ::=
  Success | InvalidKind | InvalidAttrib | InvariantError

<UpdateFunction-Q
  t.hIModule
  t.FunctionName
  (s.Attrib e.Value)
>
  == t.hIModule s.Status

<UpdateImport t.IModule t.Import e.Attribs>
  == t.IModule s.Status

<UpdateADT t.IModule (e.Name) e.Attribs>
  == t.IModule s.Status

<UpdateEntity
  t.IModule s.Kind (e.EntityName) e.Attribs
>
  == t.IModule s.Status

s.Status ::=
  Success | InvalidKind | InvalidAttrib | InvariantError

# STARTCUT
ValidAttribs {
  Function = ScopeClass Position Body Qualified;
  ModuleName = Position ModuleType;
  ImportName = Position RealName;
  ADT = Position;
}
# ENDCUT
---------------------------------------------------------------------------

<GetModuleAttribute t.IModule s.Attribute>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvariantError

<GetFucntionAttribute t.IModule s.Attrib e.FnName>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

<GetFunctionAttrubute-Q t.hIModule s.Attrib t.FnName>
  == t.hIModule Found e.Value
  == t.hIModule s.ErrorStatus

<GetImportAttribute t.IModule s.Attrib t.Import>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

<GetADTAttributes t.IModule s.Attrib e.Name>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

<GetEntityAttribute
  t.IModule s.Kind s.Attrib e.Name
>
  == t.IModule Found e.Value
  == t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

---------------------------------------------------------------------------

<GetFunctionList t.IModule>
  == t.IModule (e.FnName)*

<GetFunctionList-Q t.hIModule>
  == t.hIModule t.ModuleName*

<GetImportList t.IModule>
  == t.IModule t.ImportName*

<GetADTList t.IModule>
  == t.IModule (e.ADT)*

################################################################################
Module MLambda;

<Apply t.Lambda e.Arg>
  == e.Result

<BindLeft t.Lambda e.Left>
  == t.Lambda'
<Apply t.Lambda' e.Arg>
  === <Apply t.Lambda e.Left e.Arg>

<BindLeft-H t.Lambda e.Left>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Arg>
  == <Apply t.Lambda t.Handle e.Left e.Arg>

<BindRight t.Lambda e.Right>
  == t.Lambda'
<Apply t.Lambda' e.Arg>
  === <Apply t.Lambda e.Arg e.Right>

<Composite t.Lambda_1 ... t.Lambda_N>
  == t.CompositeLambda
<Apply t.CompositeLambda e.Arg>
  ===
  <Apply
    t.Lambda_N
    <Apply
      t.Lambda_N-1
      ...
      <Apply t.Lambda_1 e.Arg>
      ...
    >
  >

<MakeHandled t.Lambda>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Arg>
  === t.Handle <Apply t.Lambda e.Arg>

<Parallel t.Lambda_1 ... t.Lambda_N>
  == t.Lambda'
<Apply t.Lambda' e.Argument>
  === <Apply t.Lambda_1 e.Argument> ... <Apply t.Lambda_N e.Argument>

<Parallel-H e.Lambda_1 ... t.Lambda_N>
  == t.Lambda'
<Apply t.Lambda' t.Handle e.Argument>:
<Apply t.Lambda t.Handle e.Argument>
  === t.Handle_1 e.Result_1
...
<Apply t.Lambda_N t.Handle_N-1 e.Result_N-1>
  === t.Handle' e.Result

<Const e.Value>
  == t.Lambda
<Apply t.Lambda e.AnyArg> === e.Value

---------------------------------------------------------------------------

<Map t.Lambda t.Src*>
  == e.Result*
<Apply t.Lambda t.Src> == e.Result

<Reduce t.Lambda t.Accum t.Src*>
  == t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<Reduce-R t.Lambda t.Accum t.Src*>
  == t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<MapReduce t.Lambda t.Accum t.Src*>
  == t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

<MapReduce-R t.Lambda t.Accum t.Src*>
  == t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

<TerminateAccumulator t.FnTerminator t.Accum e.Elems>
  == <Apply t.FnTerminator t.Accum> e.Elems

---------------------------------------------------------------------------

<UnBracket (e.Brackets)> == e.Brackets

<Bracket e.Expr> == (e.Expr)

<UnBracket-H t.Handle (e.Brackets)>
  == t.Handle e.Brackets

<Bracket-H t.Handle e.Expr>
  == t.Handle (e.Expr)

<Nil e.Any> == empty

<Identity e.Value> == e.Value

################################################################################
Module MLinker_Refal5;

<Link t.Context (e.ProgName) (t.ModuleName e.ROutName)*>
  == t.Context Success
  == t.Context Fails

<CreateStartupUnit t.Context>
  == t.Context (t.StartupUnit)

<CreateUnitStorage> == t.UnitStorage

<AddUnit t.UnitStorage t.Unit>
  == t.UnitStorage

<AddRequest t.UnitStorage e.Name>
  == t.UnitStorage

<AddLinked t.UnitStorage e.Name>
  == t.UnitStorage

<GetNextUnit t.UnitStorage>
  == t.UnitStorage t.Unit
  == t.UnitStorage None
  == t.UnitStorage Finish

<DestroyUnitStorage t.UnitStorage> == empty

<NextRequestedName-D t.UnitStorage>
  == e.Name

<NotLinkedList t.UnitStorage>
  == t.UnitStorage (e.NotLinkedUnitName)*

################################################################################
Module MModules;

<LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath
>
  == t.hContext Found
    t.QualifiedName s.FrontEndName e.BaseDirectory
  == t.hContext NotFound

<LookupImportModule
  t.hContext (e.ModulePath) t.QualifiedName
>
  == t.hContext Found s.FrontEndName e.BaseDirectory
  == t.hContext NotFound

<GetBEList t.hContext t.ModuleName>
  == t.hContext Known (s.BE-Name e.PathToFile)*
  == t.hContext UnKnown

<GetFEName t.hContext t.ModuleName>
  == t.hContext Known Library
  == t.hContext Known s.FE-Name e.PathToFile
  == t.hContext UnKnown

<SourceState e.ModName>
  == ModuleNotFound
  == Library
  == NeedRecompile
  == SrcNotUpdated

<LookupLibrary t.hContext e.ModuleName>
  == t.hContext ModuleNotFound
  == t.hContext Library (Sym e.SymName) (Out e.OutName)

<DefaultModulePath> == e.DefaultModulePath

<LookupModule-T t.hContext e.ModuleName>
   == t.hContext
     s.Status
     (Sym e.SymName)
     (Out e.OutName)
     (Src e.SrcName)
     e.ModuleName
s.Status ::= one of
  ModuleNotFound NeedRecompile Library SrcNotUpdated SystemLibrary
  e.*Name may be None

################################################################################
Module MNameMaker;
=============================================================================
Служебный модуль, используемый только в диспетчерах front- и back-end'ов.
==============================================================================

<MakeName t.Context t.QualifiedName s.(BE/FE)Name s.FnRelativeNameMaker>
  == t.Context t.QualifiedName Success e.FilePath
  == t.Context t.QualifiedName Fails

<s.FnRelativeNameMaker t.QualifiedName s.(BE/FE)Name>
  == t.QualifiedName Success e.RelativeName
  == t.QualifiedName Fails

################################################################################
Module MOrder;

Сравнение по типам:
() > Macro > Character > Other
Скобочные термы сравниваются в лексиконографическом порядке.
Макроцифры сравниваются по арифметическим правилам.
Characters сравниваются по ASCII-значениям.
Остальные символы считаются равными.

<Compare-T t.Left t.Right>
  == s.Result t.Left t.Right

s.Result ::= '<' | '=' | '>'

<Compare t.Left t.Right> == '<' | '=' | '>'

<Sort e.Sequence>
  == e.SortedSequence

<Max e.Terms> == t.MaxTerm
e.Terms != empty

<Min e.Terms> == t.MinTerm
e.Terms != empty

################################################################################
Module MOS;

<System e.Command>
  == empty

<Arg s.Number>
  == e.Arg
  == empty

<ArgList>
  == (e.Argument)*

<ProgName> == e.ProgName

<Exit s.RetCode>
  завершение программы

<EnvList>
  == (e.VariableName)*

<Env e.Name>
  == e.Value
  == empty

################################################################################
Module MParser_Common;

<Parse s.FnModuleBody e.FileName>
  == t.ErrorList Success t.IModule
  == t.ErrorList Fails

<GeneralizeInfo
  t.GenericErrorList t.QualifiedName
  t.LocalErrorList {Maybe t.IModule}
>
  == t.ErrorList Success s.ErrorsLevel t.IModule
  == t.ErrorList Fails
s.ErrorsLevel ::= Success | Warnings | Errors

-----------------------------------------------------------------------------
Функции синтаксического анализа делятся на три категории:
(1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
(2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
(3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------

AnyQualifiedName = DotQualifiedName | QuadQualifiedName .
DotQualifiedName =
  IDENTIFIER | DotQualifiedName '.' IDENTIFIER .
QuadQualifiedName =
  IDENTIFIER | QuadQualifiedName '::' IDENTIFIER .

<N***QualifiedName
  t.ErrorList t.Lexer t.NextToken
>
  == e.ScannedQName t.ErrorList t.Lexer t.NextToken

e.ScannedQName ::=
  Success t<MQualifiedName::QName>.QualifiedName | Fails

В случае ошибки на стеке оставляется первый неожиданный терм.
Если имя было частично определено, например так:
  'PackageName::ModuleName::222',
то имя считается распознанным успешно. Информация об ошибке
падает в t.ErrorList, но синтаксически инвариант соблюдётся.

################################################################################
Module MParser_MRefal;

<SrcModule t.ErrorList t.QualifiedName e.FileName>
  == t.ErrorList Success s.Result t.IModule
  == t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

################################################################################
Module MParser_Sym;

<SymModule t.ErrorList t.QualifiedName e.FileName>
	== t.ErrorList Success s.Result t.IModule
	== t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

################################################################################
Module MQualifiedName;

<Create (e.Segment)*>
  == t.QualifiedName
обратна Parse

<Destroy t.QualifiedName> == empty

--------------------------------------------------------------------------

<AddSubName t.QualifiedName e.SubName>
  == t.UpdatedQualifiedName

<AddSuperName t.QualifiedName e.SuperName>
  == t.UpdatedQualifiedName

<Append t.QualifiedAcceptor t.QualifiedForAppend>
  == t.UpdatedQualifierAcceptor

<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
  == t.UpdatedQualifierAcceptor t.QualifierForAppend

--------------------------------------------------------------------------

<Parse t.QualifiedName>
  == (e.SegmentName)*
обратна Create

<Parse-T t.QualifiedName>
  == t.QualifiedName (e.SegmentName)*

--------------------------------------------------------------------------

<ToRelativeFSPath-T t.QualifiedName>
  == t.QualifiedName
    e.Segment '/' e.Segment '/' ... '/' e.Segment

<Equals-T t.QName1 t.QName2>
  == s.Result t.QName1 t.QName2
s.Result ::= True | False

################################################################################
Module MQualifiedSupport;

<UnQualify t.QualifiedName>
  == e.Name
t.QualifiedName должен содержать один сегмент.

<LastSegment t.Qualified>
  == e.Last

################################################################################
Module MResolver;

<Resolve t.Module t.ErrorList t.ResolveTable>
  == t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

################################################################################
Module MResolveTable;

<Create> == t.ResolveTable

<Destroy t.ResolveTable> == empty

<Add t.ResolveTable
  t.InternalQualifier
  s.ScopeClass
  t.ExternalQualifier
> == t.UpdatedResolveTable

<Lookup t.ResolveTable (e.ValidScopes) t.InternalQualifier>
  == t.ResolveTable Found s.ScopeClass t.ExternalQualifier
  == t.ResolveTable NotFound NotFound t.InternalQualifier
e.ValidScopes ::= s.ScopeClass*

################################################################################
Module MSelfDiag;

<Assert-??-T (e.Result) (e.Expected) [e.Message]>
  == e.Result
  fail down

<Assert-?? (e.Result) (e.Expected) [e.Message]>
  == empty
  fail down

################################################################################
Module MStartupSeqGenerator;

<GetFnList t.hContext e.ModuleList>
  == t.hContext e.FnList
  == t.hContext GoNotFound
  == t.hContext MultipleGo e.FnList--GoFunctions
e.FnList = (e.Function)*
e.ModuleList = t.ModuleName*

<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
  == t.StartInfo t.Context

################################################################################
Module MStrings;

<Upper e.Text> == e.UpperText
<Lower e.Text> == e.LowerText

<Length e.Expr> == s.Length
<Length e.Expr> == s.Length e.Expr

<First-Parse s.Count e.Expr> ==
  (e.First) e.Tail

<First s.Count e.Expr> == e.Truncate

<Skip s.Count e.Expr> == e.Truncated

<At s.Index e.Expr> == t.ElemAt
Нумерация начинается с нуля.

<Seq s.NFirst s.NLast>
  == s.NFirst s.NFirst+1 ... s.NLast-1 s.NLast
s.NFirst и s.NLast -- числа,
при чём должно быть s.NFirst <= s.NLast

<Reverse e.Line> == e.eniL

<Repeat s.Num e.Expr>
  == e.Expr e.Expr ... e.Expr
<Length <Repeat s.Num e.Expr>> == s.Num
s.Num >= 0

<Fields (e.Fields) e.Line>
  == (e.SubField)*
e.Fields = s<num>*

<Decart ( t.ElemA* ) ( t.ElemB* )>
  == (t.ElemA t.ElemB)*

Пример:
<Decart (1 2 3) (A B C D)> ==
  (1 A) (1 B) (1 C) (1 D)
  (2 A) (2 B) (2 C) (2 D)
  (3 A) (3 B) (3 C) (3 D)

################################################################################
Module MSwapSupport;
=============================================================================
Модуль предоставляет функции для наиболее распространённых функций с
динамическими ящиками: чтение, запись, добавление терма в начало/конец,
чтение терма с начала/конца, операции с копилкой.
==============================================================================

<Read s.FnSwap>
	== e.Content
Содержимое ящика не изменяется.

<Write s.FnSwap e.NewContent>
	== empty
Ящик получает значение e.NewContent

<PushFront s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap t.Info <s.FnSwap>>

<PushBack s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap <s.FnSwap> t.Info>

<PopFront s.FnSwap>
	== Success t.Value
	== Fails
Если <s.FnSwap> :: t.Value e.Content То
	<s.FnSwap e.Content>
	Success t.Value
Иначе
	Fails

<PopBack s.FnSwap>
	== Success t.Value
	== Fails
См. описание функции PopFront.

<Br s.FnSwap e.Key '=' e.Value> == empty

<Bury s.FnSwap (e.Key) e.Value> == empty

<Dg s.FnSwap e.Key> == e.Value

<Cp s.FnSwap e.Key> == e.Value

<Rp s.FnSwap e.Key '=' e.Value> == empty

<Replace s.FnSwap (e.Key) e.Value> == empty

<Dgall s.FnSwap> == (e.Key '=' e.Value)*

<DigAll s.FnSwap> == ((e.Key) e.Value)*

<Cpall s.FnSwap> == (e.Key '=' e.Value)*

<CopyAll s.FnSwap> == ((e.Key) e.Value)*

################################################################################
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста.

<LoadInfo_New t.Context t.ModuleName>
  == t.Context Success t.IModule
  == t.Context Fails
t.ModuleName ::= t.QualifiedName

<SymReduce-T t.hIModule>
  == t.hIModule t.hISymModule

 TODO: Доделать 

<LoadInfo t.Context e.ModuleName>
  == t.UpdatedContext
    ( Module e.ModuleName )
    ( Functions ((e.Qualifier)(e.FnName))* )
    ( Imports (e.ModName)* )
  == t.Context SymInfoNotFound

<SymTableToSymInfo-T t.IModule>
  == t.IModule
    ( CurModule e.ModName )
    ( Functions (e.FnName)* )
    ( Imports (e.ModName)* )

<LookupSym t.Context e.ModuleName>
  == (e.ModuleName) t.Context Known s.Status e.SymName
  == (e.ModuleName) t.Context NotKnown s.Status e.SymName

################################################################################
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
	== s.Char t.SymStream //Если символ из набора.
	== t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
	== t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
	== t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

################################################################################
Module MSymTable;

<Create> == t.SymTable

<AddName t.SymTable e.Name>
  == t.SymTable

<UpdateAttrib t.SymTable (e.Name) s.Attrib e.Value>
  == t.SymTable

<RemoveAttrib t.SymTable e.Name s.Attrib>
  == t.SymTable Found e.Value
  == t.SymTable NoAttrib
  == t.SymTable NoName

<GetAttrib t.SymTable e.Name s.Attrib>
  == t.SymTable Found e.Value
  == t.SymTable NoAttrib
  == t.SymTable NoName

<ExtractNames t.SymTable>
  == t.SymTable (e.Name)*

<UpdateAttribSet
  t.SymTable (e.Name)
  (s.Attrib e.Value)*
> == t.SymTable

<FindByKind t.SymTable s.Kind>
  == t.SymTable (e.Name)*

################################################################################
Module MXXIO;

<Load e.FileName>
  == Success e.LoadedExpr
  == Fails

<Save (e.FileName) e.Expr>
  == Success
  == Fails

