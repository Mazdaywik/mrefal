================================================================
Module MBackEnd_Refal5;

<Generate-T t.IModule e.OutName>
	== t.IModule

================================================================
Module MBE-Mgr;

<Register s.Name s.Generator s.Linker (e.Folder) (e.Ext)>
	== empty

<Generate t.Context t.IModule t.QualifiedName>
	== t.Context t.IModule Success
	== t.Context t.IModule Fails

<Link t.Context (e.OutName) e.OrderedFiles>
	== t.Context Success
	== t.Context Fails
e.OrderedFiles ::= (t.QualifiedName e.BaseDir)

<GetList> == s.BackEndName*

<X_GetPath-T t.Context t.QualifiedName s.BEName>
	== t.Context t.QualifiedName Success e.Path
	== t.Context t.QualifiedName Fails

<GetPath-T s.BEName t.QualifiedName e.BaseFolder>
	== t.QualifiedName Success e.OutPath
	== t.QualifiedName Fails

=============================================================================
Модуль реализует хранилище данных для диспетчеров входных и генерирующих
частей. Работает по принципу атрибутной таблицы символов. Таблица индексируются
двумя символами: именем диспетчера и именем атрибута.
==============================================================================
================================================================
Module MBEFE-Holder;

<UpdateEntry
	s.FnSwap
	s.MgrName
	(s.Option e.Value)*
> == empty

<GetInfo s.FnSwap s.MgrName s.OptionName>
	== Success e.Value
	== Fails s.Error
s.Error ::= InvalidMgr | InvalidOption

<GetMgrList s.FnSwap>
	== e<name>.MgrNames

================================================================
Module MContext;

<Create> == t.Context

<Destroy t.Context> == empty

<UpdateInfo t.Context t.QualifiedName e.NewOptionList>
	== t.UpdatedContext Success
	== t.Context Fails

<ExtractOption t.Context t.QualifiedName s.Option>
	== t.Context Found e.Option
	== t.Context OptionNotFound
	== t.Context ModuleNotFound

<ExtractModulesList t.Context>
	== t.Context t.QualifiedName*

<LastModule t.Context t.QualifiedName>
	== t.UpdatedContext Success
	== t.Context Fails

<GetProgName t.Context>
	== t.Context t.QualifiedName

================================================================
Module MCreateDirIfNeed;

<Create e.DirName> == e.DirName

<InfoDir> == 'Info'

================================================================
Module MError;

<EmptyList t.ErrorList>
	== t.ErrorList Empty
	== t.ErrorList NotEmpty

<ContentLevel t.ErrorList>
	== t.ErrorList Empty
	== t.ErrorList Warnings
	== t.ErrorList Errors

<MergeLists t.List1 t.List2>
	== t.MergedList

<AddUnexpected t.ErrorList t.UnexpToken e.ExpectedText>
	== t.UpdatedErrorList

<AddNamesMismatch t.ErrorList t.TailPos (e.InHead) (e.InTail)>
	== t.ErrorList

<AddMismatchInternalAndExternalNames
	t.ErrorList t.SrcPos t.InternalName t.ExternalName
>
	== t.ErrorList

================================================================
Module MExeTyper;

<Create s.Limit e.OutputName> == t.ExeTyper

<Destroy t.ExeTyper> == empty

<TypeChar t.ExeTyper s.Char> = t.ExeTyper

<TypeQuoted t.ExeTyper s.Quote e.Text> == t.ExeTyper

<TypeRenamed t.ExeTyper e.RenamedName> == t.ExeTyper

<TypeComment t.ExeTyper e.Comment> == t.ExeTyper

================================================================
Module MFE-Mgr;

<Register s.FEName s.FnParser (e.Ext)>
	== empty

<GetPath-T s.FEName t.QualifiedName e.BaseFolder>
	== Success t.QualifiedName e.FilePath
	== Fails t.QualifiedName

<Load s.FEName t.ErrorList t.QualifiedName e.BaseDir>
	== t.ErrorList Success s.Result t.IModule
	== t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

<GetList>
	== s.FrontEndName*

<X_GetPath-T t.Context t.QualifiedName s.FEName>
	== t.Context t.QualifiedName Success e.FileName
	== t.Context t.QualifiedName Fails

================================================================
Module MFileSystem;

<ParseFileName e.FileName>
	== (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
	== ('c;\\Directory') 'Document' ('doc')

================================================================
Module MIModule;

<Create
	t.QualifiedName
	(s.Attrib e.Value)*
>
	== t.IModule

<Destroy t.IModule> == empty

---------------------------------------------------------------------------

<GetModuleName t.IModule>
	== t.IModule e.Name

---------------------------------------------------------------------------

<UpdateModule t.IModule e.Attribs>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidAttrib | InvariantError

<UpdateFunction
	t.IModule
	(e.FunctionName)
	(s.Attrib e.Value)*
>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidKind | InvalidAttrib | InvariantError

<UpdateImport t.IModule (e.Import) e.Attribs>
	== t.IModule s.Status

<UpdateADT t.IModule (e.Name) e.Attribs>
	== t.IModule s.Status

<UpdateEntity
	t.IModule s.Kind (e.EntityName) e.Attribs
>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidKind | InvalidAttrib | InvariantError

---------------------------------------------------------------------------

<GetModuleAttribute t.IModule s.Attribute>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvariantError

<GetFucntionAttribute t.IModule s.Attrib e.FnName>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

<GetImportAttribute t.IModule s.Attrib e.Import>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

<GetADTAttributes t.IModule s.Attrib e.Name>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

<GetEntityAttribute
	t.IModule s.Kind s.Attrib e.Name
>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

---------------------------------------------------------------------------

<GetFunctionList t.IModule>
	== t.IModule (e.FnName)*

<GetImportList t.IModule>
	== t.IModule (e.ImportName)*

<GetADTList t.IModule>
	== t.IModule (e.ADT)*

================================================================
Module MLambda;

<Apply t.Lambda e.Arg>
	== e.Result

<BindLeft t.Lambda e.Left>
	== t.Lambda'
<Apply t.Lambda' e.Arg> === <Apply t.Lambda e.Left e.Arg>

<BindRight t.Lambda e.Right>
	== t.Lambda'
<Apply t.Lambda' e.Arg> === <Apply t.Lambda e.Arg e.Right>

<Map t.Lambda t.Src*>
	== e.Result*
<Apply t.Lambda t.Src> == e.Result

<Reduce t.Lambda t.Accum t.Src*>
	== t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<Reduce-R t.Lambda t.Accum t.Src*>
	== t.Accum'
<Apply t.Lambda t.Accum t.Src> == t.Accum'

<MapReduce t.Lambda t.Accum t.Src*>
	== t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

<MapReduce-R t.Lambda t.Accum t.Src*>
	== t.Accum' e.Result*
<Apply t.Lambda t.Accum t.Src> == t.Accum' e.Result

================================================================
Module MLinker_Refal5;

<Link t.Context (e.ProgName) e.ROutName>
	== t.Context Success
	== t.Context Fails

<CreateStartupUnit t.Context>
	== t.Context (t.StartupUnit)

<CreateUnitStorage> == t.UnitStorage

<AddUnit t.UnitStorage t.Unit>
	== t.UnitStorage

<AddRequest t.UnitStorage e.Name>
	== t.UnitStorage

<AddLinked t.UnitStorage e.Name>
	== t.UnitStorage

<GetNextUnit t.UnitStorage>
	== t.UnitStorage t.Unit
	== t.UnitStorage None
	== t.UnitStorage Finish

<DestroyUnitStorage t.UnitStorage> == empty

<NextRequestedName-D t.UnitStorage>
	== e.Name

<NotLinkedList t.UnitStorage>
	== t.UnitStorage (e.NotLinkedUnitName)*

================================================================
Module MLocation;

<LookupModule-T t.Context (e.Directory) e.ModuleName>
	== t.Context
		s.Known s.Status
		(Sym e.SymFileName)
		(Out e.OutFileName)
		(Src e.SrcFileName)
		(e.Directory) e.ModuleName
s.Known ::= Known | NotKnown
s.Status ::=
	if Known
		Recompiled | Updated | Library | InCompiling
	if NotKnown
		ModuleNotFound | Library | SystemLibrary | NeedRecompile | SrcNotUpdated

=============================================================================
Служебный модуль, используемый только в диспетчерах front- и back-end'ов.
==============================================================================
================================================================
Module MNameMaker;

<MakeName t.Context t.QualifiedName s.(BE/FE)Name s.FnRelativeNameMaker>
	== t.Context t.QualifiedName Success e.FilePath
	== t.Context t.QualifiedName Fails

<s.FnRelativeNameMaker t.QualifiedName s.(BE/FE)Name>
	== t.QualifiedName Success e.RelativeName
	== t.QualifiedName Fails

================================================================
Module MParser;

<SrcModule_New t.ErrorList t.QualifiedName e.FileName>
	== t.ErrorList Success s.Result t.IModule
	== t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

<SymModule_New t.ErrorList t.QualifiedName e.FileName>
	== t.ErrorList Success s.Result t.IModule
	== t.ErrorList Fails
s.Result ::= Success | Warnings | Errors

================================================================
Module MQualifiedName;

<Destroy t.QualifiedName> == empty

<Create (e.Segment)*>
	== t.QualifiedName
обратна Parse

<AddSubName t.QualifiedName e.SubName>
	== t.UpdatedQualifiedName

<AddSuperName t.QualifiedName e.SuperName>
	== t.UpdatedQualifiedName

<Parse t.QualifiedName>
	== (e.SegmentName)*
обратна Create

<Parse-T t.QualifiedName>
	== t.QualifiedName (e.SegmentName)*

<ToRelativeFSPath-T t.QualifiedName>
	== t.QualifiedName
		e.Segment '/' e.Segment '/' ... '/' e.Segment

<Append t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor

<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor t.QualifierForAppend

================================================================
Module MQualifiedSupport;

<UnQualify t.QualifiedName>
	== e.Name
t.QualifiedName должен содержать один сегмент.

================================================================
Module MResolver;

<Resolve t.Module t.ErrorList t.ResolveTable>
	== t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

================================================================
Module MResolveTable;

<Create> == t.ResolveTable

<Destroy t.ResolveTable> == empty

<Add t.ResolveTable
	t.InternalQualifier
	s.ScopeClass
	t.ExternalQualifier
> == t.UpdatedResolveTable

<Lookup t.ResolveTable (e.ValidScopes) t.InternalQualifier>
	== t.ResolveTable Found s.ScopeClass t.ExternalQualifier
	== t.ResolveTable NotFound NotFound t.InternalQualifier
e.ValidScopes ::= s.ScopeClass*

================================================================
Module MStartupSeqGenerator;

<Generate t.Context>
	== t.Context e.FnList
	== t.Context GoNotFound
	== t.Context MultipleGo e.FnList--GoFunctions
e.FnList = (e.Function)*

<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
	== t.StartInfo t.Context

================================================================
Module MStrings;

<Seq s.NFirst s.NLast>
	== s.NFirst s.NFirst+1 ... s.NLast-1 s.NLast
s.NFirst и s.NLast -- числа,
при чём должно быть s.NFirst <= s.NLast

<Reverse e.Line> == e.eniL

================================================================
Module MSwapSupport;
=============================================================================
Модуль предоставляет функции для наиболее распространённых функций с
динамическими ящиками: чтение, запись, добавление терма в начало/конец,
чтение терма с начала/конца, операции с копилкой.
==============================================================================

<Read s.FnSwap>
	== e.Content
Содержимое ящика не изменяется.

<Write s.FnSwap e.NewContent>
	== empty
Ящик получает значение e.NewContent

<PushFront s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap t.Info <s.FnSwap>>

<PushBack s.FnSwap t.Info>
	== empty
Эквивалентно <s.FnSwap <s.FnSwap> t.Info>

<PopFront s.FnSwap>
	== Success t.Value
	== Fails
Если <s.FnSwap> :: t.Value e.Content То
	<s.FnSwap e.Content>
	Success t.Value
Иначе
	Fails

<PopBack s.FnSwap>
	== Success t.Value
	== Fails
См. описание функции PopFront.

<Br s.FnSwap e.Key '=' e.Value> == empty

<Bury s.FnSwap (e.Key) e.Value> == empty

<Dg s.FnSwap e.Key> == e.Value

<Cp s.FnSwap e.Key> == e.Value

<Rp s.FnSwap e.Key '=' e.Value> == empty

<Replace s.FnSwap (e.Key) e.Value> == empty

<Dgall s.FnSwap> == (e.Key '=' e.Value)*

<DigAll s.FnSwap> == ((e.Key) e.Value)*

<Cpall s.FnSwap> == (e.Key '=' e.Value)*

<CopyAll s.FnSwap> == ((e.Key) e.Value)*

================================================================
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста. Поиск стартовых функций должен осуществлять
линковщик.

<LoadInfo_New t.Context t.ModuleName>
	== t.Context Success t.IModule
	== t.Context Fails
t.ModuleName ::= t.QualifiedName

<LoadInfo t.Context e.ModuleName>
	== t.UpdatedContext
		( Module e.ModuleName )
		( Functions ((e.Qualifier)(e.FnName))* )
		( Imports (e.ModName)* )
	== t.C ontext SymInfoNotFound

<SymTableToSymInfo-T t.IModule>
	== t.IModule
		( CurModule e.ModName )
		( Functions (e.FnName)* )
		( Imports (e.ModName)* )

<LookupSym t.Context e.ModuleName>
	== (e.ModuleName) t.Context Known s.Status e.SymName
	== (e.ModuleName) t.Context NotKnown s.Status e.SymName

================================================================
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
	== s.Char t.SymStream //Если символ из набора.
	== t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
	== t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
	== t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

================================================================
Module MSymTable;

<Create> == t.SymTable

<AddName t.SymTable e.Name>
	== t.SymTable

<UpdateAttrib t.SymTable (e.Name) s.Attrib e.Value>
	== t.SymTable

<RemoveAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<GetAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<RemoveName t.SymTable e.Name>
	== t.SymTable

<ExtractNames t.SymTable>
	== t.SymTable (e.Name)*

<Rename t.SymTable (e.OldName) e.NewName>
	== t.SymTable Success
	== t.SymTable Fails

<UpdateAttribSet
	t.SymTable (e.Name)
	(s.Attrib e.Value)*
> == t.SymTable

<FindByKind t.SymTable s.Kind>
	== t.SymTable (e.Name)*

<AddNewName t.SymTable (e.Name) (s.Attrib e.Value)*>
	== t.SymTable Success
	== t.SymTable Fails

Если имя (e.Name) отсутствует в таблице, то оно добавляется с указанными
атрибутами, в противном случае таблица не изменяется.
Фукция возвращает Success при успешном добавлении имени, Fails в случае,
если имя уже в таблице было.

