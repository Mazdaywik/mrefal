================================================================
Module MBE-Mgr;

<Register s.Name s.Generator (e.Folder) (e.Ext)>
	== empty

<Generate t.Context t.IModule t.QualifiedName>
	== t.Context t.IModule Success
	== t.Context t.IModule Fails

<GetList> == s.BackEndName*

<GetOutPath-T s.BEName t.QualifiedName e.BaseFolder>
	== Success t.QualifiedName e.OutPath
	== Fails t.QualifiedName

================================================================
Module MContext;

<Create> == t.Context

<Destroy t.Context> == empty

<UpdateInfo t.Context t.QualifiedName e.NewOptionList>
	== t.UpdatedContext Success
	== t.Context Fails

<ExtractOption t.Context t.QualifiedName s.Option>
	== t.Context Found e.Option
	== t.Context OptionNotFound
	== t.Context ModuleNotFound

<ExtractModulesList t.Context>
	== t.Context t.QualifiedName*

<LastModule t.Context t.QualifiedName>
	== t.UpdatedContext Success
	== t.Context Fails

<GetProgName t.Context>
	== t.Context t.QualifiedName

================================================================
Module MCreateDirIfNeed;

<Create e.DirName> == e.DirName

<InfoDir> == 'Info'

================================================================
Module MError;

<EmptyList t.ErrorList>
	== t.ErrorList Empty
	== t.ErrorList NotEmpty

<AddUnexpected t.ErrorList t.UnexpToken e.ExpectedText>
	== t.UpdatedErrorList

<AddNamesMismatch t.ErrorList t.TailPos (e.InHead) (e.InTail)>
	== t.ErrorList

================================================================
Module MExeTyper;

<Create s.Limit e.OutputName> == t.ExeTyper

<Destroy t.ExeTyper> == empty

<Flush t.ExeTyper> == t.ExeTyper

<TypeChar t.ExeTyper s.Char> = t.ExeTyper

<TypeQuoted t.ExeTyper s.Quote e.Text> == t.ExeTyper

<TypeRenamed t.ExeTyper e.RenamedName> == t.ExeTyper

<TypeComment t.ExeTyper e.Comment> == t.ExeTyper

================================================================
Module MFE-Mgr;

<Register s.FEName s.FnParser (e.Ext)>
	== empty

<Load s.FEName t.QualifiedName>
	== Success t.IModule
	== Fails

<GetList>
	== s.FrontEndName*

================================================================
Module MFileSystem;

<ParseFileName e.FileName>
	== (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
	== ('c;\\Directory') 'Document' ('doc')

================================================================
Module MFrontEnd;

<LoadModule e.SourceName>
	== t.Module s.Status t.ErrorList
s.Status ::= Success | Warnings | Errors | Fatal

<SymInfo-Old t.Module>
	== t.Module
	( Module (e.Directory) e.ModuleName )
	( Functions (e.FnName)* )
	( Imports ((e.ImportDirectory) e.ImportName)* )

================================================================
Module MIModule;

<Create> == t.IModule

<Destroy t.IModule> == empty

<GetModuleName t.IModule>
	== t.IModule e.Name
	== t.IModule Unknown

<SetModuleName t.IModule e.Name>
	== t.UpdatedIModule Success
	== t.IModule Fails

<UpdateFunction
	t.IModule
	(e.FunctionName)
	(s.Attrib e.Value)*
>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidKind | InvalidAttrib | InvariantError

<UpdateEntity
	t.IModule s.Kind (e.EntityName) e.Attribs
>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidKind | InvalidAttrib | InvariantError

<UpdateModule t.IModule e.Attribs>
	== t.IModule s.Status

s.Status ::=
	Success | InvalidAttrib | InvariantError

<GetFucntionAttribute t.IModule s.Attrib e.FnName>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

<GetEntityAttribute
	t.IModule s.Kind s.Attrib e.Name
>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvalidKind

<GetModuleAttribute t.IModule s.Attribute>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

s.ErrorStatus ::= NoName | NoAttrib | InvalidAttrib | InvariantError

<UpdateImport t.IModule (e.Import) e.Attribs>
	== t.IModule s.Status

<GetImportAttribute t.IModule s.Attrib e.Import>
	== t.IModule Found e.Value
	== t.IModule s.ErrorStatus

<UpdateADT t.IModule (e.Name) e.Attribs>
	== то же самое

<GetADTAttributes t.IModule s.Attrib e.Name>
	== то же самое

<GetFunctionList t.IModule>
	== t.IModule (e.FnName)*

<GetImportList t.IModule>
	== t.IModule (e.ImportName)*

<GetADTList t.IModule>
	== t.IModule (e.ADT)

================================================================
Module MLinker;

<CreateStartupUnit t.Context>
	== t.Context (t.StartupUnit)

<CreateUnitStorage> == t.UnitStorage

<AddUnit t.UnitStorage t.Unit>
	== t.UnitStorage

<AddRequest t.UnitStorage e.Name>
	== t.UnitStorage

<AddLinked t.UnitStorage e.Name>
	== t.UnitStorage

<GetNextUnit t.UnitStorage>
	== t.UnitStorage t.Unit
	== t.UnitStorage None
	== t.UnitStorage Finish

<DestroyUnitStorage t.UnitStorage> == empty

<NextRequestedName-D t.UnitStorage>
	== e.Name

<NotLinkedList t.UnitStorage>
	== t.UnitStorage (e.NotLinkedUnitName)*

================================================================
Module MLocation;

<LookupModule-T t.Context (e.Directory) e.ModuleName>
	== t.Context
		s.Known s.Status
		(Sym e.SymFileName)
		(Out e.OutFileName)
		(Src e.SrcFileName)
		(e.Directory) e.ModuleName
s.Known ::= Known | NotKnown
s.Status ::=
	if Known
		Recompiled | Updated | Library | InCompiling
	if NotKnown
		ModuleNotFound | Library | SystemLibrary | NeedRecompile | SrcNotUpdated

================================================================
Module MParser;

<SrcModule e.SrcFileName>
	== t.Module s.ErrorResult t.ErrorList
s.ErrorResult ::= Success | Warnings | Errors | Fatal

<SymModule t.Context e.SymFileName>
	== t.IModule s.ErrorResult t.ErrorList
	s.ErrorResult ::= Success | Warnings | Errors | Fatal

================================================================
Module MQualifiedName;

<Destroy t.QualifiedName> == empty

<Create (e.Segment)*>
	== t.QualifiedName
обратна Parse

<AddSubName t.QualifiedName e.SubName>
	== t.UpdatedQualifiedName

<AddSuperName t.QualifiedName e.SuperName>
	== t.UpdatedQualifiedName

<Parse t.QualifiedName>
	== (e.SegmentName)*
обратна Create

<Parse-T t.QualifiedName>
	== t.QualifiedName (e.SegmentName)*

<ToRelativeFSPath-T t.QualifiedName>
	== t.QualifiedName
		e.Segment '/' e.Segment '/' ... '/' e.Segment

<Append t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor

<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor t.QualifierForAppend

================================================================
Module MQualifiedSupport;

<DirNameToQualifiedName (e.Directory) e.Name>
	== t.QualifiedName

<QualifiedNameToDirName-T t.QualifiedName>
	== t.QualifiedName (e.Directory) e.Name

<UnQualify t.QualifiedName>
	== e.Name
t.QualifiedName должен содержать один сегмент.

================================================================
Module MResolver;

<Resolve t.Module t.ErrorList t.ResolveTable>
	== t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

================================================================
Module MResolveTable;

<Create> == t.ResolveTable

<Destroy t.ResolveTable> == empty

<Add t.ResolveTable
	t.InternalQualifier
	s.ScopeClass
	t.ExternalQualifier
> == t.UpdatedResolveTable

<Lookup t.ResolveTable (e.ValidScopes) t.InternalQualifier>
	== t.ResolveTable Found s.ScopeClass t.ExternalQualifier
	== t.ResolveTable NotFound NotFound t.InternalQualifier
e.ValidScopes ::= s.ScopeClass*

================================================================
Module MStartupSeqGenerator;

<Generate t.Context>
	== t.Context e.FnList
	== t.Context GoNotFound
	== t.Context MultipleGo e.FnList--GoFunctions
e.FnList = (e.Function)*

<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
	== t.StartInfo t.Context

================================================================
Module MStrings;

<Seq s.NFirst s.NLast>
	== s.NFirst s.NFirst+1 ... s.NLast-1 s.NLast
s.NFirst и s.NLast -- числа,
при чём должно быть s.NFirst <= s.NLast

<Reverse e.Line> == e.eniL

================================================================
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста. Поиск стартовых функций должен осуществлять
линковщик.

<LoadInfo t.Context e.ModuleName>
	== t.UpdatedContext
		( Module e.ModuleName )
		( Functions ((e.Qualifier)(e.FnName))* )
		( Imports (e.ModName)* )
	== t.Context SymInfoNotFound

<SymTableToSymInfo-T t.IModule>
	== t.IModule
		( CurModule e.ModName )
		( Functions (e.FnName)* )
		( Imports (e.ModName)* )

<LookupSym t.Context e.ModuleName>
	== (e.ModuleName) t.Context Known s.Status e.SymName
	== (e.ModuleName) t.Context NotKnown s.Status e.SymName

================================================================
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
	== s.Char t.SymStream //Если символ из набора.
	== t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
	== t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
	== t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

================================================================
Module MSymTable;

<Create> == t.SymTable

<AddName t.SymTable e.Name>
	== t.SymTable

<UpdateAttrib t.SymTable (e.Name) s.Attrib e.Value>
	== t.SymTable

<RemoveAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<GetAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<RemoveName t.SymTable e.Name>
	== t.SymTable

<ExtractNames t.SymTable>
	== t.SymTable (e.Name)*

<Rename t.SymTable (e.OldName) e.NewName>
	== t.SymTable Success
	== t.SymTable Fails

<UpdateAttribSet
	t.SymTable (e.Name)
	(s.Attrib e.Value)*
> == t.SymTable

<FindByKind t.SymTable s.Kind>
	== t.SymTable (e.Name)*

<AddNewName t.SymTable (e.Name) (s.Attrib e.Value)*>
	== t.SymTable Success
	== t.SymTable Fails

Если имя (e.Name) отсутствует в таблице, то оно добавляется с указанными
атрибутами, в противном случае таблица не изменяется.
Фукция возвращает Success при успешном добавлении имени, Fails в случае,
если имя уже в таблице было.

