===============================
Module MBackEnd;

<Generate t.Module e.OutName>
	== empty

===============================
Module MCreateDirIfNeed;

<Create e.DirName> == e.DirName

<InfoDir> == 'Info'

===============================
Module MExeTyper;

<Create s.Limit e.OutputName> == t.ExeTyper

<Destroy t.ExeTyper> == empty

<Flush t.ExeTyper> == t.ExeTyper

<TypeChar t.ExeTyper s.Char> = t.ExeTyper

<TypeQuoted t.ExeTyper s.Quote e.Text> == t.ExeTyper

<TypeRenamed t.ExeTyper e.RenamedName> == t.ExeTyper

<TypeComment t.ExeTyper e.Comment> == t.ExeTyper

===============================
Module MFileSystem;

<ParseFileName e.FileName>
	== (e.Directory) e.FileNameNoExt (e.Ext)
Пример:
<ParseFileName 'c:\\Directory\\Document.doc'>
	== ('c;\\Directory') 'Document' ('doc')

===============================
Module MFrontEnd;

<LoadModule e.SourceName>
	== t.Module s.Status t.ErrorList
s.Status ::= Success | Warnings | Errors | Fatal

<SymInfo t.Module>
	== t.Module t.SymInfo

<SymInfo-Old t.Module>
	== t.Module
	( Module (e.Directory) e.ModuleName )
	( Functions (e.FnName)* )
	( Imports ((e.ImportDirectory) e.ImportName)* )

===============================
Module MLinker;

<CreateStartupUnit t.Context>
	== t.Context (t.StartupUnit)

<CreateUnitStorage> == t.UnitStorage

<AddUnit t.UnitStorage t.Unit>
	== t.UnitStorage

<AddRequest t.UnitStorage e.Name>
	== t.UnitStorage

<AddLinked t.UnitStorage e.Name>
	== t.UnitStorage

<GetNextUnit t.UnitStorage>
	== t.UnitStorage t.Unit
	== t.UnitStorage None
	== t.UnitStorage Finish

<DestroyUnitStorage t.UnitStorage> == empty

<NextRequestedName-D t.UnitStorage>
	== e.Name

===============================
Module MLocation;

<LookupModule-T t.Context (e.Directory) e.ModuleName>
	== t.Context
		s.Known s.Status
		(Sym e.SymFileName)
		(Out e.OutFileName)
		(Src e.SrcFileName)
		(e.Directory) e.ModuleName
s.Known ::= Known | NotKnown
s.Status ::=
	if Known
		Recompiled | Updated | Library | InCompiling
	if NotKnown
		ModuleNotFound | Library | SystemLibrary | NeedRecompile | SrcNotUpdated

===============================
Module MParser;

<SrcModule e.SrcFileName>
	== t.Module s.ErrorResult t.ErrorList
s.ErrorResult ::= Success | Warnings | Errors | Fatal

<SymModule t.Context e.SymFileName>
	== t.SymTable s.ErrorResult t.ErrorList
	s.ErrorResult ::= Success | Warnings | Errors | Fatal

===============================
Module MQualifiedName;

<Create> == t.EmptyQualifierName
<Create e.Name>
	== t.QalifierName // только с одним сегментом

<Destroy t.QualifiedName> == empty

<CreateFromSegments (e.Segment)*>
	== t.QualifiedName

<AddSubName t.QualifiedName e.SubName>
	== t.UpdatedQualifiedName

<AddSuperName t.QualifiedName e.SuperName>
	== t.UpdatedQualifiedName

<Parse t.QualifiedName>
	== (e.SegmentName)*

<Parse-T t.QualifiedName>
	== t.QualifiedName (e.SegmentName)*

<ToRelativeFSPath-T t.QualifiedName>
	== t.QualifiedName
		e.Segment '/' e.Segment '/' ... '/' e.Segment

<Append t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor

<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
	== t.UpdatedQualifierAcceptor t.QualifierForAppend

===============================
Module MQualifiedSupport;

<DirNameToQualifiedName (e.Directory) e.Name>
	== t.QualifiedName

<QualifiedNameToDirName-T t.QualifiedName>
	== t.QualifiedName (e.Directory) e.Name

<UnQualify t.QualifiedName>
	== e.Name
t.QualifiedName должен содержать один сегмент.

===============================
Module MResolver;

<Resolve t.Module t.ErrorList e.QualifiedList>
	== t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

e.QualifiedList ::= ( t.ModuleLocation (e.EntryFnName)* )*
t.ModuleLocation ::= ((e.Directory) e.ModuleName)

===============================
Module MResolveTable;

<Create> == t.ResolveTable

<Add t.ResolveTable
	t.InternalQualifier
	s.ScopeClass
	t.ExternalQualifier
> == t.UpdatedResolveTable

<Lookup t.ResolveTable t.InternalQualifier>
	== t.ResolveTable Found s.ScopeClass t.ExternalQualifier
	== t.ResolveTable NotFound NotFound t.InternalQualifier

===============================
Module MStartupSeqGenerator;

<Generate t.Context>
	== t.Context e.FnList
	== t.Context GoNotFound
	== t.Context MultipleGo e.FnList--GoFunctions
e.FnList = (e.Function)*

<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
	== t.StartInfo t.Context

===============================
Module MStrings;

<Seq s.NFirst s.NLast>
	== s.NFirst s.NFirst+1 ... s.NLast-1 s.NLast
s.NFirst и s.NLast -- числа,
при чём должно быть s.NFirst <= s.NLast

<Reverse e.Line> == e.eniL

===============================
Module MSymInfo;

<Create>
	== t.SymInfo
<Create e.QualifiedModuleName>
	== t.SymInfo

<Destroy t.SymInfo>
	== empty

<LoadForModule t.Context e.QualifiedModuleName>
	== t.SymInfo t.Context

<LoadFromFile e.FileName>
	== t.SymInfo

<SaveForModule t.SymInfo t.Context>
	== t.Context

<SaveForModule-T t.SymInfo t.Context>
	== t.SymInfo t.Context

<SaveToFile t.SymInfo>
	== empty

<SaveToFile-T t.SymInfo>
	== t.SymInfo

<ToOldSymInfo t.SymInfo>
	= e.OldSymInfo

<ToOldSymInfo-T t.SymInfo>
	= t.SymInfo e.OldSymInfo

<CreateFromSymTable t.SymTable>
	== t.SymTable t.SymInfo

===============================
Module MSymModule;

Модуль инкапсулирует работу с sym-файлами: загрузку данных из них, сохранение
на диск, кеширование внутри контекста. Поиск стартовых функций должен осуществлять
линковщик.

<LoadInfo t.Context (e.Directory) e.ModuleName>
	== t.UpdatedContext
		( Module (e.Directory) e.ModuleName )
		( Functions (e.FnName)* )
		( Imports ((e.ImportDirectory) e.ImportName)* )
	== t.Context SymInfoNotFound

<LoadInfo1 t.Context e.ModuleName>
	== t.UpdatedContext
		( Functions ((e.Qualifier)(e.FnName))* )
		( Imports (e.ModName)* )
	== t.Context SymInfoNotFound

<SaveInfo-T1 t.Context t.SymTable>
	== t.UpdatedContext t.SymTable Success
	== t.Context t.SymTable Fail

<SymTableToSymInfo-T t.SymTable>
	== t.SymTable
		( CurModule e.ModName )
		( Functions (e.FnName)* )
		( Imports (e.ModName)* )

<LookupSym t.Context e.ModuleName>
	== (e.ModuleName) t.Context Known s.Status e.SymName
	== (e.ModuleName) t.Context NotKnown s.Status e.SymName

===============================
Module MSymStream;

** Описание абстрактного типа данных "Символьный поток" SymStream **
Определены операции:

<Create e.FileName> == t.SymStream
создаёт новый поток;

<NextChar t.SymStream> == t.SymStream s.Char
возвращает следующий символ из потока, CrLf в случае перехода на новую
строку, EOF в случае конца файла;

<Destroy t.SymStream> == empty
закрывает поток;

<UnGetChar t.SymStream s.Char> == t.SymStream
возвращает символ обратно в поток, при необходимости корректируется номер
строки;

<ExtractFromSet (e.Set) t.SymStream>
	== s.Char t.SymStream //Если символ из набора.
	== t.SymStream //Если символ не из набора.
извлекает из потока символ из заданного набора; во втором случае символ
возвращается в поток;

<ExtractsFromSet (e.Set) t.SymStream>
	== t.SymStream e.Chars
аналогично ExtractFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой).

<ExtractsFromSet-N (e.Set) t.SymStream s.NChars>
	== t.SymStream e.Chars
аналогично ExtractsFromSet, но возвращает последовательность символов из
заданного набора (которая может быть и пустой), причём её длина не может быть
более s.NChars символов.

===============================
Module MSymTable-Module;

<SymTable-From-Module t.Module>
	== t.SymTable

<Module-From-SymTable t.SymTable>
	== t.Module

===============================
Module MSymTable;

<Create> == t.SymTable

<AddName t.SymTable e.Name>
	== t.SymTable

<UpdateAttrib t.SymTable (e.Name) s.Attrib e.Value>
	== t.SymTable

<RemoveAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<GetAttrib t.SymTable e.Name s.Attrib>
	== t.SymTable Found e.Value
	== t.SymTable NoAttrib
	== t.SymTable NoName

<RemoveName t.SymTable e.Name>
	== t.SymTable

<ExtractNames t.SymTable>
	== t.SymTable (e.Name)*

<UpdateAttribSet
	t.SymTable (e.Name)
	(s.Attrib e.Value)*
> == t.SymTable

<FindByKind t.SymTable s.Kind>
	== t.SymTable (e.Name)*

<AddNewName t.SymTable (e.Name) (s.Attrib e.Value)*>
	== t.SymTable Success
	== t.SymTable Fails

Если имя (e.Name) отсутствует в таблице, то оно добавляется с указанными
атрибутами, в противном случае таблица не изменяется.
Фукция возвращает Success при успешном добавлении имени, Fails в случае,
если имя уже в таблице было.

<AddCurrentModule
	t.ErrorList t.SymTable t.SrcPos e.ModuleName
> == t.ErrorList t.SymTable

<ExtractCurrentModule t.SymTable>
	== t.SymTable e.ModuleName

<CheckCurrentModule t.ErrorList t.SymTable t.SrcPos e.ModuleName>
	== t.ErrorList t.SymTable
	== t.UpdatedErrorList t.SymTable

<AddNewEntity
	t.ErrorList t.SymTable t.SrcPos (e.Name)
	(s.Attribute e.Value)*
> == t.ErrorList t.SymTable

<ExtractImportList t.SymTable>
	== t.SymTable (e.ImportName)*

<AddADT t.ErrorList t.SymTable t.SrcPos e.ADTName>
	== t.ErrorList t.SymTable

<ExtractLocalInfo t.SymTable>
	== t.SymTable (s.ScopeClass e.EntityName)*
s.ScopeClass ::= Entry | Local | Swap

<ExtractEntryFunctions t.SymTable>
	== t.SymTable (e.FnName)*

