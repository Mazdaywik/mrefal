$MODULE MBE-Mgr;

$IMPORT MBEFE-Holder;
$IMPORT MContext;
$IMPORT MCreateDirIfNeed;
$IMPORT MLambda;
$IMPORT MQualifiedName;

/**=============================================================================
  Параметры конкретного диспетчера:
    s.Name ::= IDENTIFIER -- имя диспетчера
    s.FnGenerator ::= { t.IModule e.FileName = t.IModule }
    <s.FnLinker t.hContext (e.OutName) (t.ModuleName e.ObjName)*>
      == t.hContext Success
      == t.hContext Fails
    e.Folder -- имя папки
    e.Ext -- расширение файла
==============================================================================*/

$SWAP G_BackEnds;

//------------------------------------------------------------------------------

/**
  <Register s.Name s.Generator s.Linker (e.Folder) (e.Ext)>
    == empty
*/
$ENTRY Register
  s.Name s.Generator s.Linker (e.Folder) (e.Ext) =
    <MBEFE-Holder::UpdateEntry
      & G_BackEnds s.Name
      (Generator s.Generator) (Linker s.Linker)
      (Folder e.Folder) (Ext e.Ext)
    >;

//------------------------------------------------------------------------------

/**
  <Generate t.Context t.IModule t.QualifiedName>
    == t.Context t.IModule Success
    == t.Context t.IModule Fails
*/
$ENTRY Generate
  t.Context t.IModule t.QualifiedName =
    <DoGenerate
      Success t.Context t.IModule t.QualifiedName <GetList>
    >;

DoGenerate {
  Fails t.Context t.IModule t.QualifiedName e.Tail =
    <MQualifiedName::Destroy t.QualifiedName>
    t.Context t.IModule Fails;

  Success t.Context t.IModule t.QualifiedName s.NextBackEnd e.Tail =
    <DoGenerate
      <GenerateBy
        t.Context t.IModule t.QualifiedName s.NextBackEnd
      > e.Tail
    >;

  Success t.Context t.IModule t.QualifiedName =
    <MQualifiedName::Destroy t.QualifiedName>
    t.Context t.IModule Success;
}

GenerateBy
  t.hContext t.IModule t.QualifiedName s.BackEndName =
    <GenerateBy-Aux
      ( <MContext::GetBaseDirectory t.hContext t.QualifiedName> )
      t.IModule t.QualifiedName
      s.BackEndName <GetInfo s.BackEndName Generator>
    >;

GenerateBy-Aux {
  ( t.Context e.Info )
  t.IModule t.QualifiedName s.BackEndName
  Fails s.Error =
    Fails t.Context t.IModule t.QualifiedName;

  ( t.Context Fails ModuleNotFound )
  t.IModule t.QualifiedName s.BackEndName
  Success s.FnGenerator =
    Fails t.Context t.IModule t.QualifiedName;

  ( t.hContext Fails MismatchCase )
  t.hIModule t.QualifiedName s.BackEndName
  Success s.FnGenerator =
    Fails t.hContext t.hIModule t.QualifiedName;

  ( t.Context Success e.BaseDirectory )
  t.IModule t.QualifiedName s.BackEndName
  Success s.FnGenerator =
    <GenerateBy-Aux2
      t.Context t.IModule s.FnGenerator
      <GetPath-T s.BackEndName t.QualifiedName e.BaseDirectory>
    >;
}

GenerateBy-Aux2 {
  t.Context t.IModule s.FnGenerator
  Success t.QualifiedName e.FileName =
    Success t.Context
    <s.FnGenerator
      t.IModule
      <MCreateDirIfNeed::CreatePathToFile e.FileName>
    >
    t.QualifiedName;

  /* Случай, когда GetOutPath возвращает Fails не рассматриваем,
  т.к. неудача возникает только при неудаче функции GetBEInfo,
  а последняя ветвь функции GeneratePer-Aux выполняется при
  успешной GetBEInfo */
}

//------------------------------------------------------------------------------

/**
  <Link t.Context (e.OutName) e.OrderedFiles>
    == t.Context Success
    == t.Context Fails
  e.OrderedFiles ::= t.QualifiedName*
*/
$ENTRY Link
  t.Context (e.OutName) e.OrderedFiles =
    <DoLink
      t.Context Success (e.OutName) (e.OrderedFiles)
      <ExtractLinkers <GetList>>
    >;

ExtractLinkers {
  = ;
  s.BEName e.Tail =
    (s.BEName <GetLinker s.BEName>)
    <ExtractLinkers e.Tail>;
}

GetLinker s.BEName = <DelSuccess <GetInfo s.BEName Linker>>;

DelSuccess Success s.FnLinker = s.FnLinker;

DoLink {
  t.Context Fails (e.OutName) (e.OrderedFiles) e.Tail =
    t.Context Fails;

  t.Context Success (e.OutName) (e.OrderedFiles) =
    t.Context Success;

  t.Context Success (e.OutName) (e.OrderedFiles) (s.BEName s.FnLinker) e.Tail =
    <DoLink
      <s.FnLinker
        <SwapFirsts
          (e.OutName)
          <MLambda::MapReduce
            <MLambda::BindLeft & MakeObjNames s.BEName>
            t.Context e.OrderedFiles
          >
        >
      >
      (e.OutName) (e.OrderedFiles) e.Tail
    >;
}

SwapFirsts
  t.First t.Second e.Tail = t.Second t.First e.Tail;

MakeObjNames
  s.L-BEName t.hContext t.ModuleName =
    <MakeObjNames-Guard
      <X_GetPath-T t.hContext t.ModuleName s.L-BEName>
    >;

MakeObjNames-Guard
  t.hContext t.ModuleName Success e.Path =
    t.hContext (t.ModuleName e.Path);

//------------------------------------------------------------------------------

/**
  <GetList> == s.BackEndName*
*/

$ENTRY GetList = <MBEFE-Holder::GetMgrList & G_BackEnds>;

//------------------------------------------------------------------------------

/**
  <GetInfo s.FEName s.Option>
    == Success e.Option
    == Fails s.Error
  s.Error ::= InvalidMgr | InvalidOption
*/
$ENTRY GetInfo
  s.Name s.Option =
    <MBEFE-Holder::GetInfo & G_BackEnds s.Name s.Option>;

//------------------------------------------------------------------------------

/**
  <GetPath-T s.BEName t.QualifiedName e.BaseFolder>
    == Success t.QualifiedName e.OutPath
    == Fails t.QualifiedName
*/
$ENTRY GetPath-T
  s.BEName t.QualifiedName e.BaseFolder =
    <GetPath-Aux
      ( <GetInfo s.BEName Folder> ) ( <GetInfo s.BEName Ext> )
      ( <MQualifiedName::ToRelativeFSPath-T t.QualifiedName> )
      e.BaseFolder
    >;

GetPath-Aux {
  ( Fails s.Error ) ( e.Result )
  ( t.QualifiedName e.RelativePath ) e.BaseFolder =
    Fails t.QualifiedName;

  ( Success e.Folder ) ( Fails s.Error )
  ( t.QualifiedName e.RelativePath ) e.BaseFolder =
    Fails t.QualifiedName;

  ( Success e.Folder ) (Success e.Ext )
  ( t.QualifiedName e.RelativePath ) Current =
    Success t.QualifiedName e.Folder '/' e.RelativePath '.' e.Ext;

  ( Success e.Folder ) (Success e.Ext )
  ( t.QualifiedName e.RelativePath ) e.Base =
    Success t.QualifiedName e.Base '/' e.Folder '/' e.RelativePath '.' e.Ext;
}

//------------------------------------------------------------------------------

/**
  <X_GetPath-T t.Context t.QualifiedName s.BEName>
    == t.Context t.QualifiedName Success e.Path
    == t.Context t.QualifiedName Fails
*/
$ENTRY X_GetPath-T
  t.Context t.QualifiedName s.BEName =
    <MakeName
      t.Context t.QualifiedName s.BEName
    >;

MakeName
  t.Context t.QualifiedName s.MgrName =
    <MakeName--SwInContext
      ( <MContext::GetBaseDirectory t.Context t.QualifiedName> )
      t.QualifiedName s.MgrName
    >;

MakeName--SwInContext {
  ( t.hContext Success e.BaseName )
  t.QualifiedName s.MgrName =
    <MakeName--SwMakeRelative
      t.hContext (e.BaseName)
      <MakeRelative t.QualifiedName s.MgrName>
    >;

  ( t.hContext Fails ModuleNotFound )
  t.QualifiedName s.MgrName =
    t.hContext t.QualifiedName Fails;

  ( t.hContext Fails MismatchCase )
  t.QualifiedName s.MgrName =
    t.hContext t.QualifiedName Fails;

  /*
    OptionNotFound не проверяем -- нарушение инварианта.
  */
}

MakeRelative
  t.QualifiedName s.BEName =
    <MakeRelative-Aux
      ( <GetInfo s.BEName Folder> )
      ( <GetInfo s.BEName Ext> )
      <MQualifiedName::ToRelativeFSPath-T t.QualifiedName>
    >;

MakeRelative-Aux {
  ( Fails s.Error ) ( e.ResultExt ) t.QualifiedName e.Path =
    t.QualifiedName Fails;

  ( Success e.Folder ) ( Fails s.Error ) t.QualifiedName e.Path =
    t.QualifiedName Fails;

  ( Success e.Folder ) ( Success e.Ext )
  t.QualifiedName e.Path =
    t.QualifiedName Success e.Folder '/' e.Path '.' e.Ext;
}

MakeName--SwMakeRelative {
  t.Context (Current)
  t.QualifiedName Success e.RelativeName =
    t.Context t.QualifiedName Success e.RelativeName;

  t.Context (e.BaseName)
  t.QualifiedName Success e.RelativeName =
    t.Context t.QualifiedName Success e.BaseName '/' e.RelativeName;

  t.Context (e.BaseName)
  t.QualifiedName Fails =
    t.Context t.QualifiedName Fails;
}

$END MBE-Mgr.

