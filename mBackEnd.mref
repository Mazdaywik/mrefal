$MODULE MBackEnd;

$IMPORT FileIO;
$IMPORT MIModule;
$IMPORT MQualifiedName;
$IMPORT MStrings;
$IMPORT MVersion;

/**
	<Generate t.Module e.OutName>
		== empty
*/
$ENTRY Generate
	t.Module e.OutName =
		<SaveModule
			(e.OutName)
			('v ' <MVersion::ROut>)
			('r file ' e.OutName)
			()
			<GenerateContent t.Module>
		>;

SaveModule
	(e.OutName) e.Lines t.IModule =
		<FileIO::Save (e.OutName) e.Lines>
		<MIModule::Destroy t.IModule>;

GenerateContent
	t.IModule =
		<GenerateElements
			<MIModule::GetModuleName t.IModule>
		>;

GenerateElements
	t.IModule e.ModuleName =
		<DoGenerateElements
			(e.ModuleName)
			<MIModule::GetFunctionList t.IModule>
		>;

DoGenerateElements {
	(e.ModuleName) t.IModule (e.FnName) e.Tail =
		<SwGenerateElements
			(e.ModuleName)
			<MIModule::GetFunctionAttribute t.IModule ScopeClass e.FnName>
			(e.FnName) e.Tail
		>;

	(e.ModuleName) t.IModule = t.IModule;
}

SwGenerateElements {
	(e.ModuleName) t.IModule Found Swap
	(e.FnName) e.Tail =
		<GenerateSwap (e.ModuleName) e.FnName>
		<DoGenerateElements (e.ModuleName) t.IModule e.Tail>;

	(e.ModuleName) t.IModule Found s.ScopeClass
	(e.FnName) e.Tail =
		<GenerateFunction
			(e.ModuleName)
			<MIModule::GetFunctionAttribute t.IModule Body e.FnName>
			(s.ScopeClass e.FnName) e.Tail
		>;
}

GenerateSwap
	/*
		b Swap::ModuleName::SomeHolder
		c $Swap::ModuleName::SomeHolder$ {
		c 	e.$Index::NewValue$ =
		c 		<Dg ('ModuleName::SomeHolder')>
		c 		<Br ('ModuleName::SomeHolder') '=' e.$Index::NewValue$ >;
		c }

	*/
	(e.ModuleName) e.SwapName =
		('b Swap::' e.ModuleName '::' e.SwapName)
		('c $Swap::' e.ModuleName '::' e.SwapName '$ {')
		('c \te.$Index::NewValue$ =')
		('c \t\t<Dg (\'' e.ModuleName '::' e.SwapName '\')>')
		('c \t\t<Br (\'' e.ModuleName '::' e.SwapName '\') \'=\' e.$Index::NewValue$ >;')
		('c }') ();

GenerateFunction
	(e.ModuleName) t.IModule Found (e.Sentences)
	(s.ScopeClass e.FnName) e.Tail =
		<GenerateFunction-Aux
			(e.ModuleName)
			<MIModule::GetFunctionAttribute
				t.IModule Qualified e.FnName
			>
			(e.Sentences)
			(s.ScopeClass e.FnName)
			e.Tail
		>;

GenerateFunction-Aux
	(e.ModuleName) t.IModule Found t.QualifiedName
	(e.Sentences)
	(s.ScopeClass e.FnName) e.Tail =
		<GenerateFunctionCode
			s.ScopeClass t.QualifiedName e.Sentences
		>
		<DoGenerateElements (e.ModuleName) t.IModule e.Tail>;

GenerateFunctionCode {
	s.ScopeClass t.QualifiedName e.Content =
		<GenerateFnHeader
			s.ScopeClass t.QualifiedName
		> <GenerateFnBody e.Content>;
}

GenerateFnHeader
	s.ScopeClass t.QualifiedFnName =
		( 'b '
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
		)
		( 'c $'
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
			'$ {'
		);

QualifiedToLine
	t.QualifiedFnName =
		<SegmentsToLine
			<MQualifiedName::Parse t.QualifiedFnName>
		>;

SegmentsToLine {
	(e.Segment) e.Tail =
		'::' e.Segment <SegmentsToLine e.Tail>;

	= ;
}

ScopeClassToPrefix { Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; }

GenerateFnBody {
	// Обработка пустой функции
	= ('c NF = NF ; }') ();

	e.Sentences =
		<GenerateSentences e.Sentences>
		('c }') ();
}

GenerateSentences {
	(e.NextSentence) e.Tail =
		<GenerateOneSentence
			e.NextSentence
		> <GenerateSentences e.Tail>;

	= ;
}

GenerateOneSentence
	(Pattern e.Pattern) (Result e.Result) =
		( 'c \t' <GenerateExpression e.Pattern> '=' )
		( 'c \t\t' <GenerateExpression e.Result> ';' );

GenerateExpression {
	t.Term e.Tail =
		<GenerateTerm t.Term> ' '
		<GenerateExpression e.Tail>;

	= ;
}

GenerateTerm {
	(Identifier e.Name) =
		'$Ident::' e.Name '$';

	(EVar e.Name) =
		'e.$Index::' e.Name '$';

	(SVar e.Name) =
		's.$Index::' e.Name '$';

	(TVar e.Name) =
		't.$Index::' e.Name '$';

	(Literal e.Content) =
		'\'' <EscapeText e.Content> '\'';

	(DQWord e.Content) =
		'\"' <EscapeText e.Content> '\"';

	(Macro s.Value) =
		<MStrings::Symb s.Value>;

	(Structure e.InBrackets) =
		'( $ADT::__StructureBrackets$ '
		<GenerateExpression e.InBrackets>
		')';

	(Abstract (e.Callable) e.InBrackets) =
		'( ' <GenerateCallable e.Callable> ' '
		<GenerateExpression e.InBrackets>
		')';

	(Function (e.Callable) e.Argument) =
		'<' <GenerateCallable e.Callable> ' '
		<GenerateExpression e.Argument> '>';

	(IndirectCall (SVar e.Index) e.Argument) =
		'<Mu s.$Index::' e.Index '$ '
		<GenerateExpression e.Argument> '>';

	(FnPtr (e.Callable)) =
		<GenerateCallable e.Callable>;
}

EscapeText {
	s.Char e.Tail =
		<EscapeChar s.Char> <EscapeText e.Tail>;

	= ;
}

EscapeChar {
	'\t' = '\\t';
	'\n' = '\\n';
	'\\' = '\\\\';
	'\"' = '\\\"';
	'\'' = '\\\'';
	'$' = '$$';
	s.X = s.X;
}

GenerateCallable
	s.CallType t.QualifiedFnName =
		'$'
		<CallTypeToPrefix s.CallType>
		<QualifiedToLine t.QualifiedFnName>
		'$';

CallTypeToPrefix {
	Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; ADT = 'ADT';
}

$END MBackEnd.
