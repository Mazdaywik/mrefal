$MODULE MBackEnd;

$IMPORT FileIO;
$IMPORT MQualifiedName;
$IMPORT MSymTable;
$IMPORT MStrings;
$IMPORT MVersion;

/**
	<Generate t.Module e.OutName>
		== empty
*/
$ENTRY Generate
	t.Module e.OutName =
		<FileIO::Save
			(e.OutName)
			('v ' <MVersion::ROut>)
			('r file ' e.OutName)
			()
			<GenerateContent t.Module>
		>;

GenerateContent
	(t.SymTable e.Elements) =
		<GenerateSwaps
			<MSymTable::ExtractCurrentModule t.SymTable>
		>
		<GenerateElements e.Elements>;

GenerateSwaps
	t.SymTable e.ModuleName =
		<DoGenerateSwaps
			(e.ModuleName)
			<MSymTable::ExtractLocalInfo t.SymTable>
		>;

DoGenerateSwaps {
/*
	$Swap::ModuleName::SomeHolder$ {
		e.$Index::NewValue$ =
			<Dg ('ModuleName::SomeHolder')>
			<Br ('ModuleName::SomeHolder') '=' e.$Index::NewValue$ >;
	}

*/

	(e.ModuleName) t.SymTable
	e.Functions-B (Swap e.SwapName) e.Functions-E =
		('b Swap::' e.ModuleName '::' e.SwapName)
		('c $Swap::' e.ModuleName '::' e.SwapName '$ {')
		('c \te.$Index::NewValue$ =')
		('c \t\t<Dg (\'' e.ModuleName '::' e.SwapName '\')>')
		('c \t\t<Br (\'' e.ModuleName '::' e.SwapName '\') \'=\' e.$Index::NewValue$ >;')
		('c }') ()
		<DoGenerateSwaps
			(e.ModuleName) t.SymTable e.Functions-E
		>;

	// Не осталось ящиков
	(e.ModuleName) t.SymTable e.FunctionsWithOutSwaps =
		<MSymTable::Destroy t.SymTable>;
}

GenerateElements {
	(e.Element) e.Tail =
		<GenerateOneElement e.Element>
		<GenerateElements e.Tail>;

	= ;
}

GenerateOneElement {
	Function s.ScopeClass t.QualifiedName (e.Content) =
		<GenerateFnHeader
			s.ScopeClass t.QualifiedName
		> <GenerateFnBody e.Content>;
}

GenerateFnHeader
	s.ScopeClass t.QualifiedFnName =
		( 'b '
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
		)
		( 'c $'
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
			'$ {'
		);

QualifiedToLine
	t.QualifiedFnName =
		<SegmentsToLine
			<MQualifiedName::Parse t.QualifiedFnName>
		>;

SegmentsToLine {
	(e.Segment) e.Tail =
		'::' e.Segment <SegmentsToLine e.Tail>;

	= ;
}

ScopeClassToPrefix { Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; }

GenerateFnBody {
	// Обработка пустой функции
	= ('c NF = NF ; }') ();

	e.Sentences =
		<GenerateSentences e.Sentences>
		('c }') ();
}

GenerateSentences {
	(e.NextSentence) e.Tail =
		<GenerateOneSentence
			e.NextSentence
		> <GenerateSentences e.Tail>;

	= ;
}

GenerateOneSentence
	(e.Pattern) (e.Result) =
		( 'c \t' <GenerateExpression e.Pattern> '=' )
		( 'c \t\t' <GenerateExpression e.Result> ';' );

GenerateExpression {
	t.Term e.Tail =
		<GenerateTerm t.Term> ' '
		<GenerateExpression e.Tail>;

	= ;
}

GenerateTerm {
	(Identifier e.Name) =
		'$Ident::' e.Name '$';

	(EVar e.Name) =
		'e.$Index::' e.Name '$';

	(SVar e.Name) =
		's.$Index::' e.Name '$';

	(TVar e.Name) =
		't.$Index::' e.Name '$';

	(Literal e.Content) =
		'\'' <EscapeText e.Content> '\'';

	(DQWord e.Content) =
		'\"' <EscapeText e.Content> '\"';

	(Macro s.Value) =
		<MStrings::Symb s.Value>;

	(Structure e.InBrackets) =
		'( $ADT::__StructureBrackets$ '
		<GenerateExpression e.InBrackets>
		')';

	(Function (e.Callable) e.Argument) =
		'<' <GenerateCallable e.Callable> ' '
		<GenerateExpression e.Argument> '>';

	(IndirectCall (SVar e.Index) e.Argument) =
		'<Mu s.$Index::' e.Index '$ '
		<GenerateExpression e.Argument> '>';

	(FnPtr (e.Callable)) =
		<GenerateCallable e.Callable>;
}

EscapeText {
	s.Char e.Tail =
		<EscapeChar s.Char> <EscapeText e.Tail>;

	= ;
}

EscapeChar {
	'\t' = '\\t';
	'\n' = '\\n';
	'\\' = '\\\\';
	'\"' = '\\\"';
	'\'' = '\\\'';
	'$' = '$$';
	s.X = s.X;
}

GenerateCallable
	s.CallType t.QualifiedFnName =
		'$'
		<CallTypeToPrefix s.CallType>
		<QualifiedToLine t.QualifiedFnName>
		'$';

CallTypeToPrefix { Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; }

$END MBackEnd.
