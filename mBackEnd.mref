$MODULE MBackEnd;

$IMPORT FileIO;
$IMPORT MQualifiedName;
$IMPORT MSymTable;
$IMPORT MStrings;
$IMPORT MVersion;

/**
	<Generate t.Module e.OutName>
		== empty
*/
$ENTRY Generate
	t.Module e.OutName =
		<SaveModule
			(e.OutName)
			('v ' <MVersion::ROut>)
			('r file ' e.OutName)
			()
			<GenerateContent t.Module>
		>;

SaveModule
	(e.OutName) e.Lines t.SymTable =
		<FileIO::Save (e.OutName) e.Lines>
		<MSymTable::Destroy t.SymTable>;

GenerateContent
	t.SymTable =
		<GenerateElements
			<MSymTable::ExtractCurrentModule t.SymTable>
		>;

GenerateElements
	t.SymTable e.ModuleName =
		<DoGenerateElements
			(e.ModuleName)
			<MSymTable::ExtractLocalInfo t.SymTable>
		>;

DoGenerateElements {
	(e.ModuleName) t.SymTable
	(Swap e.SwapName) e.Functions =
		<GenerateSwap (e.ModuleName) e.SwapName>
		<DoGenerateElements
			(e.ModuleName) t.SymTable e.Functions
		>;

	(e.ModuleName) t.SymTable
	(s.ScopeClass e.FnName) e.Functions =
		<GenerateFunction
			(e.ModuleName)
			<MSymTable::GetAttrib
				t.SymTable e.FnName Body
			>
			(s.ScopeClass e.FnName) e.Functions
		>;

	// Не осталось элементов
	(e.ModuleName) t.SymTable = t.SymTable;
}

GenerateSwap
	/*
		b Swap::ModuleName::SomeHolder
		c $Swap::ModuleName::SomeHolder$ {
		c 	e.$Index::NewValue$ =
		c 			<Dg ('ModuleName::SomeHolder')>
		c 			<Br ('ModuleName::SomeHolder') '=' e.$Index::NewValue$ >;
		c }

	*/
	(e.ModuleName) e.SwapName =
		('b Swap::' e.ModuleName '::' e.SwapName)
		('c $Swap::' e.ModuleName '::' e.SwapName '$ {')
		('c \te.$Index::NewValue$ =')
		('c \t\t<Dg (\'' e.ModuleName '::' e.SwapName '\')>')
		('c \t\t<Br (\'' e.ModuleName '::' e.SwapName '\') \'=\' e.$Index::NewValue$ >;')
		('c }') ();

GenerateFunction
	(e.ModuleName) t.SymTable Found (e.Sentences)
	(s.ScopeClass e.FnName) e.Functions =
		<GenerateFunction-Aux
			(e.ModuleName)
			<MSymTable::GetAttrib
				t.SymTable e.FnName Qualified
			>
			(e.Sentences)
			(s.ScopeClass e.FnName) e.Functions
		>;

GenerateFunction-Aux
	(e.ModuleName) t.SymTable Found t.QualifiedName
	(e.Sentences)
	(s.ScopeClass e.FnName) e.Functions =
		<GenerateFunctionCode
			s.ScopeClass t.QualifiedName e.Sentences
		>
		<DoGenerateElements
			(e.ModuleName) t.SymTable e.Functions
		>;

GenerateFunctionCode {
	s.ScopeClass t.QualifiedName e.Content =
		<GenerateFnHeader
			s.ScopeClass t.QualifiedName
		> <GenerateFnBody e.Content>;
}

GenerateFnHeader
	s.ScopeClass t.QualifiedFnName =
		( 'b '
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
		)
		( 'c $'
			<ScopeClassToPrefix s.ScopeClass>
			<QualifiedToLine t.QualifiedFnName>
			'$ {'
		);

QualifiedToLine
	t.QualifiedFnName =
		<SegmentsToLine
			<MQualifiedName::Parse t.QualifiedFnName>
		>;

SegmentsToLine {
	(e.Segment) e.Tail =
		'::' e.Segment <SegmentsToLine e.Tail>;

	= ;
}

ScopeClassToPrefix { Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; }

GenerateFnBody {
	// Обработка пустой функции
	= ('c NF = NF ; }') ();

	e.Sentences =
		<GenerateSentences e.Sentences>
		('c }') ();
}

GenerateSentences {
	(e.NextSentence) e.Tail =
		<GenerateOneSentence
			e.NextSentence
		> <GenerateSentences e.Tail>;

	= ;
}

GenerateOneSentence
	(Pattern e.Pattern) (Result e.Result) =
		( 'c \t' <GenerateExpression e.Pattern> '=' )
		( 'c \t\t' <GenerateExpression e.Result> ';' );

GenerateExpression {
	t.Term e.Tail =
		<GenerateTerm t.Term> ' '
		<GenerateExpression e.Tail>;

	= ;
}

GenerateTerm {
	(Identifier e.Name) =
		'$Ident::' e.Name '$';

	(EVar e.Name) =
		'e.$Index::' e.Name '$';

	(SVar e.Name) =
		's.$Index::' e.Name '$';

	(TVar e.Name) =
		't.$Index::' e.Name '$';

	(Literal e.Content) =
		'\'' <EscapeText e.Content> '\'';

	(DQWord e.Content) =
		'\"' <EscapeText e.Content> '\"';

	(Macro s.Value) =
		<MStrings::Symb s.Value>;

	(Structure e.InBrackets) =
		'( $ADT::__StructureBrackets$ '
		<GenerateExpression e.InBrackets>
		')';

	(Function (e.Callable) e.Argument) =
		'<' <GenerateCallable e.Callable> ' '
		<GenerateExpression e.Argument> '>';

	(IndirectCall (SVar e.Index) e.Argument) =
		'<Mu s.$Index::' e.Index '$ '
		<GenerateExpression e.Argument> '>';

	(FnPtr (e.Callable)) =
		<GenerateCallable e.Callable>;
}

EscapeText {
	s.Char e.Tail =
		<EscapeChar s.Char> <EscapeText e.Tail>;

	= ;
}

EscapeChar {
	'\t' = '\\t';
	'\n' = '\\n';
	'\\' = '\\\\';
	'\"' = '\\\"';
	'\'' = '\\\'';
	'$' = '$$';
	s.X = s.X;
}

GenerateCallable
	s.CallType t.QualifiedFnName =
		'$'
		<CallTypeToPrefix s.CallType>
		<QualifiedToLine t.QualifiedFnName>
		'$';

CallTypeToPrefix { Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; }

$END MBackEnd.
