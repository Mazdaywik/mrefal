$MODULE MBackEnd_Refal5;

$IMPORT FileIO;
$IMPORT MIModule;
$IMPORT MLambda;
$IMPORT MQualifiedName;
$IMPORT MStrings;
$IMPORT MVersion;

/**
  <Generate-T t.IModule e.OutName>
    == t.IModule
*/
$ENTRY Generate-T
  t.IModule e.OutName =
    <SaveModule
      (e.OutName)
      ('v ' <MVersion::ROut>)
      ('r file ' e.OutName)
      ()
      <ModuleToBack <GenerateContent t.IModule>>
    >;

ModuleToBack
  t.IModule e.Lines = e.Lines t.IModule;

SaveModule
  (e.OutName) e.Lines t.IModule =
    <FileIO::Save (e.OutName) e.Lines>
    t.IModule;

GenerateContent
  t.IModule =
    <MLambda::MapReduce
      & GenerateElement
      <MIModule::GetFunctionList t.IModule>
    >;

GenerateElement
  t.IModule (e.NextFnName) =
    <GenerateElement-Aux
      <MIModule::GetFunctionAttribute
        t.IModule Qualified e.NextFnName
      >
      (e.NextFnName)
    >;

GenerateElement-Aux
  t.IModule Found t.QualifiedName (e.FnName) =
    <SwGenerateElement
      <MIModule::GetFunctionAttribute
        t.IModule ScopeClass e.FnName
      >
      t.QualifiedName (e.FnName)
    >;

SwGenerateElement {
  t.IModule Found Swap t.SwapName (e.FnName) =
    t.IModule
    <GenerateSwap t.SwapName>;

  t.IModule Found s.FnScopeClass t.FnName (e.PlainFnName) =
    <GenerateFunction
      t.IModule s.FnScopeClass t.FnName e.PlainFnName
    >;
}

GenerateSwap
  /*
    b Swap::ModuleName::SomeHolder
    c $Swap::ModuleName::SomeHolder$ {
    c   e.$Index::NewValue$ =
    c     <Dg ('ModuleName::SomeHolder')>
    c     <Br ('ModuleName::SomeHolder') '=' e.$Index::NewValue$ >;
    c }

  */
  t.SwapName =
    ( 'b ' <XQualifiedToLine Swap t.SwapName> )
    ('c $' <XQualifiedToLine Swap t.SwapName> '$ {')
    ('c \te.$Index::NewValue$ =')
    ('c \t\t<Dg (\'' <QualifiedToLine t.SwapName> '\')>')
    ('c \t\t<Br (\'' <QualifiedToLine t.SwapName> '\') \'=\' e.$Index::NewValue$ >;')
    ('c }') ();

GenerateFunction
  t.IModule s.FnScopeClass t.QualifiedName e.FnName =
    <GenerateFunction-Aux
      s.FnScopeClass t.QualifiedName
      <MIModule::GetFunctionAttribute
        t.IModule Body e.FnName
      >
    >;

GenerateFunction-Aux
  s.FnScopeClass t.QualifiedName
  t.IModule Found (e.Sentences) =
    t.IModule
    <GenerateFnHeader s.FnScopeClass t.QualifiedName>
    <GenerateFnBody e.Sentences>;

GenerateFnHeader
  s.ScopeClass t.QualifiedFnName =
    ( 'b ' <XQualifiedToLine s.ScopeClass t.QualifiedFnName> )
    ( 'c $' <XQualifiedToLine s.ScopeClass t.QualifiedFnName> '$ {' );

XQualifiedToLine
  s.ScopeClass t.QualifiedName =
    <ScopeClassToPrefix s.ScopeClass>
    <QualifiedToLine t.QualifiedName>;

QualifiedToLine
  t.QualifiedFnName =
    <SegmentsToLine
      <MQualifiedName::Parse t.QualifiedFnName>
    >;

SegmentsToLine {
  (e.Segment) e.Tail =
    '::' e.Segment <SegmentsToLine e.Tail>;

  = ;
}

ScopeClassToPrefix {
  Entry = 'Entry'; Local = 'Local'; Swap = 'Swap'; ADT = 'ADT';
}

GenerateFnBody {
  // Обработка пустой функции
  = ('c NF = NF ; }') ();

  e.Sentences =
    <GenerateSentences e.Sentences>
    ('c }') ();
}

GenerateSentences {
  (e.NextSentence) e.Tail =
    <GenerateOneSentence
      e.NextSentence
    > <GenerateSentences e.Tail>;

  = ;
}

GenerateOneSentence
  (Pattern e.Pattern) (Result e.Result) =
    ( 'c \t' <GenerateExpression e.Pattern> '=' )
    ( 'c \t\t' <GenerateExpression e.Result> ';' );

GenerateExpression {
  t.Term e.Tail =
    <GenerateTerm t.Term> ' '
    <GenerateExpression e.Tail>;

  = ;
}

GenerateTerm {
  (Identifier e.Name) =
    '$Ident::' e.Name '$';

  (EVar e.Name) =
    'e.$Index::' e.Name '$';

  (SVar e.Name) =
    's.$Index::' e.Name '$';

  (TVar e.Name) =
    't.$Index::' e.Name '$';

  (Literal e.Content) =
    '\'' <EscapeText e.Content> '\'';

  (DQWord e.Content) =
    '\"' <EscapeText e.Content> '\"';

  (Macro s.Value) =
    <MStrings::Symb s.Value>;

  (Structure e.InBrackets) =
    '( $ADT::__StructureBrackets$ '
    <GenerateExpression e.InBrackets>
    ')';

  (Abstract (e.Callable) e.InBrackets) =
    '( ' <GenerateCallable e.Callable> ' '
    <GenerateExpression e.InBrackets>
    ')';

  (Function (e.Callable) e.Argument) =
    '<' <GenerateCallable e.Callable> ' '
    <GenerateExpression e.Argument> '>';

  (IndirectCall (SVar e.Index) e.Argument) =
    '<Mu s.$Index::' e.Index '$ '
    <GenerateExpression e.Argument> '>';

  (FnPtr (e.Callable)) =
    <GenerateCallable e.Callable>;
}

EscapeText {
  s.Char e.Tail =
    <EscapeChar s.Char> <EscapeText e.Tail>;

  = ;
}

EscapeChar {
  '\t' = '\\t';
  '\n' = '\\n';
  '\\' = '\\\\';
  '\"' = '\\\"';
  '\'' = '\\\'';
  '$' = '$$';
  s.X = s.X;
}

GenerateCallable
  s.CallType t.QualifiedFnName =
    '$' <XQualifiedToLine s.CallType t.QualifiedFnName> '$';

$END MBackEnd_Refal5.
