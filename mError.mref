$MODULE MError;

$IMPORT InOut;
$IMPORT MOS;
$IMPORT MLambda;
$IMPORT MLexer;
$IMPORT MOrder;
$IMPORT MOutModuleStatus;
$IMPORT MQualifiedName;
$IMPORT MSymStream;

/**
  <Fatal e.Message>
    == fail down (errcode 1)
*/
$ENTRY Fatal
  e.Message =
    <MOutModuleStatus::Flush>
    <InOut::WriteLine 'FATAL ERROR: ' e.Message>
    <MOS::Exit 1>;

//------------------------------------------------------------------------------

/**
  <LinkError e.Message>
    == fail down (errcode 1)
*/
$ENTRY LinkError
  e.Message =
    <MOutModuleStatus::Flush>
    <InOut::WriteLine 'LINKER ERROR: ' e.Message>
    <MOS::Exit 1>;

PrintError {
  LexerError t.SrcPos e.Message =
    <OutError t.SrcPos ('LEXER') e.Message>;

  LexerUndefined t.SrcPos e.Text =
    <OutError t.SrcPos ('LEXER') 'undefined text ' e.Text>;

  Unexpected (s.Type t.SrcPos e.Info) e.Expected =
    <OutError
      t.SrcPos ('SYNTAX') 'Expected ' e.Expected ', got '
      <MLexer::TokenToString (s.Type e.Info)>
    >;

  Semantics t.SrcPos e.Message =
    <OutError t.SrcPos ('SEMANTICS') e.Message>;
}

OutError {
  t.SrcPos (e.Kind) e.Message =
    <MOutModuleStatus::Flush>
    <InOut::WriteLine
      e.Kind ' ERROR ('
      <MSymStream::SrcPosToString t.SrcPos>
      '): ' e.Message
    >;
}

$DATA ErrorList;

//------------------------------------------------------------------------------

/**
  <CreateErrList> == t.hErrorList
*/
$ENTRY CreateErrList = [ErrorList];

//------------------------------------------------------------------------------

/**
  <DestroyErrList t.hErrorList> == empty
*/
$ENTRY DestroyErrList
  [ErrorList e.Errors] = ;

//------------------------------------------------------------------------------

/**
  <EmptyList t.ErrorList>
    == t.ErrorList Empty
    == t.ErrorList NotEmpty
*/
$ENTRY EmptyList {
  [ErrorList] = [ErrorList] Empty;

  [ErrorList e.Errors] =
    [ErrorList e.Errors] NotEmpty;
}

//------------------------------------------------------------------------------

/**
  <ContentLevel t.ErrorList>
    == t.ErrorList Empty
    == t.ErrorList Warnings
    == t.ErrorList Errors
*/
$ENTRY ContentLevel
  t.ErrorList =
    <SwContentLevel <EmptyList t.ErrorList>>;

SwContentLevel {
  t.ErrorList Empty = t.ErrorList Empty;
  
  t.ErrorList NotEmpty = t.ErrorList Errors;
}

AddToList {
  [ErrorList e.Errors-B t.Error e.Errors-E]
  t.Error =
    [ErrorList e.Errors-B t.Error e.Errors-E];

  [ErrorList e.Errors] t.Error =
    [ErrorList e.Errors t.Error];
}

//------------------------------------------------------------------------------

/**
  <MergeLists t.List1 t.List2>
    == t.MergedList
*/
$ENTRY MergeLists
  t.List1 [ErrorList e.Errors2] =
    <MLambda::Reduce & AddToList t.List1 e.Errors2>;

//------------------------------------------------------------------------------

/**
  <AddUnexpected t.ErrorList t.UnexpToken e.ExpectedText>
    == t.UpdatedErrorList
*/
$ENTRY AddUnexpected {
  t.ErrorList
  (Error t.SrcPos e.Message) e.ExpectedText =
    <AddToList
      t.ErrorList (LexerError t.SrcPos e.Message )
    >;

  t.ErrorList
  (Undefined t.SrcPos e.Text) e.ExpectedText =
    <AddToList
      t.ErrorList (LexerUndefined t.SrcPos e.Text )
    >;

  t.ErrorList
  t.Unexpected e.ExpectedText =
    <AddToList
      t.ErrorList (Unexpected t.Unexpected e.ExpectedText)
    >;
}

//------------------------------------------------------------------------------

/**
  <AddNamesMismatch
    t.ErrorList t.TailPos
    t.InHead t.InTail
  >
    == t.ErrorList
*/
$ENTRY AddNamesMismatch
  t.ErrorList t.TailPos
  t.InHead t.InTail =
    <AddToList
      t.ErrorList
      ( Semantics t.TailPos
        'Mismatch module names in head \''
        <QualifiedNameToString t.InHead>
        '\' and in tail \''
        <QualifiedNameToString t.InTail>
        '\''
      )
    >;

//------------------------------------------------------------------------------

/**
  <AddRecursiveLink t.hErrorList t.SrcPos t.ImportName>
    == t.hErrorList
*/
$ENTRY AddRecursiveLink
  t.hErrorList t.SrcPos t.ImportName =
    <AddToList
      t.hErrorList
      ( Semantics t.SrcPos
        'Recursive link in import '
        <QualifiedNameToString t.ImportName>
      )
    >;

//------------------------------------------------------------------------------

/**
  <AddBrokenImport t.hErrorList t.SrcPos t.ImportName>
    == t.hErrorList
*/
$ENTRY AddBrokenImport
  t.hErrorList t.SrcPos t.ImportName =
    <AddToList
      t.hErrorList
      ( Semantics t.SrcPos
        'Can\'t load import module '
        <QualifiedNameToString t.ImportName>
      )
    >;

//------------------------------------------------------------------------------

/**
  <DependedFromSource t.hErrorList t.SrcPos t.ImportName>
    == t.hErrorList
*/
$ENTRY DependedFromSource
  t.hErrorList t.SrcPos t.ImportName =
    <AddToList
      t.hErrorList
      ( Semantics t.SrcPos
        'Can\'t load import source module from library '
        <QualifiedNameToString t.ImportName>
      )
    >;

//------------------------------------------------------------------------------

/**
  <AddImportHead t.hErrorList t.SrcPos t.ImportName>
    == t.hErrorList
*/
$ENTRY AddImportHead
  t.hErrorList t.SrcPos t.ImportName =
    <AddToList
      t.hErrorList
      ( Semantics t.SrcPos
        'Can\'t import head module '
        <QualifiedNameToString t.ImportName>
      )
    >;

//------------------------------------------------------------------------------

/**
  <AddMismatchInternalAndExternalNames
    t.ErrorList t.SrcPos t.InternalName t.ExternalName
  >
    == t.ErrorList
*/
$ENTRY AddMismatchInternalAndExternalNames
  t.ErrorList t.SrcPos t.InternalName t.ExternalName =
    <AddToList
      t.ErrorList
      ( Semantics t.SrcPos
        'Mismatch internal module name '
        <QualifiedNameToString t.InternalName>
        ' and external name '
        <QualifiedNameToString t.ExternalName>
      )
    >;

QualifiedNameToString
  t.QualifiedName =
    <MQualifiedName::ToPrintable-Quad t.QualifiedName>;

//------------------------------------------------------------------------------

/**
  <AddRedeclaredIdentifier t.ErrorList t.SrcPos e.Identifier>
    == t.UpdatedErrorList
*/
$ENTRY AddRedeclaredIdentifier
  t.ErrorList t.SrcPos e.Identifier =
    <AddToList
      t.ErrorList
      ( Semantics t.SrcPos 'Identifier redeclared ' e.Identifier )
    >;

//------------------------------------------------------------------------------

/**
  <AddVarTypeMismatch t.hErrorList t.SrcPos e.VarName>
    == t.hErrorList
*/
$ENTRY AddVarTypeMismatch
  t.ErrorList t.SrcPos e.VarName =
    <AddToList
      t.ErrorList
      ( Semantics
        t.SrcPos 'Two different variables has same index ' e.VarName
      )
    >;

//------------------------------------------------------------------------------

/**
  <AddUndeclaredVariable t.hErrorList t.SrcPos s.VarType e.Index>
    == t.hErrorList
*/
$ENTRY AddUndeclaredVariable
  t.ErrorList t.SrcPos s.VarType e.Index =
    <AddToList
      t.ErrorList
      ( Semantics
        t.SrcPos
        'Undeclared variable ' <VarTypeToPrefix s.VarType> e.Index
      )
    >;

VarTypeToPrefix {
  EVar = 'e.'; SVar = 's.'; TVar = 't.';
}

//------------------------------------------------------------------------------

/**
  <AddUnresolvedFunction t.hErrorList t.SrcPos t.FnName>
    == t.hErrorList
*/
$ENTRY AddUnresolvedFunction {
  t.ErrorList t.SrcPos t.EntityName =
    <AddToList
      t.ErrorList
      ( Semantics
        t.SrcPos
        'Unresolved calling <' <QualifiedNameToString t.EntityName> ' ... >'
      )
    >;
}

//------------------------------------------------------------------------------

/**
  <PrintErrorsAndStop t.hErrorList>
    == fail down (errcode 1)
*/
$ENTRY PrintErrorsAndStop
  t.ErrorList =
    <PrintErrors t.ErrorList>
    <MOS::Exit 1>;

//------------------------------------------------------------------------------

/**
  <PrintErrors t.hErrorList> == empty
*/
$ENTRY PrintErrors
  [ErrorList e.Errors] =
    <DoPrintErrors
      <MOrder::Sort e.Errors>
    >;

DoPrintErrors {
  (e.Error) e.Errors =
    <PrintError e.Error>
    <DoPrintErrors e.Errors>;

  = ;
}

$END MError.
