$MODULE MLinker;

$IMPORT Context;
$IMPORT FileIO;
$IMPORT InOut;
$IMPORT MCreateDirIfNeed;
$IMPORT MError;
$IMPORT MOS;
$IMPORT MExeTyper;
$IMPORT MStrings;
$IMPORT MSymModule;
$IMPORT MOrder;

$ENTRY Link {
	t.Context =
		<InOut::WriteLine 'Linking...'>
		<RealLink
			<Context::GetProgName t.Context>
		>;
}

RealLink {
	t.Context e.ProgName =
		<PutStartCaller
			<PutModules
				<MExeTyper::Create <DefLim> e.ProgName '.ref'>
				<NewAliasesTable>
				<NewStartInfo>
				<Context::ExtractModulesList t.Context>
			>
		> <MOS::System 'refc ' e.ProgName '.ref'>;
}

DefLim = 64;

PutModules
	t.ExeTyper t.Aliases t.StartInfo t.Context e.Modules =
		<DoPutModules
			t.ExeTyper
			t.Aliases
			<CreateStartInfo t.StartInfo t.Context e.Modules>
			e.Modules
		>;


DoPutModules {
	t.ExeTyper t.Aliases t.Context t.StartInfo
	(e.NextName) e.Tail =
		<DoPutModules
			<PutModule
				t.ExeTyper t.Aliases
				(e.NextName)
				<Context::ExtractOption
					t.Context
					Out
					e.NextName
				>
			>
			t.StartInfo e.Tail
		>;

	t.ExeTyper t.Aliases t.Context t.StartInfo =
		t.ExeTyper t.Aliases t.Context t.StartInfo;
}

PutModule {
	t.ExeTyper t.Aliases (e.ModuleName) t.Context Found e.OutName =
		<TypeContent
			t.ExeTyper
			t.Aliases
			e.OutName
		>
		t.Context;
}

/*
	<CreateStartInfo
		t.StartInfo t.Context e.Modules
	> == t.Context t.StartInfo
*/
CreateStartInfo {
	t.StartInfo t.Context (e.NextModuleName) e.Modules =
		<CreateStartInfo
			<UpdateStartInfo
				t.StartInfo
				t.Context
				e.NextModuleName
			>
			e.Modules
		>;

	t.StartInfo t.Context =
		t.Context t.StartInfo;
}

PutStartCaller {
	t.ExeTyper t.Aliases t.Context t.StartInfo =
		t.Context
		<DestroyExeTyperAndAliases
			<TypeStart
				t.StartInfo
				t.ExeTyper
				<OutAliases t.Aliases>
			>
		>;
}

DestroyExeTyperAndAliases
	t.Aliases t.ExeTyper =
		<CloseAliases t.Aliases>
		<MExeTyper::Destroy t.ExeTyper>;

/*------------------------------------------------------------------------------
 Построчное препроцессирование .rout-файлов с их добавлением в выходной файл.

 Последующие Type-функции выполняют построчное препроцессирование .rout-файлов.
 Поскольку содержимое этих файлов сгенерировано автоматически, то можно ожидать,
 что вызовы функций и переменные написаны одноформатно, а вручную создаваемые
 библиотечные файлы написаны с особым вниманием.
------------------------------------------------------------------------------*/

// <TypeContext t.ExeTyper t.Aliases e.FileName> ==  t.ExeTyper t.Aliases
TypeContent {
	t.ExeTyper t.Aliases e.FileName =
		<DoTypeContent
			t.Aliases t.ExeTyper <LoadLines e.FileName>
		>;
}

LoadLines
	e.FileName =
		<GroupLinkUnits
			<DoLoadLines
				<FileIO::Load e.FileName>
			>
		>;

GroupLinkUnits {
	(Banner e.Banner) e.Lines =
		<GroupOneLinkUnit
			((e.Banner)) e.Lines
		>;

	= ;
}

GroupOneLinkUnit {
	(e.Unit) (Code e.CodeLine) e.Lines =
		<GroupOneLinkUnit
			(e.Unit (e.CodeLine)) e.Lines
		>;

	(e.Unit) (Banner e.Banner) e.Lines =
		(e.Unit)
		<GroupLinkUnits (Banner e.Banner) e.Lines>;

	(e.Unit) = (e.Unit);
}

DoLoadLines {
	= ;

	(e.NextLine) e.Lines =
		<AnalyseLine (e.NextLine)>
		<DoLoadLines e.Lines>;
}
		

DoTypeContent {
	t.Aliases t.ExeTyper =
		t.ExeTyper t.Aliases;

	t.Aliases t.ExeTyper (e.NextUnit) e.Units =
		<DoTypeContent
			<TypeUnit t.Aliases t.ExeTyper e.NextUnit>
			e.Units
		>;
}

TypeUnit {
	t.Aliases t.ExeTyper (e.Banner) e.Lines =
		<DoTypeUnits
			t.Aliases
			<MExeTyper::TypeComment t.ExeTyper e.Banner>
			e.Lines
		>;
}

DoTypeUnits {
	t.Aliases t.ExeTyper =
		t.Aliases t.ExeTyper;

	t.Aliases t.ExeTyper (e.NextLine) e.Lines =
		<DoTypeUnits
			<TypeLine t.Aliases t.ExeTyper e.NextLine>
			e.Lines
		>;
}

AnalyseLine {
	('b ' e.BannerLine) = (Banner e.BannerLine);

	('r ' e.?RemarkLine) = ;

	('c ' e.CodeLine) = (Code <HideQuotes e.CodeLine>);

	() = ;
}

HideQuotes {
	'\'' e.Tail = <StartHidingQuote ('\'') e.Tail>;
	'\"' e.Tail = <StartHidingQuote ('\"') e.Tail>;
	s.Other e.Tail = s.Other <HideQuotes e.Tail>;
	= ;
}

StartHidingQuote {
	(s.Quote e.Hidden) '\\' s.Escaped e.Tail =
		<StartHidingQuote (s.Quote e.Hidden '\\' s.Escaped) e.Tail>;

	(s.Quote e.Hidden) s.Quote e.Tail =
		(s.Quote e.Hidden) <HideQuotes e.Tail>;

	(s.Quote e.Hidden) s.Other e.Tail =
		<StartHidingQuote (s.Quote e.Hidden s.Other) e.Tail>;

	(s.Quote e.Hidden) =
		<MError::LinkError
			'May be unballanced quote in StartHidingQoute'
		>;
}

TypeLine {
	t.Aliases t.ExeTyper =
		t.Aliases t.ExeTyper;

	t.Aliases t.ExeTyper e.Line =
		<TypeLine
			<SwTypeContent
				t.Aliases t.ExeTyper e.Line
			>
		>;
}

SwTypeContent {
	t.Aliases t.ExeTyper (s.Quote e.HiddenQuote) e.Raw =
		t.Aliases
		<MExeTyper::TypeQuoted
			t.ExeTyper s.Quote e.HiddenQuote
		> e.Raw;

	t.Aliases t.ExeTyper '$$' e.Raw =
		t.Aliases <MExeTyper::TypeChar t.ExeTyper '$'> e.Raw;

	t.Aliases t.ExeTyper '$' e.FnName '$' e.Raw =
		<TypeRenamed
			( <LookupAlias t.Aliases e.FnName> )
			t.ExeTyper e.Raw
		>;

	t.Aliases t.ExeTyper s.Char e.Raw =
		t.Aliases
		<MExeTyper::TypeChar t.ExeTyper s.Char>
		e.Raw;
}

TypeRenamed
	(t.Aliases e.FnAlias) t.ExeTyper e.Raw =
		t.Aliases <MExeTyper::TypeRenamed t.ExeTyper e.FnAlias> e.Raw;

*-------------------------------------------------------------------------------
* Хранилище информации о точках запуска модулей (функций Go, Init и Final)
*-------------------------------------------------------------------------------

NewStartInfo {
	= ( (/* InitList */) (/* Go */) (/* FinalList */) );
}

/**
	<UpdateStartInfo t.StartInfo t.Context e.ModuleName>
		== t.StartInfo t.Context
*/
UpdateStartInfo {
	t.StartInfo t.Context e.ModuleName =
		<UpdateInitList
			t.StartInfo
			<MSymModule::LoadInfo t.Context () e.ModuleName>
		>;
}

UpdateInitList {
	( (e.InitList) t.GoInfo t.FinalList )
	t.Context
	( Module () e.ModuleName )
	( Functions e.Fn-B ('Init') e.Fn-E )
	( Imports e.Imports ) =
		<UpdateGoInfo
			( (e.InitList ('Entry::' e.ModuleName '::Init')) t.GoInfo t.FinalList )
			( e.ModuleName )
			( Functions e.Fn-B e.Fn-E )
		> t.Context;

	t.StartInfo t.Context
	( Module () e.ModuleName )
	( Functions e.FnList )
	( Imports e.Imports ) =
		<UpdateGoInfo
			t.StartInfo
			( e.ModuleName )
			( Functions e.FnList )
		> t.Context;
}

UpdateGoInfo {
	( t.Inits () t.Finals )
	( e.ModuleName )
	( Functions e.Fn-B ('Go') e.Fn-E ) =
		<UpdateFinalList
			( t.Inits ('Entry::' e.ModuleName '::Go') t.Finals )
			( e.ModuleName )
			( Functions e.Fn-B e.Fn-E )
		>;

	( t.Inits (e.OtherGo) t.Finals )
	( e.ModuleName )
	( Functions e.Fn-B ('Go') e.Fn-E ) =
		<MError::LinkError
			'Found two Go functions: ' e.OtherGo ' and Entry::' e.ModuleName '::Go'
		>;

	( t.Inits (e.GoInfo) t.Finals )
	( e.ModuleName )
	( Functions e.FnList ) =
		<UpdateFinalList
			( t.Inits (e.GoInfo) t.Finals )
			( e.ModuleName )
			( Functions e.FnList )
		>;
}

UpdateFinalList {
	( t.Inits t.GoInfo (e.Finals) )
	( e.ModuleName )
	( Functions e.Fn-B ('Final') e.Fn-E ) =
		// Финализаторы выполняются в порядке, обратном инициализаторам
		( t.Inits t.GoInfo (('Entry::' e.ModuleName '::Final') e.Finals) );

	( t.Inits t.GoInfo t.Finals )
	( e.ModuleName )
	( Functions e.FnList ) =
		( t.Inits t.GoInfo t.Finals );
}

// <TypeStart t.StartInfo t.ExeTyper t.Aliases> == t.ExeTyper t.Aliases
TypeStart {
	( t.InitFuncs () t.FinalFuncs ) t.ExeTyper t.Aliases =
		<MError::LinkError 'Startfunction not found'>;

	( (e.InitFuncs) t.GoFunction (e.FinalFuncs) ) t.ExeTyper t.Aliases =
		<TypeCallSeq
			t.ExeTyper
			t.Aliases
			e.InitFuncs t.GoFunction e.FinalFuncs
		>;
}

TypeCallSeq {
	t.ExeTyper t.Aliases e.FunList =
		<TypeUnit
			t.Aliases t.ExeTyper
			('Starter')
			('$ENTRY Go { =')
			<DoTypeCallSeq e.FunList>
			(';}')
		>;
}

DoTypeCallSeq {
	(e.NextFunc) e.Funcs =
		('\t<$' e.NextFunc '$>')
		<DoTypeCallSeq e.Funcs>;

	= ;
}

/*------------------------------------------------------------------------------
 Таблица псевдонимов для замены имён функций и индексов переменных на более
 короткие (для индексов переменных это не особо актуально, а вот для имён
 функций необходимо, т.к. Рефал-5 не переваривает строки длиннее 260 символов,
 а квалифицированные имена функций достаточно длинны).
 Формат таблицы псевдонимов ( (e.Nums) (e.Name(e.Alias))* )
	e.Nums -- номера, преписываемые следующему псевдониму,
		e.Nums := (s.Categ e.Num)*
	e.Name -- оригинальное имя (типа 'NextToken' или '.Context')
	e.Alias -- псевдоним
------------------------------------------------------------------------------*/

NewAliasesTable {
	= ( () );
}

LookupAlias {
	( t.Num e.Aliases-B ( e.Name (e.Alias) ) e.Aliases-E )
	e.Name =
		( t.Num ( e.Name (e.Alias) ) e.Aliases-B e.Aliases-E )
		e.Alias;

	( t.Num e.Aliases ) e.Name =
		<LookupAlias
			( <NewAlias t.Num e.Name> e.Aliases )
			e.Name
		>;
}

CategChar {
	'Index' = 'i'; 'Local' = 'L'; 'Entry' = 'E';
	'Swap' = 'S'; 'Ident' = 'W'; 'ADT' = 'T';
}

NewAlias {
	/* Все */
	t.Num e.CategStr '::' e.Name =
		<NewAliasAux
			<CategChar e.CategStr>
			t.Num e.CategStr '::' e.Name
		>;
}

NewAliasAux
	s.CategChar t.Num e.NameInRout =
		<NewAliasAuxWithNumber
			s.CategChar
			<IncCateg t.Num s.CategChar>
			(e.NameInRout)
		>;

NewAliasAuxWithNumber
	s.CategChar t.Num e.AliasNumber (e.NameInRout) =
		t.Num
		(e.NameInRout (s.CategChar e.AliasNumber));

// <IncCateg t.Num s.Categ> == t.UpdatedNum s.CatNumber
IncCateg {
	(e.Nums-B (s.Categ e.Num) e.Nums-E) s.Categ =
		((s.Categ <IncStringIndex e.Num>) e.Nums-B e.Nums-E) e.Num;

	(e.Nums) s.Categ =
		<IncCateg ((s.Categ) e.Nums) s.Categ>;
}

IncStringIndex
	e.Num =
		<IncStringIndexAux
			(e.Num) <CharDigitsSeq>
		>;

CharDigitsSeq =
	'0123456789'
	'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	'abcdefghijklmnopqrstuvwxyz';

IncStringIndexAux {
	(s.Last) s.Zero s.First e.Seq s.Last =
		s.First s.Zero;

	(e.Num s.Last) s.Zero e.Seq s.Last =
		<IncStringIndexAux
			(e.Num) s.Zero e.Seq s.Last
		> s.Zero;

	(e.Num s.Last) e.Seq-B s.Last s.Next e.Seq-E =
		e.Num s.Next;

	() s.First e.Seq-E = s.First;
}

OutAliases {
	( t.Num e.Aliases ) =
		( t.Num e.Aliases )
		<UserTypeAliases
			<FileIO::Open 'w' <MCreateDirIfNeed::InfoDir> '/Aliases.als'>
			<SortAliases e.Aliases>
		>;
}

SortAliases
	e.Aliases =
		<DoDecode <MOrder::Sort <DoCode e.Aliases>>>;

DoCode {
	t.Next e.Tail =
		<Code t.Next> <DoCode e.Tail>;

	= ;
}

Code
	( e.Name (s.Categ e.Index) ) =
		( (s.Categ <MStrings::Length-T e.Index>) e.Name );

DoDecode {
	t.Next e.Tail =
		<Decode t.Next> <DoDecode e.Tail>;

	= ;
}

Decode
	( (s.Categ s.Length e.Index) e.Name ) =
		( e.Name (s.Categ e.Index) );

UserTypeAliases {
	//Пропускаем индексы переменных.
	t.FAli ('Index::' e.Name ('i' e.Alias)) e.Tail =
		<UserTypeAliases
			t.FAli e.Tail
		>;

	t.FAli (e.Categ '::' e.Name (e.Alias)) e.Tail =
		<UserTypeAliases
			<FileIO::WriteLine t.FAli e.Alias ' --> ' e.Name>
			e.Tail
		>;

	t.FAli =
		<FileIO::Close t.FAli>;
}

CloseAliases {
	( t.Num e.Aliases ) = ;
}

$END MLinker.
