$MODULE MModules;

$IMPORT MBE-Mgr;
$IMPORT MContext;
$IMPORT MFE-Mgr;
$IMPORT MFileSystem;
$IMPORT MLambda;
$IMPORT MSelfDiag;
$IMPORT MStrings;
$IMPORT MQualifiedName;

/**
  <LookupCmdLineModule
    t.hContext (e.ModulePath) e.CmdLinePath
  >
    == t.hContext Found
      t.QualifiedName s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath =
    <GenVariants-CmdLine
        t.hContext (e.ModulePath)
        <ParseFileNameEx e.CmdLinePath>
    >;

/*
  <ParseFileNameEx e.FileName>
    == s.PathType (e.Directory) e.FileNameNoExt (e.Ext)
  s.PathType ::= Relative | Absolut

  Не смотря на то, что путь типа D:Directory\File фактически
  является относительным, здесь буду считать абсолютным, т.к.
  из него нельзя построить напрямую квалифицированное имя.
*/
ParseFileNameEx
  e.FileName =
    <SwParseFileName
      <MFileSystem::ParseFileName e.FileName>
    >;

SwParseFileName {
  (s.Disk ':' e.Tail) e.FileName (e.Ext) =
    Absolut (s.Disk ':' e.Tail) e.FileName (e.Ext);

  ('/' e.Tail) e.FileName (e.Ext) =
    Absolut ('/' e.Tail) e.FileName (e.Ext);

  ('\\' e.Tail) e.FileName (e.Ext) =
    Absolut ('\\' e.Tail) e.FileName (e.Ext);

  (e.Directory) e.FileName (e.Ext) =
    Relative (e.Directory) e.FileName (e.Ext);
}

GenVariants-CmdLine
  t.hContext (e.ModulePath) s.PathType (e.Folder) e.FileName (e.Ext) =
    <GenVariants-CmdLine-Aux
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft & CrossName (e.Folder)>
        e.ModulePath
      >
      <MakeAppendNames s.PathType (e.Folder) e.ModulePath>
      (e.FileName)
      (
        <AvailFrontEnds
          <MStrings::Lower e.Ext>
        >
      )
    >;

MakeAppendNames {
  Relative (e.Folder) e.ModulePath =
    <MLambda::Map
      <MLambda::BindLeft & AppendName (e.Folder)>
      e.ModulePath
    >;

  Absolut (e.Folder) e.ModulePath =
    /* Ничего */;
}

/*
  <CrossName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
CrossName
  (e.L-Folder) (e.MPDirectory) =
    <DoCrossName
      ( <MFileSystem::CanonicalPath e.L-Folder> )
      ( <MFileSystem::CanonicalPath e.MPDirectory> )
      () e.L-Folder
    >;

DoCrossName {
  // C- -- canonical

  ( s.C-Next e.C-ModuleFolder ) ( s.C-Next e.C-MPDirectory )
  ( e.Scanned ) s.Next e.ModuleFolder =
    <DoCrossName
      ( e.C-ModuleFolder ) ( e.C-MPDirectory )
      ( e.Scanned s.Next ) e.ModuleFolder
    >;

  // Начало e.[C-]ModuleFolder совпадает с e.C-MPDirectory
  ( e.C-ModuleFolder-Tail ) () (e.BaseFolder) e.ModuleFolder-Tail =
    ( e.BaseFolder <QNameFromRelativePath e.ModuleFolder-Tail> );

  // Не совпадает
  ( e.C-ModuleFolder ) ( e.C-MPDirectory )
  ( e.Scanned ) e.ModuleFolder =
    /* Пусто */;
}

/*
  <AppendName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
AppendName
  (e.L-Folder) (e.MPDirectory) =
    ( e.MPDirectory <QNameFromRelativePath e.L-Folder> );

QNameFromRelativePath
  e.Path =
    <MQualifiedName::Create
      <SlashParse e.Path>
    >;

SlashParse
  e.Path =
    <DeleteAccum
      <MLambda::MapReduce
        & SlashParse-A () e.Path
      >
    >;

// автомат
SlashParse-A {
  // Пустые сегменты игнорируем
  () '\\' = ();
  () '/' = ();

  // Непустой сегмент выбрасываем
  (e.Segment) '\\' = () (e.Segment);
  (e.Segment) '/' = () (e.Segment);

  // Любой другой символ сохраняем
  (e.Segment) s.Next = (e.Segment s.Next);
}

DeleteAccum
  t.Accum e.Scanned = e.Scanned;

AvailFrontEnds {
  // Расширение не указано -- все доступные front-end'ы
  = <MFE-Mgr::GetList>;

  // Фильтруем по расширению
  e.Ext =
    <MLambda::Map
      <MLambda::BindRight & FilterBackEnd e.Ext>
      <MLambda::Map
        <MLambda::Composite
          & MFE-Mgr.GetExt-T
          & MLambda.Bracket
        >
        <MFE-Mgr::GetList>
      >
    >;
}

FilterBackEnd {
  ( s.BackEnd e.Ext ) e.Ext = s.BackEnd;

  ( s.BackEnd e.Ext1 ) e.Ext2 = ;
}

GenVariants-CmdLine-Aux {
  /*
    То, что front-end'ов нет, означает, что расширение неправильное.
    Выдавать осмысленную ошибку пока не будем, достаточно сообщения
    об отсутствии модуля.
  */
  t.hContext e.RawVariants (e.ModuleName) () =
    t.hContext NotFound;

  t.hContext e.RawVariants (e.ModuleName) (e.AvailFrontEnds) =
    <CheckVariants
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft & FinishVariant e.ModuleName>
        <MStrings::Decart (e.RawVariants ) (e.AvailFrontEnds Library)>
      >
    >;
}

FinishVariant
  e.L-ModuleName ( (e.BaseDirectory t.QualifiedPacketName) s.FrontEnd ) =
    ( s.FrontEnd
      <MQualifiedName::AddSubName t.QualifiedPacketName e.L-ModuleName>
      e.BaseDirectory
    );

//------------------------------------------------------------------------------

/**
  <LookupImportModule
    t.hContext (e.ModulePath) t.QualifiedName
  >
    == t.hContext Found s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupImportModule
  t.hContext (e.ModulePath) t.QualifiedName =
    <LookupImportModule-SwKnown
      (e.ModulePath)
      t.QualifiedName
      <MContext::ExtractOption
        t.hContext t.QualifiedName FrontEnd
      >
   >;


LookupImportModule-SwKnown {
  (e.ModulePath) t.QualifiedName
  t.hContext Found None =
    <LookupImportModule-Known
      t.QualifiedName Library
      <MContext::ExtractOption
        t.hContext
        t.QualifiedName
        BaseDirectory
      >
    >;

  (e.ModulePath) t.QualifiedName
  t.hContext Found s.FrontEnd e.Path =
    <LookupImportModule-Known
       t.QualifiedName s.FrontEnd
       <MContext::ExtractOption
         t.hContext
         t.QualifiedName
         BaseDirectory
       >
     >;

  (e.ModulePath) t.QualifiedName t.hContext
  ModuleNotFound =
    <LookupImportModule-Unknown
      t.hContext t.QualifiedName e.ModulePath
    >;

  (e.ModulePath) t.QualifiedName t.hContext
  MismatchCase =
    t.hContext NotFound;
}

LookupImportModule-Known {
  t.QualifiedName s.FrontEnd
  t.hContext Found e.BaseDirectory =
    t.hContext Found s.FrontEnd e.BaseDirectory;

  // Остальное -- нарушение инварианта
}

LookupImportModule-Unknown
  t.hContext t.QualifiedName e.ModulePath =
    <CheckVariants-Import-CorrectFormat
      <CheckVariants
        t.hContext
        <MLambda::Map
          <MLambda::BindLeft
            & MakeImportVariant t.QualifiedName
          >
          <MStrings::Decart
            (e.ModulePath) ( <MFE-Mgr::GetList> Library )
          >
        >
      >
    >;

MakeImportVariant
  t.L-ModuleName ((e.MP-Catalog) s.FrontEnd) =
    ( s.FrontEnd t.L-ModuleName e.MP-Catalog );

CheckVariants-Import-CorrectFormat {
  t.hContext Found t.QualifiedName s.FrontEnd e.BaseDirectory =
    t.hContext Found s.FrontEnd e.BaseDirectory;

  t.hContext NotFound =
    t.hContext NotFound;
}

//------------------------------------------------------------------------------

/*
  <CheckVariants t.hContext e.Variants>
    == t.hContext Found t.QualifiedName s.FrontEnd e.BaseDirectory
    == t.hContext NonFound;
*/
CheckVariants
  t.hContext e.Variants =
    <DoCheckVariants-CmdLine
      t.hContext e.Variants
    >;

DoCheckVariants-CmdLine {
  t.hContext (s.FrontEnd t.QualifiedName e.BaseDirectory) e.Tail =
    <SwDoCheckVariant-CmdLine
      <CheckVariant-T
        t.hContext
        s.FrontEnd t.QualifiedName e.BaseDirectory
      >
      e.Tail
    >;

  t.hContext = t.hContext NotFound;
}

CheckVariant-T {
  t.hContext Library t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-LibAux
      t.hContext t.QualifiedName
      <MLambda::Map
        <MLambda::Composite
          <MLambda::Parallel
            & MLambda.Identity
            <MLambda::BindRight
              & MBE-Mgr.GetPath-T
              t.QualifiedName e.BaseDirectory
            >
          >
          & MLambda.Bracket
        >
        <MBE-Mgr::GetList>
      >
      (e.BaseDirectory)
    >;

  t.hContext s.FrontEnd t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-SrcAux
      t.hContext
      <MFE-Mgr::GetPath-T s.FrontEnd t.QualifiedName e.BaseDirectory>
      (s.FrontEnd e.BaseDirectory)
    >;
}

CheckVariant-T-SrcAux {
  t.hContext
  Success t.QualifiedName e.FilePath (s.FrontEnd e.BaseDirectory) =
    <CheckVariant-T-SrcAux-SwExist
      t.hContext
      (s.FrontEnd t.QualifiedName e.BaseDirectory)
      <MFileSystem::ExistFile-T e.FilePath>
    >;

  t.hContext
  Fails t.QualifiedName (s.FrontEnd e.BaseDirectory) =
    t.hContext (NotFound);
}

CheckVariant-T-SrcAux-SwExist {
  t.hContext
  (s.FrontEnd t.QualifiedName e.BaseDirectory)
  True e.FrontEndName =
    <GuardInvariant
      <MContext::UpdateInfo
        t.hContext t.QualifiedName
        (FrontEnd s.FrontEnd e.FrontEndName)
        (Type Source)
        (Status_NEW Found)
        (BaseDirectory <SelectBaseDirectory e.BaseDirectory>)
      >
    >
    (Found t.QualifiedName s.FrontEnd e.BaseDirectory);

  t.hContext
  (s.FrontEnd t.QualifiedName e.BaseDirectory)
  False e.FrontEndName =
    t.hContext NotFound;
}

GuardInvariant
  t.hContext Success = t.hContext;

SelectBaseDirectory {
  '.' = Current;

  e.BaseDirectory = e.BaseDirectory;
}

CheckVariant-T-LibAux {
  t.hContext t.QualifiedName
  e.BE-Files-B (s.BackEnd Fails t.QualifiedName-Internal) e.BE-Files-E
  (e.BaseDirectory) =
    t.hContext (NotFound);

  t.hContext t.QualifiedName e.BE-Files (e.BaseDirectory) =
    <CheckVariant-T-LibAux-SwExist
      t.hContext t.QualifiedName (e.BaseDirectory)
      <MLambda::Map
        &Lib-CheckExist e.BE-Files
      >
    >;
}

Lib-CheckExist {
  ( s.BackEnd Success t.QualifiedName e.FilePath ) =
    <SwLib-CheckExist
      s.BackEnd <MFileSystem::ExistFile-T e.FilePath>
    >;
}

SwLib-CheckExist {
  s.BackEnd True e.FilePath =
    (s.BackEnd e.FilePath);

  s.BackEnd False e.FilePath =
    NotExist;
}

CheckVariant-T-LibAux-SwExist {
  t.hContext t.QualifiedName (e.BaseDirectory)
  e.BE-Files-B NotExist e.BE-Files-E =
    t.hContext NotFound;

  t.hContext t.QualifiedName (e.BaseDirectory) e.BE-Files =
    <GuardInvariant
      <MContext::UpdateInfo
        t.hContext t.QualifiedName
        (FrontEnd None)
        (BackEnds e.BE-Files)
        (Type Library)
        (Status_NEW Found)
        (BaseDirectory <SelectBaseDirectory e.BaseDirectory>)
      >
    >
    (Found t.QualifiedName Library e.BaseDirectory);
}

SwDoCheckVariant-CmdLine {
  t.hContext
  (Found t.QualifiedName s.FrontEndName e.BaseDirectory)
  e.Tail =
    t.hContext Found t.QualifiedName s.FrontEndName e.BaseDirectory;

  t.hContext NotFound e.Tail =
    <DoCheckVariants-CmdLine
      t.hContext e.Tail
    >;
}

//------------------------------------------------------------------------------

/**
  <GetBEList t.hContext t.ModuleName>
    == t.hContext Known (s.BE-Name e.PathToFile)*
    == t.hContext UnKnown
*/
$ENTRY GetBEList
  t.hContext t.ModuleName =
    <GetBEList-CheckKnown
      t.ModuleName
      <MContext::ExtractOption
        t.hContext t.ModuleName Status_NEW
      >
    >;

GetBEList-CheckKnown {
  t.ModuleName t.hContext ModuleNotFound =
    t.hContext UnKnown;

  t.ModuleName t.hContext MismatchCase =
    t.hContext UnKnown;

  t.ModuleName t.hContext Found Unknown =
    t.hContext UnKnown;

  t.ModuleName t.hContext Found s.Type =
    <GetBEList-BackEnds
      t.ModuleName
      <MContext::ExtractOption
        t.hContext t.ModuleName BackEnds
      >
    >;

  /*
    Отсутствие опции не проверяем -- это нарушение инварианта
  */
}

GetBEList-BackEnds {
  t.ModuleName t.hContext Found Unknowns =
    <GetBEList-Finish
      t.ModuleName
      <MLambda::MapReduce
        <MLambda::Composite
          <MLambda::Parallel-H
            <MLambda::MakeHandled & MLambda.Identity>
            <MLambda::BindLeft-H
              & MBE-Mgr.X_GetPath-T
              t.ModuleName
            >
          >
          & MLambda.Bracket-H
        >
        t.hContext
        <MBE-Mgr::GetList>
      >
    >;

  t.ModuleName t.hContext Found e.BackEnds =
    t.hContext Known e.BackEnds;
}

GetBEList-Finish
  t.ModuleName t.hContext e.BackEnds =
    <GetBEList-UpdateBackEnds
      t.hContext t.ModuleName
      <MLambda::Map & ToPairNameFile e.BackEnds>
    >;

ToPairNameFile
  (s.BackEnd t.ModuleName Success e.Path) = (s.BackEnd e.Path);

GetBEList-UpdateBackEnds
  t.hContext t.ModuleName e.BackEnds =
    <GuardUpdateBackEnds
      <MContext::UpdateInfo
        t.hContext t.ModuleName 
        (BackEnds e.BackEnds)
      >
    >
    Known e.BackEnds;

GuardUpdateBackEnds
  t.hContext Success = t.hContext;

//------------------------------------------------------------------------------

/**
  <GetFEName t.hContext t.ModuleName>
    == t.hContext Known Library
    == t.hContext Known s.FE-Name e.PathToFile
    == t.hContext UnKnown
*/
$ENTRY GetFEName
  t.hContext t.ModuleName =
    <GetFEName-CheckKnown
      t.ModuleName
      <MContext::ExtractOption t.hContext t.ModuleName Status_NEW>
    >;

GetFEName-CheckKnown {
  t.ModuleName t.hContext ModuleNotFound =
    t.hContext UnKnown;

  t.ModuleName t.hContext MismatchCase =
    t.hContext UnKnown;

  t.ModuleName t.hContext Found Unknown =
    t.hContext UnKnown;

  t.ModuleName t.hContext Found s.Other =
    <GetFEName-Aux
      t.ModuleName
      <MContext::ExtractOption t.hContext t.ModuleName FrontEnd>
    >;
}

GetFEName-Aux {
  t.ModuleName t.hContext Found Unknowns =
    /*
      Неожиданно. Если модуль уже известен, то он должен оказаться либо
      библиотечным, либо иметь свой front-end.
    */
    <MSelfDiag::FailDown
      & GetFEName-Aux t.ModuleName t.hContext Found Unknowns
    >;

  t.ModuleName t.hContext Found None =
    t.hContext Known Library;

  t.ModuleName t.hContext Found s.FrontEnd e.Path =
    t.hContext Known s.FrontEnd e.Path;
}

$END MModules.
