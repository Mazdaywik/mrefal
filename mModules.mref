$MODULE MModules;

$IMPORT MBE-Mgr;
$IMPORT MContext;
$IMPORT MFE-Mgr;
$IMPORT MFileSystem;
$IMPORT MLambda;
$IMPORT MSelfDiag;
$IMPORT MStrings;
$IMPORT MQualifiedName;

/**
  <LookupCmdLineModule
    t.hContext (e.ModulePath) e.CmdLinePath
  >
    == t.hContext Found
      t.QualifiedName s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath =
    <GenVariants-CmdLine
        t.hContext (e.ModulePath)
        <ParseFileNameEx e.CmdLinePath>
    >;

/*
  <ParseFileNameEx e.FileName>
    == s.PathType (e.Directory) e.FileNameNoExt (e.Ext)
  s.PathType ::= Relative | Absolut

  Не смотря на то, что путь типа D:Directory\File фактически
  является относительным, здесь буду считать абсолютным, т.к.
  из него нельзя построить напрямую квалифицированное имя.
*/
ParseFileNameEx
  e.FileName =
    <SwParseFileName
      <MFileSystem::ParseFileName e.FileName>
    >;

SwParseFileName {
  (s.Disk ':' e.Tail) e.FileName (e.Ext) =
    Absolut (s.Disk ':' e.Tail) e.FileName (e.Ext);

  ('/' e.Tail) e.FileName (e.Ext) =
    Absolut ('/' e.Tail) e.FileName (e.Ext);

  ('\\' e.Tail) e.FileName (e.Ext) =
    Absolut ('\\' e.Tail) e.FileName (e.Ext);

  (e.Directory) e.FileName (e.Ext) =
    Relative (e.Directory) e.FileName (e.Ext);
}

GenVariants-CmdLine
  t.hContext (e.ModulePath) s.PathType (e.Folder) e.FileName (e.Ext) =
    <GenVariants-CmdLine-Aux
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft & CrossName (e.Folder)>
        e.ModulePath
      >
      <MakeAppendNames s.PathType (e.Folder) e.ModulePath>
      (e.FileName)
      (
        <AvailFrontEnds
          <MStrings::Lower e.Ext>
        >
      )
    >;

MakeAppendNames {
  Relative (e.Folder) e.ModulePath =
    <MLambda::Map
      <MLambda::BindLeft & AppendName (e.Folder)>
      e.ModulePath
    >;

  Absolut (e.Folder) e.ModulePath =
    /* Ничего */;
}

/*
  <CrossName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
CrossName
  (e.L-Folder) (e.MPDirectory) =
    <DoCrossName
      ( <MFileSystem::CanonicalPath e.L-Folder> )
      ( <MFileSystem::CanonicalPath e.MPDirectory> )
      () e.L-Folder
    >;

DoCrossName {
  // C- -- canonical

  ( s.C-Next e.C-ModuleFolder ) ( s.C-Next e.C-MPDirectory )
  ( e.Scanned ) s.Next e.ModuleFolder =
    <DoCrossName
      ( e.C-ModuleFolder ) ( e.C-MPDirectory )
      ( e.Scanned s.Next ) e.ModuleFolder
    >;

  // Начало e.[C-]ModuleFolder совпадает с e.C-MPDirectory
  ( e.C-ModuleFolder-Tail ) () (e.BaseFolder) e.ModuleFolder-Tail =
    ( e.BaseFolder <QNameFromRelativePath e.ModuleFolder-Tail> );

  // Не совпадает
  ( e.C-ModuleFolder ) ( e.C-MPDirectory )
  ( e.Scanned ) e.ModuleFolder =
    /* Пусто */;
}

/*
  <AppendName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
AppendName
  (e.L-Folder) (e.MPDirectory) =
    ( e.MPDirectory <QNameFromRelativePath e.L-Folder> );

QNameFromRelativePath
  e.Path =
    <MQualifiedName::Create
      <SlashParse e.Path>
    >;

SlashParse
  e.Path =
    <DeleteAccum
      <MLambda::MapReduce
        & SlashParse-A () e.Path
      >
    >;

// автомат
SlashParse-A {
  // Пустые сегменты игнорируем
  () '\\' = ();
  () '/' = ();

  // Непустой сегмент выбрасываем
  (e.Segment) '\\' = () (e.Segment);
  (e.Segment) '/' = () (e.Segment);

  // Любой другой символ сохраняем
  (e.Segment) s.Next = (e.Segment s.Next);
}

DeleteAccum
  t.Accum e.Scanned = e.Scanned;

AvailFrontEnds {
  // Расширение не указано -- все доступные front-end'ы
  = <MFE-Mgr::GetList>;

  // Фильтруем по расширению
  e.Ext =
    <MLambda::Map
      <MLambda::BindRight & FilterBackEnd e.Ext>
      <MLambda::Map
        <MLambda::Composite
          & MFE-Mgr.GetExt-T
          & MLambda.Bracket
        >
        <MFE-Mgr::GetList>
      >
    >;
}

FilterBackEnd {
  ( s.BackEnd e.Ext ) e.Ext = s.BackEnd;

  ( s.BackEnd e.Ext1 ) e.Ext2 = ;
}

GenVariants-CmdLine-Aux {
  /*
    То, что front-end'ов нет, означает, что расширение неправильное.
    Выдавать осмысленную ошибку пока не будем, достаточно сообщения
    об отсутствии модуля.
  */
  t.hContext e.RawVariants (e.ModuleName) () =
    t.hContext NotFound;

  t.hContext e.RawVariants (e.ModuleName) (e.AvailFrontEnds) =
    <CorrectFormat-CmdLine
      <CheckVariants
        t.hContext
        <MLambda::Map
          <MLambda::BindLeft & FinishVariant e.ModuleName>
          <MStrings::Decart (e.RawVariants ) (e.AvailFrontEnds Library)>
        >
      >
    >;
}

FinishVariant
  e.L-ModuleName ( (e.BaseDirectory t.QualifiedPacketName) s.FrontEnd ) =
    ( s.FrontEnd
      <MQualifiedName::AddSubName t.QualifiedPacketName e.L-ModuleName>
      e.BaseDirectory
    );

CorrectFormat-CmdLine {
  t.hContext Found s.Type t.ModuleName s.FrontEnd e.BaseDirectory =
    t.hContext Found t.ModuleName s.FrontEnd e.BaseDirectory;

  t.hContext NotFound = t.hContext NotFound;
}

//------------------------------------------------------------------------------

/**
  <LookupImportModule
    t.hContext (e.ModulePath) t.QualifiedName
  >
    == t.hContext Success s.Status s.Type
    == t.hContext Fails MismatchCase
*/
$ENTRY LookupImportModule
  t.hContext (e.ModulePath) t.ModuleName =
    <LookupImportModule-SwKnown
      (e.ModulePath)
      t.ModuleName
      <MContext::GetStatusType t.hContext t.ModuleName>
   >;

LookupImportModule-SwKnown {
  (e.ModulePath) t.ModuleName
  t.hContext Success s.Status s.Type =
    t.hContext Success s.Status s.Type;

  (e.ModulePath) t.ModuleName
  t.hContext Fails ModuleNotFound =
    <LookupImportModule-Unknown
      t.hContext t.ModuleName e.ModulePath
    >;

  (e.ModulePath) t.ModuleName
  t.hContext Fails MismatchCase =
    t.hContext Fails MismatchCase;
}

LookupImportModule-Unknown
  t.hContext t.QualifiedName e.ModulePath =
    <CheckVariants-Import-CorrectFormat
      t.QualifiedName
      <CheckVariants
        t.hContext
        <MLambda::Map
          <MLambda::BindLeft
            & MakeImportVariant t.QualifiedName
          >
          <MStrings::Decart
            (e.ModulePath) ( <MFE-Mgr::GetList> Library )
          >
        >
      >
    >;

MakeImportVariant
  t.L-ModuleName ((e.MP-Catalog) s.FrontEnd) =
    ( s.FrontEnd t.L-ModuleName e.MP-Catalog );

CheckVariants-Import-CorrectFormat {
  t.ModuleName
  t.hContext Found s.Type t.QualifiedName s.FrontEnd e.BaseDirectory =
    t.hContext Success Found s.Type;

  t.ModuleName
  t.hContext NotFound =
    <GuardInvariant
      <MContext::CreateModule
        t.hContext t.ModuleName
        (Type Errors)
        (FrontEnd None)
        (BackEnds Unknown)
      >
    >
    Success Found Errors;
}

//------------------------------------------------------------------------------

/*
  <CheckVariants t.hContext e.Variants>
    == t.hContext Found s.Type t.QualifiedName s.FrontEnd e.BaseDirectory
    == t.hContext NonFound;
*/
CheckVariants
  t.hContext e.Variants =
    <DoCheckVariants
      t.hContext e.Variants
    >;

DoCheckVariants {
  t.hContext (s.FrontEnd t.QualifiedName e.BaseDirectory) e.Tail =
    <SwDoCheckVariant
      <CheckVariant-T
        t.hContext
        s.FrontEnd t.QualifiedName e.BaseDirectory
      >
      e.Tail
    >;

  t.hContext = t.hContext NotFound;
}

SwDoCheckVariant {
  t.hContext
  (Found s.Type t.QualifiedName s.FrontEndName e.BaseDirectory)
  e.Tail =
    t.hContext Found s.Type t.QualifiedName s.FrontEndName e.BaseDirectory;

  t.hContext NotFound e.Tail =
    <DoCheckVariants
      t.hContext e.Tail
    >;
}

CheckVariant-T {
  t.hContext Library t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-LibAux
      t.hContext t.QualifiedName
      <MLambda::Map
        <MLambda::Composite
          <MLambda::Parallel
            & MLambda.Identity
            <MLambda::BindRight
              & MBE-Mgr.GetPath-T
              t.QualifiedName e.BaseDirectory
            >
          >
          & MLambda.Bracket
        >
        <MBE-Mgr::GetList>
      >
      (e.BaseDirectory)
    >;

  t.hContext s.FrontEnd t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-SrcAux
      t.hContext
      <MFE-Mgr::GetPath-T s.FrontEnd t.QualifiedName e.BaseDirectory>
      (s.FrontEnd e.BaseDirectory)
    >;
}

CheckVariant-T-SrcAux {
  t.hContext
  Success t.QualifiedName e.FilePath (s.FrontEnd e.BaseDirectory) =
    <CheckVariant-T-SrcAux-SwExist
      t.hContext
      (s.FrontEnd t.QualifiedName e.BaseDirectory)
      <MFileSystem::ExistFile-T e.FilePath>
    >;

  t.hContext
  Fails t.QualifiedName (s.FrontEnd e.BaseDirectory) =
    t.hContext (NotFound);
}

CheckVariant-T-SrcAux-SwExist {
  t.hContext
  (s.FrontEnd t.ModuleName e.BaseDirectory)
  True e.FrontEndName =
    <CheckVariant-T-SrcAux-SwExist-Finish
      t.hContext t.ModuleName
      (s.FrontEnd e.FrontEndName)
      (<SelectBaseDirectory e.BaseDirectory>)
      <MLambda::Map
        <MLambda::BindLeft & GetBEPath-CheckExist t.ModuleName e.BaseDirectory>
        <MBE-Mgr::GetList>
      >
    >;

  t.hContext
  (s.FrontEnd t.ModuleName e.BaseDirectory)
  False e.FrontEndName =
    t.hContext NotFound;
}

SelectBaseDirectory {
  '.' = Current;

  e.BaseDirectory = e.BaseDirectory;
}

GetBEPath-CheckExist
  t.ModuleName e.BaseDirectory s.BackEndName =
    <GetBEPath-CheckExist-Aux
      s.BackEndName
      <MBE-Mgr::GetPath-T s.BackEndName t.ModuleName e.BaseDirectory>
    >;

GetBEPath-CheckExist-Aux
  s.BackEndName Success t.ModuleName e.Path =
    (s.BackEndName <MFileSystem::ExistFile-T e.Path>);

CheckVariant-T-SrcAux-SwExist-Finish {
  t.hContext t.ModuleName
  (s.FrontEnd e.FrontEndName)
  (e.BaseDirectory)
  e.BackEnds-B (s.BEName False e.Path) e.BackEnds-E =
    <GuardInvariant
      <MContext::CreateModule
        t.hContext t.ModuleName
        (Type Changed)
        (FrontEnd s.FrontEnd e.FrontEndName)
        (BackEnds
          <MLambda::Map
            & BackEnds-DelTF
            e.BackEnds-B (s.BEName False e.Path) e.BackEnds-E
          >
        )
      >
    >
    (Found Changed t.ModuleName s.FrontEnd e.BaseDirectory);

  t.hContext t.ModuleName
  (s.FrontEnd e.FrontEndName)
  (e.BaseDirectory)
  e.BackEnds =
    <GuardInvariant
      <MContext::CreateModule
        t.hContext t.ModuleName
        (Type Updated)
        (FrontEnd s.FrontEnd e.FrontEndName)
        (BackEnds <MLambda::Map & BackEnds-DelTF e.BackEnds>)
      >
    >
    (Found Updated t.ModuleName s.FrontEnd e.BaseDirectory);
}

BackEnds-DelTF
  (s.BEName s.TrueFalse e.Path) = (s.BEName e.Path);

GuardInvariant
  t.hContext Success = t.hContext;

CheckVariant-T-LibAux {
  t.hContext t.QualifiedName
  e.BE-Files-B (s.BackEnd Fails t.QualifiedName-Internal) e.BE-Files-E
  (e.BaseDirectory) =
    t.hContext (NotFound);

  t.hContext t.QualifiedName e.BE-Files (e.BaseDirectory) =
    <CheckVariant-T-LibAux-SwExist
      t.hContext t.QualifiedName (e.BaseDirectory)
      <MLambda::Map
        &Lib-CheckExist e.BE-Files
      >
    >;
}

Lib-CheckExist {
  ( s.BackEnd Success t.QualifiedName e.FilePath ) =
    <SwLib-CheckExist
      s.BackEnd <MFileSystem::ExistFile-T e.FilePath>
    >;
}

SwLib-CheckExist {
  s.BackEnd True e.FilePath =
    (s.BackEnd e.FilePath);

  s.BackEnd False e.FilePath =
    NotExist;
}

CheckVariant-T-LibAux-SwExist {
  t.hContext t.QualifiedName (e.BaseDirectory)
  e.BE-Files-B NotExist e.BE-Files-E =
    t.hContext NotFound;

  t.hContext t.QualifiedName (e.BaseDirectory) e.BE-Files =
    <GuardInvariant
      <MContext::CreateModule
        t.hContext t.QualifiedName
        (Type Library)
        (FrontEnd None)
        (BackEnds e.BE-Files)
      >
    >
    (Found Library t.QualifiedName Library e.BaseDirectory);
}

$END MModules.
