$MODULE MModules;

$IMPORT MBE-Mgr;
$IMPORT MContext;
$IMPORT MFE-Mgr;
$IMPORT MFileSystem;
$IMPORT MLambda;
$IMPORT MStrings;
$IMPORT MQualifiedName;

/**
  <LookupCmdLineModule
    t.hContext (e.ModulePath) e.CmdLinePath
  >
    == t.hContext Found
      t.QualifiedName s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath =
    <GenVariants-CmdLine
        t.hContext (e.ModulePath)
        <ParseFileNameEx e.CmdLinePath>
    >;

/*
  <ParseFileNameEx e.FileName>
    == s.PathType (e.Directory) e.FileNameNoExt (e.Ext)
  s.PathType ::= Relative | Absolut

  Не смотря на то, что путь типа D:Directory\File фактически
  является относительным, здесь буду считать абсолютным, т.к.
  из него нельзя построить напрямую квалифицированное имя.
*/
ParseFileNameEx
  e.FileName =
    <SwParseFileName
      <MFileSystem::ParseFileName e.FileName>
    >;

SwParseFileName {
  (s.Disk ':' e.Tail) e.FileName (e.Ext) =
    Absolut (s.Disk ':' e.Tail) e.FileName (e.Ext);

  ('/' e.Tail) e.FileName (e.Ext) =
    Absolut ('/' e.Tail) e.FileName (e.Ext);

  ('\\' e.Tail) e.FileName (e.Ext) =
    Absolut ('\\' e.Tail) e.FileName (e.Ext);

  (e.Directory) e.FileName (e.Ext) =
    Relative (e.Directory) e.FileName (e.Ext);
}

GenVariants-CmdLine
  t.hContext (e.ModulePath) s.PathType (e.Folder) e.FileName (e.Ext) =
    <GenVariants-CmdLine-Aux
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft & CrossName (e.Folder)>
        e.ModulePath
      >
      <MakeAppendNames s.PathType (e.Folder) e.ModulePath>
      (e.FileName)
      (
        <AvailFrontEnds
          <MStrings::Lower e.Ext>
        >
      )
    >;

MakeAppendNames {
  Relative (e.Folder) e.ModulePath =
    <MLambda::Map
      <MLambda::BindLeft & AppendName (e.Folder)>
      e.ModulePath
    >;

  Absolut (e.Folder) e.ModulePath =
    /* Ничего */;
}

/*
  <CrossName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
CrossName
  (e.L-Folder) (e.MPDirectory) =
    <DoCrossName
      ( <CanonicalPath e.L-Folder> )
      ( <CanonicalPath e.MPDirectory> )
      () e.L-Folder
    >;

DoCrossName {
  // C- -- canonical

  ( s.C-Next e.C-ModuleFolder ) ( s.C-Next e.C-MPDirectory )
  ( e.Scanned ) s.Next e.ModuleFolder =
    <DoCrossName
      ( e.C-ModuleFolder ) ( e.C-MPDirectory )
      ( e.Scanned s.Next ) e.ModuleFolder
    >;

  // Начало e.[C-]ModuleFolder совпадает с e.C-MPDirectory
  ( e.C-ModuleFolder-Tail ) () (e.BaseFolder) e.ModuleFolder-Tail =
    ( e.BaseFolder <QNameFromRelativePath e.ModuleFolder-Tail> );

  // Не совпадает
  ( e.C-ModuleFolder ) ( e.C-MPDirectory )
  ( e.Scanned ) e.ModuleFolder =
    /* Пусто */;
}

/*
  <AppendName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
AppendName
  (e.L-Folder) (e.MPDirectory) =
    ( e.MPDirectory <QNameFromRelativePath e.L-Folder> );


CanonicalPath
  e.Path = <MLambda::Map & CanonicalChar e.Path>;

CanonicalChar {
  '\\' = '/';
  s.Other = <MStrings::Lower s.Other>;
}

QNameFromRelativePath
  e.Path =
    <MQualifiedName::Create
      <SlashParse e.Path>
    >;

SlashParse
  e.Path =
    <DeleteAccum
      <MLambda::MapReduce
        & SlashParse-A () e.Path
      >
    >;

SlashParse-A {
  // Пустые сегменты игнорируем
  () '\\' = ();
  () '/' = ();

  // Непустой сегмент выбрасываем
  (e.Segment) '\\' = () (e.Segment);
  (e.Segment) '/' = () (e.Segment);

  // Любой другой символ сохраняем
  (e.Segment) s.Next = (e.Segment s.Next);
}

DeleteAccum
  t.Accum e.Scanned = e.Scanned;

AvailFrontEnds {
  // Расширение не указано -- все доступные front-end'ы
  = <MFE-Mgr::GetList>;

  // Фильтруем по расширению
  e.Ext =
    <MLambda::Map
      <MLambda::BindRight & FilterBackEnd e.Ext>
      <MLambda::Map
        <MLambda::Composite
          & MFE-Mgr.GetExt-T
          & MLambda.Bracket
        >
        <MFE-Mgr::GetList>
      >
    >;
}

FilterBackEnd {
  ( s.BackEnd e.Ext ) e.Ext = s.BackEnd;

  ( s.BackEnd e.Ext1 ) e.Ext2 = ;
}

GenVariants-CmdLine-Aux {
  /*
    То, что front-end'ов нет, означает, что расширение неправильное.
    Выдавать осмысленную ошибку пока не будем, достаточно сообщения
    об отсутствии модуля.
  */
  t.hContext e.RawVariants (e.ModuleName) () =
    t.hContext NotFound;

  t.hContext e.RawVariants (e.ModuleName) (e.AvailFrontEnds) =
    <CheckVariants-CmdLine
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft
          & FinishVariant
          (e.ModuleName) (e.AvailFrontEnds)
        >
        e.RawVariants
      >
    >;
}

FinishVariant
  (e.L-ModuleName) (e.L-AvailFrontEnds)
  ( e.BaseDirectory t.QualifiedPacketName ) =
    <MLambda::Map
      <MLambda::BindLeft
        & FinishVariant-Aux
        (
          e.BaseDirectory
          <MQualifiedName::AddSubName
            t.QualifiedPacketName
            e.L-ModuleName
          >
        )
      >
      e.L-AvailFrontEnds Library
    >;

FinishVariant-Aux
  ( e.L-BaseDirectory t.L-ModuleName ) s.FrontEnd =
    ( s.FrontEnd t.L-ModuleName e.L-BaseDirectory );

CheckVariants-CmdLine
  t.hContext e.Variants =
    <DoCheckVariants-CmdLine
      t.hContext e.Variants
    >;

DoCheckVariants-CmdLine {
  t.hContext (s.FrontEnd t.QualifiedName e.BaseDirectory) e.Tail =
    <SwDoCheckVariant-CmdLine
      <CheckVariant-T
        t.hContext
        s.FrontEnd t.QualifiedName e.BaseDirectory
      >
      e.Tail
    >;

  t.hContext = t.hContext NotFound;
}

CheckVariant-T {
  t.hContext Library t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-LibAux
      t.hContext t.QualifiedName
      <MLambda::Map
        <MLambda::Composite
          <MLambda::Parallel
            & MLambda.Identity
            <MLambda::BindRight
              & MBE-Mgr.GetPath-T
              t.QualifiedName e.BaseDirectory
            >
          >
          & MLambda.Bracket
        >
        <MBE-Mgr::GetList>
      >
      (e.BaseDirectory)
    >;

  t.hContext s.FrontEnd t.QualifiedName e.BaseDirectory =
    <CheckVariant-T-SrcAux
      t.hContext
      <MFE-Mgr::GetPath-T s.FrontEnd t.QualifiedName e.BaseDirectory>
      (s.FrontEnd e.BaseDirectory)
    >;
}

CheckVariant-T-SrcAux {
  t.hContext
  Success t.QualifiedName e.FilePath (s.FrontEnd e.BaseDirectory) =
    <CheckVariant-T-SrcAux-SwExist
      t.hContext
      (s.FrontEnd t.QualifiedName e.BaseDirectory)
      <MFileSystem::ExistFile-T e.FilePath>
    >;

  t.hContext
  Fails t.QualifiedName (s.FrontEnd e.BaseDirectory) =
    t.hContext (NotFound);
}

CheckVariant-T-SrcAux-SwExist {
  t.hContext
  (s.FrontEnd t.QualifiedName e.BaseDirectory)
  True e.FrontEndName =
    <GuardInvariant
      <MContext::UpdateInfo
        t.hContext t.QualifiedName
        (FrontEnd s.FrontEnd e.FrontEndName)
        (Type Source)
        (Status_NEW InCmdLine)
        (BaseDirectory e.BaseDirectory)
      >
    >
    (Found t.QualifiedName s.FrontEnd e.BaseDirectory);

  t.hContext
  (s.FrontEnd t.QualifiedName e.BaseDirectory)
  False e.FrontEndName =
    t.hContext NotFound;
}

CheckVariant-T-LibAux {
  t.hContext t.QualifiedName
  e.BE-Files-B (s.BackEnd t.QualifiedName-Internal Fails) e.BE-Files-E
  (e.BaseDirectory) =
    t.hContext (NotFound);

  t.hContext t.QualifiedName e.BE-Files (e.BaseDirectory) =
    <CheckVariant-T-LibAux-SwExist
      t.hContext t.QualifiedName (e.BaseDirectory)
      <MLambda::Map
        &Lib-CheckExist e.BE-Files
      >
    >;
}

Lib-CheckExist {
  ( s.BackEnd t.QualifiedName Success e.FilePath ) =
    <SwLib-CheckExist
      s.BackEnd <MFileSystem::ExistFile-T e.FilePath>
    >;
}

SwLib-CheckExist {
  s.BackEnd True e.FilePath =
    (s.BackEnd e.FilePath);

  s.BackEnd False e.FilePath =
    NotExist;
}

CheckVariant-T-LibAux-SwExist {
  t.hContext t.QualifiedName (e.BaseDirectory)
  e.BE-Files-B NotExist e.BE-Files-E =
    t.hContext NotFound;

  t.hContext t.QualifiedName (e.BaseDirectory) e.BE-Files =
    <GuardInvariant
      <MContext::UpdateInfo
        t.hContext t.QualifiedName
        (BackEnds e.BE-Files)
        (Type Library)
        (StatusNew InCmdLine)
        (BaseDirectory e.BaseDirectory)
      >
    >
    (Found t.QualifiedName Library e.BaseDirectory);
}

GuardInvariant
  t.hContext Success = t.hContext;

SwDoCheckVariant-CmdLine {
  t.hContext
  (Found t.QualifiedName s.FrontEndName e.BaseDirectory)
  e.Tail =
    t.hContext Found t.QualifiedName s.FrontEndName e.BaseDirectory;

  t.hContext NotFound e.Tail =
    <DoCheckVariants-CmdLine
      t.hContext e.Tail
    >;
}

//------------------------------------------------------------------------------

/**
  <LookupImportModule
    t.hContext (e.ModulePath) t.QualifiedName
  >
    == t.hContext Found s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupImportModule
  t.hContext (e.ModulePath) t.QualifiedName =
    t.hContext NotFound;

//##############################################################################

$IMPORT MCreateDirIfNeed;
$IMPORT MError;
$IMPORT MOrder;
$IMPORT MOS;

$ENTRY CanonicalModuleName {
  s.Initial e.Tail =
    <MStrings::Upper s.Initial> <MStrings::Lower e.Tail>;
}

$ENTRY SymName {
  t.hContext e.ModName = t.hContext <SymDirName> '\\' e.ModName '.rsym';
}

$ENTRY OutName {
  t.hContext e.ModName = t.hContext <OutDirName> '\\' e.ModName '.rout';
}

SymDirName = <MCreateDirIfNeed::Create 'Defs'>;

OutDirName = <MCreateDirIfNeed::Create 'ROut'>; 

//$ENTRY
SrcName {
  t.hContext e.ModName = t.hContext e.ModName '.mref';
}

GetTime {
  e.FileName = <MFileSystem::FileAttribute DateTime e.FileName>;
}

//$ENTRY
SourceState-T
  t.hContext e.ModName = <SourceState t.hContext e.ModName> e.ModName;

/**
  <SourceState e.ModName>
    == ModuleNotFound
    == Library
    == NeedRecompile
    == SrcNotUpdated
*/
SourceState
  t.hContext e.ModName =
    <ThreeFilesState
      <MLambda::Apply
        <MLambda::Parallel-H
          <MLambda::Composite
            & SymName
            & MLambda.Bracket-H
          >
          <MLambda::Composite
            & OutName
            & MLambda.Bracket-H
          >
          <MLambda::Composite
            & SrcName
            & MLambda.Bracket-H
          >
        >
        t.hContext
        e.ModName
      >
    >;

ThreeFilesState
  t.hContext (e.SymName) (e.OutName) (e.SrcName) =
    t.hContext
    <CompareMTimes
      <GetTime e.SymName>
      <GetTime e.OutName>
      <GetTime e.SrcName>
    >;

CompareMTimes {
  // Отсутствует исходный текст и хотя бы один из выходных файлов
  e.Times-B FileNotFound e.Times-E FileNotFound =
    ModuleNotFound;

  // Отсутствует исходный текст -- библиотечный модуль, подключается как есть
  t.SymTime t.OutTime FileNotFound =
    Library;

  // Отсутствует один из выходных файлов -- необходима перекомпиляция
  e.Times-B FileNotFound e.Times-E t.SrcTime =
    NeedRecompile;

  (e.SymTime) (e.OutTime) (e.SrcTime) =
    <SwCompareMTimes
      <MOrder::Compare (e.SymTime) (e.SrcTime)>
      <MOrder::Compare (e.OutTime) (e.SrcTime)>
    >;
}

SwCompareMTimes {
  '>' '>' = SrcNotUpdated;
  e.Other = NeedRecompile;
}

/**
  <LookupLibrary t.hContext e.ModuleName>
    == t.hContext ModuleNotFound
    == t.hContext Library (Sym e.SymName) (Out e.OutName)
*/
LookupLibrary
  t.hContext e.ModuleName =
    <SwLookupLibrary
      t.hContext
      ( <MFileSystem::ExistFile-T <HomeDir> '\\Defs\\' e.ModuleName '.rsym'> )
      ( <MFileSystem::ExistFile-T <HomeDir> '\\ROut\\' e.ModuleName '.rout'> )
    >;

SwLookupLibrary {
  t.hContext (True e.SymName) (True e.OutName) =
    t.hContext Library (Sym e.SymName) (Out e.OutName);

  t.hContext t.Other1 t.Other2 =
    t.hContext ModuleNotFound;
}

/**
  <LookupModule-T t.hContext e.ModuleName>
     == t.hContext
       s.Status
       (Sym e.SymName)
       (Out e.OutName)
       (Src e.SrcName)
       e.ModuleName
  s.Status ::= one of
    ModuleNotFound NeedRecompile Library SrcNotUpdated SystemLibrary
    e.*Name may be None
*/
$ENTRY LookupModule-T
  t.hContext e.ModuleName =
    <SwLookupModule
      <SourceState-T
        t.hContext
        e.ModuleName
      >
    >;

SwLookupModule {
  t.hContext ModuleNotFound e.ModuleName =
    <SwLookupAsSystemLibrary
      <LookupLibrary t.hContext e.ModuleName>
      e.ModuleName
    >;

  t.hContext s.OtherStatus e.ModuleName =
    <MLambda::Apply
      <MLambda::Parallel-H
        <MLambda::MakeHandled <MLambda::Const s.OtherStatus>>
        <MLambda::Composite
          & SymName
          <MLambda::BindLeft-H & MLambda.Bracket-H Sym>
        >
        <MLambda::Composite
          & OutName
          <MLambda::BindLeft-H & MLambda.Bracket-H Out>
        >
        <MLambda::Composite
          <MLambda::BindLeft-H & SrcName-SwLibrary s.OtherStatus>
          <MLambda::BindLeft-H & MLambda.Bracket-H Src>
        >
      >
      t.hContext e.ModuleName
    >
    e.ModuleName;
}

SrcName-SwLibrary {
  t.hContext Library e.ModuleName =
    t.hContext None;

  t.hContext s.Other e.ModuleName =
    <SrcName t.hContext e.ModuleName>;
}

SwLookupAsSystemLibrary {
  t.hContext ModuleNotFound e.ModuleName =
    t.hContext ModuleNotFound (Sym None) (Out None) (Src None) e.ModuleName;

  t.hContext Library (Sym e.SymName) (Out e.OutName) e.ModuleName =
    t.hContext SystemLibrary (Sym e.SymName) (Out e.OutName) (Src None) e.ModuleName;
}

$ENTRY HomeDir = <MOS::Env 'MR_Home'>;

$ENTRY Init =
  <CheckDefinedMRHome <HomeDir>>;

CheckDefinedMRHome {
  None = <MError::Fatal 'MR_Home not defined'>;
  e.Path = ;
}

$END MModules.
