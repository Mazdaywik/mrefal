$MODULE MModules;

$IMPORT MBE-Mgr;
$IMPORT MContext;
$IMPORT MFE-Mgr;
$IMPORT MFileSystem;
$IMPORT MLambda;
$IMPORT MStrings;
$IMPORT MQualifiedName;

/**
  <LookupCmdLineModule
    t.hContext (e.ModulePath) e.CmdLinePath
  >
    == t.hContext Found
      t.QualifiedName s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupCmdLineModule
  t.hContext (e.ModulePath) e.CmdLinePath =
    <GenVariants-CmdLine
        t.hContext (e.ModulePath)
        <ParseFileNameEx e.CmdLinePath>
    >;

/*
  <ParseFileNameEx e.FileName>
    == s.PathType (e.Directory) e.FileNameNoExt (e.Ext)
  s.PathType ::= Relative | Absolut

  Не смотря на то, что путь типа D:Directory\File фактически
  является относительным, здесь буду считать абсолютным, т.к.
  из него нельзя построить напрямую квалифицированное имя.
*/
ParseFileNameEx
  e.FileName =
    <SwParseFileName
      <MFileSystem::ParseFileName e.FileName>
    >;

SwParseFileName {
  (s.Disk ':' e.Tail) e.FileName (e.Ext) =
    Absolut (s.Disk ':' e.Tail) e.FileName (e.Ext);

  ('/' e.Tail) e.FileName (e.Ext) =
    Absolut ('/' e.Tail) e.FileName (e.Ext);

  ('\\' e.Tail) e.FileName (e.Ext) =
    Absolut ('\\' e.Tail) e.FileName (e.Ext);

  (e.Directory) e.FileName (e.Ext) =
    Relative (e.Directory) e.FileName (e.Ext);
}

GenVariants-CmdLine
  t.hContext (e.ModulePath) s.PathType (e.Folder) e.FileName (e.Ext) =
    <GenVariants-CmdLine-Aux
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft & CrossName (e.Folder)>
        e.ModulePath
      >
      <MakeAppendNames s.PathType (e.Folder) e.ModulePath>
      (e.FileName)
      (
        <AvailFrontEnds
          <MStrings::Lower e.Ext>
        >
      )
    >;

MakeAppendNames {
  Relative (e.Folder) e.ModulePath =
    <MLambda::Map
      <MLambda::BindLeft & AppendName (e.Folder)>
      e.ModulePath
    >;

  Absolut (e.Folder) e.ModulePath =
    /* Ничего */;
}

/*
  <CrossName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
CrossName
  (e.L-Folder) (e.MPDirectory) =
    <DoCrossName
      ( <CanonicalPath e.L-Folder> )
      ( <CanonicalPath e.MPDirectory> )
      () e.L-Folder
    >;

DoCrossName {
  // C- -- canonical

  ( s.C-Next e.C-ModuleFolder ) ( s.C-Next e.C-MPDirectory )
  ( e.Scanned ) s.Next e.ModuleFolder =
    <DoCrossName
      ( e.C-ModuleFolder ) ( e.C-MPDirectory )
      ( e.Scanned s.Next ) e.ModuleFolder
    >;

  // Начало e.[C-]ModuleFolder совпадает с e.C-MPDirectory
  ( e.C-ModuleFolder-Tail ) () (e.BaseFolder) e.ModuleFolder-Tail =
    ( e.BaseFolder <QNameFromRelativePath e.ModuleFolder-Tail> );

  // Не совпадает
  ( e.C-ModuleFolder ) ( e.C-MPDirectory )
  ( e.Scanned ) e.ModuleFolder =
    /* Пусто */;
}

/*
  <AppendName (e.L-Folder) (e.MPDirectory)>
    == ( e.BaseFolder t.QualifiedName )
    == empty
*/
AppendName
  (e.L-Folder) (e.MPDirectory) =
    ( e.MPDirectory <QNameFromRelativePath e.L-Folder> );


CanonicalPath
  e.Path = <MLambda::Map & CanonicalChar e.Path>;

CanonicalChar {
  '\\' = '/';
  s.Other = <MStrings::Lower s.Other>;
}

QNameFromRelativePath
  e.Path =
    <MQualifiedName::Create
      <SlashParse e.Path>
    >;

SlashParse
  e.Path =
    <DeleteAccum
      <MLambda::MapReduce
        & SlashParse-A () e.Path
      >
    >;

SlashParse-A {
  // Пустые сегменты игнорируем
  () '\\' = ();
  () '/' = ();

  // Непустой сегмент выбрасываем
  (e.Segment) '\\' = () (e.Segment);
  (e.Segment) '/' = () (e.Segment);

  // Любой другой символ сохраняем
  (e.Segment) s.Next = (e.Segment s.Next);
}

DeleteAccum
  t.Accum e.Scanned = e.Scanned;

AvailFrontEnds {
  // Расширение не указано -- все доступные front-end'ы
  = <MFE-Mgr::GetList>;

  // Фильтруем по расширению
  e.Ext =
    <MLambda::Map
      <MLambda::BindRight & FilterBackEnd e.Ext>
      <MLambda::Map
        <MLambda::Composite
          & MFE-Mgr.GetExt-T
          & MLambda.Bracket
        >
        <MFE-Mgr::GetList>
      >
    >;
}

FilterBackEnd {
  ( s.BackEnd e.Ext ) e.Ext = s.BackEnd;

  ( s.BackEnd e.Ext1 ) e.Ext2 = ;
}

GenVariants-CmdLine-Aux {
  /*
    То, что front-end'ов нет, означает, что расширение неправильное.
    Выдавать осмысленную ошибку пока не будем, достаточно сообщения
    об отсутствии модуля.
  */
  t.hContext e.RawVariants (e.ModuleName) () =
    t.hContext NotFound;

  t.hContext e.RawVariants (e.ModuleName) (e.AvailFrontEnds) =
    <CheckVariants-CmdLine
      t.hContext
      <MLambda::Map
        <MLambda::BindLeft
          & FinishVariant
          (e.ModuleName) (e.AvailFrontEnds)
        >
        e.RawVariants
      >
    >;
}

FinishVariant
  (e.L-ModuleName) (e.L-AvailFrontEnds)
  ( e.BaseDirectory t.QualifiedPacketName ) =
    <MLambda::Map
      <MLambda::BindLeft
        & FinishVariant-Aux
        (
          e.BaseDirectory
          <MQualifiedName::AddSubName
            t.QualifiedPacketName
            e.L-ModuleName
          >
        )
      >
      e.L-AvailFrontEnds
    >;

FinishVariant-Aux
  ( e.L-BaseDirectory t.L-ModuleName ) s.FrontEnd =
    ( s.FrontEnd t.L-ModuleName e.L-BaseDirectory );

CheckVariants-CmdLine
  t.hContext e.Variants =
    t.hContext NotFound
    <MLambda::Map
      <MLambda::Composite
        & MLambda.UnBracket
        & WriteVariant
      >
      e.Variants
    >;

WriteVariant {
  s.FrontEnd t.QualifiedName e.BaseDirectory =
    <InOut::WriteText
      ()
      (s.FrontEnd)
      (<MQualifiedName::Parse t.QualifiedName>)
      (e.BaseDirectory)
    >;
}

$import InOut;

//------------------------------------------------------------------------------

/**
  <LookupImportModule
    t.hContext (e.ModulePath) t.QualifiedName
  >
    == t.hContext Found s.FrontEndName e.BaseDirectory
    == t.hContext NotFound
*/
$ENTRY LookupImportModule
  t.hContext (e.ModulePath) t.QualifiedName =
    t.hContext NotFound;

//##############################################################################

$IMPORT MCreateDirIfNeed;
$IMPORT MError;
$IMPORT MOrder;
$IMPORT MOS;

$ENTRY CanonicalModuleName {
  s.Initial e.Tail =
    <MStrings::Upper s.Initial> <MStrings::Lower e.Tail>;
}

$ENTRY SymName {
  e.ModName = <SymDirName> '\\' e.ModName '.rsym';
}

$ENTRY OutName {
  e.ModName = <OutDirName> '\\' e.ModName '.rout';
}

SymDirName = <MCreateDirIfNeed::Create 'Defs'>;

OutDirName = <MCreateDirIfNeed::Create 'ROut'>; 

//$ENTRY
SrcName {
  e.ModName = e.ModName '.mref';
}

GetTime {
  e.FileName = <MFileSystem::FileAttribute DateTime e.FileName>;
}

//$ENTRY
SourceState-T
  e.ModName = <SourceState e.ModName> e.ModName;

/**
  <SourceState e.ModName>
    == ModuleNotFound
    == Library
    == NeedRecompile
    == SrcNotUpdated
*/
//$ENTRY
SourceState
  e.ModName =
    <ThreeFilesState
      ( <SymName e.ModName> )
      ( <OutName e.ModName> )
      ( <SrcName e.ModName> )
    >;

ThreeFilesState
  (e.SymName) (e.OutName) (e.SrcName) =
    <CompareMTimes
      <GetTime e.SymName>
      <GetTime e.OutName>
      <GetTime e.SrcName>
    >;

CompareMTimes {
  // Отсутствует исходный текст и хотя бы один из выходных файлов
  e.Times-B FileNotFound e.Times-E FileNotFound =
    ModuleNotFound;

  // Отсутствует исходный текст -- библиотечный модуль, подключается как есть
  t.SymTime t.OutTime FileNotFound =
    Library;

  // Отсутствует один из выходных файлов -- необходима перекомпиляция
  e.Times-B FileNotFound e.Times-E t.SrcTime =
    NeedRecompile;

  (e.SymTime) (e.OutTime) (e.SrcTime) =
    <SwCompareMTimes
      <MOrder::Compare (e.SymTime) (e.SrcTime)>
      <MOrder::Compare (e.OutTime) (e.SrcTime)>
    >;
}

SwCompareMTimes {
  '>' '>' = SrcNotUpdated;
  e.Other = NeedRecompile;
}

$ENTRY LookupLibrary-T
  e.ModuleName = <LookupLibrary e.ModuleName> e.ModuleName;

/**
  <LookupLibrary e.ModuleName>
    == ModuleNotFound
    == Library (Sym e.SymName) (Out e.OutName)
*/
$ENTRY LookupLibrary
  e.ModuleName =
    <SwLookupLibrary
      ( <MFileSystem::ExistFile-T <HomeDir> '\\Defs\\' e.ModuleName '.rsym'> )
      ( <MFileSystem::ExistFile-T <HomeDir> '\\ROut\\' e.ModuleName '.rout'> )
    >;

SwLookupLibrary {
  (True e.SymName) (True e.OutName) =
    Library (Sym e.SymName) (Out e.OutName);

  e.Other1 t.Other2 =
    ModuleNotFound;
}

/**
  <LookupModule-T e.ModuleName>
     == s.Status
       (Sym e.SymName)
       (Out e.OutName)
       (Src e.SrcName)
       e.ModuleName
  s.Status ::= one of
    ModuleNotFound NeedRecompile Library SrcNotUpdated SystemLibrary
    e.*Name may be None
*/
$ENTRY LookupModule-T
  e.ModuleName =
    <SwLookupModule
      <SourceState-T e.ModuleName>
    >;

SwLookupModule {
  ModuleNotFound e.ModuleName =
    <SwLookupAsSystemLibrary
      <LookupLibrary-T e.ModuleName>
    >;

  s.OtherStatus e.ModuleName =
    s.OtherStatus
    (Sym <SymName e.ModuleName>)
    (Out <OutName e.ModuleName>)
    (Src <SrcName-SwLibrary
      s.OtherStatus e.ModuleName
    >) e.ModuleName;
}

SrcName-SwLibrary {
  Library e.ModuleName = None;
  s.Other e.ModuleName = <SrcName e.ModuleName>;
}

SwLookupAsSystemLibrary {
  ModuleNotFound e.ModuleName =
    ModuleNotFound (Sym None) (Out None) (Src None) e.ModuleName;

  Library (Sym e.SymName) (Out e.OutName) e.ModuleName =
    SystemLibrary (Sym e.SymName) (Out e.OutName) (Src None) e.ModuleName;
}

$ENTRY HomeDir = <MOS::Env 'MR_Home'>;

$ENTRY Init =
  <CheckDefinedMRHome <HomeDir>>;

CheckDefinedMRHome {
  None = <MError::Fatal 'MR_Home not defined'>;
  e.Path = ;
}

$END MModules.
