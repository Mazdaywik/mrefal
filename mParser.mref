$MODULE MParser;

$IMPORT MLexer;
$IMPORT MError;
$IMPORT MFileSystem;
$IMPORT MIModule;
$IMPORT MQualifiedName;
$IMPORT MSelfDiag;
$IMPORT MStrings;
$IMPORT MVarTable;

/**
	<SrcModule e.SrcFileName>
		== t.Module s.ErrorResult t.ErrorList
	s.ErrorResult ::= Success | Warnings | Errors | Fatal
*/
$ENTRY SrcModule
	e.SrcFileName =
		<ErrorResult
			(e.SrcFileName)
			<NModule <StartParsing e.SrcFileName> >
		>;

/**
	<SymModule t.Context e.SymFileName>
		== t.IModule s.ErrorResult t.ErrorList
		s.ErrorResult ::= Success | Warnings | Errors | Fatal
*/
$ENTRY SymModule
	e.SymFileName =
		<ErrorResult
			(e.SymFileName)
			<NSymModule <StartParsing e.SymFileName> >
		>;

StartParsing
	e.FullName =
		<MError::CreateErrList>
		<MIModule::Create>
		()
		<MLexer::NextToken
			<MLexer::Create e.FullName>
		>;

ErrorResult {
	(e.FileName)
	t.ErrorList t.IModule =
		<ErrorResult-Aux
			<CheckInternalName
				<MFileSystem::ParseFileName e.FileName>
				t.ErrorList
				(<MIModule::GetModuleName t.IModule>)
			>
		>;
}

CheckInternalName {
	(e.Directory) e.Name (e.Ext)
	t.ErrorList (t.IModule e.ModuleName) =
		<SwCheckInternalName
			(<MStrings::Lower e.Name>)
			(<MStrings::Lower e.ModuleName>)
			(e.ModuleName)
			t.ErrorList
			<MIModule::GetModuleAttribute t.IModule Position>
		>;
}

SwCheckInternalName {
	(e.Name) (e.Name) (e.ModuleName)
	t.ErrorList t.IModule Found t.SrcPos =
		t.ErrorList
		<CheckSuccess
			('SwCheckInternalName')
			<MIModule::UpdateModule
				t.IModule
				(FsName e.Name)
			>
		>;

	(e.FsName) (e.LowerInternalName) (e.ModuleName)
	t.ErrorList t.IModule Found t.SrcPos =
		<MError::AddMismatchModuleAndFile
			t.ErrorList t.SrcPos (e.ModuleName) (e.FsName)
		>
		<CheckSuccess
			('SwCheckInternalName')
			<MIModule::UpdateModule
				t.IModule
				(FsName e.FsName)
			>
		>;

}

ErrorResult-Aux {
	t.ErrorList t.IModule =
		<SwErrorResult
			<MError::EmptyList t.ErrorList>
			t.IModule
		>;
}

SwErrorResult {
	t.ErrorList Empty t.Module =
		t.Module Success t.ErrorList;

	t.ErrorList NotEmpty t.Module =
		t.Module Errors t.ErrorList;
}


//------------------------------------------------------------------------------
// Добавление в таблицу символов
//------------------------------------------------------------------------------

AddNewImport
	t.ErrorList t.IModule t.SrcPos (e.NewName) e.Attribs =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateImport
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

AddNewFunction
	t.ErrorList t.IModule t.SrcPos (e.NewName) e.Attribs =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateFunction
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

AddNewADT
	t.ErrorList t.IModule t.SrcPos (e.NewName) e.Attribs =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateADT
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

CheckRedeclaration {
	t.ErrorList t.IModule Success t.SrcPos e.NewName =
		t.ErrorList t.IModule;

	t.ErrorList t.IModule InvalidKind t.SrcPos e.NewName =
		<MError::AddRedeclaredIdentifier
			t.ErrorList t.SrcPos e.NewName
		> t.IModule;

	/*
		Две другие ошибки -- InvalidKind и InvariantError означают
		нарушение инварианта. Программа автоматически умрёт.
	*/
}

//------------------------------------------------------------------------------
// Синтаксический анализ модуля
//------------------------------------------------------------------------------

// Module = ModuleHeader ModuleBody ModuleTailer .
// Цепочка Module --> ModuleHeader --> { ModuleBody --> ModuleTailer }
NModule
	t.ErrorList t.IModule () t.Lexer t.NextToken =
		<NModuleBody
			<NModuleHeader
				t.ErrorList t.IModule
				() t.Lexer t.NextToken
			>
		>;

// ModuleHeader = '$module' ModuleName ';' .
// Цепочка ModuleHeader --> { ModuleHeader-ModuleName --> ExpectEndSent }
NModuleHeader {
	t.ErrorList t.IModule ()
	t.Lexer (Directive t.SrcPos Module) =
		<NModuleHeader-ModuleName
			Regular t.ErrorList t.IModule ()
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ()
	t.Lexer (Directive t.SrcPos Program) =
		<NModuleHeader-ModuleName
			Main t.ErrorList t.IModule ()
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ()
	t.Lexer (Directive t.SrcPos ClearModule) =
		<NModuleHeader-ModuleName
			Clear t.ErrorList t.IModule ()
			<MLexer::NextToken t.Lexer>
		>;

	/* Обработка ошибок в данном случае -- добавляем в список ошибок неожиданный
	символ, считаем, что прочли текущую лексему как '$module' и продолжаем
	дальнейший разбор.
	*/
	t.ErrorList t.IModule ()
	t.Lexer t.OtherToken =
		<NModuleHeader-ModuleName
			Regular
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'directive \'$MODULE\''
			>
			t.IModule ()
			<MLexer::NextToken t.Lexer>
		>;
}

CheckSuccess {
	(e.FnName) t.IModule Success = t.IModule;

	// Нарушение инварианта -- fail down
}

// ModuleHeader-ModuleName --> ExpectEndSent
NModuleHeader-ModuleName {
	s.ModuleType t.ErrorList t.IModule ()
	t.Lexer (Identifier t.SrcPos e.Name) =
		<ExpectEndSent
			t.ErrorList
			<CheckSuccess
				('NModuleHeader-ModuleName')
				<MIModule::UpdateModule
					<CheckSuccess
						('NMH-MN: SetModuleName')
						<MIModule::SetModuleName t.IModule e.Name>
					>
					(Position t.SrcPos)
					(ModuleType s.ModuleType)
				>
			>
			()
			<MLexer::NextToken t.Lexer>
		>;

	/* Здесь мы пропускаем текущую неопознанную лексему до тех пор, пока
	не встретим идентификатор или конец ввода */
	s.ModuleType t.ErrorList t.IModule ()
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'module name'
		>
		t.IModule ()
		t.Lexer (EndOfText t.SrcPos);

	s.ModuleType t.ErrorList t.IModule ()
	t.Lexer t.OtherToken =
		<NModuleHeader-ModuleName
			s.ModuleType
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'module name'
			>
			t.IModule ()
			<MLexer::NextToken t.Lexer>
		>;
}

ExpectEndSent {
	t.ErrorList t.IModule t.Stack
	t.Lexer (EndSent t.SrcPos) =
		t.ErrorList t.IModule t.Stack
		<MLexer::NextToken t.Lexer>;

	/* Делаем вид, что точка с запятой была */
	t.ErrorList t.IModule t.Stack
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'semicolon'
		>
		t.IModule t.Stack
		t.Lexer t.OtherToken;
}

/* ModuleTailer -->
	{ ModuleTailer-ModuleName -->
		{ ModuleTailer-Dot --> ModuleTailer-EOF }
	}
*/
NModuleTailer {
	t.ErrorList t.IModule ( e.ModuleBody )
	t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer-ModuleName
			t.ErrorList
			(<MIModule::GetModuleName t.IModule>)
			( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;
}

/* ModuleTailer-ModuleName --> { ModuleTailer-Dot --> ModuleTailer-EOF } */
NModuleTailer-ModuleName {
	t.ErrorList (t.IModule e.ModuleName)
	( e.ModuleBody )
	t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NModuleTailer-Dot
			t.ErrorList t.IModule ( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList (t.IModule e.ModuleName-Head)
	( e.ModuleBody )
	t.Lexer (Identifier t.SrcPos e.ModuleName-Tail) =
		<NModuleTailer-Dot
			<MError::AddNamesMismatch
				t.ErrorList t.SrcPos
				(e.ModuleName-Head) (e.ModuleName-Tail)
			>
			t.IModule ( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;

	/* Пропускаем следующую лексему, до тех пор, пока не встретим
	конец файла или идентификатор */
	t.ErrorList (t.IModule e.ModuleName)
	( e.ModuleBody )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'repeat of module name'
		>
		t.IModule ( e.ModuleBody )
		t.Lexer (EndOfText t.SrcPos);

	t.ErrorList (t.IModule e.ModuleName)
	( e.ModuleBody )
	t.Lexer t.OtherToken =
		<NModuleTailer-ModuleName
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'repeat of moduleName'
			>
			(t.IModule e.ModuleName)
			( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;
}

// ModuleTailer-Dot --> { ModuleTailer-EOF --> _|_ }
NModuleTailer-Dot {
	t.ErrorList t.IModule ( e.ModuleBody )
	t.Lexer (Dot t.SrcPos) =
		<NModuleTailer-EOF
			t.ErrorList t.IModule ( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;

	/* Считаем, что точка была */
	t.ErrorList t.IModule ( e.ModuleBody )
	t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end dot'
			>
			t.IModule ( e.ModuleBody )
			t.Lexer t.OtherToken
		>;
}

// ModuleTailer-EOF --> _|_
NModuleTailer-EOF {
	t.ErrorList t.IModule ( /* Должно быть пусто */ )
	t.Lexer (EndOfText t.SrcPos) =
		t.ErrorList
		t.IModule
		<MLexer::Destroy t.Lexer>;

	/* Пропускаем все другие лексемы до тех пор, пока не доберёмся до конца файла */
	t.ErrorList t.IModule ( e.ModuleBody )
	t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end of file'
			>
			t.IModule ( e.ModuleBody )
			<MLexer::NextToken t.Lexer>
		>;
}


/* ModuleBody = { ImportBlock | FunctionDefinition | SwapDefinition }* .
	ModuleBody --> ModuleTailer
В случае конца файла
	ModuleBody --> _|_*/
NModuleBody {
	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Import) =
		<NModuleBody
			<NImportBlock
				t.ErrorList
				t.IModule
				( e.Elements )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Swap) =
		<NModuleBody
			<NSwapBlock
				t.ErrorList t.IModule
				( e.Elements )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Entry) =
		<NModuleBody
			<NFunctionDefinition
				t.ErrorList t.IModule
				( Entry (e.Elements) )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Data) =
		<NModuleBody
			<NDataBlock
				t.ErrorList t.IModule
				( e.Elements )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Identifier t.SrcPos e.Ident) =
		<NModuleBody
			<NFunctionDefinition
				t.ErrorList t.IModule
				( Local (e.Elements) )
				t.Lexer (Identifier t.SrcPos e.Ident)
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (EndSent t.SrcPos) =
		<NModuleBody
			t.ErrorList t.IModule ( e.Elements )
			<MLexer::NextToken t.Lexer>
		>;

	/* Завершение рекурсии */
	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer
			t.ErrorList t.IModule ( e.Elements )
			t.Lexer (Directive t.SrcPos End)
		>;

	/* При обнаружении конца файла завершаем анализ */
	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos)
			'$entry, $import, $swap or local function definition'
		>
		t.IModule
		<MLexer::Destroy t.Lexer>;

	/* Любая другая лексема пропускается */
	t.ErrorList t.IModule ( e.Elements )
	t.Lexer t.OtherToken =
		<NModuleBody
			<MError::AddUnexpected
				t.ErrorList t.OtherToken
				'$entry, $import, $swap or local function definition'
			>
			t.IModule ( e.Elements )
			<MLexer::NextToken t.Lexer>
		>;
}

NImportBlock {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterName
			t.ErrorList t.IModule
			( Import e.ModuleName )
			( e.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name or module alias'
		> t.IModule ( e.ParentStack )
		<MLexer::NextToken t.Lexer>;
}

NImportBlock-AfterName {
	t.ErrorList t.IModule (Import e.ModuleName)
	( e.ParentStack )
	t.Lexer (EndSent t.SrcPos) =
		<AddNewImport
			t.ErrorList t.IModule t.SrcPos (e.ModuleName)
			(Alias e.ModuleName)
		> ( e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule (Import e.ModuleName)
	( e.ParentStack )
	t.Lexer (Replaces t.SrcPos) =
		<NImportBlock-ModuleRenaming
			t.ErrorList t.IModule
			(Alias e.ModuleName)
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule (Import e.ModuleName)
	( e.ParentStack )
	t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			<AddNewImport
				t.ErrorList t.IModule t.SrcPos (e.ModuleName)
				(Alias e.ModuleName)
			> ( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	// Считаем, что пользователь пропустил точку с запятой
	t.ErrorList t.IModule (Import e.ModuleName)
	( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma, semicolon or replace'
		> t.IModule ( e.ParentStack )
		t.Lexer t.OtherToken;
}

NImportBlock-ModuleRenaming {
	t.ErrorList t.IModule
	(Alias e.Alias) ( e.ParentStack )
	t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterAlias
			<AddNewImport
				t.ErrorList t.IModule t.SrcPos (e.ModuleName)
				(Alias e.Alias)
			>
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	//Считаем, что попытки переименования не было
	t.ErrorList t.IModule
	(Alias e.Alias) ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name'
		> t.IModule
		( e.ParentStack )
		t.Lexer t.OtherToken;
}

NImportBlock-AfterAlias {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			t.ErrorList t.IModule ( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (EndSent t.SrcPos) =
		t.ErrorList t.IModule ( e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		> t.IModule ( e.ParentStack )
		t.Lexer t.OtherToken;
}

/*
	SwapBlock = '$swap' SwapBlock-Chain .
	SwapBlock-Chain = IDENTIFIER SwapBlock-AfterName .
	SwapBlock-AfterName = ';' | ',' Swap-Chain .
*/
NSwapBlock {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Identifier t.SrcPos e.Ident) =
		<NSwapBlock-AfterName
			<AddNewFunction
				t.ErrorList t.IModule t.SrcPos (e.Ident)
				(ScopeClass Swap)
			>
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'swap name'
		> t.IModule
		( e.ParentStack )
		t.Lexer t.OtherToken;
}

NSwapBlock-AfterName {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Comma t.SrcPos) =
		<NSwapBlock
			t.ErrorList t.IModule
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (EndSent t.SrcPos) =
		t.ErrorList t.IModule ( e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		> t.IModule ( e.ParentStack )
		t.Lexer t.OtherToken;
}

/*
	DataBlock = '$swap' DataBlock-Chain .
	DataBlock-Chain = IDENTIFIER DataBlock-AfterName .
	DataBlock-AfterName = ';' | ',' DataBlock-Chain .
*/
NDataBlock {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Identifier t.SrcPos e.Ident) =
		<NDataBlock-AfterName
			<AddNewADT
				t.ErrorList t.IModule t.SrcPos (e.Ident)
			>
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'swap name'
		> t.IModule
		( e.ParentStack )
		t.Lexer t.OtherToken;
}

NDataBlock-AfterName {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Comma t.SrcPos) =
		<NDataBlock
			t.ErrorList t.IModule
			( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (EndSent t.SrcPos) =
		t.ErrorList t.IModule ( e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		> t.IModule ( e.ParentStack )
		t.Lexer t.OtherToken;
}

NFunctionDefinition {
	t.ErrorList t.IModule ( s.ScopeClass t.ParentStack )
	t.Lexer (Identifier t.SrcPos e.Ident) =
		<NFunctionDefinition-Closing
			<NFunctionBody
				t.ErrorList t.IModule
				(( (Function s.ScopeClass (e.Ident) t.SrcPos) t.ParentStack ))
				<MLexer::NextToken t.Lexer>
			>
		>;

	/* Возвращаемся в ModuleBody, как будто спецификатора $ENTRY и не было
	в помине */
	t.ErrorList t.IModule ( s.ScopeClass (e.ParentStack) )
	t.Lexer t.UnexpectedToken =
		<MError::AddUnexpected
			t.ErrorList t.UnexpectedToken 'function name'
		>
		t.IModule ( e.ParentStack )
		t.Lexer t.UnexpectedToken;
}

NFunctionDefinition-Closing
	t.ErrorList t.IModule
	( t.FunctionBody ( Function s.ScopeClass (e.Name) t.SrcPos ) (e.ParentStack) )
	t.Lexer t.NextToken =
		<AddNewFunction
			t.ErrorList t.IModule t.SrcPos (e.Name)
			(Body t.FunctionBody)
			(ScopeClass s.ScopeClass)
			(Qualified <MQualifiedName::Create (e.Name)>)
		>
		( e.ParentStack )
		t.Lexer t.NextToken;

NFunctionBody {
	t.ErrorList t.IModule ( t.ParentStack )
	t.Lexer (OpenBlock t.SrcPos) =
		<NBlock
			t.ErrorList t.IModule ( t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( t.ParentStack )
	t.Lexer t.StartSentence =
		<NFunctionBody
			<NSentence
				t.ErrorList t.IModule ( (OneSentence t.ParentStack) )
				t.Lexer t.StartSentence
			>
		>;

	t.ErrorList t.IModule ( e.Sentence OneSentence (e.ParentStack) )
	t.Lexer t.NextToken =
		t.ErrorList t.IModule ( (e.Sentence) e.ParentStack )
		t.Lexer t.NextToken;
}

NBlock {
	t.ErrorList t.IModule ( e.Sentences (e.ParentStack) )
	t.Lexer (CloseBlock t.SrcPos) =
		t.ErrorList t.IModule
		( (<MStrings::Reverse e.Sentences>) e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule ( e.Sentences (e.ParentStack) )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'start of pattern of closing block'
		> t.IModule
		( (<MStrings::Reverse e.Sentences>) e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule ( e.Sentences t.ParentStack )
	t.Lexer t.StartSentence =
		<NBlock
			<NSentence
				t.ErrorList t.IModule
				( (e.Sentences t.ParentStack) )
				t.Lexer t.StartSentence
			>
		>;
}

NSentence {
	t.ErrorList t.IModule ( (e.ParentStack) )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'start of pattern'
		> t.IModule
		( e.ParentStack )
		t.Lexer (EndOfText t.SrcPos);

	t.ErrorList t.IModule ( t.ParentStack )
	t.Lexer (s.StartOfPattern t.SrcPos e.Info) =
		<NSentence-ExpectReplaces
			<NPatternExpr
				t.ErrorList t.IModule
				<MVarTable::Create>
				( '$' (t.ParentStack) )
				t.Lexer (s.StartOfPattern t.SrcPos e.Info)
			>
		>;
}

NSentence-ExpectReplaces {
	t.ErrorList t.IModule t.VarTable
	( t.Pattern t.ParentStack )
	t.Lexer (Replaces t.SrcPos) =
		<NSentence-Closing
			<NResultExpr
				t.ErrorList t.IModule t.VarTable
				( '$' (t.Pattern t.ParentStack) )
				<MLexer::NextToken t.Lexer>
			>
		>;

	/* Игнорируем уже разобранное образцовое выражение --
	игнорируем целиком пропущенное предложение. При этом необходимо
	съесть неожиданную лексему -- эта лексема оказалась неожиданной
	для образцового выражения, а следующее предложение начинается с
	образца. */
	t.ErrorList t.IModule t.VarTable
	( t.Pattern (e.ParentStack) )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) '\'=\''
		> t.IModule
		<MVarTable::Destroy t.VarTable>
		( e.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule t.VarTable
	( t.Pattern (e.ParentStack) )
	t.Lexer t.UnexpectedToken =
		<MError::AddUnexpected
			t.ErrorList t.UnexpectedToken '\'=\''
		> t.IModule
		<MVarTable::Destroy t.VarTable>
		( e.ParentStack )
		<MLexer::NextToken t.Lexer>;
}

NSentence-Closing {
	t.ErrorList t.IModule t.VarTable
	( t.Result t.Pattern (e.ParentStack) )
	t.Lexer t.NextToken =
		<ExpectEndSent
			t.ErrorList t.IModule
			<MVarTable::Destroy t.VarTable>
			( (t.Pattern t.Result) e.ParentStack )
			t.Lexer t.NextToken
		>;
}

AddVariable {
	t.IModule t.ErrorList t.VarTable Success
	( e.PatternExpr t.ParentStack )
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		t.ErrorList t.IModule t.VarTable
		( e.PatternExpr (s.VarType e.Index) t.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.IModule t.ErrorList t.VarTable Fail
	( e.PatternExpr t.ParentStack )
	t.Lexer t.VarToken =
		t.ErrorList t.IModule t.VarTable
		( e.PatternExpr t.ParentStack )
		<MLexer::NextToken t.Lexer>;
}

NPatternExpr {
	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		<NPatternExpr
			<AddVariable
				t.IModule
				<MVarTable::AddVariable
					t.ErrorList t.VarTable t.SrcPos s.VarType e.Index
				>
				( e.PatternExpr t.ParentStack )
				t.Lexer (Var t.SrcPos s.VarType e.Index)
			>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (Identifier t.SrcPos e.Identifier) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			( e.PatternExpr (Identifier e.Identifier) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (Literal t.SrcPos e.Content) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.PatternExpr (Literal e.Content) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (DQWord t.SrcPos e.Content) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.PatternExpr (DQWord e.Content) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (Macro t.SrcPos s.Value) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.PatternExpr (Macro s.Value) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (OpenBrac t.SrcPos) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			( (')' e.PatternExpr) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (OpenSquare t.SrcPos) =
		<NPatternExpr
			<CallableADTName
				t.ErrorList t.IModule t.VarTable
				( (']' e.PatternExpr) t.ParentStack )
				<MLexer::NextToken t.Lexer>
			>
		>;

	/* Сделаем осмысленную реакцию на ошибки -- будем интерпретировать
	функциональную скобку как структурную. */
	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (OpenFnCall t.SrcPos) =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList (OpenFnCall t.SrcPos)
				'any correct passive term'
			> t.IModule t.VarTable
			( (')' e.PatternExpr) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( (')' e.MultiBracket) e.InBrackets t.ParentStack)
	t.Lexer (CloseBrac t.SrcPos) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.MultiBracket (Structure e.InBrackets) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( (']' e.MultiBracket) InvalidADT e.InBrackets t.ParentStack)
	t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.MultiBracket (Structure e.InBrackets) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( (']' e.MultiBracket) t.Callable e.InBrackets t.ParentStack)
	t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			t.ErrorList t.IModule t.VarTable
			(e.MultiBracket
				(Abstract t.Callable e.InBrackets)
				t.ParentStack
			)
			<MLexer::NextToken t.Lexer>
		>;

	/* Продолжение осмысленной реакции -- интерпретация закрывающей
	функциональной скобки как структурной*/
	t.ErrorList t.IModule t.VarTable
	( (')' e.MultiBracket) e.InBracket t.ParentStack)
	t.Lexer (CloseFnCall t.SrcPos) =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList (CloseFnCall t.SrcPos)
				'any correct passive term'
			> t.IModule t.VarTable
			(e.MultiBracket (Structure e.InBracket) t.ParentStack)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (CloseBrac t.SrcPos) =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList (CloseBrac t.SrcPos)
				'any correct term (unbalanced structure brackets)'
			> t.IModule t.VarTable
			( e.PatternExpr t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( e.PatternExpr t.ParentStack )
	t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList (CloseSquare t.SrcPos)
				'any correct term (unbalanced ADT brackets)'
			> t.IModule t.VarTable
			( e.PatternExpr t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( '$' e.PatternExpr (e.ParentStack))
	t.Lexer (Replaces t.SrcPos) =
		t.ErrorList t.IModule t.VarTable
		( (Pattern e.PatternExpr) e.ParentStack )
		t.Lexer (Replaces t.SrcPos);

	t.ErrorList t.IModule t.VarTable
	( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
	t.Lexer (Replaces t.SrcPos) =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList (Replaces t.SrcPos)
				'\'' s.BracketType '\''
			> t.IModule t.VarTable
			( e.MultiBracket (e.InBrackets) t.ParentStack )
			t.Lexer (Replaces t.SrcPos)
		>;

	t.ErrorList t.IModule t.VarTable
	( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
	t.Lexer t.Unexpected =
		<NPatternExpr
			<MError::AddUnexpected
				t.ErrorList t.Unexpected
				'\'' s.BracketType '\''
			> t.IModule t.VarTable
			( e.MultiBracket (e.InBrackets) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( '$' e.PatternExpr (e.ParentStack) )
	t.Lexer t.Unexpected =
		<MError::AddUnexpected
			t.ErrorList t.Unexpected
			'pattern expression or semicolon'
		> t.IModule t.VarTable
		( (Pattern e.PatternExpr) e.ParentStack )
		t.Lexer t.Unexpected;
}

CallableADTName {
	t.ErrorList t.IModule t.VarTable
	( e.Pattern t.UpParentStack )
	t.Lexer (Identifier t.SrcPos e.Content) =
		t.ErrorList t.IModule t.VarTable
		( e.Pattern
			(Qualified t.SrcPos
				<MQualifiedName::Create (e.Content)>
			) t.UpParentStack
		) <MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule t.VarTable
	( e.Pattern t.UpParentStack )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'name of ADT'
		> t.IModule t.VarTable
		( e.Pattern InvalidADT t.UpParentStack )
		t.Lexer t.OtherToken;

}

CheckVariable {
	t.IModule t.ErrorList t.VarTable Success
	( e.ResultExpr t.ParentStack )
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		t.ErrorList t.IModule t.VarTable
		( e.ResultExpr (s.VarType e.Index) t.ParentStack )
		<MLexer::NextToken t.Lexer>;

	t.IModule t.ErrorList t.VarTable Fail
	( e.ResultExpr t.ParentStack )
	t.Lexer t.VarToken =
		t.ErrorList t.IModule t.VarTable
		( e.ResultExpr t.ParentStack )
		<MLexer::NextToken t.Lexer>;
}

NResultExpr {
	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		<NResultExpr
			<CheckVariable
				t.IModule
				<MVarTable::CheckVariable
					t.ErrorList t.VarTable t.SrcPos s.VarType e.Index
				>
				( e.ResultExpr t.ParentStack )
				t.Lexer (Var t.SrcPos s.VarType e.Index)
			>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (Identifier t.SrcPos e.Ident) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.ResultExpr (Identifier e.Ident) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (Literal t.SrcPos e.Content) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.ResultExpr (Literal e.Content) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (DQWord t.SrcPos e.Content) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.ResultExpr (DQWord e.Content) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (Macro t.SrcPos s.Value) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.ResultExpr (Macro s.Value) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (OpenBrac t.SrcPos) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( ( ')' e.ResultExpr ) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (OpenFnCall t.SrcPos) =
		<NResultExpr
			<NCallable
				t.ErrorList t.IModule t.VarTable
				( ( ('>' e.ResultExpr) t.ParentStack ) )
				<MLexer::NextToken t.Lexer>
			>                        
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (OpenSquare t.SrcPos) =
		<NResultExpr
			<CallableADTName
				t.ErrorList t.IModule t.VarTable
				( ( ']' e.ResultExpr ) t.ParentStack )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule t.VarTable
	( ( ')' e.MultiBracket ) e.InBrackets t.ParentStack )
	t.Lexer (CloseBrac t.SrcPos) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer ( CloseBrac t.SrcPos ) =
		<NResultExpr
			<MError::AddUnexpected
				t.ErrorList ( CloseBrac t.SrcPos )
				'result expression or semicolon (unbalanced structure brackets)'
			> t.IModule t.VarTable
			( e.ResultExpr t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( ( ']' e.MultiBracket ) InvalidADT e.InBrackets t.ParentStack )
	t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( ( ']' e.MultiBracket ) t.Callable e.InBrackets t.ParentStack )
	t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket
				(Abstract t.Callable e.InBrackets)
				t.ParentStack
			)
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			<MError::AddUnexpected
				t.ErrorList (CloseSquare t.SrcPos)
				'result expression or semicolon (unbalanced ADT brackets)'
			> t.IModule t.VarTable
			( e.ResultExpr t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	/* В случае ошибочного callable функциональные скобки
	интерпретируем как структурные. */
	t.ErrorList t.IModule t.VarTable
	( ('>' e.MultiBracket) InvalidCallable e.ResultExprFnArgument t.ParentStack )
	t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket
				(Structure e.ResultExprFnArgument)
				t.ParentStack
			) <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( ('>' e.MultiBracket) (FnCall t.Callable) e.ResultExprFnArgument t.ParentStack )
	t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			<MakeFnCallTerm
				t.ErrorList t.IModule t.VarTable
				( e.MultiBracket t.ParentStack )
				t.Callable e.ResultExprFnArgument
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	( ('>' e.MultiBracket) (IndirectCall (SVar e.Index)) e.ResultExprFnArgument t.ParentStack )
	t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket
				(IndirectCall (SVar e.Index) e.ResultExprFnArgument)
				t.ParentStack
			) <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(e.ResultExpr t.ParentStack)
	t.Lexer (CloseFnCall t.SrcPos) =
		<NResultExpr
			<MError::AddUnexpected
				t.ErrorList (CloseFnCall t.SrcPos)
				'result expression or semicolon (unbalanced function brackets)'
			> t.IModule t.VarTable
			( e.ResultExpr t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	('$' e.ResultExpr (e.ParentStack))
	t.Lexer (EndSent t.SrcPos) =
		t.ErrorList t.IModule t.VarTable ( (Result e.ResultExpr) e.ParentStack )
		t.Lexer (EndSent t.SrcPos);

	t.ErrorList t.IModule t.VarTable
	( ( s.BracketType e.MultiBracket ) e.InBrackets t.ParentStack )
	t.Lexer t.Unexpected =
		<NResultExpr
			<MError::AddUnexpected
				t.ErrorList t.Unexpected
				s.BracketType ' (unbalanced brackets)'
			> t.IModule t.VarTable
			( e.MultiBracket (e.InBrackets) t.ParentStack )
			t.Lexer t.Unexpected
		>;

	t.ErrorList t.IModule t.VarTable
	( '$' e.ResultExpr (e.ParentStack) )
	t.Lexer t.Unexpected =
		<MError::AddUnexpected
			t.ErrorList t.Unexpected
			'result expression or \';\'.'
		> t.IModule t.VarTable
		( (e.ResultExpr) e.ParentStack )
		t.Lexer t.Unexpected;
}

MakeFnCallTerm {
	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName )
	e.Argument =
		<SwMakeFnCallTerm
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket t.ParentStack )
			( Qualified t.SrcPos <MQualifiedName::Parse-T t.QualifiedName> )
			e.Argument
		>;
}

SwMakeFnCallTerm {
	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName ('FnPtr') )
	e.Argument =
		<MQualifiedName::Destroy t.QualifiedName>
		<CheckArgumentFnPtr
			t.ErrorList t.IModule
			t.VarTable
			( e.MultiBracket t.ParentStack )
			t.SrcPos e.Argument
		>;

	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName e.Segments )
	e.Argument =
		t.ErrorList t.IModule t.VarTable
		( e.MultiBracket
			(Function
				( Qualified t.SrcPos t.QualifiedName )
				e.Argument
			)
			t.ParentStack
		);
}

CheckArgumentFnPtr {
	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	t.SrcPos e.Argument =
		<DoCheckArgumentFnPtr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket t.ParentStack )
			<MQualifiedName::Create>
			t.SrcPos e.Argument
		>;
}

DoCheckArgumentFnPtr {
	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos
	(Identifier e.Content) e.Tail =
		<DoCheckArgumentFnPtr
			t.ErrorList t.IModule t.VarTable
			( e.MultiBracket t.ParentStack )
			<MQualifiedName::AddSubName t.QualifiedName e.Content>
			t.SrcPos e.Tail
		>;

	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos =
		t.ErrorList t.IModule t.VarTable
		( e.MultiBracket
			(FnPtr
				(Qualified
					t.SrcPos t.QualifiedName
				)
			)
			t.ParentStack
		);

	t.ErrorList t.IModule t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos
	t.OtherTerm e.Tail =
		<DoCheckArgumentFnPtr
			<MError::FnPtrError
				t.ErrorList t.SrcPos
			>
			t.IModule t.VarTable
			( e.MultiBracket t.ParentStack )
			t.QualifiedName t.SrcPos e.Tail
		>;
}

NCallable {
	t.ErrorList t.IModule t.VarTable ( t.ParentStack )
	t.Lexer (Identifier t.SrcPos e.Name) =
		<NCallable-AfterName
			t.ErrorList t.IModule t.VarTable
			( Name t.SrcPos e.Name )
			( t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable ( t.ParentStack )
	t.Lexer (Var t.SrcPos SVar e.Index) =
		<CheckCallableVariable
			t.IModule
			<MVarTable::CheckVariable
				t.ErrorList t.VarTable t.SrcPos SVar e.Index
			> ( t.ParentStack )
			t.Lexer (Var t.SrcPos SVar e.Index)
		>;

	t.ErrorList t.IModule t.VarTable ( (e.ResultExpr t.UpParentStack) )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'function name or module name'
		> t.IModule t.VarTable
 		( e.ResultExpr InvalidCallable t.UpParentStack )
		t.Lexer t.OtherToken;
}

CheckCallableVariable {
	t.IModule t.ErrorList t.VarTable Success
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer (Var t.SrcPos SVar e.Index) =
		t.ErrorList t.IModule t.VarTable (
			e.ResultExpr
			( IndirectCall (SVar e.Index))
			t.UpParentStack
		)
		<MLexer::NextToken t.Lexer>;

	t.IModule t.ErrorList t.VarTable Fail
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer (Var t.SrcPos SVar e.Index) =
		t.ErrorList
		t.IModule t.VarTable
		( e.ResultExpr InvalidCallable t.UpParentStack)
		<MLexer::NextToken t.Lexer>;
}

NCallable-AfterName {
	t.ErrorList t.IModule t.VarTable
	(Name t.NamePos e.Name)
	( t.ParentStack ) t.Lexer (DoubleColon t.SrcPos) =
		<NCallable-ReadQualified
			t.ErrorList t.IModule t.VarTable
			(Module t.NamePos e.Name)
			( t.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule t.VarTable
	(Name t.NamePos e.Name)
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer t.NextToken =
		t.ErrorList t.IModule t.VarTable (
			e.ResultExpr
			( FnCall
				(Qualified
					t.NamePos
					<MQualifiedName::Create (e.Name)>
				)
			) t.UpParentStack
		) t.Lexer t.NextToken;
}

NCallable-ReadQualified {
	t.ErrorList t.IModule t.VarTable
	(Module t.ModNamePos e.Name)
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer (Identifier t.SrcPos e.Function) =
		t.ErrorList t.IModule t.VarTable (
			e.ResultExpr
			(FnCall
				(Qualified
					t.ModNamePos
					<MQualifiedName::Create (e.Name) (e.Function)>
				)
			) t.UpParentStack
		) <MLexer::NextToken t.Lexer>;

	t.ErrorList t.IModule t.VarTable
	(Module t.ModNamePos e.Name)
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'qualified function name'
		> t.IModule t.VarTable
		( e.ResultExpr InvalidCallable t.UpParentStack )
		t.Lexer t.OtherToken;
}


//------------------------------------------------------------------------------
// Синтаксический анализ sym-модуля
//------------------------------------------------------------------------------

NSymModule {
	t.ErrorList t.IModule ()
	t.Lexer t.NextToken =
		<NSymModuleBody
			<NModuleHeader
				t.ErrorList t.IModule () t.Lexer t.NextToken
			>
		>;
}

NFunctionDeclaration {
	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer (Identifier t.SrcPos e.FnName) =
		<ExpectEndSent
			<AddNewFunction
				t.ErrorList t.IModule t.SrcPos (e.FnName)
				(ScopeClass Entry)
			> ( e.ParentStack )
			<MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.IModule ( e.ParentStack )
	t.Lexer t.Unexpected =
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'function name'
		> t.IModule ( e.ParentStack )
		t.Lexer t.Unexpected;
}

NSymModuleBody {
	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Import) =
		<NSymModuleBody
			<NImportBlock
				t.ErrorList t.IModule
				( e.Elements )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos Entry) =
		<NSymModuleBody
			<NFunctionDeclaration
				t.ErrorList t.IModule
				( e.Elements )
				<MLexer::NextToken t.Lexer>
			>
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer
			t.ErrorList t.IModule ( e.Elements )
			t.Lexer (Directive t.SrcPos End)
		>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos)
			'import or function declaration'
		> t.IModule
		<MLexer::Destroy t.Lexer>;

	t.ErrorList t.IModule ( e.Elements )
	t.Lexer t.Unexpected =
		<NSymModuleBody
			<MError::AddUnexpected
				t.ErrorList t.Unexpected 'import or function declaration'
			> t.IModule ( e.Elements )
			<MLexer::NextToken t.Lexer>
		>;
}

$END MParser.
