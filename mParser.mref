$MODULE MParser;

$IMPORT MLexer;
$IMPORT MError;
$IMPORT MIModule;
$IMPORT MQualifiedName;
$IMPORT MStrings;
$IMPORT MVarTable;

/**
	<SrcModule_New t.ErrorList t.QualifiedName e.FileName>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
	s.Result ::= Success | Warnings | Errors
*/
$ENTRY SrcModule
	t.ErrorList t.QualifiedName e.FileName =
		<GeneralizeInfo
			t.ErrorList
			t.QualifiedName
			<Parse <FnPtr NModule> e.FileName>
		>;

/**
	<SymModule_New t.ErrorList t.QualifiedName e.FileName>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
	s.Result ::= Success | Warnings | Errors
*/
$ENTRY SymModule
	t.ErrorList t.QualifiedName e.FileName =
		<GeneralizeInfo
			t.ErrorList
			t.QualifiedName
			<Parse <FnPtr NSymModule> e.FileName>
		>;

Parse
	s.FnMainNeterminal e.FileName =
		<Parse-Aux
			<s.FnMainNeterminal
				<MIModule::Create>
				<MError::CreateErrList>
				<MLexer::NextToken
					<MLexer::Create e.FileName>
				>
			>
		>;

Parse-Aux
	t.IModule t.ErrorList = t.ErrorList Success t.IModule;

GeneralizeInfo {
	t.GenericErrorList t.QualifiedName
	t.ErrorList Success t.IModule =
		<MergeErrorLists
			t.GenericErrorList
			<CheckLocalErrorList
				<CompareQNames
					t.QualifiedName
					t.ErrorList
					t.IModule
				>
			>
		>;

	t.GenericErrorList t.QualifiedName
	t.ErrorList Fails =
		<MError::MergeLists t.GenericErrorList t.ErrorList>
		<MQualifiedName::Destroy t.QualifiedName>
		Fails;
}

/*
	<MergeErrorLists
		t.Generic t.ErrorList Success s.Result t.IModule
		t.Generic t.ErrorList Fails
	>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
	s.Reslult ::= Success | Warnings | Errors
*/
MergeErrorLists {
	t.Generic t.LocalErrorList s.SF-Result e.MaybeInfo =
		<MError::MergeLists t.Generic t.LocalErrorList>
		s.SF-Result e.MaybeInfo;
}

/*
	<CheckLocalErrorList
		t.ErrorList Success t.IModule
		t.ErrorList Fails
	>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
*/
CheckLocalErrorList {
	t.ErrorList Success t.IModule =
		<CheckLocalErrorList-Aux
			<MError::ContentLevel t.ErrorList>
			t.IModule
		>;

	t.ErrorList Fails = t.ErrorList Fails;
}

CheckLocalErrorList-Aux {
	t.ErrorList Empty t.IModule =
		t.ErrorList Success Success t.IModule;

	t.ErrorList Warnigs t.IModule =
		t.ErrorList Success Warnings t.IModule;

	t.ErrorList Errors t.IModule =
		t.ErrorList Success Errors t.IModule;

}

/*
	<CompareQNames
		t.QualifiedName t.ErrorList t.IModule
	>
		== t.ErrorList Success t.IModule
		== t.ErrorList Fails
*/
CompareQNames
	t.QualifiedName t.ErrorList t.IModule =
		<CompareQNames-Aux
			( <MQualifiedName::Parse-T t.QualifiedName> )
			t.ErrorList
			<MIModule::GetModuleName t.IModule>
		>;

CompareQNames-Aux {
	( t.ExternalName e.Segments )
	t.ErrorList t.IModule Unknown =
		<MQualifiedName::Destroy t.ExternalName>
		<MIModule::Destroy t.IModule>
		// В список ошибок ничего не добавляем, т.к. подобное состояние модуля
		// уже должно быть отловлено.
		t.ErrorList Fails;

	( t.ExternalName (e.Name) )
	t.ErrorList t.IModule e.Name =
		<MQualifiedName::Destroy t.ExternalName>
		t.ErrorList Success t.IModule;

	( t.ExternalName e.ExtName )
	t.ErrorList t.IModule e.InternalName =
		<CompareQNames-AddErrorInfo
			t.ExternalName t.ErrorList
			<MIModule::GetModuleAttribute t.IModule Position>
			<MQualifiedName::Create (e.InternalName)>
		>;
}

CompareQNames-AddErrorInfo {
	t.ExternalName t.ErrorList
	t.IModule Found t.SrcPos
	t.InternalName =
		<MIModule::Destroy t.IModule>
		<MError::AddMismatchInternalAndExternalNames
			t.ErrorList t.SrcPos t.InternalName t.ExternalName
		> Fails;

	// Ошибку не проверяем, пусть будет fail down
}

/*------------------------------------------------------------------------------
	Функции синтаксического анализа делятся на три категории:
	(1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
	После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
	(2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
	(3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

//------------------------------------------------------------------------------
// Добавление в таблицу символов
//------------------------------------------------------------------------------

AddNewImport
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateImport
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

AddNewFunction
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList=
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateFunction
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

AddNewADT
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateADT
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

CheckRedeclaration {
	t.ErrorList t.IModule Success t.SrcPos e.NewName =
		t.IModule t.ErrorList;

	t.ErrorList t.IModule InvalidKind t.SrcPos e.NewName =
		t.IModule
		<MError::AddRedeclaredIdentifier
			t.ErrorList t.SrcPos e.NewName
		>;

	/*
		Две другие ошибки -- InvalidKind и InvariantError означают
		нарушение инварианта. Программа автоматически умрёт.
	*/
}

//------------------------------------------------------------------------------
// Синтаксический анализ модуля
//------------------------------------------------------------------------------

// Module = ModuleHeader ModuleBody ModuleTailer .
NModule
	t.IModule t.ErrorList t.Lexer t.NextToken =
		<NModuleBody
			<NModuleHeader
				t.IModule t.ErrorList t.Lexer t.NextToken
			>
		>;

//-------------------------------------------------------------------------------

// ModuleHeader = '$module' ModuleName ';' .
NModuleHeader {
	t.IModule t.ErrorList t.Lexer (Directive t.SrcPos Module) =
		<NModuleHeader-ModuleName
			t.IModule Regular
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule t.ErrorList t.Lexer (Directive t.SrcPos Program) =
		<NModuleHeader-ModuleName
			t.IModule Main
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule t.ErrorList t.Lexer (Directive t.SrcPos ClearModule) =
		<NModuleHeader-ModuleName
			t.IModule Clear
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Обработка ошибок в данном случае -- добавляем в список ошибок неожиданный
	символ, считаем, что прочли текущую лексему как '$module' и продолжаем
	дальнейший разбор.
	*/
	t.IModule t.ErrorList t.Lexer t.OtherToken =
		<NModuleHeader-ModuleName
			t.IModule Regular
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'directive \'$MODULE\''
			>
			<MLexer::NextToken t.Lexer>
		>;
}

CheckSuccess {
	(e.FnName) t.IModule Success = t.IModule;

	/* Нарушение инварианта -- fail down
	В случае fail down в отладочном дампе будет виден параметр
	e.FnName -- это позволяет отловить место вылета ошибки */
}

NModuleHeader-ModuleName {
	t.IModule s.ModuleType
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<ExpectEndSent-Section
			<CheckSuccess
				('NModuleHeader-ModuleName')
				<MIModule::UpdateModule
					<CheckSuccess
						('NMH-MN: SetModuleName')
						<MIModule::SetModuleName t.IModule e.Name>
					>
					(Position t.SrcPos)
					(ModuleType s.ModuleType)
				>
			>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Здесь мы пропускаем текущую неопознанную лексему до тех пор, пока
	не встретим идентификатор или конец ввода */
	t.IModule s.ModuleType
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'module name'
		>
		t.Lexer (EndOfText t.SrcPos);

	t.IModule s.ModuleType t.ErrorList t.Lexer t.OtherToken =
		<NModuleHeader-ModuleName
			t.IModule s.ModuleType
			<MError::AddUnexpected
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;
}

//------------------------------------------------------------------------------

/*
	AnyQualifiedName = DotQualifiedName | QuadQualifiedName .
	DotQualifiedName =
		IDENTIFIER | DotQualifiedName '.' IDENTIFIER .
	QuadQualifiedName =
		IDENTIFIER | QuadQualifiedName '::' IDENTIFIER .
	
	<N***QualifiedName
		t.ErrorList t.Lexer t.NextToken
	>
		== e.ScannedQName t.ErrorList t.Lexer t.NextToken

	e.ScannedQName ::=
		Success t<MQualifiedName::QName>.QualifiedName | Fails

	В случае ошибки на стеке оставляется первый неожиданный терм.
	Если имя было частично определено, например так:
		'PackageName::ModuleName::222',
	то имя считается распознанным успешно. Информация об ошибке
	падает в t.ErrorList, но синтаксически инвариант соблюдётся.
*/
NAnyQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NAnyQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		Fails
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NAnyQualifiedName-AfterName {
	t.StartName t.ErrorList t.Lexer (DoubleColon t.SrcPos) =
		<NQuadQualifiedName-Loop
			t.StartName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.StartName t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NDotQualifiedName-Loop
			t.StartName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.StartName t.ErrorList t.Lexer t.OtherToken =
		Success t.StartName
		t.ErrorList t.Lexer t.OtherToken;
}

NQuadQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NQuadQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		<MError::AddUnexpected
			t.Unexpected 'identifier'
		>
		t.ErrorList t.Lexer t.Unexpected;
}

NQuadQualifiedName-AfterName {
	t.PartOfName t.ErrorList t.Lexer (DoubleColon t.SrcPos) =
		<NQuadQualifiedName-Loop
			t.PartOfName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		Success t.PartOfName
		t.ErrorList t.Lexer t.Unexpected;
}

NQuadQualifiedName-Loop {
	t.PartOfName t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NQuadQualifiedName-AfterName
			<MQualifiedName::AddSubName
				t.PartOfName e.Name
			>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		Success t.PartOfName
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NDotQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NDotQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		Fails
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NDotQualifiedName-AfterName {
	t.PartOfName t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NDotQualifiedName-Loop
			t.PartOfName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		Success t.PartOfName
		t.ErrorList t.Lexer t.Unexpected;
}

NDotQualifiedName-Loop {
	t.PartOfName t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NDotQualifiedName-AfterName
			<MQualifiedName::AddSubName
				t.PartOfName e.Name
			>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		Success t.PartOfName
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

ExpectEndSent-Section {
	t.IModule t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.IModule
		t.ErrorList <MLexer::NextToken t.Lexer>;

	/* Делаем вид, что точка с запятой была */
	t.IModule t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'semicolon'
		>
		t.Lexer t.OtherToken;
}

ExpectEndSent {
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.ErrorList <MLexer::NextToken t.Lexer>;

	/* Делаем вид, что точка с запятой была */
	t.ErrorList t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'semicolon'
		>
		t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

NModuleTailer {
	t.IModule t.ErrorList t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer-ModuleName
			(<MIModule::GetModuleName t.IModule>)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;
}

NModuleTailer-ModuleName {
	(t.IModule e.ModuleName)
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName) =
		t.IModule
		<NModuleTailer-Dot
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	(t.IModule e.ModuleName-Head)
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName-Tail) =
		t.IModule
		<NModuleTailer-Dot
			<MError::AddNamesMismatch
				t.ErrorList t.SrcPos
				(e.ModuleName-Head) (e.ModuleName-Tail)
			>
			<MLexer::NextToken t.Lexer>
		>;

	/* Пропускаем следующую лексему, до тех пор, пока не встретим
	конец файла или идентификатор */
	(t.IModule e.ModuleName)
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'repeat of module name'
		>
		t.Lexer (EndOfText t.SrcPos);

	(t.IModule e.ModuleName)
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-ModuleName
			(t.IModule e.ModuleName)
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'repeat of moduleName'
			>
			<MLexer::NextToken t.Lexer>
		>;
}

NModuleTailer-Dot {
	t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NModuleTailer-EOF
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Считаем, что точка была */
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end dot'
			>
			t.Lexer t.OtherToken
		>;
}

NModuleTailer-EOF {
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.ErrorList <MLexer::Destroy t.Lexer>;

	/* Пропускаем все другие лексемы до тех пор, пока не доберёмся до конца файла */
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end of file'
			>
			<MLexer::NextToken t.Lexer>
		>;
}


//------------------------------------------------------------------------------

/* ModuleBody = { ImportBlock | FunctionDefinition | SwapDefinition }* . */
NModuleBody {
	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Import) =
		<NModuleBody
			<NImportBlock
				t.IModule
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Swap) =
		<NModuleBody
			<NSwapBlock
				t.IModule
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Entry) =
		<NModuleBody
			<NFunctionDefinition
				t.IModule
				( Entry )
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Data) =
		<NModuleBody
			<NDataBlock
				t.IModule
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
		<NModuleBody
			<NFunctionDefinition
				t.IModule
				( Local )
				t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident)
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		<NModuleBody
			t.IModule
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Завершение рекурсии */
	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer
			t.IModule
			t.ErrorList t.Lexer (Directive t.SrcPos End)
		>;

	/* При обнаружении конца файла завершаем анализ */
	t.IModule
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList
			(EndOfText t.SrcPos)
			'$entry, $import, $swap or local function definition'
		>
		<MLexer::Destroy t.Lexer>;

	/* Любая другая лексема пропускается */
	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleBody
			t.IModule
			<MError::AddUnexpected
				t.ErrorList
				t.OtherToken
				'$entry, $import, $swap or local function definition'
			>
			<MLexer::NextToken t.Lexer>
		>;
}

//------------------------------------------------------------------------------

NImportBlock {
	t.IModule
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterName
			t.IModule
			( Import e.ModuleName )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name or module alias'
		>
		<MLexer::NextToken t.Lexer>;
}

NImportBlock-AfterName {
	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		<AddNewImport
			t.IModule t.SrcPos (e.ModuleName)
			(Alias e.ModuleName)
			t.ErrorList
		>
		<MLexer::NextToken t.Lexer>;

	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (Replaces t.SrcPos) =
		<NImportBlock-ModuleRenaming
			t.IModule
			(Alias e.ModuleName)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			<AddNewImport
				t.IModule t.SrcPos (e.ModuleName)
				(Alias e.ModuleName)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	// Считаем, что пользователь пропустил точку с запятой
	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma, semicolon or replace'
		>
		t.Lexer t.OtherToken;
}

NImportBlock-ModuleRenaming {
	t.IModule
	(Alias e.Alias)
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterAlias
			<AddNewImport
				t.IModule t.SrcPos (e.ModuleName)
				(Alias e.Alias)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	//Считаем, что попытки переименования не было
	t.IModule
	(Alias e.Alias)
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name'
		>
		t.Lexer t.OtherToken;
}

NImportBlock-AfterAlias {
	t.IModule
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			t.IModule
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.IModule
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		>
		t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

/*
	SwapBlock = '$swap' SwapBlock-Chain .
	SwapBlock-Chain = IDENTIFIER SwapBlock-AfterName .
	SwapBlock-AfterName = ';' | ',' Swap-Chain .
*/
NSwapBlock {
	t.IModule
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
		<NSwapBlock-AfterName
			<AddNewFunction
				t.IModule t.SrcPos (e.Ident)
				(ScopeClass Swap)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'swap name'
		>
		t.Lexer t.OtherToken;
}

NSwapBlock-AfterName {
	t.IModule
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NSwapBlock
			t.IModule
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.IModule
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		>
		t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

/*
	DataBlock = '$swap' DataBlock-Chain .
	DataBlock-Chain = IDENTIFIER DataBlock-AfterName .
	DataBlock-AfterName = ';' | ',' DataBlock-Chain .
*/
NDataBlock {
	t.IModule
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
		<NDataBlock-AfterName
			<AddNewADT
				t.IModule t.SrcPos (e.Ident)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'swap name'
		>
		t.Lexer t.OtherToken;
}

NDataBlock-AfterName {
	t.IModule
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NDataBlock
			t.IModule
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.IModule
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		>
		t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

NFunctionDefinition {
	t.IModule ( s.ScopeClass )
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
		<NFunctionDefinition-Closing
			t.IModule
			<NFunctionBody
				(( (Function s.ScopeClass (e.Ident) t.SrcPos) ))
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	/* Возвращаемся в ModuleBody, как будто спецификатора $ENTRY и не было
	в помине */
	t.IModule ( s.ScopeClass )
	t.ErrorList t.Lexer t.UnexpectedToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.UnexpectedToken 'function name'
		>
		t.Lexer t.UnexpectedToken;
}

NFunctionDefinition-Closing
	t.IModule
	( t.FunctionBody ( Function s.ScopeClass (e.Name) t.SrcPos ) )
	t.ErrorList t.Lexer t.NextToken =
		<AddNewFunction
			t.IModule t.SrcPos (e.Name)
			(Body t.FunctionBody)
			(ScopeClass s.ScopeClass)
			(Qualified <MQualifiedName::Create (e.Name)>)
			t.ErrorList
		>
		t.Lexer t.NextToken;

//------------------------------------------------------------------------------

NFunctionBody {
	( t.ParentStack ) t.ErrorList t.Lexer (OpenBlock t.SrcPos) =
		<NBlock
			( t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	( t.ParentStack ) t.ErrorList t.Lexer t.StartSentence =
		<NFunctionBody
			<NSentence
				( (OneSentence t.ParentStack) )
				t.ErrorList t.Lexer t.StartSentence
			>
		>;

	( e.Sentence OneSentence (e.ParentStack) )
	t.ErrorList t.Lexer t.NextToken =
		( (e.Sentence) e.ParentStack )
		t.ErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

NBlock {
	( e.Sentences (e.ParentStack) )
	t.ErrorList t.Lexer (CloseBlock t.SrcPos) =
		( (<MStrings::Reverse e.Sentences>) e.ParentStack )
		t.ErrorList <MLexer::NextToken t.Lexer>;

	( e.Sentences (e.ParentStack) )
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		( (<MStrings::Reverse e.Sentences>) e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'start of pattern of closing block'
		>
		<MLexer::NextToken t.Lexer>;

	( e.Sentences t.ParentStack )
	t.ErrorList t.Lexer t.StartSentence =
		<NBlock
			<NSentence
				( (e.Sentences t.ParentStack) )
				t.ErrorList t.Lexer t.StartSentence
			>
		>;
}

//------------------------------------------------------------------------------

NSentence {
	( (e.ParentStack) )
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		( e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'start of pattern'
		>
		t.Lexer (EndOfText t.SrcPos);

	( t.ParentStack )
	t.ErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info) =
		<NSentence-ExpectReplaces
			<NPatternExpr
				<MVarTable::Create>
				( '$' (t.ParentStack) )
				t.ErrorList t.Lexer (s.StartOfPattern t.SrcPos e.Info)
			>
		>;
}

NSentence-ExpectReplaces {
	t.VarTable ( t.Pattern t.ParentStack )
	t.ErrorList t.Lexer (Replaces t.SrcPos) =
		<NSentence-Closing
			<NResultExpr
				t.VarTable ( '$' (t.Pattern t.ParentStack) )
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	/* Игнорируем уже разобранное образцовое выражение --
	игнорируем целиком пропущенное предложение. При этом необходимо
	съесть неожиданную лексему -- эта лексема оказалась неожиданной
	для образцового выражения, а следующее предложение начинается с
	образца. */

	t.VarTable ( t.Pattern (e.ParentStack) )
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		<MVarTable::Destroy t.VarTable>
		( e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) '\'=\''
		>
		<MLexer::NextToken t.Lexer>;

	t.VarTable ( t.Pattern (e.ParentStack) )
	t.ErrorList t.Lexer t.UnexpectedToken =
		<MVarTable::Destroy t.VarTable>
		( e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList t.UnexpectedToken '\'=\''
		>
		<MLexer::NextToken t.Lexer>;
}

NSentence-Closing {
	t.VarTable ( t.Result t.Pattern (e.ParentStack) )
	t.ErrorList t.Lexer t.NextToken =
		<MVarTable::Destroy t.VarTable>
		( (t.Pattern t.Result) e.ParentStack )
		<ExpectEndSent
			t.ErrorList t.Lexer t.NextToken
		>;
}

//------------------------------------------------------------------------------

AddVariable {
	t.ErrorList t.VarTable Success
	( e.PatternExpr t.ParentStack )
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		t.VarTable
		( e.PatternExpr (s.VarType e.Index) t.ParentStack )
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.ErrorList t.VarTable Fails
	( e.PatternExpr t.ParentStack )
	t.Lexer t.VarToken =
		t.VarTable
		( e.PatternExpr t.ParentStack )
		t.ErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NPatternExpr {
	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
		<NPatternExpr
			<AddVariable
				<MVarTable::AddVariable
					t.ErrorList t.VarTable t.SrcPos s.VarType e.Index
				>
				( e.PatternExpr t.ParentStack )
				t.Lexer (Var t.SrcPos s.VarType e.Index)
			>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Identifier) =
		<NPatternExpr
			t.VarTable
			<AnyExpr-AnalyzeStartOfQualifiedName
				( e.PatternExpr t.ParentStack )
				(e.Identifier)
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (Literal t.SrcPos e.Content) =
		<NPatternExpr
			t.VarTable
			(e.PatternExpr (Literal e.Content) t.ParentStack)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (DQWord t.SrcPos e.Content) =
		<NPatternExpr
			t.VarTable
			(e.PatternExpr (DQWord e.Content) t.ParentStack)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (Macro t.SrcPos s.Value) =
		<NPatternExpr
			t.VarTable
			(e.PatternExpr (Macro s.Value) t.ParentStack)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (Ampersand t.SrcPos) =
		<NPatternExpr
			t.VarTable
			<QualifiedSuccessed
				t.SrcPos ( e.PatternExpr t.ParentStack )
				<NDotQualifiedName
					t.ErrorList <MLexer::NextToken t.Lexer>
				>
			>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (OpenBrac t.SrcPos) =
		<NPatternExpr
			t.VarTable ( (')' e.PatternExpr) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (OpenSquare t.SrcPos) =
		<NPatternExpr
			<CallableADTName
				t.VarTable ( (']' e.PatternExpr) t.ParentStack )
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	/* Сделаем осмысленную реакцию на ошибки -- будем интерпретировать
	функциональную скобку как структурную. */
	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (OpenFnCall t.SrcPos) =
		<NPatternExpr
			t.VarTable ( (')' e.PatternExpr) t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (OpenFnCall t.SrcPos)
				'any correct passive term'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( (')' e.MultiBracket) e.InBrackets t.ParentStack)
	t.ErrorList t.Lexer (CloseBrac t.SrcPos) =
		<NPatternExpr
			t.VarTable
			(e.MultiBracket (Structure e.InBrackets) t.ParentStack)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( (']' e.MultiBracket) InvalidADT e.InBrackets t.ParentStack)
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			t.VarTable
			(e.MultiBracket (Structure e.InBrackets) t.ParentStack)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( (']' e.MultiBracket) t.Callable e.InBrackets t.ParentStack)
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			t.VarTable
			(e.MultiBracket
				(Abstract t.Callable e.InBrackets)
				t.ParentStack
			)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Продолжение осмысленной реакции -- интерпретация закрывающей
	функциональной скобки как структурной*/
	t.VarTable ( (')' e.MultiBracket) e.InBracket t.ParentStack)
	t.ErrorList t.Lexer (CloseFnCall t.SrcPos) =
		<NPatternExpr
			t.VarTable
			(e.MultiBracket (Structure e.InBracket) t.ParentStack)
			<MError::AddUnexpected
				t.ErrorList (CloseFnCall t.SrcPos)
				'any correct passive term'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (CloseBrac t.SrcPos) =
		<NPatternExpr
			t.VarTable ( e.PatternExpr t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (CloseBrac t.SrcPos)
				'any correct term (unbalanced structure brackets)'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.PatternExpr t.ParentStack )
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NPatternExpr
			t.VarTable ( e.PatternExpr t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (CloseSquare t.SrcPos)
				'any correct term (unbalanced ADT brackets)'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( '$' e.PatternExpr (e.ParentStack))
	t.ErrorList t.Lexer (Replaces t.SrcPos) =
		t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
		t.ErrorList t.Lexer (Replaces t.SrcPos);

	t.VarTable
	( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer (Replaces t.SrcPos) =
		<NPatternExpr
			t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (Replaces t.SrcPos)
				'\'' s.BracketType '\''
			>
			t.Lexer (Replaces t.SrcPos)
		>;

	t.VarTable
	( (s.BracketType e.MultiBracket) e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer t.Unexpected =
		<NPatternExpr
			t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList t.Unexpected
				'\'' s.BracketType '\''
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( '$' e.PatternExpr (e.ParentStack) )
	t.ErrorList t.Lexer t.Unexpected =
		t.VarTable ( (Pattern e.PatternExpr) e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList t.Unexpected
			'pattern expression or semicolon'
		>
		t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

AnyExpr-AnalyzeStartOfQualifiedName {
	(e.Expression t.ParentStack) (e.Name)
	t.ErrorList t.Lexer (Dot t.SrcPos) =
		<ConcatQualified
			(e.Name)
			t.SrcPos (e.Expression t.ParentStack)
			<NDotQualifiedName
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	(e.Expression t.ParentStack) (e.Name)
	t.ErrorList t.Lexer t.NextToken =
		(e.Expression (Identifier e.Name) t.ParentStack)
		t.ErrorList t.Lexer t.NextToken;
}

ConcatQualified {
	(e.Name) t.SrcPos (e.Expression t.ParentStack)
	Success t.QualifiedName
	t.ErrorList t.Lexer t.NextToken =
		(e.Expression
			(FnPtr
				(Qualified
					t.SrcPos
					<MQualifiedName::AddSuperName t.QualifiedName e.Name>
				)
			)
			t.ParentStack
		)
		t.ErrorList t.Lexer t.NextToken;

	(e.Name) t.SrcPos (e.Expression t.ParentStack)
	Fails
	t.ErrorList t.Lexer t.NextToken =
		(e.Expression (Identifier e.Name) t.ParentStack)
		t.ErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

QualifiedSuccessed {
	t.SrcPos ( e.Expression t.ParentStack)
	Success t.QualifiedName
	t.ErrorList t.Lexer t.NextToken =
		(e.Expression
			(FnPtr (Qualified t.SrcPos t.QualifiedName))
			t.ParentStack
		)
		t.ErrorList t.Lexer t.NextToken;

	t.SrcPos ( e.Expression t.ParentStack )
	Fails
	t.ErrorList t.Lexer t.NextToken =
        (e.Expression t.ParentStack)
        t.ErrorList t.Lexer t.NextToken;
}

//------------------------------------------------------------------------------

CallableADTName {
	t.VarTable ( e.Pattern t.UpParentStack )
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Content) =
		t.VarTable
		( e.Pattern
			(Qualified t.SrcPos
				<MQualifiedName::Create (e.Content)>
			) t.UpParentStack
		) t.ErrorList <MLexer::NextToken t.Lexer>;

	t.VarTable ( e.Pattern t.UpParentStack )
	t.ErrorList t.Lexer t.OtherToken =
		t.VarTable
		( e.Pattern InvalidADT t.UpParentStack )
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'name of ADT'
		>
		t.Lexer t.OtherToken;

}

//------------------------------------------------------------------------------

CheckVariable {
	t.ErrorList t.VarTable Success
	( e.ResultExpr t.ParentStack )
	t.Lexer (Var t.SrcPos s.VarType e.Index) =
		t.VarTable ( e.ResultExpr (s.VarType e.Index) t.ParentStack )
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.ErrorList t.VarTable Fails
	( e.ResultExpr t.ParentStack )
	t.Lexer t.VarToken =
		t.VarTable ( e.ResultExpr t.ParentStack )
		t.ErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------

NResultExpr {
	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (Var t.SrcPos s.VarType e.Index) =
		<NResultExpr
			<CheckVariable
				<MVarTable::CheckVariable
					t.ErrorList t.VarTable t.SrcPos s.VarType e.Index
				>
				( e.ResultExpr t.ParentStack )
				t.Lexer (Var t.SrcPos s.VarType e.Index)
			>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Ident) =
		<NResultExpr
			t.VarTable
			<AnyExpr-AnalyzeStartOfQualifiedName
				( e.ResultExpr t.ParentStack )
				(e.Ident)
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (Literal t.SrcPos e.Content) =
		<NResultExpr
			t.VarTable
			( e.ResultExpr (Literal e.Content) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (DQWord t.SrcPos e.Content) =
		<NResultExpr
			t.VarTable
			( e.ResultExpr (DQWord e.Content) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (Macro t.SrcPos s.Value) =
		<NResultExpr
			t.VarTable
			( e.ResultExpr (Macro s.Value) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable ( e.ResultExpr t.ParentStack )
	t.ErrorList t.Lexer (Ampersand t.SrcPos) =
		<NResultExpr
			t.VarTable
			<QualifiedSuccessed
				t.SrcPos ( e.ResultExpr t.ParentStack )
				<NDotQualifiedName
					t.ErrorList <MLexer::NextToken t.Lexer>
				>
			>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (OpenBrac t.SrcPos) =
		<NResultExpr
			t.VarTable ( ( ')' e.ResultExpr ) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (OpenFnCall t.SrcPos) =
		<NResultExpr
			<NCallable
				t.VarTable
				( ( ('>' e.ResultExpr) t.ParentStack ) )
				t.ErrorList <MLexer::NextToken t.Lexer>
			>                        
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (OpenSquare t.SrcPos) =
		<NResultExpr
			<CallableADTName
				t.VarTable ( ( ']' e.ResultExpr ) t.ParentStack )
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.VarTable ( ( ')' e.MultiBracket ) e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer (CloseBrac t.SrcPos) =
		<NResultExpr
			t.VarTable
			( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer ( CloseBrac t.SrcPos ) =
		<NResultExpr
			t.VarTable ( e.ResultExpr t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList ( CloseBrac t.SrcPos )
				'result expression or semicolon (unbalanced structure brackets)'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( ( ']' e.MultiBracket ) InvalidADT e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			t.VarTable
			( e.MultiBracket (Structure e.InBrackets) t.ParentStack )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( ( ']' e.MultiBracket ) t.Callable e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			t.VarTable
			( e.MultiBracket
				(Abstract t.Callable e.InBrackets)
				t.ParentStack
			)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (CloseSquare t.SrcPos) =
		<NResultExpr
			t.VarTable ( e.ResultExpr t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (CloseSquare t.SrcPos)
				'result expression or semicolon (unbalanced ADT brackets)'
			>
			<MLexer::NextToken t.Lexer>
		>;

	/* В случае ошибочного callable функциональные скобки
	интерпретируем как структурные. */
	t.VarTable
	( ('>' e.MultiBracket) InvalidCallable e.ResultExprFnArgument t.ParentStack )
	t.ErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			t.VarTable
			( e.MultiBracket
				(Structure e.ResultExprFnArgument)
				t.ParentStack
			) t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( ('>' e.MultiBracket) (FnCall t.Callable) e.ResultExprFnArgument t.ParentStack )
	t.ErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			<MakeFnCallTerm
				t.VarTable ( e.MultiBracket t.ParentStack )
				t.Callable e.ResultExprFnArgument
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable
	( ('>' e.MultiBracket) (IndirectCall (SVar e.Index)) e.ResultExprFnArgument t.ParentStack )
	t.ErrorList t.Lexer ( CloseFnCall t.SrcPos ) =
		<NResultExpr
			t.VarTable
			( e.MultiBracket
				(IndirectCall (SVar e.Index) e.ResultExprFnArgument)
				t.ParentStack
			) t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.VarTable (e.ResultExpr t.ParentStack)
	t.ErrorList t.Lexer (CloseFnCall t.SrcPos) =
		<NResultExpr
			t.VarTable ( e.ResultExpr t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList (CloseFnCall t.SrcPos)
				'result expression or semicolon (unbalanced function brackets)'
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.VarTable ('$' e.ResultExpr (e.ParentStack))
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.VarTable ( (Result e.ResultExpr) e.ParentStack )
		t.ErrorList t.Lexer (EndSent t.SrcPos);

	t.VarTable
	( ( s.BracketType e.MultiBracket ) e.InBrackets t.ParentStack )
	t.ErrorList t.Lexer t.Unexpected =
		<NResultExpr
			t.VarTable ( e.MultiBracket (e.InBrackets) t.ParentStack )
			<MError::AddUnexpected
				t.ErrorList t.Unexpected
				s.BracketType ' (unbalanced brackets)'
			>
			t.Lexer t.Unexpected
		>;

	t.VarTable ( '$' e.ResultExpr (e.ParentStack) )
	t.ErrorList t.Lexer t.Unexpected =
		t.VarTable ( (e.ResultExpr) e.ParentStack )
		<MError::AddUnexpected
			t.ErrorList t.Unexpected
			'result expression or \';\'.'
		>
		t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

MakeFnCallTerm {
	t.VarTable ( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName )
	e.Argument t.ErrorList =
		<SwMakeFnCallTerm
			t.VarTable
			( e.MultiBracket t.ParentStack )
			( Qualified t.SrcPos <MQualifiedName::Parse-T t.QualifiedName> )
			e.Argument t.ErrorList
		>;
}

SwMakeFnCallTerm {
	t.VarTable ( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName ('FnPtr') )
	e.Argument t.ErrorList =
		<MQualifiedName::Destroy t.QualifiedName>
		<CheckArgumentFnPtr
			t.VarTable
			( e.MultiBracket t.ParentStack )
			t.SrcPos e.Argument t.ErrorList
		>;

	t.VarTable ( e.MultiBracket t.ParentStack )
	( Qualified t.SrcPos t.QualifiedName e.Segments )
	e.Argument t.ErrorList =
		t.VarTable
		( e.MultiBracket
			(Function
				( Qualified t.SrcPos t.QualifiedName )
				e.Argument
			)
			t.ParentStack
		) t.ErrorList;
}

CheckArgumentFnPtr {
	t.VarTable
	( e.MultiBracket t.ParentStack )
	t.SrcPos e.Argument t.ErrorList =
		<DoCheckArgumentFnPtr
			t.VarTable
			( e.MultiBracket t.ParentStack )
			<MQualifiedName::Create>
			t.SrcPos e.Argument t.ErrorList
		>;
}

DoCheckArgumentFnPtr {
	t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos
	(Identifier e.Content) e.Tail t.ErrorList =
		<DoCheckArgumentFnPtr
			t.VarTable
			( e.MultiBracket t.ParentStack )
			<MQualifiedName::AddSubName t.QualifiedName e.Content>
			t.SrcPos e.Tail t.ErrorList
		>;

	t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos t.ErrorList =
		t.VarTable
		( e.MultiBracket
			(FnPtr
				(Qualified
					t.SrcPos t.QualifiedName
				)
			)
			t.ParentStack
		) t.ErrorList;

	t.VarTable
	( e.MultiBracket t.ParentStack )
	t.QualifiedName t.SrcPos
	t.OtherTerm e.Tail t.ErrorList =
		<DoCheckArgumentFnPtr
			t.VarTable
			( e.MultiBracket t.ParentStack )
			t.QualifiedName t.SrcPos e.Tail
			<MError::FnPtrError
				t.ErrorList t.SrcPos
			>
		>;
}

//------------------------------------------------------------------------------

NCallable {
	t.VarTable ( t.ParentStack )
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		t.VarTable
		<NCallable-ReadQualifiedName
			t.SrcPos ( t.ParentStack )
			<NAnyQualifiedName
				t.ErrorList t.Lexer (Identifier t.SrcPos e.Name)
			>
		>;

	t.VarTable ( t.ParentStack )
	t.ErrorList t.Lexer (Ampersand t.SrcPos) =
		t.VarTable
		<NCallable-ReadQualifiedName
			t.SrcPos ( t.ParentStack )
			<NAnyQualifiedName
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.VarTable ( t.ParentStack )
	t.ErrorList t.Lexer (Var t.SrcPos SVar e.Index) =
		<CheckCallableVariable
			<MVarTable::CheckVariable
				t.ErrorList t.VarTable t.SrcPos SVar e.Index
			> ( t.ParentStack )
			t.Lexer (Var t.SrcPos SVar e.Index)
		>;

	t.VarTable ( (e.ResultExpr t.UpParentStack) )
	t.ErrorList t.Lexer t.OtherToken =
		t.VarTable
 		( e.ResultExpr InvalidCallable t.UpParentStack )
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'function name or module name'
		>
		t.Lexer t.OtherToken;
}

NCallable-ReadQualifiedName {
	t.NamePos ( (e.ResultExpr t.UpParentStack) )
	Success t.QualifiedName
	t.ErrorList t.Lexer t.NextToken =
		( e.ResultExpr
			( FnCall
				( Qualified t.NamePos t.QualifiedName )
			) t.UpParentStack
		)
		t.ErrorList t.Lexer t.NextToken;

	t.NamePos ( (e.ResultExpr t.UpParentStack) )
	Fails
	t.ErrorList t.Lexer t.NextToken =
		( e.ResultExpr InvalidCallable t.UpParentStack )
		t.ErrorList t.Lexer t.NextToken;
}

CheckCallableVariable {
	t.ErrorList t.VarTable Success
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer (Var t.SrcPos SVar e.Index) =
		t.VarTable (
			e.ResultExpr
			( IndirectCall (SVar e.Index))
			t.UpParentStack
		)
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.ErrorList t.VarTable Fails
	( (e.ResultExpr t.UpParentStack) )
	t.Lexer (Var t.SrcPos SVar e.Index) =
		t.VarTable
		( e.ResultExpr InvalidCallable t.UpParentStack)
		t.ErrorList <MLexer::NextToken t.Lexer>;
}

//------------------------------------------------------------------------------
// Синтаксический анализ sym-модуля
//------------------------------------------------------------------------------

NSymModule {
	t.IModule t.ErrorList t.Lexer t.NextToken =
		<NSymModuleBody
			<NModuleHeader
				t.IModule t.ErrorList t.Lexer t.NextToken
			>
		>;
}

//------------------------------------------------------------------------------

NFunctionDeclaration {
	t.IModule t.ErrorList t.Lexer (Identifier t.SrcPos e.FnName) =
		<ExpectEndSent-Section
			<AddNewFunction
				t.IModule t.SrcPos (e.FnName)
				(ScopeClass Entry)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer t.Unexpected =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'function name'
		>
		t.Lexer t.Unexpected;
}

//------------------------------------------------------------------------------

NSymModuleBody {
	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Import) =
		<NSymModuleBody
			<NImportBlock
				t.IModule
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos Entry) =
		<NSymModuleBody
			<NFunctionDeclaration
				t.IModule
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;

	t.IModule
	t.ErrorList t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer
			t.IModule
			t.ErrorList t.Lexer (Directive t.SrcPos End)
		>;

	t.IModule
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos)
			'import or function declaration'
		>
		<MLexer::Destroy t.Lexer>;

	t.IModule
	t.ErrorList t.Lexer t.Unexpected =
		<NSymModuleBody
			t.IModule
			<MError::AddUnexpected
				t.ErrorList t.Unexpected 'import or function declaration'
			>
			<MLexer::NextToken t.Lexer>
		>;
}

$END MParser.
