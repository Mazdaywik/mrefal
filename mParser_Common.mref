$MODULE MParser_Common;

$IMPORT MLexer;
$IMPORT MError;
$IMPORT MIModule;
$IMPORT MQualifiedName;

//==============================================================================
// Служебные функции
//==============================================================================

/**
	<Parse s.FnModuleBody e.FileName>
		== t.ErrorList Success t.IModule
		== t.ErrorList Fails
*/
$ENTRY Parse
	s.FnModuleBody e.FileName =
		<NGenericModule
			s.FnModuleBody
			<MError::CreateErrList>
			<MLexer::NextToken
				<MLexer::Create e.FileName>
			>
		>;

/**
	<GeneralizeInfo
		t.GenericErrorList t.QualifiedName
		t.LocalErrorList {Maybe t.IModule}
	>
		== t.ErrorList Success s.ErrorsLevel t.IModule
		== t.ErrorList Fails
	s.ErrorsLevel ::= Success | Warnings | Errors
*/
$ENTRY GeneralizeInfo {
	t.GenericErrorList t.QualifiedName
	t.ErrorList Success t.IModule =
		<MergeErrorLists
			t.GenericErrorList
			<CheckLocalErrorList
				<CompareQNames
					t.QualifiedName
					t.ErrorList
					t.IModule
				>
			>
		>;

	t.GenericErrorList t.QualifiedName
	t.ErrorList Fails =
		<MError::MergeLists t.GenericErrorList t.ErrorList>
		<MQualifiedName::Destroy t.QualifiedName>
		Fails;
}

/*
	<MergeErrorLists
		t.Generic t.ErrorList Success s.Result t.IModule
		t.Generic t.ErrorList Fails
	>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
	s.Reslult ::= Success | Warnings | Errors
*/
MergeErrorLists {
	t.Generic t.LocalErrorList s.SF-Result e.MaybeInfo =
		<MError::MergeLists t.Generic t.LocalErrorList>
		s.SF-Result e.MaybeInfo;
}

/*
	<CheckLocalErrorList
		t.ErrorList Success t.IModule
		t.ErrorList Fails
	>
		== t.ErrorList Success s.Result t.IModule
		== t.ErrorList Fails
*/
CheckLocalErrorList {
	t.ErrorList Success t.IModule =
		<CheckLocalErrorList-Aux
			<MError::ContentLevel t.ErrorList>
			t.IModule
		>;

	t.ErrorList Fails = t.ErrorList Fails;
}

CheckLocalErrorList-Aux {
	t.ErrorList Empty t.IModule =
		t.ErrorList Success Success t.IModule;

	t.ErrorList Warnigs t.IModule =
		t.ErrorList Success Warnings t.IModule;

	t.ErrorList Errors t.IModule =
		t.ErrorList Success Errors t.IModule;

}

/*
	<CompareQNames
		t.QualifiedName t.ErrorList t.IModule
	>
		== t.ErrorList Success t.IModule
		== t.ErrorList Fails
*/
CompareQNames
	t.QualifiedName t.ErrorList t.IModule =
		<CompareQNames-Aux
			( <MQualifiedName::Parse-T t.QualifiedName> )
			t.ErrorList
			<MIModule::GetModuleName t.IModule>
		>;

CompareQNames-Aux {
	( t.ExternalName (e.Name) )
	t.ErrorList t.IModule e.Name =
		<MQualifiedName::Destroy t.ExternalName>
		t.ErrorList Success t.IModule;

	( t.ExternalName e.ExtName )
	t.ErrorList t.IModule e.InternalName =
		<CompareQNames-AddErrorInfo
			t.ExternalName t.ErrorList
			<MIModule::GetModuleAttribute t.IModule Position>
			<MQualifiedName::Create (e.InternalName)>
		>;
}

CompareQNames-AddErrorInfo {
	t.ExternalName t.ErrorList
	t.IModule Found t.SrcPos
	t.InternalName =
		<MIModule::Destroy t.IModule>
		<MError::AddMismatchInternalAndExternalNames
			t.ErrorList t.SrcPos t.InternalName t.ExternalName
		> Fails;

	// Ошибку не проверяем, пусть будет fail down
}

//------------------------------------------------------------------------------
// Функции добавления в таблицу символов
//------------------------------------------------------------------------------

$ENTRY AddNewImport
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateImport
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

$ENTRY AddNewFunction
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList=
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateFunction
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

$ENTRY AddNewADT
	t.IModule t.SrcPos (e.NewName) e.Attribs t.ErrorList =
		<CheckRedeclaration
			t.ErrorList
			<MIModule::UpdateADT
				t.IModule (e.NewName)
				e.Attribs (Position t.SrcPos)
			>
			t.SrcPos e.NewName
		>;

CheckRedeclaration {
	t.ErrorList t.IModule Success t.SrcPos e.NewName =
		t.IModule t.ErrorList;

	t.ErrorList t.IModule InvalidKind t.SrcPos e.NewName =
		t.IModule
		<MError::AddRedeclaredIdentifier
			t.ErrorList t.SrcPos e.NewName
		>;

	/*
		Две другие ошибки -- InvalidKind и InvariantError означают
		нарушение инварианта. Программа автоматически умрёт.
	*/
}

/**-----------------------------------------------------------------------------
	Функции синтаксического анализа делятся на три категории:
	(1) Функции, распознающие основные секции файла: начало, конец, объявления,
импорты, определения. Эти функции после себя на стеке ничего не оставляют.
Даже в формате этих функций стек отсутствует.
	После распознавания глобальной структуры эта информация сразу помещается
в IModule, поэтому после работы этих функций стека не остаётся.
	(2) Функции, распознающие остальные нетерминалы. Эти функции активно рабо-
тают со стеком. Эти функции после распознавания оставляют на стеке распознан-
ный нетерминал.
	(3) Промежуточные функции. Они могут работать так, как хотят.
------------------------------------------------------------------------------*/

//==============================================================================
// Общие нетерминалы.
//==============================================================================

//------------------------------------------------------------------------------
// Распознавание заголовка и окончания модуля.
//------------------------------------------------------------------------------

/*
	<NGenericModule s.FnBody t.ErrorList t.Lexer t.NextToken>
		== t.ErrorList Success t.IModule
		== t.ErrorList Fails
*/
NGenericModule
	s.FnBody t.ErrorList t.Lexer t.NextToken =
		<NGenericModule-SwParseHeader
			s.FnBody
			<NModuleHeader
				t.ErrorList t.Lexer t.NextToken
			>
		>;

NGenericModule-SwParseHeader {
	s.FnBody
	t.ErrorList Success t.IModule t.Lexer t.NextToken =
		<s.FnBody
			t.IModule t.ErrorList t.Lexer t.NextToken
		>;

	s.FnBody t.ErrorList Fails =
		t.ErrorList Fails;
}

//-------------------------------------------------------------------------------

// ModuleHeader = '$module' ModuleName ';' .

NModuleHeader
	t.ErrorList t.Lexer t.NextToken =
		<NModuleHeader-ModuleName
			<NModuleHeader-Directive
				t.ErrorList t.Lexer t.NextToken
			>
		>;

NModuleHeader-Directive {
	t.ErrorList t.Lexer (Directive t.SrcPos Module) =
		Regular
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.ErrorList t.Lexer (Directive t.SrcPos Program) =
		Main
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.ErrorList t.Lexer (Directive t.SrcPos ClearModule) =
		Clear
		t.ErrorList <MLexer::NextToken t.Lexer>;

	/* Обработка ошибок в данном случае -- добавляем в список ошибок неожиданный
	символ, считаем, что прочли текущую лексему как '$module' и продолжаем
	дальнейший разбор.
	*/
	t.ErrorList t.Lexer t.OtherToken =
		Regular
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'directive \'$MODULE\''
		>
		<MLexer::NextToken t.Lexer>;
}

NModuleHeader-ModuleName {
	s.ModuleType
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NModuleHeader-ModuleName-CheckQualified
			s.ModuleType t.SrcPos
			<NQuadQualifiedName
				t.ErrorList
				t.Lexer (Identifier t.SrcPos e.Name)
			>
		>;

	/* Здесь мы пропускаем текущую неопознанную лексему до тех пор, пока
	не встретим идентификатор или конец ввода */
	s.ModuleType
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'module name'
		>
		Fails
		<MLexer::Destroy t.Lexer>;

	s.ModuleType t.ErrorList t.Lexer t.OtherToken =
		<NModuleHeader-ModuleName
			s.ModuleType
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'module name'
			>
			<MLexer::NextToken t.Lexer>
		>;
}

CheckSuccess {
	(e.FnName) t.IModule Success = t.IModule;

	/* Нарушение инварианта -- fail down
	В случае fail down в отладочном дампе будет виден параметр
	e.FnName -- это позволяет отловить место вылета ошибки */
}

NModuleHeader-ModuleName-CheckQualified {
	s.ModuleType t.SrcPos Success t.QualifiedName
	t.ErrorList t.Lexer t.NextToken =
		<NModuleHeader-ExpectEndSent
			<CheckSuccess
				('NMH-MN-CQ')
				<MIModule::Create
					t.QualifiedName
					(Position t.SrcPos)
					(ModuleType s.ModuleType)
				>
			>
			t.ErrorList t.Lexer t.NextToken
		>;

	/* Вообще-то эта ветвь не должна выполняться, т.к.
	функция NQuadQualifiedName возвращает Fails только если на входе
	она не получает идентификатор. А мы ей именно идентификатор посылаем. */
	s.ModuleType t.SrcPos Fails
	t.ErrorList t.Lexer t.NextToken =
		t.ErrorList Fails
		<MLexer::Destroy t.Lexer>;
}

NModuleHeader-ExpectEndSent {
	t.IModule t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.ErrorList
		Success t.IModule <MLexer::NextToken t.Lexer>;

	t.IModule t.ErrorList t.Lexer t.OtherToken =
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'semicolon'
		>
		Success t.IModule t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------

/*
	<NModuleTailer
		t.IModule t.ErrorList t.Lexer t.NextToken
	>
		== t.ErrorList Success t.IModule
		== t.ErrorList Fails
*/
$ENTRY NModuleTailer {
	t.IModule t.ErrorList t.Lexer (Directive t.SrcPos End) =
		<NModuleTailer-ModuleName
			<MIModule::GetModuleName_Q t.IModule>
			<SrcPosQualifiedName
				t.ErrorList <MLexer::NextToken t.Lexer>
			>
		>;
}

SrcPosQualifiedName
	t.ErrorList t.Lexer (s.Token t.SrcPos e.Info) =
		t.SrcPos
		<NQuadQualifiedName
			t.ErrorList t.Lexer (s.Token t.SrcPos e.Info)
		>;

NModuleTailer-ModuleName {
	t.IModule t.HeadModuleName 
	t.SrcPos Success t.TailModuleName
	t.ErrorList t.Lexer t.NextToken =
		<NModuleTailer-Dot
			<NModuleTailer-CompareNames
				t.SrcPos
				<MQualifiedName::Equals-T t.HeadModuleName t.TailModuleName>
				t.ErrorList
			>
			t.Lexer t.NextToken
		>
		Success
		t.IModule;

	/* Пропускаем следующую лексему, до тех пор, пока не встретим
	конец файла или идентификатор */
	t.IModule t.HeadModuleName
	t.SrcPos Fails
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		<MError::AddUnexpected
			t.ErrorList (EndOfText t.SrcPos) 'repeat of module name'
		>
		Success
		t.IModule;

	t.IModule t.HeadModuleName
	t.SrcPos Fails
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-ModuleName
			t.IModule t.HeadModuleName
			<SrcPosQualifiedName
				<MError::AddUnexpected
					t.ErrorList t.OtherToken 'repeat of module name'
				>
				<MLexer::NextToken t.Lexer>
			>
		>;
}

NModuleTailer-CompareNames {
	t.SrcPos
	True t.HeadName t.TailName t.ErrorList =
		t.ErrorList;

	t.SrcPos
	False t.HeadName t.TailName t.ErrorList =
		<MError::AddNamesMismatch
			t.ErrorList t.SrcPos t.HeadName t.TailName
		>;
}

/*
	<NModuleTailer-Dot t.ErrorList t.Lexer t.NextToken>
		== t.ErrorList
*/
NModuleTailer-Dot {
	t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NModuleTailer-EOF
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	/* Считаем, что точка была */
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end dot'
			>
			t.Lexer t.OtherToken
		>;
}

NModuleTailer-EOF {
	t.ErrorList t.Lexer (EndOfText t.SrcPos) =
		t.ErrorList <MLexer::Destroy t.Lexer>;

	/* Пропускаем все другие лексемы до тех пор, пока не доберёмся до конца файла */
	t.ErrorList t.Lexer t.OtherToken =
		<NModuleTailer-EOF
			<MError::AddUnexpected
				t.ErrorList t.OtherToken 'end of file'
			>
			<MLexer::NextToken t.Lexer>
		>;
}

/*------------------------------------------------------------------------------
  Распознавание блока импорта. Импорт используется как в исходных, так и в
  символических файлах.
------------------------------------------------------------------------------*/

$ENTRY NImportBlock {
	t.IModule
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterName
			t.IModule
			( Import e.ModuleName )
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name or module alias'
		>
		<MLexer::NextToken t.Lexer>;
}

NImportBlock-AfterName {
	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		<AddNewImport
			t.IModule t.SrcPos (e.ModuleName)
			(Alias e.ModuleName)
			t.ErrorList
		>
		<MLexer::NextToken t.Lexer>;

	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (Replaces t.SrcPos) =
		<NImportBlock-ModuleRenaming
			t.IModule
			(Alias e.ModuleName)
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			<AddNewImport
				t.IModule t.SrcPos (e.ModuleName)
				(Alias e.ModuleName)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	// Считаем, что пользователь пропустил точку с запятой
	t.IModule (Import e.ModuleName)
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma, semicolon or replace'
		>
		t.Lexer t.OtherToken;
}

NImportBlock-ModuleRenaming {
	t.IModule
	(Alias e.Alias)
	t.ErrorList t.Lexer (Identifier t.SrcPos e.ModuleName) =
		<NImportBlock-AfterAlias
			<AddNewImport
				t.IModule t.SrcPos (e.ModuleName)
				(Alias e.Alias)
				t.ErrorList
			>
			<MLexer::NextToken t.Lexer>
		>;

	//Считаем, что попытки переименования не было
	t.IModule
	(Alias e.Alias)
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'module name'
		>
		t.Lexer t.OtherToken;
}

NImportBlock-AfterAlias {
	t.IModule
	t.ErrorList t.Lexer (Comma t.SrcPos) =
		<NImportBlock
			t.IModule
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.IModule
	t.ErrorList t.Lexer (EndSent t.SrcPos) =
		t.IModule
		t.ErrorList <MLexer::NextToken t.Lexer>;

	t.IModule
	t.ErrorList t.Lexer t.OtherToken =
		t.IModule
		<MError::AddUnexpected
			t.ErrorList t.OtherToken 'comma or semicolon'
		>
		t.Lexer t.OtherToken;
}

//------------------------------------------------------------------------------
// Распознавание квалифицированных имён.
//------------------------------------------------------------------------------

/**
	AnyQualifiedName = DotQualifiedName | QuadQualifiedName .
	DotQualifiedName =
		IDENTIFIER | DotQualifiedName '.' IDENTIFIER .
	QuadQualifiedName =
		IDENTIFIER | QuadQualifiedName '::' IDENTIFIER .
	
	<N***QualifiedName
		t.ErrorList t.Lexer t.NextToken
	>
		== e.ScannedQName t.ErrorList t.Lexer t.NextToken

	e.ScannedQName ::=
		Success t<MQualifiedName::QName>.QualifiedName | Fails

	В случае ошибки на стеке оставляется первый неожиданный терм.
	Если имя было частично определено, например так:
		'PackageName::ModuleName::222',
	то имя считается распознанным успешно. Информация об ошибке
	падает в t.ErrorList, но синтаксически инвариант соблюдётся.
*/
$ENTRY NAnyQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		Success
		<NAnyQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		Fails
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NAnyQualifiedName-AfterName {
	t.StartName t.ErrorList t.Lexer (DoubleColon t.SrcPos) =
		<NQuadQualifiedName-Loop
			t.StartName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.StartName t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NDotQualifiedName-Loop
			t.StartName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.StartName t.ErrorList t.Lexer t.OtherToken =
		t.StartName
		t.ErrorList t.Lexer t.OtherToken;
}

$ENTRY NQuadQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		Success
		<NQuadQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		Fails
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NQuadQualifiedName-AfterName {
	t.PartOfName t.ErrorList t.Lexer (DoubleColon t.SrcPos) =
		<NQuadQualifiedName-Loop
			t.PartOfName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		t.PartOfName
		t.ErrorList t.Lexer t.Unexpected;
}

NQuadQualifiedName-Loop {
	t.PartOfName t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NQuadQualifiedName-AfterName
			<MQualifiedName::AddSubName
				t.PartOfName e.Name
			>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		t.PartOfName
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

$ENTRY NDotQualifiedName {
	t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		Success
		<NDotQualifiedName-AfterName
			<MQualifiedName::Create (e.Name)>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.ErrorList t.Lexer t.Unexpected =
		Fails
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

NDotQualifiedName-AfterName {
	t.PartOfName t.ErrorList t.Lexer (Dot t.SrcPos) =
		<NDotQualifiedName-Loop
			t.PartOfName
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		t.PartOfName
		t.ErrorList t.Lexer t.Unexpected;
}

NDotQualifiedName-Loop {
	t.PartOfName t.ErrorList t.Lexer (Identifier t.SrcPos e.Name) =
		<NDotQualifiedName-AfterName
			<MQualifiedName::AddSubName
				t.PartOfName e.Name
			>
			t.ErrorList <MLexer::NextToken t.Lexer>
		>;

	t.PartOfName t.ErrorList t.Lexer t.Unexpected =
		t.PartOfName
		<MError::AddUnexpected
			t.ErrorList t.Unexpected 'identifier'
		>
		t.Lexer t.Unexpected;
}

$END MParser_Common.
