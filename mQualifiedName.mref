$MODULE MQualifiedName;

/*==============================================================================
	Абстрактный тип данных -- квалифицированное имя.
==============================================================================*/

/*------------------------------------------------------------------------------
	Внутренний формат
		t.QualifiedName = [QName t.Segment*]
		t.Segment = (e.Name)
		e.Name != empty
------------------------------------------------------------------------------*/

$IMPORT MSelfDiag;

$DATA QName;

/**
	<Destroy t.QualifiedName> == empty
*/
$ENTRY Destroy
	[QName e.Segments] = ;

/**
	<Create (e.Segment)*>
		== t.QualifiedName
	обратна Parse
*/
$ENTRY Create
	e.Segments =
		[QName <CheckSegments e.Segments>];

CheckSegments {
	= ;

	(e.Segment) e.Tail =
		(<CheckSegment e.Segment>)
		<CheckSegments e.Tail>;
}

/**
	<AddSubName t.QualifiedName e.SubName>
		== t.UpdatedQualifiedName
*/
$ENTRY AddSubName
	[QName e.Qualifiers] e.SubName =
		<MSelfDiag::Assert-NE (e.SubName) () 'SubName must be not empty'>
		[QName
			e.Qualifiers (<CheckSegment e.SubName>)
		];

/**
	<AddSuperName t.QualifiedName e.SuperName>
		== t.UpdatedQualifiedName
*/
$ENTRY AddSuperName
	[QName e.Qualifiers] e.SuperName =
		<MSelfDiag::Assert-NE (e.SuperName) () 'SuperName must be not empty'>
		[QName
			(<CheckSegment e.SuperName>) e.Qualifiers
		];

CheckSegment {
	=
		<MSelfDiag::Error 'Segment can\'t be empty'>;

	e.Segment = e.Segment;
}

/**
	<Parse t.QualifiedName>
		== (e.SegmentName)*
	обратна Create
*/
$ENTRY Parse
	[QName e.Qualifiers] =
		e.Qualifiers;

/**
	<Parse-T t.QualifiedName>
		== t.QualifiedName (e.SegmentName)*
*/
$ENTRY Parse-T
	[QName e.Qualifiers] =
		[QName e.Qualifiers] e.Qualifiers;

/**
	<ToRelativeFSPath-T t.QualifiedName>
		== t.QualifiedName
			e.Segment '/' e.Segment '/' ... '/' e.Segment
*/
$ENTRY ToRelativeFSPath-T
	[QName e.Segments] =
		[QName e.Segments] <CreatePath e.Segments>;

CreatePath {
	(e.OneSegment) = e.OneSegment;

	(e.NextSegment) e.Tail =
		e.NextSegment '/' <CreatePath e.Tail>;
}

/**
	<Append t.QualifiedAcceptor t.QualifiedForAppend>
		== t.UpdatedQualifierAcceptor
*/
$ENTRY Append
	[QName e.AcceptorSegments] [QName e.ForAppendSegments] =
		[QName e.AcceptorSegments e.ForAppendSegments];

/**
	<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
		== t.UpdatedQualifierAcceptor t.QualifierForAppend
*/
$ENTRY Append-T
	t.Acceptor t.ForAppend =
		<Append t.Acceptor t.ForAppend> t.ForAppend;

$END MQualifiedName.