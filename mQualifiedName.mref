$MODULE MQualifiedName;

/*******************************************************************************
	Абстрактный тип данных -- квалифицированное имя.
*******************************************************************************/

/*------------------------------------------------------------------------------
	Внутренний формат
		t.QualifiedName = (QName t.Segment*)
		t.Segment = (e.Name)
		e.Name != empty
------------------------------------------------------------------------------*/

$IMPORT MSelfDiag;

/**
	<Create> == t.EmptyQualifierName
	<Create e.Name>
		== t.QalifierName // только с одним сегментом
*/
$ENTRY Create {
	= <CreateFromSegments>;

	e.Name =
		<CreateFromSegments (e.Name)>;
}

/**
	<Destroy t.QualifiedName> == empty
*/
$ENTRY Destroy
	(QName e.Segments) = ;

/**
	<CreateFromSegments (e.Segment)*>
		== t.QualifiedName
*/
$ENTRY CreateFromSegments
	e.Segments =
		(QName <CheckSegments e.Segments>);

CheckSegments {
	= ;

	(e.Segment) e.Tail =
		(<CheckSegment e.Segment>)
		<CheckSegments e.Tail>;
}

/**
	<AddSubName t.QualifiedName e.SubName>
		== t.UpdatedQualifiedName
*/
$ENTRY AddSubName
	(QName e.Qualifiers) e.SubName =
		<MSelfDiag::Assert-NE (e.SubName) () 'SubName must be not empty'>
		(QName
			e.Qualifiers (<CheckSegment e.SubName>)
		);

/**
	<AddSuperName t.QualifiedName e.SuperName>
		== t.UpdatedQualifiedName
*/
$ENTRY AddSuperName
	(QName e.Qualifiers) e.SuperName =
		<MSelfDiag::Assert-NE (e.SuperName) () 'SuperName must be not empty'>
		(QName
			(<CheckSegment e.SuperName>) e.Qualifiers
		);

CheckSegment {
	=
		<MSelfDiag::Error
			'Segment in qualified name must not be empty'
		>;

	e.Segment = e.Segment;
}

/**
	<Parse t.QualifiedName>
		== (e.SegmentName)*
*/
$ENTRY Parse
	(QName e.Qualifiers) =
		e.Qualifiers;

/**
	<Parse-T t.QualifiedName>
		== t.QualifiedName (e.SegmentName)*
*/
$ENTRY Parse-T
	(QName e.Qualifiers) =
		(QName e.Qualifiers) e.Qualifiers;

/**
	<ToRelativeFSPath-T t.QualifiedName>
		== t.QualifiedName
			e.Segment '/' e.Segment '/' ... '/' e.Segment
*/
$ENTRY ToRelativeFSPath-T
	(QName e.Segments) =
		(QName e.Segments) <CreatePath e.Segments>;

CreatePath {
	(e.OneSegment) = e.OneSegment;

	(e.NextSegment) e.Tail =
		e.NextSegment '/' <CreatePath e.Tail>;
}

/**
	<Append t.QualifiedAcceptor t.QualifiedForAppend>
		== t.UpdatedQualifierAcceptor
*/
$ENTRY Append
	(QName e.AcceptorSegments) (QName e.ForAppendSegments) =
		(QName e.AcceptorSegments e.ForAppendSegments);

/**
	<Append-T t.QualifiedAcceptor t.QualifiedForAppend>
		== t.UpdatedQualifierAcceptor t.QualifierForAppend
*/
$ENTRY Append-T
	t.Acceptor t.ForAppend =
		<Append t.Acceptor t.ForAppend> t.ForAppend;

$END MQualifiedName.