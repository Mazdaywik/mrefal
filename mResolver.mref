$MODULE MResolver;

$IMPORT MError;
$IMPORT MFnPtrAdder;
$IMPORT MQualifiedName;
$IMPORT MQualifiedSupport;
$IMPORT MResolveTable;
$IMPORT MSymTable;
$IMPORT MSymTable-Module;

/**
	<Resolve t.Module t.ErrorList t.ResolveTable e.QualifiedList>
		== t.ResolvedModule s.ErrorStatus t.UpdatedErrorList

	e.QualifiedList ::= ( t.ModuleLocation (e.EntryFnName)* )*
	t.ModuleLocation ::= ((e.Directory) e.ModuleName)
*/
$ENTRY Resolve
	t.SymTable t.ErrorList t.ResolveTable e.QualifiedList =
		<Resolve-Aux
			<MSymTable-Module::Module-From-SymTable
				<MFnPtrAdder::AddFnPtr
					t.SymTable e.QualifiedList
				>
			>
			t.ResolveTable t.ErrorList
		>;

Resolve-Aux
	( t.SymTable e.ModuleContent ) t.ResolveTable t.ErrorList =
		<StartResolving
			t.ResolveTable
			( <MSymTable::ExtractLocalInfo t.SymTable> )
			(e.ModuleContent) t.ErrorList
		>;

StartResolving
	t.ResolveTable
	( t.SymTable e.LocalScope )
	( e.ModuleContent )
	t.ErrorList =
		<ResolvingElements
			<FillTable
				t.ResolveTable
				( <MSymTable::ExtractCurrentModule t.SymTable> )
				(e.ModuleContent) t.ErrorList
				e.LocalScope
			>
		>;

FillTable {
	t.ResolveTable
	( t.SymTable e.CurrentModule )
	(e.ModuleContent) t.ErrorList
	e.LocalScope =
		<FillLocal t.ResolveTable (e.CurrentModule) e.LocalScope>
		t.SymTable (e.ModuleContent) t.ErrorList;
}

/*
	Инвариант: <FillLocal t.ResolveTable (e.CurrentModule) e.LocalScope>
		e.LocalScope ::= (s.ScopeClass e.FnName)*
*/
FillLocal {
	t.ResolveTable (e.CurrentModule)
	(s.ScopeClass e.Function) e.Functions =
		<FillLocal
			<MResolveTable::Add
				t.ResolveTable
				<MQualifiedName::Create (e.Function)>
				s.ScopeClass
				<MQualifiedName::Create (e.CurrentModule)(e.Function)>
			> (e.CurrentModule) e.Functions
		>;

	t.ResolveTable (e.CurrentModule) =
		t.ResolveTable;
}

ResolvingElements
	t.ResolveTable t.SymTable ( e.Elements ) t.ErrorList =
		<DoResolvingElements
			t.SymTable
			( )
			t.ErrorList
			t.ResolveTable
			e.Elements
		>;

DoResolvingElements {
	t.SymTable ( e.ResolvedElements )
	t.ErrorList
	t.ResolveTable =
		<MSymTable-Module::SymTable-From-Module
			( t.SymTable e.ResolvedElements )
		>
		<MResolveTable::Destroy t.ResolveTable>
		<CheckErrors t.ErrorList>;

	t.SymTable ( e.ResolvedElements )
	t.ErrorList t.ResolveTable
	t.NextElement e.Elements =
		<DoResolvingElements
			<AddElement
				t.SymTable ( e.ResolvedElements )
				<ResolvingOneElement
					t.NextElement
					t.ErrorList t.ResolveTable
				>
			> e.Elements
		>;
}

CheckErrors
	t.ErrorList =
		<SwCheckErrors
			<MError::EmptyList t.ErrorList>
		>;

SwCheckErrors {
	t.ErrorList Empty = Success t.ErrorList;
	t.ErrorList NotEmpty = Errors t.ErrorList;
}

AddElement
	t.SymTable ( e.ResolvedElements )
	t.Resolved t.ErrorList t.ResolveTable =
		t.SymTable
		( e.ResolvedElements t.Resolved )
		t.ErrorList t.ResolveTable;

// Модуль состоит только из функций, swaps регистрируются в таблице символов
ResolvingOneElement {
	( Function s.ScopeClass (e.FnName) t.QualifiedName (e.Sentences) )
	t.ErrorList t.ResolveTable =
		<ResolveFnName-Header
			( Function s.ScopeClass (e.FnName) t.QualifiedName (e.Sentences) )
			t.ErrorList
			<MResolveTable::Lookup t.ResolveTable t.QualifiedName>
		>;
}

ResolveFnName-Header {
	( Function s.ScopeClass (e.FnName) t.QualifiedName (e.Sentences) )
	t.ErrorList
	t.ResolveTable Found s.ScopeClass t.FunctionNameQualified =
		<DoResolvingFunction
			( Function s.ScopeClass (e.FnName) t.FunctionNameQualified )
			t.ErrorList t.ResolveTable
			() e.Sentences
		>;
}

DoResolvingFunction {
	( Function s.ScopeClass (e.FnName) t.QualifiedFNName )
	t.ErrorList t.ResolveTable
	(e.Resolved) =
		( Function s.ScopeClass (e.FnName) t.QualifiedFNName (e.Resolved) )
		t.ErrorList t.ResolveTable;

	( Function s.ScopeClass (e.FnName) t.QualifiedFNName )
	t.ErrorList t.ResolveTable
	(e.Resolved) t.NextSentence e.Tail =
		<DoResolvingFunction
			(Function s.ScopeClass (e.FnName) t.QualifiedFNName )
			<ResolvingSentence
				t.ErrorList t.ResolveTable
				(e.Resolved) t.NextSentence
			> e.Tail
		>;
}

ResolvingSentence {
	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) (e.Result) ) =
		<ResolvingResult
			t.ErrorList t.ResolveTable
			(e.ResolvedSentences)
			( (e.Pattern) ('$') ) e.Result '$'
		>;
}

ResolvingResult {
	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) ('$' e.ScannedResult) )
	'$' =
		t.ErrorList t.ResolveTable
		( e.ResolvedSentences
			( (e.Pattern) (e.ScannedResult) )
		);

	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) ( e.ScannedResult ) )
	( Structure e.InBrackets ) e.Tail =
		<ResolvingResult
			t.ErrorList t.ResolveTable
			(e.ResolvedSentences)
			( (e.Pattern)
				( '!' Structure (e.ScannedResult) )
			) e.InBrackets ( '!' Structure e.Tail )
		>;

	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) ( e.ScannedResult ) )
	( Function t.Callable e.Argument ) e.Tail =
		<ResolvingResult
			<ResolvingCallable
				t.ErrorList t.ResolveTable
				(e.ResolvedSentences)
				( (e.Pattern)
					( '!' Function (e.ScannedResult) )
				) t.Callable e.Argument ( '!' Function e.Tail )
			>
		>;

	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) ( e.ScannedResult ) )
	( IndirectCall (SVar e.Index) e.Argument ) e.Tail =
		<ResolvingResult
			t.ErrorList t.ResolveTable
			(e.ResolvedSentences)
			( (e.Pattern)
				( '!' IndirectCall (e.ScannedResult) (SVar e.Index) )
			) e.Argument ('!' IndirectCall e.Tail)
		>;

	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern)
		( '!' s.BracketType (e.LMultiBracket) e.InBrackets )
	) ( '!' s.BracketType e.RMultiBracket ) =
		<ResolvingResult
			t.ErrorList t.ResolveTable
			(e.ResolvedSentences)
			( (e.Pattern)
				( e.LMultiBracket (s.BracketType e.InBrackets) )
			) e.RMultiBracket
		>;

	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) (e.ScannedResult) )
	t.NextTerm e.Tail =
		<ResolvingResult
			t.ErrorList t.ResolveTable
			(e.ResolvedSentences)
			( (e.Pattern) (e.ScannedResult t.NextTerm) )
			e.Tail
		>;
}

/*
	То, ради чего делается весь этот сложный рекурсивный просмотр --
анализ корректности вызовов. Стратегия обработки ошибок (необъявленных
функций): функциональный терм заменяем скобочным термом и заносим
информацию об ошибке в список ошибок.
*/
ResolvingCallable {
	t.ErrorList t.ResolveTable
	(e.ResolvedSentences)
	( (e.Pattern) ('!' Function (e.LMultiBracket)) )
	(Qualified t.SrcPosModule t.QualifiedName)
	e.Argument ('!' Function e.RMultiBracket) =
		<SwResolvingCallable
			t.ErrorList
			<MResolveTable::Lookup
				t.ResolveTable
				t.QualifiedName
			> t.SrcPosModule
			(e.ResolvedSentences)
			( (e.Pattern) ('!' Function (e.LMultiBracket)) )
			e.Argument ('!' Function e.RMultiBracket)
		>;
}

SwResolvingCallable {
	t.ErrorList t.ResolveTable
	Found s.ScopeClass t.QualifiedName t.SrcPos
	(e.ResolvedSentences)
	( (e.Pattern) ('!' Function (e.LMultiBracket)) )
	e.Argument ('!' Function e.RMultiBracket) =
		t.ErrorList t.ResolveTable
		(e.ResolvedSentences)
		( (e.Pattern)
			('!' Function (e.LMultiBracket)	(s.ScopeClass t.QualifiedName))
		) e.Argument ('!' Function e.RMultiBracket);

	t.ErrorList t.ResolveTable
	NotFound NotFound t.UnresolvedQualified t.SrcPos
	(e.ResolvedSentences)
	( (e.Pattern) ('!' Function (e.LMultiBracket)) )
	e.Argument ('!' Function e.RMultiBracket) =
		<MError::AddUnresolvedFunction
			t.ErrorList t.SrcPos GenericQualified
			<MQualifiedName::Parse t.UnresolvedQualified>
		> t.ResolveTable
		(e.ResolvedSentences)
		( (e.Pattern) ('!' Structure (e.LMultiBracket)) )
		e.Argument ('!' Structure e.RMultiBracket);
}

$END MResolver.